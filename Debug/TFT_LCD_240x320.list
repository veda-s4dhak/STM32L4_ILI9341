
TFT_LCD_240x320.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00013604  08000194  08000194  00010194  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000362c  08013798  08013798  00023798  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08016dc4  08016dc4  00030074  2**0
                  CONTENTS
  4 .ARM          00000000  08016dc4  08016dc4  00030074  2**0
                  CONTENTS
  5 .preinit_array 00000000  08016dc4  08016dc4  00030074  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08016dc4  08016dc4  00026dc4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08016dc8  08016dc8  00026dc8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000074  20000000  08016dcc  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000099c4  20000074  08016e40  00030074  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20009a38  08016e40  00039a38  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00030074  2**0
                  CONTENTS, READONLY
 12 .debug_info   0003e422  00000000  00000000  000300a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00007168  00000000  00000000  0006e4c6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00001bb8  00000000  00000000  00075630  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00001af8  00000000  00000000  000771e8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  000295d4  00000000  00000000  00078ce0  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   00024fc7  00000000  00000000  000a22b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    000d60eb  00000000  00000000  000c727b  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  0019d366  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00007094  00000000  00000000  0019d3e4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000194 <__do_global_dtors_aux>:
 8000194:	b510      	push	{r4, lr}
 8000196:	4c05      	ldr	r4, [pc, #20]	; (80001ac <__do_global_dtors_aux+0x18>)
 8000198:	7823      	ldrb	r3, [r4, #0]
 800019a:	b933      	cbnz	r3, 80001aa <__do_global_dtors_aux+0x16>
 800019c:	4b04      	ldr	r3, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x1c>)
 800019e:	b113      	cbz	r3, 80001a6 <__do_global_dtors_aux+0x12>
 80001a0:	4804      	ldr	r0, [pc, #16]	; (80001b4 <__do_global_dtors_aux+0x20>)
 80001a2:	f3af 8000 	nop.w
 80001a6:	2301      	movs	r3, #1
 80001a8:	7023      	strb	r3, [r4, #0]
 80001aa:	bd10      	pop	{r4, pc}
 80001ac:	20000074 	.word	0x20000074
 80001b0:	00000000 	.word	0x00000000
 80001b4:	08013780 	.word	0x08013780

080001b8 <frame_dummy>:
 80001b8:	b508      	push	{r3, lr}
 80001ba:	4b03      	ldr	r3, [pc, #12]	; (80001c8 <frame_dummy+0x10>)
 80001bc:	b11b      	cbz	r3, 80001c6 <frame_dummy+0xe>
 80001be:	4903      	ldr	r1, [pc, #12]	; (80001cc <frame_dummy+0x14>)
 80001c0:	4803      	ldr	r0, [pc, #12]	; (80001d0 <frame_dummy+0x18>)
 80001c2:	f3af 8000 	nop.w
 80001c6:	bd08      	pop	{r3, pc}
 80001c8:	00000000 	.word	0x00000000
 80001cc:	20000078 	.word	0x20000078
 80001d0:	08013780 	.word	0x08013780

080001d4 <strcmp>:
 80001d4:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001d8:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001dc:	2a01      	cmp	r2, #1
 80001de:	bf28      	it	cs
 80001e0:	429a      	cmpcs	r2, r3
 80001e2:	d0f7      	beq.n	80001d4 <strcmp>
 80001e4:	1ad0      	subs	r0, r2, r3
 80001e6:	4770      	bx	lr

080001e8 <strlen>:
 80001e8:	4603      	mov	r3, r0
 80001ea:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001ee:	2a00      	cmp	r2, #0
 80001f0:	d1fb      	bne.n	80001ea <strlen+0x2>
 80001f2:	1a18      	subs	r0, r3, r0
 80001f4:	3801      	subs	r0, #1
 80001f6:	4770      	bx	lr

080001f8 <lv_debug_check_null>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

bool lv_debug_check_null(const void * p)
{
 80001f8:	b480      	push	{r7}
 80001fa:	b083      	sub	sp, #12
 80001fc:	af00      	add	r7, sp, #0
 80001fe:	6078      	str	r0, [r7, #4]
    if(p) return true;
 8000200:	687b      	ldr	r3, [r7, #4]
 8000202:	2b00      	cmp	r3, #0
 8000204:	d001      	beq.n	800020a <lv_debug_check_null+0x12>
 8000206:	2301      	movs	r3, #1
 8000208:	e000      	b.n	800020c <lv_debug_check_null+0x14>

    return false;
 800020a:	2300      	movs	r3, #0
}
 800020c:	4618      	mov	r0, r3
 800020e:	370c      	adds	r7, #12
 8000210:	46bd      	mov	sp, r7
 8000212:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000216:	4770      	bx	lr

08000218 <lv_debug_check_style>:

    return false;
}

bool lv_debug_check_style(const lv_style_t * style)
{
 8000218:	b480      	push	{r7}
 800021a:	b083      	sub	sp, #12
 800021c:	af00      	add	r7, sp, #0
 800021e:	6078      	str	r0, [r7, #4]
    if(style == NULL) return true;  /*NULL style is still valid*/
 8000220:	687b      	ldr	r3, [r7, #4]
 8000222:	2b00      	cmp	r3, #0
 8000224:	d101      	bne.n	800022a <lv_debug_check_style+0x12>
 8000226:	2301      	movs	r3, #1
 8000228:	e007      	b.n	800023a <lv_debug_check_style+0x22>

#if LV_USE_ASSERT_STYLE
    if(style->debug_sentinel != LV_STYLE_DEGUG_SENTINEL_VALUE) {
 800022a:	687b      	ldr	r3, [r7, #4]
 800022c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800022e:	4a06      	ldr	r2, [pc, #24]	; (8000248 <lv_debug_check_style+0x30>)
 8000230:	4293      	cmp	r3, r2
 8000232:	d001      	beq.n	8000238 <lv_debug_check_style+0x20>
        LV_LOG_WARN("Invalid style (local variable or not initialized?)");
        return false;
 8000234:	2300      	movs	r3, #0
 8000236:	e000      	b.n	800023a <lv_debug_check_style+0x22>
    }
#endif

    return true;
 8000238:	2301      	movs	r3, #1
}
 800023a:	4618      	mov	r0, r3
 800023c:	370c      	adds	r7, #12
 800023e:	46bd      	mov	sp, r7
 8000240:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000244:	4770      	bx	lr
 8000246:	bf00      	nop
 8000248:	12345678 	.word	0x12345678

0800024c <lv_debug_log_error>:
    LV_LOG_WARN("lv_debug_check_str: string is longer than LV_DEBUG_STR_MAX_LENGTH");
    return false;
}

void lv_debug_log_error(const char * msg, uint64_t value)
{
 800024c:	b580      	push	{r7, lr}
 800024e:	b0c8      	sub	sp, #288	; 0x120
 8000250:	af00      	add	r7, sp, #0
 8000252:	f107 010c 	add.w	r1, r7, #12
 8000256:	6008      	str	r0, [r1, #0]
 8000258:	4639      	mov	r1, r7
 800025a:	e9c1 2300 	strd	r2, r3, [r1]
    static const char hex[] = "0123456789ABCDEF";

    size_t msg_len = strlen(msg);
 800025e:	f107 030c 	add.w	r3, r7, #12
 8000262:	6818      	ldr	r0, [r3, #0]
 8000264:	f7ff ffc0 	bl	80001e8 <strlen>
 8000268:	f8c7 0114 	str.w	r0, [r7, #276]	; 0x114
    uint32_t value_len = sizeof(unsigned long int);
 800026c:	2304      	movs	r3, #4
 800026e:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110

    if(msg_len < 230) {
 8000272:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8000276:	2be5      	cmp	r3, #229	; 0xe5
 8000278:	d871      	bhi.n	800035e <lv_debug_log_error+0x112>
        char buf[255];
        char * bufp = buf;
 800027a:	f107 0310 	add.w	r3, r7, #16
 800027e:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

        /*Add the function name*/
        memcpy(bufp, msg, msg_len);
 8000282:	f107 030c 	add.w	r3, r7, #12
 8000286:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 800028a:	6819      	ldr	r1, [r3, #0]
 800028c:	f8d7 011c 	ldr.w	r0, [r7, #284]	; 0x11c
 8000290:	f013 fa5a 	bl	8013748 <memcpy>
        bufp += msg_len;
 8000294:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8000298:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 800029c:	4413      	add	r3, r2
 800029e:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

        /*Add value in hey*/
        *bufp = ' ';
 80002a2:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80002a6:	2220      	movs	r2, #32
 80002a8:	701a      	strb	r2, [r3, #0]
        bufp ++;
 80002aa:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80002ae:	3301      	adds	r3, #1
 80002b0:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
        *bufp = '(';
 80002b4:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80002b8:	2228      	movs	r2, #40	; 0x28
 80002ba:	701a      	strb	r2, [r3, #0]
        bufp ++;
 80002bc:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80002c0:	3301      	adds	r3, #1
 80002c2:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
        *bufp = '0';
 80002c6:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80002ca:	2230      	movs	r2, #48	; 0x30
 80002cc:	701a      	strb	r2, [r3, #0]
        bufp ++;
 80002ce:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80002d2:	3301      	adds	r3, #1
 80002d4:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
        *bufp = 'x';
 80002d8:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80002dc:	2278      	movs	r2, #120	; 0x78
 80002de:	701a      	strb	r2, [r3, #0]
        bufp ++;
 80002e0:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80002e4:	3301      	adds	r3, #1
 80002e6:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

        int8_t i;
        for(i = value_len * 2 - 1; i >= 0; i--) {
 80002ea:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 80002ee:	b2db      	uxtb	r3, r3
 80002f0:	005b      	lsls	r3, r3, #1
 80002f2:	b2db      	uxtb	r3, r3
 80002f4:	3b01      	subs	r3, #1
 80002f6:	b2db      	uxtb	r3, r3
 80002f8:	f887 311b 	strb.w	r3, [r7, #283]	; 0x11b
 80002fc:	e01e      	b.n	800033c <lv_debug_log_error+0xf0>
            uint8_t x = (unsigned long int)((unsigned long int)value >> (i * 4)) & 0xF;
 80002fe:	463b      	mov	r3, r7
 8000300:	681a      	ldr	r2, [r3, #0]
 8000302:	f997 311b 	ldrsb.w	r3, [r7, #283]	; 0x11b
 8000306:	009b      	lsls	r3, r3, #2
 8000308:	fa22 f303 	lsr.w	r3, r2, r3
 800030c:	b2db      	uxtb	r3, r3
 800030e:	f003 030f 	and.w	r3, r3, #15
 8000312:	f887 310f 	strb.w	r3, [r7, #271]	; 0x10f

            *bufp = hex[x];
 8000316:	f897 310f 	ldrb.w	r3, [r7, #271]	; 0x10f
 800031a:	4a13      	ldr	r2, [pc, #76]	; (8000368 <lv_debug_log_error+0x11c>)
 800031c:	5cd2      	ldrb	r2, [r2, r3]
 800031e:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8000322:	701a      	strb	r2, [r3, #0]
            bufp++;
 8000324:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8000328:	3301      	adds	r3, #1
 800032a:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
        for(i = value_len * 2 - 1; i >= 0; i--) {
 800032e:	f997 311b 	ldrsb.w	r3, [r7, #283]	; 0x11b
 8000332:	b2db      	uxtb	r3, r3
 8000334:	3b01      	subs	r3, #1
 8000336:	b2db      	uxtb	r3, r3
 8000338:	f887 311b 	strb.w	r3, [r7, #283]	; 0x11b
 800033c:	f997 311b 	ldrsb.w	r3, [r7, #283]	; 0x11b
 8000340:	2b00      	cmp	r3, #0
 8000342:	dadc      	bge.n	80002fe <lv_debug_log_error+0xb2>
        }

        *bufp = ')';
 8000344:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8000348:	2229      	movs	r2, #41	; 0x29
 800034a:	701a      	strb	r2, [r3, #0]
        bufp ++;
 800034c:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8000350:	3301      	adds	r3, #1
 8000352:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

        *bufp = '\0';
 8000356:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 800035a:	2200      	movs	r2, #0
 800035c:	701a      	strb	r2, [r3, #0]
        LV_LOG_ERROR(buf);
    } else {
        LV_LOG_ERROR(msg);
    }
}
 800035e:	bf00      	nop
 8000360:	f507 7790 	add.w	r7, r7, #288	; 0x120
 8000364:	46bd      	mov	sp, r7
 8000366:	bd80      	pop	{r7, pc}
 8000368:	08013940 	.word	0x08013940

0800036c <lv_disp_get_scr_act>:
 * @param disp pointer to display which active screen should be get. (NULL to use the default
 * screen)
 * @return pointer to the active screen object (loaded by 'lv_scr_load()')
 */
lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)
{
 800036c:	b580      	push	{r7, lr}
 800036e:	b082      	sub	sp, #8
 8000370:	af00      	add	r7, sp, #0
 8000372:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 8000374:	687b      	ldr	r3, [r7, #4]
 8000376:	2b00      	cmp	r3, #0
 8000378:	d102      	bne.n	8000380 <lv_disp_get_scr_act+0x14>
 800037a:	f00b fb1d 	bl	800b9b8 <lv_disp_get_default>
 800037e:	6078      	str	r0, [r7, #4]
    if(!disp) {
 8000380:	687b      	ldr	r3, [r7, #4]
 8000382:	2b00      	cmp	r3, #0
 8000384:	d101      	bne.n	800038a <lv_disp_get_scr_act+0x1e>
        LV_LOG_WARN("lv_scr_act: no display registered to get its top layer");
        return NULL;
 8000386:	2300      	movs	r3, #0
 8000388:	e001      	b.n	800038e <lv_disp_get_scr_act+0x22>
    }

    return disp->act_scr;
 800038a:	687b      	ldr	r3, [r7, #4]
 800038c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 800038e:	4618      	mov	r0, r3
 8000390:	3708      	adds	r7, #8
 8000392:	46bd      	mov	sp, r7
 8000394:	bd80      	pop	{r7, pc}

08000396 <lv_disp_get_layer_top>:
 * Return with the top layer. (Same on every screen and it is above the normal screen layer)
 * @param disp pointer to display which top layer should be get. (NULL to use the default screen)
 * @return pointer to the top layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)
{
 8000396:	b580      	push	{r7, lr}
 8000398:	b082      	sub	sp, #8
 800039a:	af00      	add	r7, sp, #0
 800039c:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 800039e:	687b      	ldr	r3, [r7, #4]
 80003a0:	2b00      	cmp	r3, #0
 80003a2:	d102      	bne.n	80003aa <lv_disp_get_layer_top+0x14>
 80003a4:	f00b fb08 	bl	800b9b8 <lv_disp_get_default>
 80003a8:	6078      	str	r0, [r7, #4]
    if(!disp) {
 80003aa:	687b      	ldr	r3, [r7, #4]
 80003ac:	2b00      	cmp	r3, #0
 80003ae:	d101      	bne.n	80003b4 <lv_disp_get_layer_top+0x1e>
        LV_LOG_WARN("lv_layer_top: no display registered to get its top layer");
        return NULL;
 80003b0:	2300      	movs	r3, #0
 80003b2:	e001      	b.n	80003b8 <lv_disp_get_layer_top+0x22>
    }

    return disp->top_layer;
 80003b4:	687b      	ldr	r3, [r7, #4]
 80003b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
}
 80003b8:	4618      	mov	r0, r3
 80003ba:	3708      	adds	r7, #8
 80003bc:	46bd      	mov	sp, r7
 80003be:	bd80      	pop	{r7, pc}

080003c0 <lv_disp_get_layer_sys>:
 * layer)
 * @param disp pointer to display which sys. layer  should be get. (NULL to use the default screen)
 * @return pointer to the sys layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)
{
 80003c0:	b580      	push	{r7, lr}
 80003c2:	b082      	sub	sp, #8
 80003c4:	af00      	add	r7, sp, #0
 80003c6:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 80003c8:	687b      	ldr	r3, [r7, #4]
 80003ca:	2b00      	cmp	r3, #0
 80003cc:	d102      	bne.n	80003d4 <lv_disp_get_layer_sys+0x14>
 80003ce:	f00b faf3 	bl	800b9b8 <lv_disp_get_default>
 80003d2:	6078      	str	r0, [r7, #4]
    if(!disp) {
 80003d4:	687b      	ldr	r3, [r7, #4]
 80003d6:	2b00      	cmp	r3, #0
 80003d8:	d101      	bne.n	80003de <lv_disp_get_layer_sys+0x1e>
        LV_LOG_WARN("lv_layer_sys: no display registered to get its top layer");
        return NULL;
 80003da:	2300      	movs	r3, #0
 80003dc:	e001      	b.n	80003e2 <lv_disp_get_layer_sys+0x22>
    }

    return disp->sys_layer;
 80003de:	687b      	ldr	r3, [r7, #4]
 80003e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
}
 80003e2:	4618      	mov	r0, r3
 80003e4:	3708      	adds	r7, #8
 80003e6:	46bd      	mov	sp, r7
 80003e8:	bd80      	pop	{r7, pc}
	...

080003ec <lv_group_init>:

/**
 * Init. the group module
 */
void lv_group_init(void)
{
 80003ec:	b580      	push	{r7, lr}
 80003ee:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_group_ll), sizeof(lv_group_t));
 80003f0:	2160      	movs	r1, #96	; 0x60
 80003f2:	4802      	ldr	r0, [pc, #8]	; (80003fc <lv_group_init+0x10>)
 80003f4:	f00c f960 	bl	800c6b8 <lv_ll_init>
}
 80003f8:	bf00      	nop
 80003fa:	bd80      	pop	{r7, pc}
 80003fc:	20009994 	.word	0x20009994

08000400 <lv_group_add_obj>:
 * Add an object to a group
 * @param group pointer to a group
 * @param obj pointer to an object to add
 */
void lv_group_add_obj(lv_group_t * group, lv_obj_t * obj)
{
 8000400:	b590      	push	{r4, r7, lr}
 8000402:	b085      	sub	sp, #20
 8000404:	af00      	add	r7, sp, #0
 8000406:	6078      	str	r0, [r7, #4]
 8000408:	6039      	str	r1, [r7, #0]
    if(group == NULL) return;
 800040a:	687b      	ldr	r3, [r7, #4]
 800040c:	2b00      	cmp	r3, #0
 800040e:	d04e      	beq.n	80004ae <lv_group_add_obj+0xae>

    /*Do not add the object twice*/
    lv_obj_t ** obj_i;
    LV_LL_READ(group->obj_ll, obj_i)
 8000410:	687b      	ldr	r3, [r7, #4]
 8000412:	4618      	mov	r0, r3
 8000414:	f00c fad2 	bl	800c9bc <lv_ll_get_head>
 8000418:	60f8      	str	r0, [r7, #12]
 800041a:	e00a      	b.n	8000432 <lv_group_add_obj+0x32>
    {
        if((*obj_i) == obj) {
 800041c:	68fb      	ldr	r3, [r7, #12]
 800041e:	681b      	ldr	r3, [r3, #0]
 8000420:	683a      	ldr	r2, [r7, #0]
 8000422:	429a      	cmp	r2, r3
 8000424:	d045      	beq.n	80004b2 <lv_group_add_obj+0xb2>
    LV_LL_READ(group->obj_ll, obj_i)
 8000426:	687b      	ldr	r3, [r7, #4]
 8000428:	68f9      	ldr	r1, [r7, #12]
 800042a:	4618      	mov	r0, r3
 800042c:	f00c faec 	bl	800ca08 <lv_ll_get_next>
 8000430:	60f8      	str	r0, [r7, #12]
 8000432:	68fb      	ldr	r3, [r7, #12]
 8000434:	2b00      	cmp	r3, #0
 8000436:	d1f1      	bne.n	800041c <lv_group_add_obj+0x1c>
            return;
        }
    }

    /*If the object is already in a group and focused then defocus it*/
    if(obj->group_p) {
 8000438:	683b      	ldr	r3, [r7, #0]
 800043a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800043c:	2b00      	cmp	r3, #0
 800043e:	d00a      	beq.n	8000456 <lv_group_add_obj+0x56>
        if(lv_obj_is_focused(obj)) {
 8000440:	6838      	ldr	r0, [r7, #0]
 8000442:	f002 fafb 	bl	8002a3c <lv_obj_is_focused>
 8000446:	4603      	mov	r3, r0
 8000448:	2b00      	cmp	r3, #0
 800044a:	d004      	beq.n	8000456 <lv_group_add_obj+0x56>
            lv_group_refocus(obj->group_p);
 800044c:	683b      	ldr	r3, [r7, #0]
 800044e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000450:	4618      	mov	r0, r3
 8000452:	f000 f8a3 	bl	800059c <lv_group_refocus>

            LV_LOG_INFO("lv_group_add_obj: assign object to an other group");
        }
    }

    obj->group_p     = group;
 8000456:	683b      	ldr	r3, [r7, #0]
 8000458:	687a      	ldr	r2, [r7, #4]
 800045a:	62da      	str	r2, [r3, #44]	; 0x2c
    lv_obj_t ** next = lv_ll_ins_tail(&group->obj_ll);
 800045c:	687b      	ldr	r3, [r7, #4]
 800045e:	4618      	mov	r0, r3
 8000460:	f00c f9c5 	bl	800c7ee <lv_ll_ins_tail>
 8000464:	60b8      	str	r0, [r7, #8]
    LV_ASSERT_MEM(next);
 8000466:	68b8      	ldr	r0, [r7, #8]
 8000468:	f7ff fec6 	bl	80001f8 <lv_debug_check_null>
 800046c:	4603      	mov	r3, r0
 800046e:	f083 0301 	eor.w	r3, r3, #1
 8000472:	b2db      	uxtb	r3, r3
 8000474:	2b00      	cmp	r3, #0
 8000476:	d008      	beq.n	800048a <lv_group_add_obj+0x8a>
 8000478:	68bb      	ldr	r3, [r7, #8]
 800047a:	f04f 0400 	mov.w	r4, #0
 800047e:	461a      	mov	r2, r3
 8000480:	4623      	mov	r3, r4
 8000482:	480f      	ldr	r0, [pc, #60]	; (80004c0 <lv_group_add_obj+0xc0>)
 8000484:	f7ff fee2 	bl	800024c <lv_debug_log_error>
 8000488:	e7fe      	b.n	8000488 <lv_group_add_obj+0x88>
    if(next == NULL) return;
 800048a:	68bb      	ldr	r3, [r7, #8]
 800048c:	2b00      	cmp	r3, #0
 800048e:	d012      	beq.n	80004b6 <lv_group_add_obj+0xb6>
    *next = obj;
 8000490:	68bb      	ldr	r3, [r7, #8]
 8000492:	683a      	ldr	r2, [r7, #0]
 8000494:	601a      	str	r2, [r3, #0]

    /* If the head and the tail is equal then there is only one object in the linked list.
     * In this case automatically activate it*/
    if(lv_ll_get_head(&group->obj_ll) == next) {
 8000496:	687b      	ldr	r3, [r7, #4]
 8000498:	4618      	mov	r0, r3
 800049a:	f00c fa8f 	bl	800c9bc <lv_ll_get_head>
 800049e:	4602      	mov	r2, r0
 80004a0:	68bb      	ldr	r3, [r7, #8]
 80004a2:	4293      	cmp	r3, r2
 80004a4:	d108      	bne.n	80004b8 <lv_group_add_obj+0xb8>
        lv_group_refocus(group);
 80004a6:	6878      	ldr	r0, [r7, #4]
 80004a8:	f000 f878 	bl	800059c <lv_group_refocus>
 80004ac:	e004      	b.n	80004b8 <lv_group_add_obj+0xb8>
    if(group == NULL) return;
 80004ae:	bf00      	nop
 80004b0:	e002      	b.n	80004b8 <lv_group_add_obj+0xb8>
            return;
 80004b2:	bf00      	nop
 80004b4:	e000      	b.n	80004b8 <lv_group_add_obj+0xb8>
    if(next == NULL) return;
 80004b6:	bf00      	nop
    }
}
 80004b8:	3714      	adds	r7, #20
 80004ba:	46bd      	mov	sp, r7
 80004bc:	bd90      	pop	{r4, r7, pc}
 80004be:	bf00      	nop
 80004c0:	08013798 	.word	0x08013798

080004c4 <lv_group_focus_next>:
/**
 * Focus the next object in a group (defocus the current)
 * @param group pointer to a group
 */
void lv_group_focus_next(lv_group_t * group)
{
 80004c4:	b580      	push	{r7, lr}
 80004c6:	b082      	sub	sp, #8
 80004c8:	af00      	add	r7, sp, #0
 80004ca:	6078      	str	r0, [r7, #4]
    focus_next_core(group, lv_ll_get_head, lv_ll_get_next);
 80004cc:	4a04      	ldr	r2, [pc, #16]	; (80004e0 <lv_group_focus_next+0x1c>)
 80004ce:	4905      	ldr	r1, [pc, #20]	; (80004e4 <lv_group_focus_next+0x20>)
 80004d0:	6878      	ldr	r0, [r7, #4]
 80004d2:	f000 f89b 	bl	800060c <focus_next_core>
}
 80004d6:	bf00      	nop
 80004d8:	3708      	adds	r7, #8
 80004da:	46bd      	mov	sp, r7
 80004dc:	bd80      	pop	{r7, pc}
 80004de:	bf00      	nop
 80004e0:	0800ca09 	.word	0x0800ca09
 80004e4:	0800c9bd 	.word	0x0800c9bd

080004e8 <lv_group_focus_prev>:
/**
 * Focus the previous object in a group (defocus the current)
 * @param group pointer to a group
 */
void lv_group_focus_prev(lv_group_t * group)
{
 80004e8:	b580      	push	{r7, lr}
 80004ea:	b082      	sub	sp, #8
 80004ec:	af00      	add	r7, sp, #0
 80004ee:	6078      	str	r0, [r7, #4]
    focus_next_core(group, lv_ll_get_tail, lv_ll_get_prev);
 80004f0:	4a04      	ldr	r2, [pc, #16]	; (8000504 <lv_group_focus_prev+0x1c>)
 80004f2:	4905      	ldr	r1, [pc, #20]	; (8000508 <lv_group_focus_prev+0x20>)
 80004f4:	6878      	ldr	r0, [r7, #4]
 80004f6:	f000 f889 	bl	800060c <focus_next_core>
}
 80004fa:	bf00      	nop
 80004fc:	3708      	adds	r7, #8
 80004fe:	46bd      	mov	sp, r7
 8000500:	bd80      	pop	{r7, pc}
 8000502:	bf00      	nop
 8000504:	0800ca3d 	.word	0x0800ca3d
 8000508:	0800c9e3 	.word	0x0800c9e3

0800050c <lv_group_mod_style>:
 * @param group pointer to group
 * @param style pointer to a style to modify
 * @return a copy of the input style but modified with the 'style_mod' function
 */
lv_style_t * lv_group_mod_style(lv_group_t * group, const lv_style_t * style)
{
 800050c:	b580      	push	{r7, lr}
 800050e:	b082      	sub	sp, #8
 8000510:	af00      	add	r7, sp, #0
 8000512:	6078      	str	r0, [r7, #4]
 8000514:	6039      	str	r1, [r7, #0]
    /*Load the current style. It will be modified by the callback*/
    lv_style_copy(&group->style_tmp, style);
 8000516:	687b      	ldr	r3, [r7, #4]
 8000518:	331c      	adds	r3, #28
 800051a:	6839      	ldr	r1, [r7, #0]
 800051c:	4618      	mov	r0, r3
 800051e:	f003 fc8b 	bl	8003e38 <lv_style_copy>

    if(group->editing) {
 8000522:	687b      	ldr	r3, [r7, #4]
 8000524:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8000528:	f003 0302 	and.w	r3, r3, #2
 800052c:	b2db      	uxtb	r3, r3
 800052e:	2b00      	cmp	r3, #0
 8000530:	d00b      	beq.n	800054a <lv_group_mod_style+0x3e>
        if(group->style_mod_edit_cb) group->style_mod_edit_cb(group, &group->style_tmp);
 8000532:	687b      	ldr	r3, [r7, #4]
 8000534:	695b      	ldr	r3, [r3, #20]
 8000536:	2b00      	cmp	r3, #0
 8000538:	d012      	beq.n	8000560 <lv_group_mod_style+0x54>
 800053a:	687b      	ldr	r3, [r7, #4]
 800053c:	695b      	ldr	r3, [r3, #20]
 800053e:	687a      	ldr	r2, [r7, #4]
 8000540:	321c      	adds	r2, #28
 8000542:	4611      	mov	r1, r2
 8000544:	6878      	ldr	r0, [r7, #4]
 8000546:	4798      	blx	r3
 8000548:	e00a      	b.n	8000560 <lv_group_mod_style+0x54>
    } else {
        if(group->style_mod_cb) group->style_mod_cb(group, &group->style_tmp);
 800054a:	687b      	ldr	r3, [r7, #4]
 800054c:	691b      	ldr	r3, [r3, #16]
 800054e:	2b00      	cmp	r3, #0
 8000550:	d006      	beq.n	8000560 <lv_group_mod_style+0x54>
 8000552:	687b      	ldr	r3, [r7, #4]
 8000554:	691b      	ldr	r3, [r3, #16]
 8000556:	687a      	ldr	r2, [r7, #4]
 8000558:	321c      	adds	r2, #28
 800055a:	4611      	mov	r1, r2
 800055c:	6878      	ldr	r0, [r7, #4]
 800055e:	4798      	blx	r3
    }
    return &group->style_tmp;
 8000560:	687b      	ldr	r3, [r7, #4]
 8000562:	331c      	adds	r3, #28
}
 8000564:	4618      	mov	r0, r3
 8000566:	3708      	adds	r7, #8
 8000568:	46bd      	mov	sp, r7
 800056a:	bd80      	pop	{r7, pc}

0800056c <lv_group_get_focused>:
 * Get the focused object or NULL if there isn't one
 * @param group pointer to a group
 * @return pointer to the focused object
 */
lv_obj_t * lv_group_get_focused(const lv_group_t * group)
{
 800056c:	b480      	push	{r7}
 800056e:	b083      	sub	sp, #12
 8000570:	af00      	add	r7, sp, #0
 8000572:	6078      	str	r0, [r7, #4]
    if(!group) return NULL;
 8000574:	687b      	ldr	r3, [r7, #4]
 8000576:	2b00      	cmp	r3, #0
 8000578:	d101      	bne.n	800057e <lv_group_get_focused+0x12>
 800057a:	2300      	movs	r3, #0
 800057c:	e008      	b.n	8000590 <lv_group_get_focused+0x24>
    if(group->obj_focus == NULL) return NULL;
 800057e:	687b      	ldr	r3, [r7, #4]
 8000580:	68db      	ldr	r3, [r3, #12]
 8000582:	2b00      	cmp	r3, #0
 8000584:	d101      	bne.n	800058a <lv_group_get_focused+0x1e>
 8000586:	2300      	movs	r3, #0
 8000588:	e002      	b.n	8000590 <lv_group_get_focused+0x24>

    return *group->obj_focus;
 800058a:	687b      	ldr	r3, [r7, #4]
 800058c:	68db      	ldr	r3, [r3, #12]
 800058e:	681b      	ldr	r3, [r3, #0]
}
 8000590:	4618      	mov	r0, r3
 8000592:	370c      	adds	r7, #12
 8000594:	46bd      	mov	sp, r7
 8000596:	f85d 7b04 	ldr.w	r7, [sp], #4
 800059a:	4770      	bx	lr

0800059c <lv_group_refocus>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void lv_group_refocus(lv_group_t * g)
{
 800059c:	b580      	push	{r7, lr}
 800059e:	b084      	sub	sp, #16
 80005a0:	af00      	add	r7, sp, #0
 80005a2:	6078      	str	r0, [r7, #4]
    /*Refocus must temporarily allow wrapping to work correctly*/
    uint8_t temp_wrap = g->wrap;
 80005a4:	687b      	ldr	r3, [r7, #4]
 80005a6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80005aa:	f3c3 1300 	ubfx	r3, r3, #4, #1
 80005ae:	b2db      	uxtb	r3, r3
 80005b0:	73fb      	strb	r3, [r7, #15]
    g->wrap           = 1;
 80005b2:	687a      	ldr	r2, [r7, #4]
 80005b4:	f892 305c 	ldrb.w	r3, [r2, #92]	; 0x5c
 80005b8:	f043 0310 	orr.w	r3, r3, #16
 80005bc:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c

    if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_NEXT)
 80005c0:	687b      	ldr	r3, [r7, #4]
 80005c2:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80005c6:	f003 0308 	and.w	r3, r3, #8
 80005ca:	b2db      	uxtb	r3, r3
 80005cc:	2b00      	cmp	r3, #0
 80005ce:	d103      	bne.n	80005d8 <lv_group_refocus+0x3c>
        lv_group_focus_next(g);
 80005d0:	6878      	ldr	r0, [r7, #4]
 80005d2:	f7ff ff77 	bl	80004c4 <lv_group_focus_next>
 80005d6:	e00a      	b.n	80005ee <lv_group_refocus+0x52>
    else if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_PREV)
 80005d8:	687b      	ldr	r3, [r7, #4]
 80005da:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80005de:	f003 0308 	and.w	r3, r3, #8
 80005e2:	b2db      	uxtb	r3, r3
 80005e4:	2b00      	cmp	r3, #0
 80005e6:	d002      	beq.n	80005ee <lv_group_refocus+0x52>
        lv_group_focus_prev(g);
 80005e8:	6878      	ldr	r0, [r7, #4]
 80005ea:	f7ff ff7d 	bl	80004e8 <lv_group_focus_prev>
    /*Restore wrap property*/
    g->wrap = temp_wrap;
 80005ee:	7bfb      	ldrb	r3, [r7, #15]
 80005f0:	f003 0301 	and.w	r3, r3, #1
 80005f4:	b2d9      	uxtb	r1, r3
 80005f6:	687a      	ldr	r2, [r7, #4]
 80005f8:	f892 305c 	ldrb.w	r3, [r2, #92]	; 0x5c
 80005fc:	f361 1304 	bfi	r3, r1, #4, #1
 8000600:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
}
 8000604:	bf00      	nop
 8000606:	3710      	adds	r7, #16
 8000608:	46bd      	mov	sp, r7
 800060a:	bd80      	pop	{r7, pc}

0800060c <focus_next_core>:
    }
}

static void focus_next_core(lv_group_t * group, void * (*begin)(const lv_ll_t *),
                            void * (*move)(const lv_ll_t *, const void *))
{
 800060c:	b580      	push	{r7, lr}
 800060e:	b088      	sub	sp, #32
 8000610:	af00      	add	r7, sp, #0
 8000612:	60f8      	str	r0, [r7, #12]
 8000614:	60b9      	str	r1, [r7, #8]
 8000616:	607a      	str	r2, [r7, #4]
    if(group->frozen) return;
 8000618:	68fb      	ldr	r3, [r7, #12]
 800061a:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800061e:	f003 0301 	and.w	r3, r3, #1
 8000622:	b2db      	uxtb	r3, r3
 8000624:	2b00      	cmp	r3, #0
 8000626:	f040 80a6 	bne.w	8000776 <focus_next_core+0x16a>

    lv_obj_t ** obj_next     = group->obj_focus;
 800062a:	68fb      	ldr	r3, [r7, #12]
 800062c:	68db      	ldr	r3, [r3, #12]
 800062e:	61fb      	str	r3, [r7, #28]
    lv_obj_t ** obj_sentinel = NULL;
 8000630:	2300      	movs	r3, #0
 8000632:	61bb      	str	r3, [r7, #24]
    bool can_move            = true;
 8000634:	2301      	movs	r3, #1
 8000636:	75fb      	strb	r3, [r7, #23]
    bool can_begin           = true;
 8000638:	2301      	movs	r3, #1
 800063a:	75bb      	strb	r3, [r7, #22]

    for(;;) {
        if(obj_next == NULL) {
 800063c:	69fb      	ldr	r3, [r7, #28]
 800063e:	2b00      	cmp	r3, #0
 8000640:	d11b      	bne.n	800067a <focus_next_core+0x6e>
            if(group->wrap || obj_sentinel == NULL) {
 8000642:	68fb      	ldr	r3, [r7, #12]
 8000644:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8000648:	f003 0310 	and.w	r3, r3, #16
 800064c:	b2db      	uxtb	r3, r3
 800064e:	2b00      	cmp	r3, #0
 8000650:	d103      	bne.n	800065a <focus_next_core+0x4e>
 8000652:	69bb      	ldr	r3, [r7, #24]
 8000654:	2b00      	cmp	r3, #0
 8000656:	f040 8090 	bne.w	800077a <focus_next_core+0x16e>
                if(!can_begin) return;
 800065a:	7dbb      	ldrb	r3, [r7, #22]
 800065c:	f083 0301 	eor.w	r3, r3, #1
 8000660:	b2db      	uxtb	r3, r3
 8000662:	2b00      	cmp	r3, #0
 8000664:	f040 808b 	bne.w	800077e <focus_next_core+0x172>
                obj_next  = begin(&group->obj_ll);
 8000668:	68fa      	ldr	r2, [r7, #12]
 800066a:	68bb      	ldr	r3, [r7, #8]
 800066c:	4610      	mov	r0, r2
 800066e:	4798      	blx	r3
 8000670:	61f8      	str	r0, [r7, #28]
                can_move  = false;
 8000672:	2300      	movs	r3, #0
 8000674:	75fb      	strb	r3, [r7, #23]
                can_begin = false;
 8000676:	2300      	movs	r3, #0
 8000678:	75bb      	strb	r3, [r7, #22]
                /*Currently focused object is the last/first in the group, keep it that way*/
                return;
            }
        }

        if(obj_sentinel == NULL) {
 800067a:	69bb      	ldr	r3, [r7, #24]
 800067c:	2b00      	cmp	r3, #0
 800067e:	d104      	bne.n	800068a <focus_next_core+0x7e>
            obj_sentinel = obj_next;
 8000680:	69fb      	ldr	r3, [r7, #28]
 8000682:	61bb      	str	r3, [r7, #24]
            if(obj_sentinel == NULL) return; /*Group is empty*/
 8000684:	69bb      	ldr	r3, [r7, #24]
 8000686:	2b00      	cmp	r3, #0
 8000688:	d07b      	beq.n	8000782 <focus_next_core+0x176>
        }

        if(can_move) {
 800068a:	7dfb      	ldrb	r3, [r7, #23]
 800068c:	2b00      	cmp	r3, #0
 800068e:	d009      	beq.n	80006a4 <focus_next_core+0x98>
            obj_next = move(&group->obj_ll, obj_next);
 8000690:	68fa      	ldr	r2, [r7, #12]
 8000692:	687b      	ldr	r3, [r7, #4]
 8000694:	69f9      	ldr	r1, [r7, #28]
 8000696:	4610      	mov	r0, r2
 8000698:	4798      	blx	r3
 800069a:	61f8      	str	r0, [r7, #28]

            /*Give up if we walked the entire list and haven't found another visible object*/
            if(obj_next == obj_sentinel) return;
 800069c:	69fa      	ldr	r2, [r7, #28]
 800069e:	69bb      	ldr	r3, [r7, #24]
 80006a0:	429a      	cmp	r2, r3
 80006a2:	d070      	beq.n	8000786 <focus_next_core+0x17a>
        }

        can_move = true;
 80006a4:	2301      	movs	r3, #1
 80006a6:	75fb      	strb	r3, [r7, #23]

        if(obj_next == NULL) continue;
 80006a8:	69fb      	ldr	r3, [r7, #28]
 80006aa:	2b00      	cmp	r3, #0
 80006ac:	d00b      	beq.n	80006c6 <focus_next_core+0xba>

        /*Hidden objects don't receive focus*/
        if(!lv_obj_get_hidden(*obj_next)) break;
 80006ae:	69fb      	ldr	r3, [r7, #28]
 80006b0:	681b      	ldr	r3, [r3, #0]
 80006b2:	4618      	mov	r0, r3
 80006b4:	f002 f8b8 	bl	8002828 <lv_obj_get_hidden>
 80006b8:	4603      	mov	r3, r0
 80006ba:	f083 0301 	eor.w	r3, r3, #1
 80006be:	b2db      	uxtb	r3, r3
 80006c0:	2b00      	cmp	r3, #0
 80006c2:	d102      	bne.n	80006ca <focus_next_core+0xbe>
 80006c4:	e7ba      	b.n	800063c <focus_next_core+0x30>
        if(obj_next == NULL) continue;
 80006c6:	bf00      	nop
        if(obj_next == NULL) {
 80006c8:	e7b8      	b.n	800063c <focus_next_core+0x30>
        if(!lv_obj_get_hidden(*obj_next)) break;
 80006ca:	bf00      	nop
    }

    if(obj_next == group->obj_focus) return; /*There's only one visible object and it's already focused*/
 80006cc:	68fb      	ldr	r3, [r7, #12]
 80006ce:	68db      	ldr	r3, [r3, #12]
 80006d0:	69fa      	ldr	r2, [r7, #28]
 80006d2:	429a      	cmp	r2, r3
 80006d4:	d059      	beq.n	800078a <focus_next_core+0x17e>

    if(group->obj_focus) {
 80006d6:	68fb      	ldr	r3, [r7, #12]
 80006d8:	68db      	ldr	r3, [r3, #12]
 80006da:	2b00      	cmp	r3, #0
 80006dc:	d01c      	beq.n	8000718 <focus_next_core+0x10c>
        (*group->obj_focus)->signal_cb(*group->obj_focus, LV_SIGNAL_DEFOCUS, NULL);
 80006de:	68fb      	ldr	r3, [r7, #12]
 80006e0:	68db      	ldr	r3, [r3, #12]
 80006e2:	681b      	ldr	r3, [r3, #0]
 80006e4:	69db      	ldr	r3, [r3, #28]
 80006e6:	68fa      	ldr	r2, [r7, #12]
 80006e8:	68d2      	ldr	r2, [r2, #12]
 80006ea:	6810      	ldr	r0, [r2, #0]
 80006ec:	2200      	movs	r2, #0
 80006ee:	2111      	movs	r1, #17
 80006f0:	4798      	blx	r3
        lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_DEFOCUSED, NULL);
 80006f2:	68fb      	ldr	r3, [r7, #12]
 80006f4:	68db      	ldr	r3, [r3, #12]
 80006f6:	681b      	ldr	r3, [r3, #0]
 80006f8:	2200      	movs	r2, #0
 80006fa:	210d      	movs	r1, #13
 80006fc:	4618      	mov	r0, r3
 80006fe:	f001 fcf7 	bl	80020f0 <lv_event_send>
 8000702:	4603      	mov	r3, r0
 8000704:	757b      	strb	r3, [r7, #21]
        if(res != LV_RES_OK) return;
 8000706:	7d7b      	ldrb	r3, [r7, #21]
 8000708:	2b01      	cmp	r3, #1
 800070a:	d140      	bne.n	800078e <focus_next_core+0x182>
        lv_obj_invalidate(*group->obj_focus);
 800070c:	68fb      	ldr	r3, [r7, #12]
 800070e:	68db      	ldr	r3, [r3, #12]
 8000710:	681b      	ldr	r3, [r3, #0]
 8000712:	4618      	mov	r0, r3
 8000714:	f000 fcc2 	bl	800109c <lv_obj_invalidate>
    }

    group->obj_focus = obj_next;
 8000718:	68fb      	ldr	r3, [r7, #12]
 800071a:	69fa      	ldr	r2, [r7, #28]
 800071c:	60da      	str	r2, [r3, #12]

    (*group->obj_focus)->signal_cb(*group->obj_focus, LV_SIGNAL_FOCUS, NULL);
 800071e:	68fb      	ldr	r3, [r7, #12]
 8000720:	68db      	ldr	r3, [r3, #12]
 8000722:	681b      	ldr	r3, [r3, #0]
 8000724:	69db      	ldr	r3, [r3, #28]
 8000726:	68fa      	ldr	r2, [r7, #12]
 8000728:	68d2      	ldr	r2, [r2, #12]
 800072a:	6810      	ldr	r0, [r2, #0]
 800072c:	2200      	movs	r2, #0
 800072e:	2110      	movs	r1, #16
 8000730:	4798      	blx	r3
    lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_FOCUSED, NULL);
 8000732:	68fb      	ldr	r3, [r7, #12]
 8000734:	68db      	ldr	r3, [r3, #12]
 8000736:	681b      	ldr	r3, [r3, #0]
 8000738:	2200      	movs	r2, #0
 800073a:	210c      	movs	r1, #12
 800073c:	4618      	mov	r0, r3
 800073e:	f001 fcd7 	bl	80020f0 <lv_event_send>
 8000742:	4603      	mov	r3, r0
 8000744:	753b      	strb	r3, [r7, #20]
    if(res != LV_RES_OK) return;
 8000746:	7d3b      	ldrb	r3, [r7, #20]
 8000748:	2b01      	cmp	r3, #1
 800074a:	d122      	bne.n	8000792 <focus_next_core+0x186>

    /*If the object or its parent has `top == true` bring it to the foregorund*/
    obj_to_foreground(*group->obj_focus);
 800074c:	68fb      	ldr	r3, [r7, #12]
 800074e:	68db      	ldr	r3, [r3, #12]
 8000750:	681b      	ldr	r3, [r3, #0]
 8000752:	4618      	mov	r0, r3
 8000754:	f000 f821 	bl	800079a <obj_to_foreground>

    lv_obj_invalidate(*group->obj_focus);
 8000758:	68fb      	ldr	r3, [r7, #12]
 800075a:	68db      	ldr	r3, [r3, #12]
 800075c:	681b      	ldr	r3, [r3, #0]
 800075e:	4618      	mov	r0, r3
 8000760:	f000 fc9c 	bl	800109c <lv_obj_invalidate>

    if(group->focus_cb) group->focus_cb(group);
 8000764:	68fb      	ldr	r3, [r7, #12]
 8000766:	699b      	ldr	r3, [r3, #24]
 8000768:	2b00      	cmp	r3, #0
 800076a:	d013      	beq.n	8000794 <focus_next_core+0x188>
 800076c:	68fb      	ldr	r3, [r7, #12]
 800076e:	699b      	ldr	r3, [r3, #24]
 8000770:	68f8      	ldr	r0, [r7, #12]
 8000772:	4798      	blx	r3
 8000774:	e00e      	b.n	8000794 <focus_next_core+0x188>
    if(group->frozen) return;
 8000776:	bf00      	nop
 8000778:	e00c      	b.n	8000794 <focus_next_core+0x188>
                return;
 800077a:	bf00      	nop
 800077c:	e00a      	b.n	8000794 <focus_next_core+0x188>
                if(!can_begin) return;
 800077e:	bf00      	nop
 8000780:	e008      	b.n	8000794 <focus_next_core+0x188>
            if(obj_sentinel == NULL) return; /*Group is empty*/
 8000782:	bf00      	nop
 8000784:	e006      	b.n	8000794 <focus_next_core+0x188>
            if(obj_next == obj_sentinel) return;
 8000786:	bf00      	nop
 8000788:	e004      	b.n	8000794 <focus_next_core+0x188>
    if(obj_next == group->obj_focus) return; /*There's only one visible object and it's already focused*/
 800078a:	bf00      	nop
 800078c:	e002      	b.n	8000794 <focus_next_core+0x188>
        if(res != LV_RES_OK) return;
 800078e:	bf00      	nop
 8000790:	e000      	b.n	8000794 <focus_next_core+0x188>
    if(res != LV_RES_OK) return;
 8000792:	bf00      	nop
}
 8000794:	3720      	adds	r7, #32
 8000796:	46bd      	mov	sp, r7
 8000798:	bd80      	pop	{r7, pc}

0800079a <obj_to_foreground>:

static void obj_to_foreground(lv_obj_t * obj)
{
 800079a:	b580      	push	{r7, lr}
 800079c:	b084      	sub	sp, #16
 800079e:	af00      	add	r7, sp, #0
 80007a0:	6078      	str	r0, [r7, #4]
    /*Search for 'top' attribute*/
    lv_obj_t * i        = obj;
 80007a2:	687b      	ldr	r3, [r7, #4]
 80007a4:	60fb      	str	r3, [r7, #12]
    lv_obj_t * last_top = NULL;
 80007a6:	2300      	movs	r3, #0
 80007a8:	60bb      	str	r3, [r7, #8]
    while(i != NULL) {
 80007aa:	e00d      	b.n	80007c8 <obj_to_foreground+0x2e>
        if(i->top != 0) last_top = i;
 80007ac:	68fb      	ldr	r3, [r7, #12]
 80007ae:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80007b2:	f003 0320 	and.w	r3, r3, #32
 80007b6:	b2db      	uxtb	r3, r3
 80007b8:	2b00      	cmp	r3, #0
 80007ba:	d001      	beq.n	80007c0 <obj_to_foreground+0x26>
 80007bc:	68fb      	ldr	r3, [r7, #12]
 80007be:	60bb      	str	r3, [r7, #8]
        i = lv_obj_get_parent(i);
 80007c0:	68f8      	ldr	r0, [r7, #12]
 80007c2:	f001 fe4d 	bl	8002460 <lv_obj_get_parent>
 80007c6:	60f8      	str	r0, [r7, #12]
    while(i != NULL) {
 80007c8:	68fb      	ldr	r3, [r7, #12]
 80007ca:	2b00      	cmp	r3, #0
 80007cc:	d1ee      	bne.n	80007ac <obj_to_foreground+0x12>
    }

    if(last_top != NULL) {
 80007ce:	68bb      	ldr	r3, [r7, #8]
 80007d0:	2b00      	cmp	r3, #0
 80007d2:	d002      	beq.n	80007da <obj_to_foreground+0x40>
        /*Move the last_top object to the foreground*/
        lv_obj_move_foreground(last_top);
 80007d4:	68b8      	ldr	r0, [r7, #8]
 80007d6:	f000 fcaf 	bl	8001138 <lv_obj_move_foreground>
    }
}
 80007da:	bf00      	nop
 80007dc:	3710      	adds	r7, #16
 80007de:	46bd      	mov	sp, r7
 80007e0:	bd80      	pop	{r7, pc}

080007e2 <lv_indev_init>:

/**
 * Initialize the display input device subsystem
 */
void lv_indev_init(void)
{
 80007e2:	b580      	push	{r7, lr}
 80007e4:	af00      	add	r7, sp, #0
    lv_indev_reset(NULL); /*Reset all input devices*/
 80007e6:	2000      	movs	r0, #0
 80007e8:	f000 f80e 	bl	8000808 <lv_indev_reset>
}
 80007ec:	bf00      	nop
 80007ee:	bd80      	pop	{r7, pc}

080007f0 <lv_indev_get_act>:
 * Get the currently processed input device. Can be used in action functions too.
 * @return pointer to the currently processed input device or NULL if no input device processing
 * right now
 */
lv_indev_t * lv_indev_get_act(void)
{
 80007f0:	b480      	push	{r7}
 80007f2:	af00      	add	r7, sp, #0
    return indev_act;
 80007f4:	4b03      	ldr	r3, [pc, #12]	; (8000804 <lv_indev_get_act+0x14>)
 80007f6:	681b      	ldr	r3, [r3, #0]
}
 80007f8:	4618      	mov	r0, r3
 80007fa:	46bd      	mov	sp, r7
 80007fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000800:	4770      	bx	lr
 8000802:	bf00      	nop
 8000804:	20000090 	.word	0x20000090

08000808 <lv_indev_reset>:
/**
 * Reset one or all input devices
 * @param indev pointer to an input device to reset or NULL to reset all of them
 */
void lv_indev_reset(lv_indev_t * indev)
{
 8000808:	b580      	push	{r7, lr}
 800080a:	b084      	sub	sp, #16
 800080c:	af00      	add	r7, sp, #0
 800080e:	6078      	str	r0, [r7, #4]
    if(indev)
 8000810:	687b      	ldr	r3, [r7, #4]
 8000812:	2b00      	cmp	r3, #0
 8000814:	d007      	beq.n	8000826 <lv_indev_reset+0x1e>
        indev->proc.reset_query = 1;
 8000816:	687a      	ldr	r2, [r7, #4]
 8000818:	f892 304c 	ldrb.w	r3, [r2, #76]	; 0x4c
 800081c:	f043 0302 	orr.w	r3, r3, #2
 8000820:	f882 304c 	strb.w	r3, [r2, #76]	; 0x4c
            i->proc.reset_query = 1;

            i = lv_indev_get_next(i);
        }
    }
}
 8000824:	e012      	b.n	800084c <lv_indev_reset+0x44>
        lv_indev_t * i = lv_indev_get_next(NULL);
 8000826:	2000      	movs	r0, #0
 8000828:	f00b f986 	bl	800bb38 <lv_indev_get_next>
 800082c:	60f8      	str	r0, [r7, #12]
        while(i) {
 800082e:	e00a      	b.n	8000846 <lv_indev_reset+0x3e>
            i->proc.reset_query = 1;
 8000830:	68fa      	ldr	r2, [r7, #12]
 8000832:	f892 304c 	ldrb.w	r3, [r2, #76]	; 0x4c
 8000836:	f043 0302 	orr.w	r3, r3, #2
 800083a:	f882 304c 	strb.w	r3, [r2, #76]	; 0x4c
            i = lv_indev_get_next(i);
 800083e:	68f8      	ldr	r0, [r7, #12]
 8000840:	f00b f97a 	bl	800bb38 <lv_indev_get_next>
 8000844:	60f8      	str	r0, [r7, #12]
        while(i) {
 8000846:	68fb      	ldr	r3, [r7, #12]
 8000848:	2b00      	cmp	r3, #0
 800084a:	d1f1      	bne.n	8000830 <lv_indev_reset+0x28>
}
 800084c:	bf00      	nop
 800084e:	3710      	adds	r7, #16
 8000850:	46bd      	mov	sp, r7
 8000852:	bd80      	pop	{r7, pc}

08000854 <lv_indev_is_dragging>:
 * LV_INDEV_TYPE_BUTTON)
 * @param indev pointer to an input device
 * @return true: drag is in progress
 */
bool lv_indev_is_dragging(const lv_indev_t * indev)
{
 8000854:	b480      	push	{r7}
 8000856:	b083      	sub	sp, #12
 8000858:	af00      	add	r7, sp, #0
 800085a:	6078      	str	r0, [r7, #4]
    if(indev == NULL) return false;
 800085c:	687b      	ldr	r3, [r7, #4]
 800085e:	2b00      	cmp	r3, #0
 8000860:	d101      	bne.n	8000866 <lv_indev_is_dragging+0x12>
 8000862:	2300      	movs	r3, #0
 8000864:	e014      	b.n	8000890 <lv_indev_is_dragging+0x3c>
    if(indev->driver.type != LV_INDEV_TYPE_POINTER && indev->driver.type != LV_INDEV_TYPE_BUTTON) return false;
 8000866:	687b      	ldr	r3, [r7, #4]
 8000868:	781b      	ldrb	r3, [r3, #0]
 800086a:	2b01      	cmp	r3, #1
 800086c:	d005      	beq.n	800087a <lv_indev_is_dragging+0x26>
 800086e:	687b      	ldr	r3, [r7, #4]
 8000870:	781b      	ldrb	r3, [r3, #0]
 8000872:	2b03      	cmp	r3, #3
 8000874:	d001      	beq.n	800087a <lv_indev_is_dragging+0x26>
 8000876:	2300      	movs	r3, #0
 8000878:	e00a      	b.n	8000890 <lv_indev_is_dragging+0x3c>
    return indev->proc.types.pointer.drag_in_prog == 0 ? false : true;
 800087a:	687b      	ldr	r3, [r7, #4]
 800087c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8000880:	f003 0302 	and.w	r3, r3, #2
 8000884:	b2db      	uxtb	r3, r3
 8000886:	2b00      	cmp	r3, #0
 8000888:	bf14      	ite	ne
 800088a:	2301      	movne	r3, #1
 800088c:	2300      	moveq	r3, #0
 800088e:	b2db      	uxtb	r3, r3
}
 8000890:	4618      	mov	r0, r3
 8000892:	370c      	adds	r7, #12
 8000894:	46bd      	mov	sp, r7
 8000896:	f85d 7b04 	ldr.w	r7, [sp], #4
 800089a:	4770      	bx	lr

0800089c <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 800089c:	b580      	push	{r7, lr}
 800089e:	b082      	sub	sp, #8
 80008a0:	af00      	add	r7, sp, #0
 80008a2:	6078      	str	r0, [r7, #4]
 80008a4:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 80008a6:	2208      	movs	r2, #8
 80008a8:	6839      	ldr	r1, [r7, #0]
 80008aa:	6878      	ldr	r0, [r7, #4]
 80008ac:	f012 ff4c 	bl	8013748 <memcpy>
}
 80008b0:	bf00      	nop
 80008b2:	3708      	adds	r7, #8
 80008b4:	46bd      	mov	sp, r7
 80008b6:	bd80      	pop	{r7, pc}

080008b8 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 80008b8:	b480      	push	{r7}
 80008ba:	b083      	sub	sp, #12
 80008bc:	af00      	add	r7, sp, #0
 80008be:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 80008c0:	687b      	ldr	r3, [r7, #4]
 80008c2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80008c6:	b29a      	uxth	r2, r3
 80008c8:	687b      	ldr	r3, [r7, #4]
 80008ca:	f9b3 3000 	ldrsh.w	r3, [r3]
 80008ce:	b29b      	uxth	r3, r3
 80008d0:	1ad3      	subs	r3, r2, r3
 80008d2:	b29b      	uxth	r3, r3
 80008d4:	3301      	adds	r3, #1
 80008d6:	b29b      	uxth	r3, r3
 80008d8:	b21b      	sxth	r3, r3
}
 80008da:	4618      	mov	r0, r3
 80008dc:	370c      	adds	r7, #12
 80008de:	46bd      	mov	sp, r7
 80008e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008e4:	4770      	bx	lr

080008e6 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 80008e6:	b480      	push	{r7}
 80008e8:	b083      	sub	sp, #12
 80008ea:	af00      	add	r7, sp, #0
 80008ec:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 80008ee:	687b      	ldr	r3, [r7, #4]
 80008f0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80008f4:	b29a      	uxth	r2, r3
 80008f6:	687b      	ldr	r3, [r7, #4]
 80008f8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80008fc:	b29b      	uxth	r3, r3
 80008fe:	1ad3      	subs	r3, r2, r3
 8000900:	b29b      	uxth	r3, r3
 8000902:	3301      	adds	r3, #1
 8000904:	b29b      	uxth	r3, r3
 8000906:	b21b      	sxth	r3, r3
}
 8000908:	4618      	mov	r0, r3
 800090a:	370c      	adds	r7, #12
 800090c:	46bd      	mov	sp, r7
 800090e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000912:	4770      	bx	lr

08000914 <lv_init>:

/**
 * Init. the 'lv' library.
 */
void lv_init(void)
{
 8000914:	b580      	push	{r7, lr}
 8000916:	af00      	add	r7, sp, #0
    /* Do nothing if already initialized */
    if(lv_initialized) {
 8000918:	4b13      	ldr	r3, [pc, #76]	; (8000968 <lv_init+0x54>)
 800091a:	781b      	ldrb	r3, [r3, #0]
 800091c:	2b00      	cmp	r3, #0
 800091e:	d121      	bne.n	8000964 <lv_init+0x50>
    }

    LV_LOG_TRACE("lv_init started");

    /*Initialize the lv_misc modules*/
    lv_mem_init();
 8000920:	f00c f954 	bl	800cbcc <lv_mem_init>
    lv_task_core_init();
 8000924:	f00c faf6 	bl	800cf14 <lv_task_core_init>

#if LV_USE_FILESYSTEM
    lv_fs_init();
 8000928:	f00b fd30 	bl	800c38c <lv_fs_init>
#endif

#if LV_USE_ANIMATION
    lv_anim_core_init();
 800092c:	f00b f96a 	bl	800bc04 <lv_anim_core_init>
#endif

#if LV_USE_GROUP
    lv_group_init();
 8000930:	f7ff fd5c 	bl	80003ec <lv_group_init>
#endif

    /*Init. the sstyles*/
    lv_style_init();
 8000934:	f003 f824 	bl	8003980 <lv_style_init>

    /*Initialize the screen refresh system*/
    lv_refr_init();
 8000938:	f002 fa53 	bl	8002de2 <lv_refr_init>

    lv_ll_init(&LV_GC_ROOT(_lv_disp_ll), sizeof(lv_disp_t));
 800093c:	f44f 71b6 	mov.w	r1, #364	; 0x16c
 8000940:	480a      	ldr	r0, [pc, #40]	; (800096c <lv_init+0x58>)
 8000942:	f00b feb9 	bl	800c6b8 <lv_ll_init>
    lv_ll_init(&LV_GC_ROOT(_lv_indev_ll), sizeof(lv_indev_t));
 8000946:	215c      	movs	r1, #92	; 0x5c
 8000948:	4809      	ldr	r0, [pc, #36]	; (8000970 <lv_init+0x5c>)
 800094a:	f00b feb5 	bl	800c6b8 <lv_ll_init>

    /*Init the input device handling*/
    lv_indev_init();
 800094e:	f7ff ff48 	bl	80007e2 <lv_indev_init>

    lv_img_decoder_init();
 8000952:	f009 f8f1 	bl	8009b38 <lv_img_decoder_init>
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);
 8000956:	2001      	movs	r0, #1
 8000958:	f009 f800 	bl	800995c <lv_img_cache_set_size>

    lv_initialized = true;
 800095c:	4b02      	ldr	r3, [pc, #8]	; (8000968 <lv_init+0x54>)
 800095e:	2201      	movs	r2, #1
 8000960:	701a      	strb	r2, [r3, #0]
 8000962:	e000      	b.n	8000966 <lv_init+0x52>
        return;
 8000964:	bf00      	nop
    LV_LOG_INFO("lv_init ready");
}
 8000966:	bd80      	pop	{r7, pc}
 8000968:	20000094 	.word	0x20000094
 800096c:	2000995c 	.word	0x2000995c
 8000970:	2000994c 	.word	0x2000994c

08000974 <lv_obj_create>:
 *                  If NULL then a screen will be created
 * @param copy pointer to a base object, if not NULL then the new object will be copied from it
 * @return pointer to the new object
 */
lv_obj_t * lv_obj_create(lv_obj_t * parent, const lv_obj_t * copy)
{
 8000974:	b590      	push	{r4, r7, lr}
 8000976:	b087      	sub	sp, #28
 8000978:	af00      	add	r7, sp, #0
 800097a:	6078      	str	r0, [r7, #4]
 800097c:	6039      	str	r1, [r7, #0]

    lv_obj_t * new_obj = NULL;
 800097e:	2300      	movs	r3, #0
 8000980:	617b      	str	r3, [r7, #20]
    /*Create a screen if the parent is NULL*/
    if(parent == NULL) {
 8000982:	687b      	ldr	r3, [r7, #4]
 8000984:	2b00      	cmp	r3, #0
 8000986:	f040 80cb 	bne.w	8000b20 <lv_obj_create+0x1ac>
        LV_LOG_TRACE("Screen create started");
        lv_disp_t * disp = lv_disp_get_default();
 800098a:	f00b f815 	bl	800b9b8 <lv_disp_get_default>
 800098e:	60f8      	str	r0, [r7, #12]
        if(!disp) {
 8000990:	68fb      	ldr	r3, [r7, #12]
 8000992:	2b00      	cmp	r3, #0
 8000994:	d101      	bne.n	800099a <lv_obj_create+0x26>
            LV_LOG_WARN("lv_obj_create: not display created to so far. No place to assign the new screen");
            return NULL;
 8000996:	2300      	movs	r3, #0
 8000998:	e2c1      	b.n	8000f1e <lv_obj_create+0x5aa>
        }

        new_obj = lv_ll_ins_head(&disp->scr_ll);
 800099a:	68fb      	ldr	r3, [r7, #12]
 800099c:	332c      	adds	r3, #44	; 0x2c
 800099e:	4618      	mov	r0, r3
 80009a0:	f00b feaa 	bl	800c6f8 <lv_ll_ins_head>
 80009a4:	6178      	str	r0, [r7, #20]
        LV_ASSERT_MEM(new_obj);
 80009a6:	6978      	ldr	r0, [r7, #20]
 80009a8:	f7ff fc26 	bl	80001f8 <lv_debug_check_null>
 80009ac:	4603      	mov	r3, r0
 80009ae:	f083 0301 	eor.w	r3, r3, #1
 80009b2:	b2db      	uxtb	r3, r3
 80009b4:	2b00      	cmp	r3, #0
 80009b6:	d008      	beq.n	80009ca <lv_obj_create+0x56>
 80009b8:	697b      	ldr	r3, [r7, #20]
 80009ba:	f04f 0400 	mov.w	r4, #0
 80009be:	461a      	mov	r2, r3
 80009c0:	4623      	mov	r3, r4
 80009c2:	48a5      	ldr	r0, [pc, #660]	; (8000c58 <lv_obj_create+0x2e4>)
 80009c4:	f7ff fc42 	bl	800024c <lv_debug_log_error>
 80009c8:	e7fe      	b.n	80009c8 <lv_obj_create+0x54>
        if(new_obj == NULL) return NULL;
 80009ca:	697b      	ldr	r3, [r7, #20]
 80009cc:	2b00      	cmp	r3, #0
 80009ce:	d101      	bne.n	80009d4 <lv_obj_create+0x60>
 80009d0:	2300      	movs	r3, #0
 80009d2:	e2a4      	b.n	8000f1e <lv_obj_create+0x5aa>

        new_obj->par = NULL; /*Screens has no a parent*/
 80009d4:	697b      	ldr	r3, [r7, #20]
 80009d6:	2200      	movs	r2, #0
 80009d8:	601a      	str	r2, [r3, #0]
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
 80009da:	697b      	ldr	r3, [r7, #20]
 80009dc:	3304      	adds	r3, #4
 80009de:	2144      	movs	r1, #68	; 0x44
 80009e0:	4618      	mov	r0, r3
 80009e2:	f00b fe69 	bl	800c6b8 <lv_ll_init>

        /*Set the callbacks*/
        new_obj->signal_cb = lv_obj_signal;
 80009e6:	697b      	ldr	r3, [r7, #20]
 80009e8:	4a9c      	ldr	r2, [pc, #624]	; (8000c5c <lv_obj_create+0x2e8>)
 80009ea:	61da      	str	r2, [r3, #28]
        new_obj->design_cb = lv_obj_design;
 80009ec:	697b      	ldr	r3, [r7, #20]
 80009ee:	4a9c      	ldr	r2, [pc, #624]	; (8000c60 <lv_obj_create+0x2ec>)
 80009f0:	621a      	str	r2, [r3, #32]
        new_obj->event_cb = NULL;
 80009f2:	697b      	ldr	r3, [r7, #20]
 80009f4:	2200      	movs	r2, #0
 80009f6:	619a      	str	r2, [r3, #24]

        /*Set coordinates to full screen size*/
        new_obj->coords.x1    = 0;
 80009f8:	697b      	ldr	r3, [r7, #20]
 80009fa:	2200      	movs	r2, #0
 80009fc:	821a      	strh	r2, [r3, #16]
        new_obj->coords.y1    = 0;
 80009fe:	697b      	ldr	r3, [r7, #20]
 8000a00:	2200      	movs	r2, #0
 8000a02:	825a      	strh	r2, [r3, #18]
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
 8000a04:	2000      	movs	r0, #0
 8000a06:	f00a ffe3 	bl	800b9d0 <lv_disp_get_hor_res>
 8000a0a:	4603      	mov	r3, r0
 8000a0c:	b29b      	uxth	r3, r3
 8000a0e:	3b01      	subs	r3, #1
 8000a10:	b29b      	uxth	r3, r3
 8000a12:	b21a      	sxth	r2, r3
 8000a14:	697b      	ldr	r3, [r7, #20]
 8000a16:	829a      	strh	r2, [r3, #20]
        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;
 8000a18:	2000      	movs	r0, #0
 8000a1a:	f00a fffa 	bl	800ba12 <lv_disp_get_ver_res>
 8000a1e:	4603      	mov	r3, r0
 8000a20:	b29b      	uxth	r3, r3
 8000a22:	3b01      	subs	r3, #1
 8000a24:	b29b      	uxth	r3, r3
 8000a26:	b21a      	sxth	r2, r3
 8000a28:	697b      	ldr	r3, [r7, #20]
 8000a2a:	82da      	strh	r2, [r3, #22]
        new_obj->ext_draw_pad = 0;
 8000a2c:	697b      	ldr	r3, [r7, #20]
 8000a2e:	2200      	movs	r2, #0
 8000a30:	869a      	strh	r2, [r3, #52]	; 0x34
        new_obj->ext_click_pad_ver = 0;
#endif

        /*Init realign*/
#if LV_USE_OBJ_REALIGN
        new_obj->realign.align        = LV_ALIGN_CENTER;
 8000a32:	697b      	ldr	r3, [r7, #20]
 8000a34:	2200      	movs	r2, #0
 8000a36:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        new_obj->realign.xofs         = 0;
 8000a3a:	697b      	ldr	r3, [r7, #20]
 8000a3c:	2200      	movs	r2, #0
 8000a3e:	879a      	strh	r2, [r3, #60]	; 0x3c
        new_obj->realign.yofs         = 0;
 8000a40:	697b      	ldr	r3, [r7, #20]
 8000a42:	2200      	movs	r2, #0
 8000a44:	87da      	strh	r2, [r3, #62]	; 0x3e
        new_obj->realign.base         = NULL;
 8000a46:	697b      	ldr	r3, [r7, #20]
 8000a48:	2200      	movs	r2, #0
 8000a4a:	639a      	str	r2, [r3, #56]	; 0x38
        new_obj->realign.auto_realign = 0;
 8000a4c:	697a      	ldr	r2, [r7, #20]
 8000a4e:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8000a52:	f36f 0300 	bfc	r3, #0, #1
 8000a56:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif

        /*Set the default styles*/
        lv_theme_t * th = lv_theme_get_current();
 8000a5a:	f010 fafd 	bl	8011058 <lv_theme_get_current>
 8000a5e:	60b8      	str	r0, [r7, #8]
        if(th) {
 8000a60:	68bb      	ldr	r3, [r7, #8]
 8000a62:	2b00      	cmp	r3, #0
 8000a64:	d004      	beq.n	8000a70 <lv_obj_create+0xfc>
            new_obj->style_p = th->style.scr;
 8000a66:	68bb      	ldr	r3, [r7, #8]
 8000a68:	681a      	ldr	r2, [r3, #0]
 8000a6a:	697b      	ldr	r3, [r7, #20]
 8000a6c:	629a      	str	r2, [r3, #40]	; 0x28
 8000a6e:	e002      	b.n	8000a76 <lv_obj_create+0x102>
        } else {
            new_obj->style_p = &lv_style_scr;
 8000a70:	697b      	ldr	r3, [r7, #20]
 8000a72:	4a7c      	ldr	r2, [pc, #496]	; (8000c64 <lv_obj_create+0x2f0>)
 8000a74:	629a      	str	r2, [r3, #40]	; 0x28
#if LV_USE_USER_DATA
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
#endif

#if LV_USE_GROUP
        new_obj->group_p = NULL;
 8000a76:	697b      	ldr	r3, [r7, #20]
 8000a78:	2200      	movs	r2, #0
 8000a7a:	62da      	str	r2, [r3, #44]	; 0x2c
#endif
        /*Set attributes*/
        new_obj->click        = 0;
 8000a7c:	697a      	ldr	r2, [r7, #20]
 8000a7e:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000a82:	f36f 0300 	bfc	r3, #0, #1
 8000a86:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag         = 0;
 8000a8a:	697a      	ldr	r2, [r7, #20]
 8000a8c:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000a90:	f36f 0341 	bfc	r3, #1, #1
 8000a94:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_throw   = 0;
 8000a98:	697a      	ldr	r2, [r7, #20]
 8000a9a:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000a9e:	f36f 0382 	bfc	r3, #2, #1
 8000aa2:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_parent  = 0;
 8000aa6:	697a      	ldr	r2, [r7, #20]
 8000aa8:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000aac:	f36f 03c3 	bfc	r3, #3, #1
 8000ab0:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->hidden       = 0;
 8000ab4:	697a      	ldr	r2, [r7, #20]
 8000ab6:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000aba:	f36f 1304 	bfc	r3, #4, #1
 8000abe:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->top          = 0;
 8000ac2:	697a      	ldr	r2, [r7, #20]
 8000ac4:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000ac8:	f36f 1345 	bfc	r3, #5, #1
 8000acc:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->protect      = LV_PROTECT_NONE;
 8000ad0:	697b      	ldr	r3, [r7, #20]
 8000ad2:	2200      	movs	r2, #0
 8000ad4:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
        new_obj->opa_scale_en = 0;
 8000ad8:	697a      	ldr	r2, [r7, #20]
 8000ada:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000ade:	f36f 1386 	bfc	r3, #6, #1
 8000ae2:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->opa_scale    = LV_OPA_COVER;
 8000ae6:	697b      	ldr	r3, [r7, #20]
 8000ae8:	22ff      	movs	r2, #255	; 0xff
 8000aea:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
        new_obj->parent_event = 0;
 8000aee:	697a      	ldr	r2, [r7, #20]
 8000af0:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000af4:	f36f 13c7 	bfc	r3, #7, #1
 8000af8:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
#if LV_USE_BIDI
        new_obj->base_dir     = LV_BIDI_BASE_DIR_DEF;
#else
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
 8000afc:	697a      	ldr	r2, [r7, #20]
 8000afe:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 8000b02:	f36f 0383 	bfc	r3, #2, #2
 8000b06:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
#endif

        new_obj->reserved     = 0;
 8000b0a:	697a      	ldr	r2, [r7, #20]
 8000b0c:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 8000b10:	f36f 1306 	bfc	r3, #4, #3
 8000b14:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31

        new_obj->ext_attr = NULL;
 8000b18:	697b      	ldr	r3, [r7, #20]
 8000b1a:	2200      	movs	r2, #0
 8000b1c:	625a      	str	r2, [r3, #36]	; 0x24
 8000b1e:	e0fc      	b.n	8000d1a <lv_obj_create+0x3a6>
        LV_LOG_INFO("Screen create ready");
    }
    /*parent != NULL create normal obj. on a parent*/
    else {
        LV_LOG_TRACE("Object create started");
        LV_ASSERT_OBJ(parent, LV_OBJX_NAME);
 8000b20:	6878      	ldr	r0, [r7, #4]
 8000b22:	f7ff fb69 	bl	80001f8 <lv_debug_check_null>
 8000b26:	4603      	mov	r3, r0
 8000b28:	f083 0301 	eor.w	r3, r3, #1
 8000b2c:	b2db      	uxtb	r3, r3
 8000b2e:	2b00      	cmp	r3, #0
 8000b30:	d008      	beq.n	8000b44 <lv_obj_create+0x1d0>
 8000b32:	687b      	ldr	r3, [r7, #4]
 8000b34:	f04f 0400 	mov.w	r4, #0
 8000b38:	461a      	mov	r2, r3
 8000b3a:	4623      	mov	r3, r4
 8000b3c:	484a      	ldr	r0, [pc, #296]	; (8000c68 <lv_obj_create+0x2f4>)
 8000b3e:	f7ff fb85 	bl	800024c <lv_debug_log_error>
 8000b42:	e7fe      	b.n	8000b42 <lv_obj_create+0x1ce>

        new_obj = lv_ll_ins_head(&parent->child_ll);
 8000b44:	687b      	ldr	r3, [r7, #4]
 8000b46:	3304      	adds	r3, #4
 8000b48:	4618      	mov	r0, r3
 8000b4a:	f00b fdd5 	bl	800c6f8 <lv_ll_ins_head>
 8000b4e:	6178      	str	r0, [r7, #20]
        LV_ASSERT_MEM(new_obj);
 8000b50:	6978      	ldr	r0, [r7, #20]
 8000b52:	f7ff fb51 	bl	80001f8 <lv_debug_check_null>
 8000b56:	4603      	mov	r3, r0
 8000b58:	f083 0301 	eor.w	r3, r3, #1
 8000b5c:	b2db      	uxtb	r3, r3
 8000b5e:	2b00      	cmp	r3, #0
 8000b60:	d008      	beq.n	8000b74 <lv_obj_create+0x200>
 8000b62:	697b      	ldr	r3, [r7, #20]
 8000b64:	f04f 0400 	mov.w	r4, #0
 8000b68:	461a      	mov	r2, r3
 8000b6a:	4623      	mov	r3, r4
 8000b6c:	483a      	ldr	r0, [pc, #232]	; (8000c58 <lv_obj_create+0x2e4>)
 8000b6e:	f7ff fb6d 	bl	800024c <lv_debug_log_error>
 8000b72:	e7fe      	b.n	8000b72 <lv_obj_create+0x1fe>
        if(new_obj == NULL) return NULL;
 8000b74:	697b      	ldr	r3, [r7, #20]
 8000b76:	2b00      	cmp	r3, #0
 8000b78:	d101      	bne.n	8000b7e <lv_obj_create+0x20a>
 8000b7a:	2300      	movs	r3, #0
 8000b7c:	e1cf      	b.n	8000f1e <lv_obj_create+0x5aa>

        new_obj->par = parent; /*Set the parent*/
 8000b7e:	697b      	ldr	r3, [r7, #20]
 8000b80:	687a      	ldr	r2, [r7, #4]
 8000b82:	601a      	str	r2, [r3, #0]
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
 8000b84:	697b      	ldr	r3, [r7, #20]
 8000b86:	3304      	adds	r3, #4
 8000b88:	2144      	movs	r1, #68	; 0x44
 8000b8a:	4618      	mov	r0, r3
 8000b8c:	f00b fd94 	bl	800c6b8 <lv_ll_init>

        /*Set the callbacks*/
        new_obj->signal_cb = lv_obj_signal;
 8000b90:	697b      	ldr	r3, [r7, #20]
 8000b92:	4a32      	ldr	r2, [pc, #200]	; (8000c5c <lv_obj_create+0x2e8>)
 8000b94:	61da      	str	r2, [r3, #28]
        new_obj->design_cb = lv_obj_design;
 8000b96:	697b      	ldr	r3, [r7, #20]
 8000b98:	4a31      	ldr	r2, [pc, #196]	; (8000c60 <lv_obj_create+0x2ec>)
 8000b9a:	621a      	str	r2, [r3, #32]
        new_obj->event_cb = NULL;
 8000b9c:	697b      	ldr	r3, [r7, #20]
 8000b9e:	2200      	movs	r2, #0
 8000ba0:	619a      	str	r2, [r3, #24]

#if LV_USE_BIDI
        new_obj->base_dir     = LV_BIDI_DIR_INHERIT;
#else
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
 8000ba2:	697a      	ldr	r2, [r7, #20]
 8000ba4:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 8000ba8:	f36f 0383 	bfc	r3, #2, #2
 8000bac:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
#endif

        /*Set coordinates left top corner of parent*/
        new_obj->coords.y1    = parent->coords.y1;
 8000bb0:	687b      	ldr	r3, [r7, #4]
 8000bb2:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 8000bb6:	697b      	ldr	r3, [r7, #20]
 8000bb8:	825a      	strh	r2, [r3, #18]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
 8000bba:	687b      	ldr	r3, [r7, #4]
 8000bbc:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8000bc0:	b29b      	uxth	r3, r3
 8000bc2:	3342      	adds	r3, #66	; 0x42
 8000bc4:	b29b      	uxth	r3, r3
 8000bc6:	b21a      	sxth	r2, r3
 8000bc8:	697b      	ldr	r3, [r7, #20]
 8000bca:	82da      	strh	r2, [r3, #22]
        if(lv_obj_get_base_dir(new_obj) == LV_BIDI_DIR_RTL) {
 8000bcc:	6978      	ldr	r0, [r7, #20]
 8000bce:	f001 fe53 	bl	8002878 <lv_obj_get_base_dir>
 8000bd2:	4603      	mov	r3, r0
 8000bd4:	2b01      	cmp	r3, #1
 8000bd6:	d10e      	bne.n	8000bf6 <lv_obj_create+0x282>
            new_obj->coords.x2    = parent->coords.x2;
 8000bd8:	687b      	ldr	r3, [r7, #4]
 8000bda:	f9b3 2014 	ldrsh.w	r2, [r3, #20]
 8000bde:	697b      	ldr	r3, [r7, #20]
 8000be0:	829a      	strh	r2, [r3, #20]
            new_obj->coords.x1    = parent->coords.x2 - LV_OBJ_DEF_WIDTH;
 8000be2:	687b      	ldr	r3, [r7, #4]
 8000be4:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8000be8:	b29b      	uxth	r3, r3
 8000bea:	3b64      	subs	r3, #100	; 0x64
 8000bec:	b29b      	uxth	r3, r3
 8000bee:	b21a      	sxth	r2, r3
 8000bf0:	697b      	ldr	r3, [r7, #20]
 8000bf2:	821a      	strh	r2, [r3, #16]
 8000bf4:	e00d      	b.n	8000c12 <lv_obj_create+0x29e>
        } else {
            new_obj->coords.x1    = parent->coords.x1;
 8000bf6:	687b      	ldr	r3, [r7, #4]
 8000bf8:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 8000bfc:	697b      	ldr	r3, [r7, #20]
 8000bfe:	821a      	strh	r2, [r3, #16]
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
 8000c00:	687b      	ldr	r3, [r7, #4]
 8000c02:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8000c06:	b29b      	uxth	r3, r3
 8000c08:	3364      	adds	r3, #100	; 0x64
 8000c0a:	b29b      	uxth	r3, r3
 8000c0c:	b21a      	sxth	r2, r3
 8000c0e:	697b      	ldr	r3, [r7, #20]
 8000c10:	829a      	strh	r2, [r3, #20]
        }
        new_obj->ext_draw_pad = 0;
 8000c12:	697b      	ldr	r3, [r7, #20]
 8000c14:	2200      	movs	r2, #0
 8000c16:	869a      	strh	r2, [r3, #52]	; 0x34
        new_obj->ext_click_pad_ver = 0;
#endif

        /*Init realign*/
#if LV_USE_OBJ_REALIGN
        new_obj->realign.align        = LV_ALIGN_CENTER;
 8000c18:	697b      	ldr	r3, [r7, #20]
 8000c1a:	2200      	movs	r2, #0
 8000c1c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        new_obj->realign.xofs         = 0;
 8000c20:	697b      	ldr	r3, [r7, #20]
 8000c22:	2200      	movs	r2, #0
 8000c24:	879a      	strh	r2, [r3, #60]	; 0x3c
        new_obj->realign.yofs         = 0;
 8000c26:	697b      	ldr	r3, [r7, #20]
 8000c28:	2200      	movs	r2, #0
 8000c2a:	87da      	strh	r2, [r3, #62]	; 0x3e
        new_obj->realign.base         = NULL;
 8000c2c:	697b      	ldr	r3, [r7, #20]
 8000c2e:	2200      	movs	r2, #0
 8000c30:	639a      	str	r2, [r3, #56]	; 0x38
        new_obj->realign.auto_realign = 0;
 8000c32:	697a      	ldr	r2, [r7, #20]
 8000c34:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8000c38:	f36f 0300 	bfc	r3, #0, #1
 8000c3c:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif
        /*Set appearance*/
        lv_theme_t * th = lv_theme_get_current();
 8000c40:	f010 fa0a 	bl	8011058 <lv_theme_get_current>
 8000c44:	6138      	str	r0, [r7, #16]
        if(th) {
 8000c46:	693b      	ldr	r3, [r7, #16]
 8000c48:	2b00      	cmp	r3, #0
 8000c4a:	d00f      	beq.n	8000c6c <lv_obj_create+0x2f8>
            new_obj->style_p = th->style.panel;
 8000c4c:	693b      	ldr	r3, [r7, #16]
 8000c4e:	689a      	ldr	r2, [r3, #8]
 8000c50:	697b      	ldr	r3, [r7, #20]
 8000c52:	629a      	str	r2, [r3, #40]	; 0x28
 8000c54:	e00d      	b.n	8000c72 <lv_obj_create+0x2fe>
 8000c56:	bf00      	nop
 8000c58:	080137a8 	.word	0x080137a8
 8000c5c:	08002bf5 	.word	0x08002bf5
 8000c60:	08002ad9 	.word	0x08002ad9
 8000c64:	20009880 	.word	0x20009880
 8000c68:	080137b8 	.word	0x080137b8
        } else {
            new_obj->style_p = &lv_style_plain_color;
 8000c6c:	697b      	ldr	r3, [r7, #20]
 8000c6e:	4aae      	ldr	r2, [pc, #696]	; (8000f28 <lv_obj_create+0x5b4>)
 8000c70:	629a      	str	r2, [r3, #40]	; 0x28
#if LV_USE_USER_DATA
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
#endif

#if LV_USE_GROUP
        new_obj->group_p = NULL;
 8000c72:	697b      	ldr	r3, [r7, #20]
 8000c74:	2200      	movs	r2, #0
 8000c76:	62da      	str	r2, [r3, #44]	; 0x2c
#endif

        /*Set attributes*/
        new_obj->click        = 1;
 8000c78:	697a      	ldr	r2, [r7, #20]
 8000c7a:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000c7e:	f043 0301 	orr.w	r3, r3, #1
 8000c82:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag         = 0;
 8000c86:	697a      	ldr	r2, [r7, #20]
 8000c88:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000c8c:	f36f 0341 	bfc	r3, #1, #1
 8000c90:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_dir     = LV_DRAG_DIR_ALL;
 8000c94:	697a      	ldr	r2, [r7, #20]
 8000c96:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 8000c9a:	f043 0303 	orr.w	r3, r3, #3
 8000c9e:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
        new_obj->drag_throw   = 0;
 8000ca2:	697a      	ldr	r2, [r7, #20]
 8000ca4:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000ca8:	f36f 0382 	bfc	r3, #2, #1
 8000cac:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_parent  = 0;
 8000cb0:	697a      	ldr	r2, [r7, #20]
 8000cb2:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000cb6:	f36f 03c3 	bfc	r3, #3, #1
 8000cba:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->hidden       = 0;
 8000cbe:	697a      	ldr	r2, [r7, #20]
 8000cc0:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000cc4:	f36f 1304 	bfc	r3, #4, #1
 8000cc8:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->top          = 0;
 8000ccc:	697a      	ldr	r2, [r7, #20]
 8000cce:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000cd2:	f36f 1345 	bfc	r3, #5, #1
 8000cd6:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->protect      = LV_PROTECT_NONE;
 8000cda:	697b      	ldr	r3, [r7, #20]
 8000cdc:	2200      	movs	r2, #0
 8000cde:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
        new_obj->opa_scale    = LV_OPA_COVER;
 8000ce2:	697b      	ldr	r3, [r7, #20]
 8000ce4:	22ff      	movs	r2, #255	; 0xff
 8000ce6:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
        new_obj->opa_scale_en = 0;
 8000cea:	697a      	ldr	r2, [r7, #20]
 8000cec:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000cf0:	f36f 1386 	bfc	r3, #6, #1
 8000cf4:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->parent_event = 0;
 8000cf8:	697a      	ldr	r2, [r7, #20]
 8000cfa:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000cfe:	f36f 13c7 	bfc	r3, #7, #1
 8000d02:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->reserved     = 0;
 8000d06:	697a      	ldr	r2, [r7, #20]
 8000d08:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 8000d0c:	f36f 1306 	bfc	r3, #4, #3
 8000d10:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31

        new_obj->ext_attr = NULL;
 8000d14:	697b      	ldr	r3, [r7, #20]
 8000d16:	2200      	movs	r2, #0
 8000d18:	625a      	str	r2, [r3, #36]	; 0x24
    }

    /*Copy the attributes if required*/
    if(copy != NULL) {
 8000d1a:	683b      	ldr	r3, [r7, #0]
 8000d1c:	2b00      	cmp	r3, #0
 8000d1e:	f000 80f1 	beq.w	8000f04 <lv_obj_create+0x590>
        LV_ASSERT_OBJ(copy, LV_OBJX_NAME);
 8000d22:	6838      	ldr	r0, [r7, #0]
 8000d24:	f7ff fa68 	bl	80001f8 <lv_debug_check_null>
 8000d28:	4603      	mov	r3, r0
 8000d2a:	f083 0301 	eor.w	r3, r3, #1
 8000d2e:	b2db      	uxtb	r3, r3
 8000d30:	2b00      	cmp	r3, #0
 8000d32:	d008      	beq.n	8000d46 <lv_obj_create+0x3d2>
 8000d34:	683b      	ldr	r3, [r7, #0]
 8000d36:	f04f 0400 	mov.w	r4, #0
 8000d3a:	461a      	mov	r2, r3
 8000d3c:	4623      	mov	r3, r4
 8000d3e:	487b      	ldr	r0, [pc, #492]	; (8000f2c <lv_obj_create+0x5b8>)
 8000d40:	f7ff fa84 	bl	800024c <lv_debug_log_error>
 8000d44:	e7fe      	b.n	8000d44 <lv_obj_create+0x3d0>
        lv_area_copy(&new_obj->coords, &copy->coords);
 8000d46:	697b      	ldr	r3, [r7, #20]
 8000d48:	f103 0210 	add.w	r2, r3, #16
 8000d4c:	683b      	ldr	r3, [r7, #0]
 8000d4e:	3310      	adds	r3, #16
 8000d50:	4619      	mov	r1, r3
 8000d52:	4610      	mov	r0, r2
 8000d54:	f7ff fda2 	bl	800089c <lv_area_copy>
        new_obj->ext_draw_pad = copy->ext_draw_pad;
 8000d58:	683b      	ldr	r3, [r7, #0]
 8000d5a:	f9b3 2034 	ldrsh.w	r2, [r3, #52]	; 0x34
 8000d5e:	697b      	ldr	r3, [r7, #20]
 8000d60:	869a      	strh	r2, [r3, #52]	; 0x34
#if LV_USE_USER_DATA
        memcpy(&new_obj->user_data, &copy->user_data, sizeof(lv_obj_user_data_t));
#endif
        /*Copy realign*/
#if LV_USE_OBJ_REALIGN
        new_obj->realign.align        = copy->realign.align;
 8000d62:	683b      	ldr	r3, [r7, #0]
 8000d64:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
 8000d68:	697b      	ldr	r3, [r7, #20]
 8000d6a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        new_obj->realign.xofs         = copy->realign.xofs;
 8000d6e:	683b      	ldr	r3, [r7, #0]
 8000d70:	f9b3 203c 	ldrsh.w	r2, [r3, #60]	; 0x3c
 8000d74:	697b      	ldr	r3, [r7, #20]
 8000d76:	879a      	strh	r2, [r3, #60]	; 0x3c
        new_obj->realign.yofs         = copy->realign.yofs;
 8000d78:	683b      	ldr	r3, [r7, #0]
 8000d7a:	f9b3 203e 	ldrsh.w	r2, [r3, #62]	; 0x3e
 8000d7e:	697b      	ldr	r3, [r7, #20]
 8000d80:	87da      	strh	r2, [r3, #62]	; 0x3e
        new_obj->realign.base         = copy->realign.base;
 8000d82:	683b      	ldr	r3, [r7, #0]
 8000d84:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8000d86:	697b      	ldr	r3, [r7, #20]
 8000d88:	639a      	str	r2, [r3, #56]	; 0x38
        new_obj->realign.auto_realign = copy->realign.auto_realign;
 8000d8a:	683b      	ldr	r3, [r7, #0]
 8000d8c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8000d90:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8000d94:	b2d9      	uxtb	r1, r3
 8000d96:	697a      	ldr	r2, [r7, #20]
 8000d98:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8000d9c:	f361 0300 	bfi	r3, r1, #0, #1
 8000da0:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif

        /*Only copy the `event_cb`. `signal_cb` and `design_cb` will be copied in the derived
         * object type (e.g. `lv_btn`)*/
        new_obj->event_cb = copy->event_cb;
 8000da4:	683b      	ldr	r3, [r7, #0]
 8000da6:	699a      	ldr	r2, [r3, #24]
 8000da8:	697b      	ldr	r3, [r7, #20]
 8000daa:	619a      	str	r2, [r3, #24]

        /*Copy attributes*/
        new_obj->click        = copy->click;
 8000dac:	683b      	ldr	r3, [r7, #0]
 8000dae:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8000db2:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8000db6:	b2d9      	uxtb	r1, r3
 8000db8:	697a      	ldr	r2, [r7, #20]
 8000dba:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000dbe:	f361 0300 	bfi	r3, r1, #0, #1
 8000dc2:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag         = copy->drag;
 8000dc6:	683b      	ldr	r3, [r7, #0]
 8000dc8:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8000dcc:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8000dd0:	b2d9      	uxtb	r1, r3
 8000dd2:	697a      	ldr	r2, [r7, #20]
 8000dd4:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000dd8:	f361 0341 	bfi	r3, r1, #1, #1
 8000ddc:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_dir     = copy->drag_dir;
 8000de0:	683b      	ldr	r3, [r7, #0]
 8000de2:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8000de6:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8000dea:	b2d9      	uxtb	r1, r3
 8000dec:	697a      	ldr	r2, [r7, #20]
 8000dee:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 8000df2:	f361 0301 	bfi	r3, r1, #0, #2
 8000df6:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
        new_obj->drag_throw   = copy->drag_throw;
 8000dfa:	683b      	ldr	r3, [r7, #0]
 8000dfc:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8000e00:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8000e04:	b2d9      	uxtb	r1, r3
 8000e06:	697a      	ldr	r2, [r7, #20]
 8000e08:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000e0c:	f361 0382 	bfi	r3, r1, #2, #1
 8000e10:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_parent  = copy->drag_parent;
 8000e14:	683b      	ldr	r3, [r7, #0]
 8000e16:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8000e1a:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8000e1e:	b2d9      	uxtb	r1, r3
 8000e20:	697a      	ldr	r2, [r7, #20]
 8000e22:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000e26:	f361 03c3 	bfi	r3, r1, #3, #1
 8000e2a:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->hidden       = copy->hidden;
 8000e2e:	683b      	ldr	r3, [r7, #0]
 8000e30:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8000e34:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8000e38:	b2d9      	uxtb	r1, r3
 8000e3a:	697a      	ldr	r2, [r7, #20]
 8000e3c:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000e40:	f361 1304 	bfi	r3, r1, #4, #1
 8000e44:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->top          = copy->top;
 8000e48:	683b      	ldr	r3, [r7, #0]
 8000e4a:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8000e4e:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8000e52:	b2d9      	uxtb	r1, r3
 8000e54:	697a      	ldr	r2, [r7, #20]
 8000e56:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000e5a:	f361 1345 	bfi	r3, r1, #5, #1
 8000e5e:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->parent_event = copy->parent_event;
 8000e62:	683b      	ldr	r3, [r7, #0]
 8000e64:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8000e68:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8000e6c:	b2d9      	uxtb	r1, r3
 8000e6e:	697a      	ldr	r2, [r7, #20]
 8000e70:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000e74:	f361 13c7 	bfi	r3, r1, #7, #1
 8000e78:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30

        new_obj->opa_scale_en = copy->opa_scale_en;
 8000e7c:	683b      	ldr	r3, [r7, #0]
 8000e7e:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8000e82:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8000e86:	b2d9      	uxtb	r1, r3
 8000e88:	697a      	ldr	r2, [r7, #20]
 8000e8a:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8000e8e:	f361 1386 	bfi	r3, r1, #6, #1
 8000e92:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->protect      = copy->protect;
 8000e96:	683b      	ldr	r3, [r7, #0]
 8000e98:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8000e9c:	697b      	ldr	r3, [r7, #20]
 8000e9e:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
        new_obj->opa_scale    = copy->opa_scale;
 8000ea2:	683b      	ldr	r3, [r7, #0]
 8000ea4:	f893 2033 	ldrb.w	r2, [r3, #51]	; 0x33
 8000ea8:	697b      	ldr	r3, [r7, #20]
 8000eaa:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33

        new_obj->style_p = copy->style_p;
 8000eae:	683b      	ldr	r3, [r7, #0]
 8000eb0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000eb2:	697b      	ldr	r3, [r7, #20]
 8000eb4:	629a      	str	r2, [r3, #40]	; 0x28

#if LV_USE_GROUP
        /*Add to the same group*/
        if(copy->group_p != NULL) {
 8000eb6:	683b      	ldr	r3, [r7, #0]
 8000eb8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000eba:	2b00      	cmp	r3, #0
 8000ebc:	d005      	beq.n	8000eca <lv_obj_create+0x556>
            lv_group_add_obj(copy->group_p, new_obj);
 8000ebe:	683b      	ldr	r3, [r7, #0]
 8000ec0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000ec2:	6979      	ldr	r1, [r7, #20]
 8000ec4:	4618      	mov	r0, r3
 8000ec6:	f7ff fa9b 	bl	8000400 <lv_group_add_obj>
        }
#endif

        /*Set the same coordinates for non screen objects*/
        if(lv_obj_get_parent(copy) != NULL && parent != NULL) {
 8000eca:	6838      	ldr	r0, [r7, #0]
 8000ecc:	f001 fac8 	bl	8002460 <lv_obj_get_parent>
 8000ed0:	4603      	mov	r3, r0
 8000ed2:	2b00      	cmp	r3, #0
 8000ed4:	d011      	beq.n	8000efa <lv_obj_create+0x586>
 8000ed6:	687b      	ldr	r3, [r7, #4]
 8000ed8:	2b00      	cmp	r3, #0
 8000eda:	d00e      	beq.n	8000efa <lv_obj_create+0x586>
            lv_obj_set_pos(new_obj, lv_obj_get_x(copy), lv_obj_get_y(copy));
 8000edc:	6838      	ldr	r0, [r7, #0]
 8000ede:	f001 fb33 	bl	8002548 <lv_obj_get_x>
 8000ee2:	4603      	mov	r3, r0
 8000ee4:	461c      	mov	r4, r3
 8000ee6:	6838      	ldr	r0, [r7, #0]
 8000ee8:	f001 fb62 	bl	80025b0 <lv_obj_get_y>
 8000eec:	4603      	mov	r3, r0
 8000eee:	461a      	mov	r2, r3
 8000ef0:	4621      	mov	r1, r4
 8000ef2:	6978      	ldr	r0, [r7, #20]
 8000ef4:	f000 f95e 	bl	80011b4 <lv_obj_set_pos>
 8000ef8:	e004      	b.n	8000f04 <lv_obj_create+0x590>
        } else {
            lv_obj_set_pos(new_obj, 0, 0);
 8000efa:	2200      	movs	r2, #0
 8000efc:	2100      	movs	r1, #0
 8000efe:	6978      	ldr	r0, [r7, #20]
 8000f00:	f000 f958 	bl	80011b4 <lv_obj_set_pos>

        LV_LOG_INFO("Object create ready");
    }

    /*Send a signal to the parent to notify it about the new child*/
    if(parent != NULL) {
 8000f04:	687b      	ldr	r3, [r7, #4]
 8000f06:	2b00      	cmp	r3, #0
 8000f08:	d008      	beq.n	8000f1c <lv_obj_create+0x5a8>
        parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, new_obj);
 8000f0a:	687b      	ldr	r3, [r7, #4]
 8000f0c:	69db      	ldr	r3, [r3, #28]
 8000f0e:	697a      	ldr	r2, [r7, #20]
 8000f10:	2101      	movs	r1, #1
 8000f12:	6878      	ldr	r0, [r7, #4]
 8000f14:	4798      	blx	r3

        /*Invalidate the area if not screen created*/
        lv_obj_invalidate(new_obj);
 8000f16:	6978      	ldr	r0, [r7, #20]
 8000f18:	f000 f8c0 	bl	800109c <lv_obj_invalidate>
    }

    return new_obj;
 8000f1c:	697b      	ldr	r3, [r7, #20]
}
 8000f1e:	4618      	mov	r0, r3
 8000f20:	371c      	adds	r7, #28
 8000f22:	46bd      	mov	sp, r7
 8000f24:	bd90      	pop	{r4, r7, pc}
 8000f26:	bf00      	nop
 8000f28:	20009900 	.word	0x20009900
 8000f2c:	080137b8 	.word	0x080137b8

08000f30 <lv_obj_invalidate_area>:
 * This area will be redrawn by 'lv_refr_task'
 * @param obj pointer to an object
 * @param area the area to redraw
 */
void lv_obj_invalidate_area(const lv_obj_t * obj, const lv_area_t * area)
{
 8000f30:	b590      	push	{r4, r7, lr}
 8000f32:	b08d      	sub	sp, #52	; 0x34
 8000f34:	af00      	add	r7, sp, #0
 8000f36:	6078      	str	r0, [r7, #4]
 8000f38:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8000f3a:	6878      	ldr	r0, [r7, #4]
 8000f3c:	f7ff f95c 	bl	80001f8 <lv_debug_check_null>
 8000f40:	4603      	mov	r3, r0
 8000f42:	f083 0301 	eor.w	r3, r3, #1
 8000f46:	b2db      	uxtb	r3, r3
 8000f48:	2b00      	cmp	r3, #0
 8000f4a:	d008      	beq.n	8000f5e <lv_obj_invalidate_area+0x2e>
 8000f4c:	687b      	ldr	r3, [r7, #4]
 8000f4e:	f04f 0400 	mov.w	r4, #0
 8000f52:	461a      	mov	r2, r3
 8000f54:	4623      	mov	r3, r4
 8000f56:	4850      	ldr	r0, [pc, #320]	; (8001098 <lv_obj_invalidate_area+0x168>)
 8000f58:	f7ff f978 	bl	800024c <lv_debug_log_error>
 8000f5c:	e7fe      	b.n	8000f5c <lv_obj_invalidate_area+0x2c>

    if(lv_obj_get_hidden(obj)) return;
 8000f5e:	6878      	ldr	r0, [r7, #4]
 8000f60:	f001 fc62 	bl	8002828 <lv_obj_get_hidden>
 8000f64:	4603      	mov	r3, r0
 8000f66:	2b00      	cmp	r3, #0
 8000f68:	f040 808e 	bne.w	8001088 <lv_obj_invalidate_area+0x158>

    /*Invalidate the object only if it belongs to the 'LV_GC_ROOT(_lv_act_scr)'*/
    lv_obj_t * obj_scr = lv_obj_get_screen(obj);
 8000f6c:	6878      	ldr	r0, [r7, #4]
 8000f6e:	f001 fa01 	bl	8002374 <lv_obj_get_screen>
 8000f72:	6278      	str	r0, [r7, #36]	; 0x24
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
 8000f74:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8000f76:	f001 fa25 	bl	80023c4 <lv_obj_get_disp>
 8000f7a:	6238      	str	r0, [r7, #32]
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
 8000f7c:	6a38      	ldr	r0, [r7, #32]
 8000f7e:	f7ff f9f5 	bl	800036c <lv_disp_get_scr_act>
 8000f82:	4602      	mov	r2, r0
 8000f84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000f86:	4293      	cmp	r3, r2
 8000f88:	d00d      	beq.n	8000fa6 <lv_obj_invalidate_area+0x76>
 8000f8a:	6a38      	ldr	r0, [r7, #32]
 8000f8c:	f7ff fa03 	bl	8000396 <lv_disp_get_layer_top>
 8000f90:	4602      	mov	r2, r0
 8000f92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000f94:	4293      	cmp	r3, r2
 8000f96:	d006      	beq.n	8000fa6 <lv_obj_invalidate_area+0x76>
       obj_scr == lv_disp_get_layer_sys(disp)) {
 8000f98:	6a38      	ldr	r0, [r7, #32]
 8000f9a:	f7ff fa11 	bl	80003c0 <lv_disp_get_layer_sys>
 8000f9e:	4602      	mov	r2, r0
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
 8000fa0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000fa2:	4293      	cmp	r3, r2
 8000fa4:	d175      	bne.n	8001092 <lv_obj_invalidate_area+0x162>

        /*Truncate the area to the object*/
        lv_area_t obj_coords;
        lv_coord_t ext_size = obj->ext_draw_pad;
 8000fa6:	687b      	ldr	r3, [r7, #4]
 8000fa8:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8000faa:	83fb      	strh	r3, [r7, #30]
        lv_area_copy(&obj_coords, &obj->coords);
 8000fac:	687b      	ldr	r3, [r7, #4]
 8000fae:	f103 0210 	add.w	r2, r3, #16
 8000fb2:	f107 0314 	add.w	r3, r7, #20
 8000fb6:	4611      	mov	r1, r2
 8000fb8:	4618      	mov	r0, r3
 8000fba:	f7ff fc6f 	bl	800089c <lv_area_copy>
        obj_coords.x1 -= ext_size;
 8000fbe:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8000fc2:	b29a      	uxth	r2, r3
 8000fc4:	8bfb      	ldrh	r3, [r7, #30]
 8000fc6:	1ad3      	subs	r3, r2, r3
 8000fc8:	b29b      	uxth	r3, r3
 8000fca:	b21b      	sxth	r3, r3
 8000fcc:	82bb      	strh	r3, [r7, #20]
        obj_coords.y1 -= ext_size;
 8000fce:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8000fd2:	b29a      	uxth	r2, r3
 8000fd4:	8bfb      	ldrh	r3, [r7, #30]
 8000fd6:	1ad3      	subs	r3, r2, r3
 8000fd8:	b29b      	uxth	r3, r3
 8000fda:	b21b      	sxth	r3, r3
 8000fdc:	82fb      	strh	r3, [r7, #22]
        obj_coords.x2 += ext_size;
 8000fde:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8000fe2:	b29a      	uxth	r2, r3
 8000fe4:	8bfb      	ldrh	r3, [r7, #30]
 8000fe6:	4413      	add	r3, r2
 8000fe8:	b29b      	uxth	r3, r3
 8000fea:	b21b      	sxth	r3, r3
 8000fec:	833b      	strh	r3, [r7, #24]
        obj_coords.y2 += ext_size;
 8000fee:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8000ff2:	b29a      	uxth	r2, r3
 8000ff4:	8bfb      	ldrh	r3, [r7, #30]
 8000ff6:	4413      	add	r3, r2
 8000ff8:	b29b      	uxth	r3, r3
 8000ffa:	b21b      	sxth	r3, r3
 8000ffc:	837b      	strh	r3, [r7, #26]

        bool is_common;
        lv_area_t area_trunc;

        is_common = lv_area_intersect(&area_trunc, area, &obj_coords);
 8000ffe:	f107 0214 	add.w	r2, r7, #20
 8001002:	f107 030c 	add.w	r3, r7, #12
 8001006:	6839      	ldr	r1, [r7, #0]
 8001008:	4618      	mov	r0, r3
 800100a:	f00b f85b 	bl	800c0c4 <lv_area_intersect>
 800100e:	4603      	mov	r3, r0
 8001010:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        if(is_common == false) return;  /*The area is not on the object*/
 8001014:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8001018:	f083 0301 	eor.w	r3, r3, #1
 800101c:	b2db      	uxtb	r3, r3
 800101e:	2b00      	cmp	r3, #0
 8001020:	d134      	bne.n	800108c <lv_obj_invalidate_area+0x15c>

        /*Truncate recursively to the parents*/
        lv_obj_t * par = lv_obj_get_parent(obj);
 8001022:	6878      	ldr	r0, [r7, #4]
 8001024:	f001 fa1c 	bl	8002460 <lv_obj_get_parent>
 8001028:	62b8      	str	r0, [r7, #40]	; 0x28
        while(par != NULL) {
 800102a:	e01d      	b.n	8001068 <lv_obj_invalidate_area+0x138>
            is_common = lv_area_intersect(&area_trunc, &area_trunc, &par->coords);
 800102c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800102e:	f103 0210 	add.w	r2, r3, #16
 8001032:	f107 010c 	add.w	r1, r7, #12
 8001036:	f107 030c 	add.w	r3, r7, #12
 800103a:	4618      	mov	r0, r3
 800103c:	f00b f842 	bl	800c0c4 <lv_area_intersect>
 8001040:	4603      	mov	r3, r0
 8001042:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            if(is_common == false) break;       /*If no common parts with parent break;*/
 8001046:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800104a:	f083 0301 	eor.w	r3, r3, #1
 800104e:	b2db      	uxtb	r3, r3
 8001050:	2b00      	cmp	r3, #0
 8001052:	d10d      	bne.n	8001070 <lv_obj_invalidate_area+0x140>
            if(lv_obj_get_hidden(par)) return; /*If the parent is hidden then the child is hidden and won't be drawn*/
 8001054:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8001056:	f001 fbe7 	bl	8002828 <lv_obj_get_hidden>
 800105a:	4603      	mov	r3, r0
 800105c:	2b00      	cmp	r3, #0
 800105e:	d117      	bne.n	8001090 <lv_obj_invalidate_area+0x160>

            par = lv_obj_get_parent(par);
 8001060:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8001062:	f001 f9fd 	bl	8002460 <lv_obj_get_parent>
 8001066:	62b8      	str	r0, [r7, #40]	; 0x28
        while(par != NULL) {
 8001068:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800106a:	2b00      	cmp	r3, #0
 800106c:	d1de      	bne.n	800102c <lv_obj_invalidate_area+0xfc>
 800106e:	e000      	b.n	8001072 <lv_obj_invalidate_area+0x142>
            if(is_common == false) break;       /*If no common parts with parent break;*/
 8001070:	bf00      	nop
        }

        if(is_common) lv_inv_area(disp, &area_trunc);
 8001072:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8001076:	2b00      	cmp	r3, #0
 8001078:	d00b      	beq.n	8001092 <lv_obj_invalidate_area+0x162>
 800107a:	f107 030c 	add.w	r3, r7, #12
 800107e:	4619      	mov	r1, r3
 8001080:	6a38      	ldr	r0, [r7, #32]
 8001082:	f001 feb5 	bl	8002df0 <lv_inv_area>
 8001086:	e004      	b.n	8001092 <lv_obj_invalidate_area+0x162>
    if(lv_obj_get_hidden(obj)) return;
 8001088:	bf00      	nop
 800108a:	e002      	b.n	8001092 <lv_obj_invalidate_area+0x162>
        if(is_common == false) return;  /*The area is not on the object*/
 800108c:	bf00      	nop
 800108e:	e000      	b.n	8001092 <lv_obj_invalidate_area+0x162>
            if(lv_obj_get_hidden(par)) return; /*If the parent is hidden then the child is hidden and won't be drawn*/
 8001090:	bf00      	nop
    }
}
 8001092:	3734      	adds	r7, #52	; 0x34
 8001094:	46bd      	mov	sp, r7
 8001096:	bd90      	pop	{r4, r7, pc}
 8001098:	080137b8 	.word	0x080137b8

0800109c <lv_obj_invalidate>:
/**
 * Mark the object as invalid therefore its current position will be redrawn by 'lv_refr_task'
 * @param obj pointer to an object
 */
void lv_obj_invalidate(const lv_obj_t * obj)
{
 800109c:	b590      	push	{r4, r7, lr}
 800109e:	b087      	sub	sp, #28
 80010a0:	af00      	add	r7, sp, #0
 80010a2:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80010a4:	6878      	ldr	r0, [r7, #4]
 80010a6:	f7ff f8a7 	bl	80001f8 <lv_debug_check_null>
 80010aa:	4603      	mov	r3, r0
 80010ac:	f083 0301 	eor.w	r3, r3, #1
 80010b0:	b2db      	uxtb	r3, r3
 80010b2:	2b00      	cmp	r3, #0
 80010b4:	d008      	beq.n	80010c8 <lv_obj_invalidate+0x2c>
 80010b6:	687b      	ldr	r3, [r7, #4]
 80010b8:	f04f 0400 	mov.w	r4, #0
 80010bc:	461a      	mov	r2, r3
 80010be:	4623      	mov	r3, r4
 80010c0:	481c      	ldr	r0, [pc, #112]	; (8001134 <lv_obj_invalidate+0x98>)
 80010c2:	f7ff f8c3 	bl	800024c <lv_debug_log_error>
 80010c6:	e7fe      	b.n	80010c6 <lv_obj_invalidate+0x2a>

    /*Truncate the area to the object*/
    lv_area_t obj_coords;
    lv_coord_t ext_size = obj->ext_draw_pad;
 80010c8:	687b      	ldr	r3, [r7, #4]
 80010ca:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 80010cc:	82fb      	strh	r3, [r7, #22]
    lv_area_copy(&obj_coords, &obj->coords);
 80010ce:	687b      	ldr	r3, [r7, #4]
 80010d0:	f103 0210 	add.w	r2, r3, #16
 80010d4:	f107 030c 	add.w	r3, r7, #12
 80010d8:	4611      	mov	r1, r2
 80010da:	4618      	mov	r0, r3
 80010dc:	f7ff fbde 	bl	800089c <lv_area_copy>
    obj_coords.x1 -= ext_size;
 80010e0:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80010e4:	b29a      	uxth	r2, r3
 80010e6:	8afb      	ldrh	r3, [r7, #22]
 80010e8:	1ad3      	subs	r3, r2, r3
 80010ea:	b29b      	uxth	r3, r3
 80010ec:	b21b      	sxth	r3, r3
 80010ee:	81bb      	strh	r3, [r7, #12]
    obj_coords.y1 -= ext_size;
 80010f0:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80010f4:	b29a      	uxth	r2, r3
 80010f6:	8afb      	ldrh	r3, [r7, #22]
 80010f8:	1ad3      	subs	r3, r2, r3
 80010fa:	b29b      	uxth	r3, r3
 80010fc:	b21b      	sxth	r3, r3
 80010fe:	81fb      	strh	r3, [r7, #14]
    obj_coords.x2 += ext_size;
 8001100:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8001104:	b29a      	uxth	r2, r3
 8001106:	8afb      	ldrh	r3, [r7, #22]
 8001108:	4413      	add	r3, r2
 800110a:	b29b      	uxth	r3, r3
 800110c:	b21b      	sxth	r3, r3
 800110e:	823b      	strh	r3, [r7, #16]
    obj_coords.y2 += ext_size;
 8001110:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8001114:	b29a      	uxth	r2, r3
 8001116:	8afb      	ldrh	r3, [r7, #22]
 8001118:	4413      	add	r3, r2
 800111a:	b29b      	uxth	r3, r3
 800111c:	b21b      	sxth	r3, r3
 800111e:	827b      	strh	r3, [r7, #18]

    lv_obj_invalidate_area(obj, &obj_coords);
 8001120:	f107 030c 	add.w	r3, r7, #12
 8001124:	4619      	mov	r1, r3
 8001126:	6878      	ldr	r0, [r7, #4]
 8001128:	f7ff ff02 	bl	8000f30 <lv_obj_invalidate_area>

}
 800112c:	bf00      	nop
 800112e:	371c      	adds	r7, #28
 8001130:	46bd      	mov	sp, r7
 8001132:	bd90      	pop	{r4, r7, pc}
 8001134:	080137b8 	.word	0x080137b8

08001138 <lv_obj_move_foreground>:
/**
 * Move and object to the foreground
 * @param obj pointer to an object
 */
void lv_obj_move_foreground(lv_obj_t * obj)
{
 8001138:	b590      	push	{r4, r7, lr}
 800113a:	b085      	sub	sp, #20
 800113c:	af00      	add	r7, sp, #0
 800113e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8001140:	6878      	ldr	r0, [r7, #4]
 8001142:	f7ff f859 	bl	80001f8 <lv_debug_check_null>
 8001146:	4603      	mov	r3, r0
 8001148:	f083 0301 	eor.w	r3, r3, #1
 800114c:	b2db      	uxtb	r3, r3
 800114e:	2b00      	cmp	r3, #0
 8001150:	d008      	beq.n	8001164 <lv_obj_move_foreground+0x2c>
 8001152:	687b      	ldr	r3, [r7, #4]
 8001154:	f04f 0400 	mov.w	r4, #0
 8001158:	461a      	mov	r2, r3
 800115a:	4623      	mov	r3, r4
 800115c:	4814      	ldr	r0, [pc, #80]	; (80011b0 <lv_obj_move_foreground+0x78>)
 800115e:	f7ff f875 	bl	800024c <lv_debug_log_error>
 8001162:	e7fe      	b.n	8001162 <lv_obj_move_foreground+0x2a>

    lv_obj_t * parent = lv_obj_get_parent(obj);
 8001164:	6878      	ldr	r0, [r7, #4]
 8001166:	f001 f97b 	bl	8002460 <lv_obj_get_parent>
 800116a:	60f8      	str	r0, [r7, #12]

    /*Do nothing of already in the foreground*/
    if(lv_ll_get_head(&parent->child_ll) == obj) return;
 800116c:	68fb      	ldr	r3, [r7, #12]
 800116e:	3304      	adds	r3, #4
 8001170:	4618      	mov	r0, r3
 8001172:	f00b fc23 	bl	800c9bc <lv_ll_get_head>
 8001176:	4602      	mov	r2, r0
 8001178:	687b      	ldr	r3, [r7, #4]
 800117a:	4293      	cmp	r3, r2
 800117c:	d014      	beq.n	80011a8 <lv_obj_move_foreground+0x70>

    lv_obj_invalidate(parent);
 800117e:	68f8      	ldr	r0, [r7, #12]
 8001180:	f7ff ff8c 	bl	800109c <lv_obj_invalidate>

    lv_ll_chg_list(&parent->child_ll, &parent->child_ll, obj, true);
 8001184:	68fb      	ldr	r3, [r7, #12]
 8001186:	1d18      	adds	r0, r3, #4
 8001188:	68fb      	ldr	r3, [r7, #12]
 800118a:	1d19      	adds	r1, r3, #4
 800118c:	2301      	movs	r3, #1
 800118e:	687a      	ldr	r2, [r7, #4]
 8001190:	f00b fbbf 	bl	800c912 <lv_ll_chg_list>

    /*Notify the new parent about the child*/
    parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, obj);
 8001194:	68fb      	ldr	r3, [r7, #12]
 8001196:	69db      	ldr	r3, [r3, #28]
 8001198:	687a      	ldr	r2, [r7, #4]
 800119a:	2101      	movs	r1, #1
 800119c:	68f8      	ldr	r0, [r7, #12]
 800119e:	4798      	blx	r3

    lv_obj_invalidate(parent);
 80011a0:	68f8      	ldr	r0, [r7, #12]
 80011a2:	f7ff ff7b 	bl	800109c <lv_obj_invalidate>
 80011a6:	e000      	b.n	80011aa <lv_obj_move_foreground+0x72>
    if(lv_ll_get_head(&parent->child_ll) == obj) return;
 80011a8:	bf00      	nop
}
 80011aa:	3714      	adds	r7, #20
 80011ac:	46bd      	mov	sp, r7
 80011ae:	bd90      	pop	{r4, r7, pc}
 80011b0:	080137b8 	.word	0x080137b8

080011b4 <lv_obj_set_pos>:
 * @param obj pointer to an object
 * @param x new distance from the left side of the parent
 * @param y new distance from the top of the parent
 */
void lv_obj_set_pos(lv_obj_t * obj, lv_coord_t x, lv_coord_t y)
{
 80011b4:	b590      	push	{r4, r7, lr}
 80011b6:	b087      	sub	sp, #28
 80011b8:	af00      	add	r7, sp, #0
 80011ba:	6078      	str	r0, [r7, #4]
 80011bc:	460b      	mov	r3, r1
 80011be:	807b      	strh	r3, [r7, #2]
 80011c0:	4613      	mov	r3, r2
 80011c2:	803b      	strh	r3, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80011c4:	6878      	ldr	r0, [r7, #4]
 80011c6:	f7ff f817 	bl	80001f8 <lv_debug_check_null>
 80011ca:	4603      	mov	r3, r0
 80011cc:	f083 0301 	eor.w	r3, r3, #1
 80011d0:	b2db      	uxtb	r3, r3
 80011d2:	2b00      	cmp	r3, #0
 80011d4:	d008      	beq.n	80011e8 <lv_obj_set_pos+0x34>
 80011d6:	687b      	ldr	r3, [r7, #4]
 80011d8:	f04f 0400 	mov.w	r4, #0
 80011dc:	461a      	mov	r2, r3
 80011de:	4623      	mov	r3, r4
 80011e0:	4843      	ldr	r0, [pc, #268]	; (80012f0 <lv_obj_set_pos+0x13c>)
 80011e2:	f7ff f833 	bl	800024c <lv_debug_log_error>
 80011e6:	e7fe      	b.n	80011e6 <lv_obj_set_pos+0x32>

    /*Convert x and y to absolute coordinates*/
    lv_obj_t * par = obj->par;
 80011e8:	687b      	ldr	r3, [r7, #4]
 80011ea:	681b      	ldr	r3, [r3, #0]
 80011ec:	617b      	str	r3, [r7, #20]

    x = x + par->coords.x1;
 80011ee:	697b      	ldr	r3, [r7, #20]
 80011f0:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80011f4:	b29a      	uxth	r2, r3
 80011f6:	887b      	ldrh	r3, [r7, #2]
 80011f8:	4413      	add	r3, r2
 80011fa:	b29b      	uxth	r3, r3
 80011fc:	807b      	strh	r3, [r7, #2]
    y = y + par->coords.y1;
 80011fe:	697b      	ldr	r3, [r7, #20]
 8001200:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8001204:	b29a      	uxth	r2, r3
 8001206:	883b      	ldrh	r3, [r7, #0]
 8001208:	4413      	add	r3, r2
 800120a:	b29b      	uxth	r3, r3
 800120c:	803b      	strh	r3, [r7, #0]

    /*Calculate and set the movement*/
    lv_point_t diff;
    diff.x = x - obj->coords.x1;
 800120e:	887a      	ldrh	r2, [r7, #2]
 8001210:	687b      	ldr	r3, [r7, #4]
 8001212:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8001216:	b29b      	uxth	r3, r3
 8001218:	1ad3      	subs	r3, r2, r3
 800121a:	b29b      	uxth	r3, r3
 800121c:	b21b      	sxth	r3, r3
 800121e:	823b      	strh	r3, [r7, #16]
    diff.y = y - obj->coords.y1;
 8001220:	883a      	ldrh	r2, [r7, #0]
 8001222:	687b      	ldr	r3, [r7, #4]
 8001224:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8001228:	b29b      	uxth	r3, r3
 800122a:	1ad3      	subs	r3, r2, r3
 800122c:	b29b      	uxth	r3, r3
 800122e:	b21b      	sxth	r3, r3
 8001230:	827b      	strh	r3, [r7, #18]

    /* Do nothing if the position is not changed */
    /* It is very important else recursive positioning can
     * occur without position change*/
    if(diff.x == 0 && diff.y == 0) return;
 8001232:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8001236:	2b00      	cmp	r3, #0
 8001238:	d103      	bne.n	8001242 <lv_obj_set_pos+0x8e>
 800123a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800123e:	2b00      	cmp	r3, #0
 8001240:	d051      	beq.n	80012e6 <lv_obj_set_pos+0x132>

    /*Invalidate the original area*/
    lv_obj_invalidate(obj);
 8001242:	6878      	ldr	r0, [r7, #4]
 8001244:	f7ff ff2a 	bl	800109c <lv_obj_invalidate>

    /*Save the original coordinates*/
    lv_area_t ori;
    lv_obj_get_coords(obj, &ori);
 8001248:	f107 0308 	add.w	r3, r7, #8
 800124c:	4619      	mov	r1, r3
 800124e:	6878      	ldr	r0, [r7, #4]
 8001250:	f001 f956 	bl	8002500 <lv_obj_get_coords>

    obj->coords.x1 += diff.x;
 8001254:	687b      	ldr	r3, [r7, #4]
 8001256:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 800125a:	b29a      	uxth	r2, r3
 800125c:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8001260:	b29b      	uxth	r3, r3
 8001262:	4413      	add	r3, r2
 8001264:	b29b      	uxth	r3, r3
 8001266:	b21a      	sxth	r2, r3
 8001268:	687b      	ldr	r3, [r7, #4]
 800126a:	821a      	strh	r2, [r3, #16]
    obj->coords.y1 += diff.y;
 800126c:	687b      	ldr	r3, [r7, #4]
 800126e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8001272:	b29a      	uxth	r2, r3
 8001274:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8001278:	b29b      	uxth	r3, r3
 800127a:	4413      	add	r3, r2
 800127c:	b29b      	uxth	r3, r3
 800127e:	b21a      	sxth	r2, r3
 8001280:	687b      	ldr	r3, [r7, #4]
 8001282:	825a      	strh	r2, [r3, #18]
    obj->coords.x2 += diff.x;
 8001284:	687b      	ldr	r3, [r7, #4]
 8001286:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 800128a:	b29a      	uxth	r2, r3
 800128c:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8001290:	b29b      	uxth	r3, r3
 8001292:	4413      	add	r3, r2
 8001294:	b29b      	uxth	r3, r3
 8001296:	b21a      	sxth	r2, r3
 8001298:	687b      	ldr	r3, [r7, #4]
 800129a:	829a      	strh	r2, [r3, #20]
    obj->coords.y2 += diff.y;
 800129c:	687b      	ldr	r3, [r7, #4]
 800129e:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 80012a2:	b29a      	uxth	r2, r3
 80012a4:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80012a8:	b29b      	uxth	r3, r3
 80012aa:	4413      	add	r3, r2
 80012ac:	b29b      	uxth	r3, r3
 80012ae:	b21a      	sxth	r2, r3
 80012b0:	687b      	ldr	r3, [r7, #4]
 80012b2:	82da      	strh	r2, [r3, #22]

    refresh_children_position(obj, diff.x, diff.y);
 80012b4:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80012b8:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 80012bc:	4619      	mov	r1, r3
 80012be:	6878      	ldr	r0, [r7, #4]
 80012c0:	f001 fcda 	bl	8002c78 <refresh_children_position>

    /*Inform the object about its new coordinates*/
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
 80012c4:	687b      	ldr	r3, [r7, #4]
 80012c6:	69db      	ldr	r3, [r3, #28]
 80012c8:	f107 0208 	add.w	r2, r7, #8
 80012cc:	2102      	movs	r1, #2
 80012ce:	6878      	ldr	r0, [r7, #4]
 80012d0:	4798      	blx	r3

    /*Send a signal to the parent too*/
    par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
 80012d2:	697b      	ldr	r3, [r7, #20]
 80012d4:	69db      	ldr	r3, [r3, #28]
 80012d6:	687a      	ldr	r2, [r7, #4]
 80012d8:	2101      	movs	r1, #1
 80012da:	6978      	ldr	r0, [r7, #20]
 80012dc:	4798      	blx	r3

    /*Invalidate the new area*/
    lv_obj_invalidate(obj);
 80012de:	6878      	ldr	r0, [r7, #4]
 80012e0:	f7ff fedc 	bl	800109c <lv_obj_invalidate>
 80012e4:	e000      	b.n	80012e8 <lv_obj_set_pos+0x134>
    if(diff.x == 0 && diff.y == 0) return;
 80012e6:	bf00      	nop
}
 80012e8:	371c      	adds	r7, #28
 80012ea:	46bd      	mov	sp, r7
 80012ec:	bd90      	pop	{r4, r7, pc}
 80012ee:	bf00      	nop
 80012f0:	080137b8 	.word	0x080137b8

080012f4 <lv_obj_set_x>:
 * Set the x coordinate of a object
 * @param obj pointer to an object
 * @param x new distance from the left side from the parent
 */
void lv_obj_set_x(lv_obj_t * obj, lv_coord_t x)
{
 80012f4:	b590      	push	{r4, r7, lr}
 80012f6:	b083      	sub	sp, #12
 80012f8:	af00      	add	r7, sp, #0
 80012fa:	6078      	str	r0, [r7, #4]
 80012fc:	460b      	mov	r3, r1
 80012fe:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8001300:	6878      	ldr	r0, [r7, #4]
 8001302:	f7fe ff79 	bl	80001f8 <lv_debug_check_null>
 8001306:	4603      	mov	r3, r0
 8001308:	f083 0301 	eor.w	r3, r3, #1
 800130c:	b2db      	uxtb	r3, r3
 800130e:	2b00      	cmp	r3, #0
 8001310:	d008      	beq.n	8001324 <lv_obj_set_x+0x30>
 8001312:	687b      	ldr	r3, [r7, #4]
 8001314:	f04f 0400 	mov.w	r4, #0
 8001318:	461a      	mov	r2, r3
 800131a:	4623      	mov	r3, r4
 800131c:	4809      	ldr	r0, [pc, #36]	; (8001344 <lv_obj_set_x+0x50>)
 800131e:	f7fe ff95 	bl	800024c <lv_debug_log_error>
 8001322:	e7fe      	b.n	8001322 <lv_obj_set_x+0x2e>

    lv_obj_set_pos(obj, x, lv_obj_get_y(obj));
 8001324:	6878      	ldr	r0, [r7, #4]
 8001326:	f001 f943 	bl	80025b0 <lv_obj_get_y>
 800132a:	4603      	mov	r3, r0
 800132c:	461a      	mov	r2, r3
 800132e:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8001332:	4619      	mov	r1, r3
 8001334:	6878      	ldr	r0, [r7, #4]
 8001336:	f7ff ff3d 	bl	80011b4 <lv_obj_set_pos>
}
 800133a:	bf00      	nop
 800133c:	370c      	adds	r7, #12
 800133e:	46bd      	mov	sp, r7
 8001340:	bd90      	pop	{r4, r7, pc}
 8001342:	bf00      	nop
 8001344:	080137b8 	.word	0x080137b8

08001348 <lv_obj_set_y>:
 * Set the y coordinate of a object
 * @param obj pointer to an object
 * @param y new distance from the top of the parent
 */
void lv_obj_set_y(lv_obj_t * obj, lv_coord_t y)
{
 8001348:	b590      	push	{r4, r7, lr}
 800134a:	b083      	sub	sp, #12
 800134c:	af00      	add	r7, sp, #0
 800134e:	6078      	str	r0, [r7, #4]
 8001350:	460b      	mov	r3, r1
 8001352:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8001354:	6878      	ldr	r0, [r7, #4]
 8001356:	f7fe ff4f 	bl	80001f8 <lv_debug_check_null>
 800135a:	4603      	mov	r3, r0
 800135c:	f083 0301 	eor.w	r3, r3, #1
 8001360:	b2db      	uxtb	r3, r3
 8001362:	2b00      	cmp	r3, #0
 8001364:	d008      	beq.n	8001378 <lv_obj_set_y+0x30>
 8001366:	687b      	ldr	r3, [r7, #4]
 8001368:	f04f 0400 	mov.w	r4, #0
 800136c:	461a      	mov	r2, r3
 800136e:	4623      	mov	r3, r4
 8001370:	4809      	ldr	r0, [pc, #36]	; (8001398 <lv_obj_set_y+0x50>)
 8001372:	f7fe ff6b 	bl	800024c <lv_debug_log_error>
 8001376:	e7fe      	b.n	8001376 <lv_obj_set_y+0x2e>

    lv_obj_set_pos(obj, lv_obj_get_x(obj), y);
 8001378:	6878      	ldr	r0, [r7, #4]
 800137a:	f001 f8e5 	bl	8002548 <lv_obj_get_x>
 800137e:	4603      	mov	r3, r0
 8001380:	4619      	mov	r1, r3
 8001382:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8001386:	461a      	mov	r2, r3
 8001388:	6878      	ldr	r0, [r7, #4]
 800138a:	f7ff ff13 	bl	80011b4 <lv_obj_set_pos>
}
 800138e:	bf00      	nop
 8001390:	370c      	adds	r7, #12
 8001392:	46bd      	mov	sp, r7
 8001394:	bd90      	pop	{r4, r7, pc}
 8001396:	bf00      	nop
 8001398:	080137b8 	.word	0x080137b8

0800139c <lv_obj_set_size>:
 * @param obj pointer to an object
 * @param w new width
 * @param h new height
 */
void lv_obj_set_size(lv_obj_t * obj, lv_coord_t w, lv_coord_t h)
{
 800139c:	b590      	push	{r4, r7, lr}
 800139e:	b087      	sub	sp, #28
 80013a0:	af00      	add	r7, sp, #0
 80013a2:	6078      	str	r0, [r7, #4]
 80013a4:	460b      	mov	r3, r1
 80013a6:	807b      	strh	r3, [r7, #2]
 80013a8:	4613      	mov	r3, r2
 80013aa:	803b      	strh	r3, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80013ac:	6878      	ldr	r0, [r7, #4]
 80013ae:	f7fe ff23 	bl	80001f8 <lv_debug_check_null>
 80013b2:	4603      	mov	r3, r0
 80013b4:	f083 0301 	eor.w	r3, r3, #1
 80013b8:	b2db      	uxtb	r3, r3
 80013ba:	2b00      	cmp	r3, #0
 80013bc:	d008      	beq.n	80013d0 <lv_obj_set_size+0x34>
 80013be:	687b      	ldr	r3, [r7, #4]
 80013c0:	f04f 0400 	mov.w	r4, #0
 80013c4:	461a      	mov	r2, r3
 80013c6:	4623      	mov	r3, r4
 80013c8:	4843      	ldr	r0, [pc, #268]	; (80014d8 <lv_obj_set_size+0x13c>)
 80013ca:	f7fe ff3f 	bl	800024c <lv_debug_log_error>
 80013ce:	e7fe      	b.n	80013ce <lv_obj_set_size+0x32>


    /* Do nothing if the size is not changed */
    /* It is very important else recursive resizing can
     * occur without size change*/
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
 80013d0:	6878      	ldr	r0, [r7, #4]
 80013d2:	f001 f921 	bl	8002618 <lv_obj_get_width>
 80013d6:	4603      	mov	r3, r0
 80013d8:	461a      	mov	r2, r3
 80013da:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80013de:	4293      	cmp	r3, r2
 80013e0:	d108      	bne.n	80013f4 <lv_obj_set_size+0x58>
 80013e2:	6878      	ldr	r0, [r7, #4]
 80013e4:	f001 f93a 	bl	800265c <lv_obj_get_height>
 80013e8:	4603      	mov	r3, r0
 80013ea:	461a      	mov	r2, r3
 80013ec:	f9b7 3000 	ldrsh.w	r3, [r7]
 80013f0:	4293      	cmp	r3, r2
 80013f2:	d06d      	beq.n	80014d0 <lv_obj_set_size+0x134>
        return;
    }

    /*Invalidate the original area*/
    lv_obj_invalidate(obj);
 80013f4:	6878      	ldr	r0, [r7, #4]
 80013f6:	f7ff fe51 	bl	800109c <lv_obj_invalidate>

    /*Save the original coordinates*/
    lv_area_t ori;
    lv_obj_get_coords(obj, &ori);
 80013fa:	f107 0308 	add.w	r3, r7, #8
 80013fe:	4619      	mov	r1, r3
 8001400:	6878      	ldr	r0, [r7, #4]
 8001402:	f001 f87d 	bl	8002500 <lv_obj_get_coords>

    /*Set the length and height*/
    obj->coords.y2 = obj->coords.y1 + h - 1;
 8001406:	687b      	ldr	r3, [r7, #4]
 8001408:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 800140c:	b29a      	uxth	r2, r3
 800140e:	883b      	ldrh	r3, [r7, #0]
 8001410:	4413      	add	r3, r2
 8001412:	b29b      	uxth	r3, r3
 8001414:	3b01      	subs	r3, #1
 8001416:	b29b      	uxth	r3, r3
 8001418:	b21a      	sxth	r2, r3
 800141a:	687b      	ldr	r3, [r7, #4]
 800141c:	82da      	strh	r2, [r3, #22]
    if(lv_obj_get_base_dir(obj) == LV_BIDI_DIR_RTL) {
 800141e:	6878      	ldr	r0, [r7, #4]
 8001420:	f001 fa2a 	bl	8002878 <lv_obj_get_base_dir>
 8001424:	4603      	mov	r3, r0
 8001426:	2b01      	cmp	r3, #1
 8001428:	d10c      	bne.n	8001444 <lv_obj_set_size+0xa8>
        obj->coords.x1 = obj->coords.x2 - w + 1;
 800142a:	687b      	ldr	r3, [r7, #4]
 800142c:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8001430:	b29a      	uxth	r2, r3
 8001432:	887b      	ldrh	r3, [r7, #2]
 8001434:	1ad3      	subs	r3, r2, r3
 8001436:	b29b      	uxth	r3, r3
 8001438:	3301      	adds	r3, #1
 800143a:	b29b      	uxth	r3, r3
 800143c:	b21a      	sxth	r2, r3
 800143e:	687b      	ldr	r3, [r7, #4]
 8001440:	821a      	strh	r2, [r3, #16]
 8001442:	e00b      	b.n	800145c <lv_obj_set_size+0xc0>
    } else {
        obj->coords.x2 = obj->coords.x1 + w - 1;
 8001444:	687b      	ldr	r3, [r7, #4]
 8001446:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 800144a:	b29a      	uxth	r2, r3
 800144c:	887b      	ldrh	r3, [r7, #2]
 800144e:	4413      	add	r3, r2
 8001450:	b29b      	uxth	r3, r3
 8001452:	3b01      	subs	r3, #1
 8001454:	b29b      	uxth	r3, r3
 8001456:	b21a      	sxth	r2, r3
 8001458:	687b      	ldr	r3, [r7, #4]
 800145a:	829a      	strh	r2, [r3, #20]
    }

    /*Send a signal to the object with its new coordinates*/
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
 800145c:	687b      	ldr	r3, [r7, #4]
 800145e:	69db      	ldr	r3, [r3, #28]
 8001460:	f107 0208 	add.w	r2, r7, #8
 8001464:	2102      	movs	r1, #2
 8001466:	6878      	ldr	r0, [r7, #4]
 8001468:	4798      	blx	r3

    /*Send a signal to the parent too*/
    lv_obj_t * par = lv_obj_get_parent(obj);
 800146a:	6878      	ldr	r0, [r7, #4]
 800146c:	f000 fff8 	bl	8002460 <lv_obj_get_parent>
 8001470:	6138      	str	r0, [r7, #16]
    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
 8001472:	693b      	ldr	r3, [r7, #16]
 8001474:	2b00      	cmp	r3, #0
 8001476:	d005      	beq.n	8001484 <lv_obj_set_size+0xe8>
 8001478:	693b      	ldr	r3, [r7, #16]
 800147a:	69db      	ldr	r3, [r3, #28]
 800147c:	687a      	ldr	r2, [r7, #4]
 800147e:	2101      	movs	r1, #1
 8001480:	6938      	ldr	r0, [r7, #16]
 8001482:	4798      	blx	r3

    /*Tell the children the parent's size has changed*/
    lv_obj_t * i;
    LV_LL_READ(obj->child_ll, i)
 8001484:	687b      	ldr	r3, [r7, #4]
 8001486:	3304      	adds	r3, #4
 8001488:	4618      	mov	r0, r3
 800148a:	f00b fa97 	bl	800c9bc <lv_ll_get_head>
 800148e:	6178      	str	r0, [r7, #20]
 8001490:	e00c      	b.n	80014ac <lv_obj_set_size+0x110>
    {
        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG, NULL);
 8001492:	697b      	ldr	r3, [r7, #20]
 8001494:	69db      	ldr	r3, [r3, #28]
 8001496:	2200      	movs	r2, #0
 8001498:	2103      	movs	r1, #3
 800149a:	6978      	ldr	r0, [r7, #20]
 800149c:	4798      	blx	r3
    LV_LL_READ(obj->child_ll, i)
 800149e:	687b      	ldr	r3, [r7, #4]
 80014a0:	3304      	adds	r3, #4
 80014a2:	6979      	ldr	r1, [r7, #20]
 80014a4:	4618      	mov	r0, r3
 80014a6:	f00b faaf 	bl	800ca08 <lv_ll_get_next>
 80014aa:	6178      	str	r0, [r7, #20]
 80014ac:	697b      	ldr	r3, [r7, #20]
 80014ae:	2b00      	cmp	r3, #0
 80014b0:	d1ef      	bne.n	8001492 <lv_obj_set_size+0xf6>
    }

    /*Invalidate the new area*/
    lv_obj_invalidate(obj);
 80014b2:	6878      	ldr	r0, [r7, #4]
 80014b4:	f7ff fdf2 	bl	800109c <lv_obj_invalidate>

    /*Automatically realign the object if required*/
#if LV_USE_OBJ_REALIGN
    if(obj->realign.auto_realign) lv_obj_realign(obj);
 80014b8:	687b      	ldr	r3, [r7, #4]
 80014ba:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 80014be:	f003 0301 	and.w	r3, r3, #1
 80014c2:	b2db      	uxtb	r3, r3
 80014c4:	2b00      	cmp	r3, #0
 80014c6:	d004      	beq.n	80014d2 <lv_obj_set_size+0x136>
 80014c8:	6878      	ldr	r0, [r7, #4]
 80014ca:	f000 fcf1 	bl	8001eb0 <lv_obj_realign>
 80014ce:	e000      	b.n	80014d2 <lv_obj_set_size+0x136>
        return;
 80014d0:	bf00      	nop
#endif
}
 80014d2:	371c      	adds	r7, #28
 80014d4:	46bd      	mov	sp, r7
 80014d6:	bd90      	pop	{r4, r7, pc}
 80014d8:	080137b8 	.word	0x080137b8

080014dc <lv_obj_set_height>:
 * Set the height of an object
 * @param obj pointer to an object
 * @param h new height
 */
void lv_obj_set_height(lv_obj_t * obj, lv_coord_t h)
{
 80014dc:	b590      	push	{r4, r7, lr}
 80014de:	b083      	sub	sp, #12
 80014e0:	af00      	add	r7, sp, #0
 80014e2:	6078      	str	r0, [r7, #4]
 80014e4:	460b      	mov	r3, r1
 80014e6:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80014e8:	6878      	ldr	r0, [r7, #4]
 80014ea:	f7fe fe85 	bl	80001f8 <lv_debug_check_null>
 80014ee:	4603      	mov	r3, r0
 80014f0:	f083 0301 	eor.w	r3, r3, #1
 80014f4:	b2db      	uxtb	r3, r3
 80014f6:	2b00      	cmp	r3, #0
 80014f8:	d008      	beq.n	800150c <lv_obj_set_height+0x30>
 80014fa:	687b      	ldr	r3, [r7, #4]
 80014fc:	f04f 0400 	mov.w	r4, #0
 8001500:	461a      	mov	r2, r3
 8001502:	4623      	mov	r3, r4
 8001504:	4809      	ldr	r0, [pc, #36]	; (800152c <lv_obj_set_height+0x50>)
 8001506:	f7fe fea1 	bl	800024c <lv_debug_log_error>
 800150a:	e7fe      	b.n	800150a <lv_obj_set_height+0x2e>

    lv_obj_set_size(obj, lv_obj_get_width(obj), h);
 800150c:	6878      	ldr	r0, [r7, #4]
 800150e:	f001 f883 	bl	8002618 <lv_obj_get_width>
 8001512:	4603      	mov	r3, r0
 8001514:	4619      	mov	r1, r3
 8001516:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800151a:	461a      	mov	r2, r3
 800151c:	6878      	ldr	r0, [r7, #4]
 800151e:	f7ff ff3d 	bl	800139c <lv_obj_set_size>
}
 8001522:	bf00      	nop
 8001524:	370c      	adds	r7, #12
 8001526:	46bd      	mov	sp, r7
 8001528:	bd90      	pop	{r4, r7, pc}
 800152a:	bf00      	nop
 800152c:	080137b8 	.word	0x080137b8

08001530 <lv_obj_align>:
 * @param align type of alignment (see 'lv_align_t' enum)
 * @param x_mod x coordinate shift after alignment
 * @param y_mod y coordinate shift after alignment
 */
void lv_obj_align(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_mod, lv_coord_t y_mod)
{
 8001530:	b590      	push	{r4, r7, lr}
 8001532:	b089      	sub	sp, #36	; 0x24
 8001534:	af00      	add	r7, sp, #0
 8001536:	60f8      	str	r0, [r7, #12]
 8001538:	60b9      	str	r1, [r7, #8]
 800153a:	4611      	mov	r1, r2
 800153c:	461a      	mov	r2, r3
 800153e:	460b      	mov	r3, r1
 8001540:	71fb      	strb	r3, [r7, #7]
 8001542:	4613      	mov	r3, r2
 8001544:	80bb      	strh	r3, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8001546:	68f8      	ldr	r0, [r7, #12]
 8001548:	f7fe fe56 	bl	80001f8 <lv_debug_check_null>
 800154c:	4603      	mov	r3, r0
 800154e:	f083 0301 	eor.w	r3, r3, #1
 8001552:	b2db      	uxtb	r3, r3
 8001554:	2b00      	cmp	r3, #0
 8001556:	d008      	beq.n	800156a <lv_obj_align+0x3a>
 8001558:	68fb      	ldr	r3, [r7, #12]
 800155a:	f04f 0400 	mov.w	r4, #0
 800155e:	461a      	mov	r2, r3
 8001560:	4623      	mov	r3, r4
 8001562:	48b1      	ldr	r0, [pc, #708]	; (8001828 <lv_obj_align+0x2f8>)
 8001564:	f7fe fe72 	bl	800024c <lv_debug_log_error>
 8001568:	e7fe      	b.n	8001568 <lv_obj_align+0x38>

    lv_coord_t new_x = lv_obj_get_x(obj);
 800156a:	68f8      	ldr	r0, [r7, #12]
 800156c:	f000 ffec 	bl	8002548 <lv_obj_get_x>
 8001570:	4603      	mov	r3, r0
 8001572:	83fb      	strh	r3, [r7, #30]
    lv_coord_t new_y = lv_obj_get_y(obj);
 8001574:	68f8      	ldr	r0, [r7, #12]
 8001576:	f001 f81b 	bl	80025b0 <lv_obj_get_y>
 800157a:	4603      	mov	r3, r0
 800157c:	83bb      	strh	r3, [r7, #28]

    if(base == NULL) {
 800157e:	68bb      	ldr	r3, [r7, #8]
 8001580:	2b00      	cmp	r3, #0
 8001582:	d103      	bne.n	800158c <lv_obj_align+0x5c>
        base = lv_obj_get_parent(obj);
 8001584:	68f8      	ldr	r0, [r7, #12]
 8001586:	f000 ff6b 	bl	8002460 <lv_obj_get_parent>
 800158a:	60b8      	str	r0, [r7, #8]
    }

    LV_ASSERT_OBJ(base, LV_OBJX_NAME);
 800158c:	68b8      	ldr	r0, [r7, #8]
 800158e:	f7fe fe33 	bl	80001f8 <lv_debug_check_null>
 8001592:	4603      	mov	r3, r0
 8001594:	f083 0301 	eor.w	r3, r3, #1
 8001598:	b2db      	uxtb	r3, r3
 800159a:	2b00      	cmp	r3, #0
 800159c:	d008      	beq.n	80015b0 <lv_obj_align+0x80>
 800159e:	68bb      	ldr	r3, [r7, #8]
 80015a0:	f04f 0400 	mov.w	r4, #0
 80015a4:	461a      	mov	r2, r3
 80015a6:	4623      	mov	r3, r4
 80015a8:	489f      	ldr	r0, [pc, #636]	; (8001828 <lv_obj_align+0x2f8>)
 80015aa:	f7fe fe4f 	bl	800024c <lv_debug_log_error>
 80015ae:	e7fe      	b.n	80015ae <lv_obj_align+0x7e>


    switch(align) {
 80015b0:	79fb      	ldrb	r3, [r7, #7]
 80015b2:	2b14      	cmp	r3, #20
 80015b4:	f200 81fb 	bhi.w	80019ae <lv_obj_align+0x47e>
 80015b8:	a201      	add	r2, pc, #4	; (adr r2, 80015c0 <lv_obj_align+0x90>)
 80015ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80015be:	bf00      	nop
 80015c0:	08001615 	.word	0x08001615
 80015c4:	0800166b 	.word	0x0800166b
 80015c8:	08001675 	.word	0x08001675
 80015cc:	080016a5 	.word	0x080016a5
 80015d0:	080016c5 	.word	0x080016c5
 80015d4:	080016e5 	.word	0x080016e5
 80015d8:	0800172b 	.word	0x0800172b
 80015dc:	08001761 	.word	0x08001761
 80015e0:	08001791 	.word	0x08001791
 80015e4:	080017d7 	.word	0x080017d7
 80015e8:	080017ed 	.word	0x080017ed
 80015ec:	0800182d 	.word	0x0800182d
 80015f0:	08001859 	.word	0x08001859
 80015f4:	08001869 	.word	0x08001869
 80015f8:	0800189f 	.word	0x0800189f
 80015fc:	080018c5 	.word	0x080018c5
 8001600:	080018db 	.word	0x080018db
 8001604:	08001917 	.word	0x08001917
 8001608:	08001943 	.word	0x08001943
 800160c:	08001953 	.word	0x08001953
 8001610:	08001989 	.word	0x08001989
        case LV_ALIGN_CENTER:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 8001614:	68b8      	ldr	r0, [r7, #8]
 8001616:	f000 ffff 	bl	8002618 <lv_obj_get_width>
 800161a:	4603      	mov	r3, r0
 800161c:	0fda      	lsrs	r2, r3, #31
 800161e:	4413      	add	r3, r2
 8001620:	105b      	asrs	r3, r3, #1
 8001622:	b21b      	sxth	r3, r3
 8001624:	b29c      	uxth	r4, r3
 8001626:	68f8      	ldr	r0, [r7, #12]
 8001628:	f000 fff6 	bl	8002618 <lv_obj_get_width>
 800162c:	4603      	mov	r3, r0
 800162e:	0fda      	lsrs	r2, r3, #31
 8001630:	4413      	add	r3, r2
 8001632:	105b      	asrs	r3, r3, #1
 8001634:	b21b      	sxth	r3, r3
 8001636:	b29b      	uxth	r3, r3
 8001638:	1ae3      	subs	r3, r4, r3
 800163a:	b29b      	uxth	r3, r3
 800163c:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 800163e:	68b8      	ldr	r0, [r7, #8]
 8001640:	f001 f80c 	bl	800265c <lv_obj_get_height>
 8001644:	4603      	mov	r3, r0
 8001646:	0fda      	lsrs	r2, r3, #31
 8001648:	4413      	add	r3, r2
 800164a:	105b      	asrs	r3, r3, #1
 800164c:	b21b      	sxth	r3, r3
 800164e:	b29c      	uxth	r4, r3
 8001650:	68f8      	ldr	r0, [r7, #12]
 8001652:	f001 f803 	bl	800265c <lv_obj_get_height>
 8001656:	4603      	mov	r3, r0
 8001658:	0fda      	lsrs	r2, r3, #31
 800165a:	4413      	add	r3, r2
 800165c:	105b      	asrs	r3, r3, #1
 800165e:	b21b      	sxth	r3, r3
 8001660:	b29b      	uxth	r3, r3
 8001662:	1ae3      	subs	r3, r4, r3
 8001664:	b29b      	uxth	r3, r3
 8001666:	83bb      	strh	r3, [r7, #28]
            break;
 8001668:	e1a1      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_IN_TOP_LEFT:
            new_x = 0;
 800166a:	2300      	movs	r3, #0
 800166c:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 800166e:	2300      	movs	r3, #0
 8001670:	83bb      	strh	r3, [r7, #28]
            break;
 8001672:	e19c      	b.n	80019ae <lv_obj_align+0x47e>
        case LV_ALIGN_IN_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 8001674:	68b8      	ldr	r0, [r7, #8]
 8001676:	f000 ffcf 	bl	8002618 <lv_obj_get_width>
 800167a:	4603      	mov	r3, r0
 800167c:	0fda      	lsrs	r2, r3, #31
 800167e:	4413      	add	r3, r2
 8001680:	105b      	asrs	r3, r3, #1
 8001682:	b21b      	sxth	r3, r3
 8001684:	b29c      	uxth	r4, r3
 8001686:	68f8      	ldr	r0, [r7, #12]
 8001688:	f000 ffc6 	bl	8002618 <lv_obj_get_width>
 800168c:	4603      	mov	r3, r0
 800168e:	0fda      	lsrs	r2, r3, #31
 8001690:	4413      	add	r3, r2
 8001692:	105b      	asrs	r3, r3, #1
 8001694:	b21b      	sxth	r3, r3
 8001696:	b29b      	uxth	r3, r3
 8001698:	1ae3      	subs	r3, r4, r3
 800169a:	b29b      	uxth	r3, r3
 800169c:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 800169e:	2300      	movs	r3, #0
 80016a0:	83bb      	strh	r3, [r7, #28]
            break;
 80016a2:	e184      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_IN_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 80016a4:	68b8      	ldr	r0, [r7, #8]
 80016a6:	f000 ffb7 	bl	8002618 <lv_obj_get_width>
 80016aa:	4603      	mov	r3, r0
 80016ac:	b29c      	uxth	r4, r3
 80016ae:	68f8      	ldr	r0, [r7, #12]
 80016b0:	f000 ffb2 	bl	8002618 <lv_obj_get_width>
 80016b4:	4603      	mov	r3, r0
 80016b6:	b29b      	uxth	r3, r3
 80016b8:	1ae3      	subs	r3, r4, r3
 80016ba:	b29b      	uxth	r3, r3
 80016bc:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 80016be:	2300      	movs	r3, #0
 80016c0:	83bb      	strh	r3, [r7, #28]
            break;
 80016c2:	e174      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_IN_BOTTOM_LEFT:
            new_x = 0;
 80016c4:	2300      	movs	r3, #0
 80016c6:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 80016c8:	68b8      	ldr	r0, [r7, #8]
 80016ca:	f000 ffc7 	bl	800265c <lv_obj_get_height>
 80016ce:	4603      	mov	r3, r0
 80016d0:	b29c      	uxth	r4, r3
 80016d2:	68f8      	ldr	r0, [r7, #12]
 80016d4:	f000 ffc2 	bl	800265c <lv_obj_get_height>
 80016d8:	4603      	mov	r3, r0
 80016da:	b29b      	uxth	r3, r3
 80016dc:	1ae3      	subs	r3, r4, r3
 80016de:	b29b      	uxth	r3, r3
 80016e0:	83bb      	strh	r3, [r7, #28]
            break;
 80016e2:	e164      	b.n	80019ae <lv_obj_align+0x47e>
        case LV_ALIGN_IN_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 80016e4:	68b8      	ldr	r0, [r7, #8]
 80016e6:	f000 ff97 	bl	8002618 <lv_obj_get_width>
 80016ea:	4603      	mov	r3, r0
 80016ec:	0fda      	lsrs	r2, r3, #31
 80016ee:	4413      	add	r3, r2
 80016f0:	105b      	asrs	r3, r3, #1
 80016f2:	b21b      	sxth	r3, r3
 80016f4:	b29c      	uxth	r4, r3
 80016f6:	68f8      	ldr	r0, [r7, #12]
 80016f8:	f000 ff8e 	bl	8002618 <lv_obj_get_width>
 80016fc:	4603      	mov	r3, r0
 80016fe:	0fda      	lsrs	r2, r3, #31
 8001700:	4413      	add	r3, r2
 8001702:	105b      	asrs	r3, r3, #1
 8001704:	b21b      	sxth	r3, r3
 8001706:	b29b      	uxth	r3, r3
 8001708:	1ae3      	subs	r3, r4, r3
 800170a:	b29b      	uxth	r3, r3
 800170c:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 800170e:	68b8      	ldr	r0, [r7, #8]
 8001710:	f000 ffa4 	bl	800265c <lv_obj_get_height>
 8001714:	4603      	mov	r3, r0
 8001716:	b29c      	uxth	r4, r3
 8001718:	68f8      	ldr	r0, [r7, #12]
 800171a:	f000 ff9f 	bl	800265c <lv_obj_get_height>
 800171e:	4603      	mov	r3, r0
 8001720:	b29b      	uxth	r3, r3
 8001722:	1ae3      	subs	r3, r4, r3
 8001724:	b29b      	uxth	r3, r3
 8001726:	83bb      	strh	r3, [r7, #28]
            break;
 8001728:	e141      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_IN_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 800172a:	68b8      	ldr	r0, [r7, #8]
 800172c:	f000 ff74 	bl	8002618 <lv_obj_get_width>
 8001730:	4603      	mov	r3, r0
 8001732:	b29c      	uxth	r4, r3
 8001734:	68f8      	ldr	r0, [r7, #12]
 8001736:	f000 ff6f 	bl	8002618 <lv_obj_get_width>
 800173a:	4603      	mov	r3, r0
 800173c:	b29b      	uxth	r3, r3
 800173e:	1ae3      	subs	r3, r4, r3
 8001740:	b29b      	uxth	r3, r3
 8001742:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 8001744:	68b8      	ldr	r0, [r7, #8]
 8001746:	f000 ff89 	bl	800265c <lv_obj_get_height>
 800174a:	4603      	mov	r3, r0
 800174c:	b29c      	uxth	r4, r3
 800174e:	68f8      	ldr	r0, [r7, #12]
 8001750:	f000 ff84 	bl	800265c <lv_obj_get_height>
 8001754:	4603      	mov	r3, r0
 8001756:	b29b      	uxth	r3, r3
 8001758:	1ae3      	subs	r3, r4, r3
 800175a:	b29b      	uxth	r3, r3
 800175c:	83bb      	strh	r3, [r7, #28]
            break;
 800175e:	e126      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_IN_LEFT_MID:
            new_x = 0;
 8001760:	2300      	movs	r3, #0
 8001762:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 8001764:	68b8      	ldr	r0, [r7, #8]
 8001766:	f000 ff79 	bl	800265c <lv_obj_get_height>
 800176a:	4603      	mov	r3, r0
 800176c:	0fda      	lsrs	r2, r3, #31
 800176e:	4413      	add	r3, r2
 8001770:	105b      	asrs	r3, r3, #1
 8001772:	b21b      	sxth	r3, r3
 8001774:	b29c      	uxth	r4, r3
 8001776:	68f8      	ldr	r0, [r7, #12]
 8001778:	f000 ff70 	bl	800265c <lv_obj_get_height>
 800177c:	4603      	mov	r3, r0
 800177e:	0fda      	lsrs	r2, r3, #31
 8001780:	4413      	add	r3, r2
 8001782:	105b      	asrs	r3, r3, #1
 8001784:	b21b      	sxth	r3, r3
 8001786:	b29b      	uxth	r3, r3
 8001788:	1ae3      	subs	r3, r4, r3
 800178a:	b29b      	uxth	r3, r3
 800178c:	83bb      	strh	r3, [r7, #28]
            break;
 800178e:	e10e      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_IN_RIGHT_MID:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 8001790:	68b8      	ldr	r0, [r7, #8]
 8001792:	f000 ff41 	bl	8002618 <lv_obj_get_width>
 8001796:	4603      	mov	r3, r0
 8001798:	b29c      	uxth	r4, r3
 800179a:	68f8      	ldr	r0, [r7, #12]
 800179c:	f000 ff3c 	bl	8002618 <lv_obj_get_width>
 80017a0:	4603      	mov	r3, r0
 80017a2:	b29b      	uxth	r3, r3
 80017a4:	1ae3      	subs	r3, r4, r3
 80017a6:	b29b      	uxth	r3, r3
 80017a8:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 80017aa:	68b8      	ldr	r0, [r7, #8]
 80017ac:	f000 ff56 	bl	800265c <lv_obj_get_height>
 80017b0:	4603      	mov	r3, r0
 80017b2:	0fda      	lsrs	r2, r3, #31
 80017b4:	4413      	add	r3, r2
 80017b6:	105b      	asrs	r3, r3, #1
 80017b8:	b21b      	sxth	r3, r3
 80017ba:	b29c      	uxth	r4, r3
 80017bc:	68f8      	ldr	r0, [r7, #12]
 80017be:	f000 ff4d 	bl	800265c <lv_obj_get_height>
 80017c2:	4603      	mov	r3, r0
 80017c4:	0fda      	lsrs	r2, r3, #31
 80017c6:	4413      	add	r3, r2
 80017c8:	105b      	asrs	r3, r3, #1
 80017ca:	b21b      	sxth	r3, r3
 80017cc:	b29b      	uxth	r3, r3
 80017ce:	1ae3      	subs	r3, r4, r3
 80017d0:	b29b      	uxth	r3, r3
 80017d2:	83bb      	strh	r3, [r7, #28]
            break;
 80017d4:	e0eb      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_OUT_TOP_LEFT:
            new_x = 0;
 80017d6:	2300      	movs	r3, #0
 80017d8:	83fb      	strh	r3, [r7, #30]
            new_y = -lv_obj_get_height(obj);
 80017da:	68f8      	ldr	r0, [r7, #12]
 80017dc:	f000 ff3e 	bl	800265c <lv_obj_get_height>
 80017e0:	4603      	mov	r3, r0
 80017e2:	b29b      	uxth	r3, r3
 80017e4:	425b      	negs	r3, r3
 80017e6:	b29b      	uxth	r3, r3
 80017e8:	83bb      	strh	r3, [r7, #28]
            break;
 80017ea:	e0e0      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_OUT_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 80017ec:	68b8      	ldr	r0, [r7, #8]
 80017ee:	f000 ff13 	bl	8002618 <lv_obj_get_width>
 80017f2:	4603      	mov	r3, r0
 80017f4:	0fda      	lsrs	r2, r3, #31
 80017f6:	4413      	add	r3, r2
 80017f8:	105b      	asrs	r3, r3, #1
 80017fa:	b21b      	sxth	r3, r3
 80017fc:	b29c      	uxth	r4, r3
 80017fe:	68f8      	ldr	r0, [r7, #12]
 8001800:	f000 ff0a 	bl	8002618 <lv_obj_get_width>
 8001804:	4603      	mov	r3, r0
 8001806:	0fda      	lsrs	r2, r3, #31
 8001808:	4413      	add	r3, r2
 800180a:	105b      	asrs	r3, r3, #1
 800180c:	b21b      	sxth	r3, r3
 800180e:	b29b      	uxth	r3, r3
 8001810:	1ae3      	subs	r3, r4, r3
 8001812:	b29b      	uxth	r3, r3
 8001814:	83fb      	strh	r3, [r7, #30]
            new_y = -lv_obj_get_height(obj);
 8001816:	68f8      	ldr	r0, [r7, #12]
 8001818:	f000 ff20 	bl	800265c <lv_obj_get_height>
 800181c:	4603      	mov	r3, r0
 800181e:	b29b      	uxth	r3, r3
 8001820:	425b      	negs	r3, r3
 8001822:	b29b      	uxth	r3, r3
 8001824:	83bb      	strh	r3, [r7, #28]
            break;
 8001826:	e0c2      	b.n	80019ae <lv_obj_align+0x47e>
 8001828:	080137b8 	.word	0x080137b8

        case LV_ALIGN_OUT_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 800182c:	68b8      	ldr	r0, [r7, #8]
 800182e:	f000 fef3 	bl	8002618 <lv_obj_get_width>
 8001832:	4603      	mov	r3, r0
 8001834:	b29c      	uxth	r4, r3
 8001836:	68f8      	ldr	r0, [r7, #12]
 8001838:	f000 feee 	bl	8002618 <lv_obj_get_width>
 800183c:	4603      	mov	r3, r0
 800183e:	b29b      	uxth	r3, r3
 8001840:	1ae3      	subs	r3, r4, r3
 8001842:	b29b      	uxth	r3, r3
 8001844:	83fb      	strh	r3, [r7, #30]
            new_y = -lv_obj_get_height(obj);
 8001846:	68f8      	ldr	r0, [r7, #12]
 8001848:	f000 ff08 	bl	800265c <lv_obj_get_height>
 800184c:	4603      	mov	r3, r0
 800184e:	b29b      	uxth	r3, r3
 8001850:	425b      	negs	r3, r3
 8001852:	b29b      	uxth	r3, r3
 8001854:	83bb      	strh	r3, [r7, #28]
            break;
 8001856:	e0aa      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_OUT_BOTTOM_LEFT:
            new_x = 0;
 8001858:	2300      	movs	r3, #0
 800185a:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base);
 800185c:	68b8      	ldr	r0, [r7, #8]
 800185e:	f000 fefd 	bl	800265c <lv_obj_get_height>
 8001862:	4603      	mov	r3, r0
 8001864:	83bb      	strh	r3, [r7, #28]
            break;
 8001866:	e0a2      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_OUT_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 8001868:	68b8      	ldr	r0, [r7, #8]
 800186a:	f000 fed5 	bl	8002618 <lv_obj_get_width>
 800186e:	4603      	mov	r3, r0
 8001870:	0fda      	lsrs	r2, r3, #31
 8001872:	4413      	add	r3, r2
 8001874:	105b      	asrs	r3, r3, #1
 8001876:	b21b      	sxth	r3, r3
 8001878:	b29c      	uxth	r4, r3
 800187a:	68f8      	ldr	r0, [r7, #12]
 800187c:	f000 fecc 	bl	8002618 <lv_obj_get_width>
 8001880:	4603      	mov	r3, r0
 8001882:	0fda      	lsrs	r2, r3, #31
 8001884:	4413      	add	r3, r2
 8001886:	105b      	asrs	r3, r3, #1
 8001888:	b21b      	sxth	r3, r3
 800188a:	b29b      	uxth	r3, r3
 800188c:	1ae3      	subs	r3, r4, r3
 800188e:	b29b      	uxth	r3, r3
 8001890:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base);
 8001892:	68b8      	ldr	r0, [r7, #8]
 8001894:	f000 fee2 	bl	800265c <lv_obj_get_height>
 8001898:	4603      	mov	r3, r0
 800189a:	83bb      	strh	r3, [r7, #28]
            break;
 800189c:	e087      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_OUT_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 800189e:	68b8      	ldr	r0, [r7, #8]
 80018a0:	f000 feba 	bl	8002618 <lv_obj_get_width>
 80018a4:	4603      	mov	r3, r0
 80018a6:	b29c      	uxth	r4, r3
 80018a8:	68f8      	ldr	r0, [r7, #12]
 80018aa:	f000 feb5 	bl	8002618 <lv_obj_get_width>
 80018ae:	4603      	mov	r3, r0
 80018b0:	b29b      	uxth	r3, r3
 80018b2:	1ae3      	subs	r3, r4, r3
 80018b4:	b29b      	uxth	r3, r3
 80018b6:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base);
 80018b8:	68b8      	ldr	r0, [r7, #8]
 80018ba:	f000 fecf 	bl	800265c <lv_obj_get_height>
 80018be:	4603      	mov	r3, r0
 80018c0:	83bb      	strh	r3, [r7, #28]
            break;
 80018c2:	e074      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_OUT_LEFT_TOP:
            new_x = -lv_obj_get_width(obj);
 80018c4:	68f8      	ldr	r0, [r7, #12]
 80018c6:	f000 fea7 	bl	8002618 <lv_obj_get_width>
 80018ca:	4603      	mov	r3, r0
 80018cc:	b29b      	uxth	r3, r3
 80018ce:	425b      	negs	r3, r3
 80018d0:	b29b      	uxth	r3, r3
 80018d2:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 80018d4:	2300      	movs	r3, #0
 80018d6:	83bb      	strh	r3, [r7, #28]
            break;
 80018d8:	e069      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_OUT_LEFT_MID:
            new_x = -lv_obj_get_width(obj);
 80018da:	68f8      	ldr	r0, [r7, #12]
 80018dc:	f000 fe9c 	bl	8002618 <lv_obj_get_width>
 80018e0:	4603      	mov	r3, r0
 80018e2:	b29b      	uxth	r3, r3
 80018e4:	425b      	negs	r3, r3
 80018e6:	b29b      	uxth	r3, r3
 80018e8:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 80018ea:	68b8      	ldr	r0, [r7, #8]
 80018ec:	f000 feb6 	bl	800265c <lv_obj_get_height>
 80018f0:	4603      	mov	r3, r0
 80018f2:	0fda      	lsrs	r2, r3, #31
 80018f4:	4413      	add	r3, r2
 80018f6:	105b      	asrs	r3, r3, #1
 80018f8:	b21b      	sxth	r3, r3
 80018fa:	b29c      	uxth	r4, r3
 80018fc:	68f8      	ldr	r0, [r7, #12]
 80018fe:	f000 fead 	bl	800265c <lv_obj_get_height>
 8001902:	4603      	mov	r3, r0
 8001904:	0fda      	lsrs	r2, r3, #31
 8001906:	4413      	add	r3, r2
 8001908:	105b      	asrs	r3, r3, #1
 800190a:	b21b      	sxth	r3, r3
 800190c:	b29b      	uxth	r3, r3
 800190e:	1ae3      	subs	r3, r4, r3
 8001910:	b29b      	uxth	r3, r3
 8001912:	83bb      	strh	r3, [r7, #28]
            break;
 8001914:	e04b      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_OUT_LEFT_BOTTOM:
            new_x = -lv_obj_get_width(obj);
 8001916:	68f8      	ldr	r0, [r7, #12]
 8001918:	f000 fe7e 	bl	8002618 <lv_obj_get_width>
 800191c:	4603      	mov	r3, r0
 800191e:	b29b      	uxth	r3, r3
 8001920:	425b      	negs	r3, r3
 8001922:	b29b      	uxth	r3, r3
 8001924:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 8001926:	68b8      	ldr	r0, [r7, #8]
 8001928:	f000 fe98 	bl	800265c <lv_obj_get_height>
 800192c:	4603      	mov	r3, r0
 800192e:	b29c      	uxth	r4, r3
 8001930:	68f8      	ldr	r0, [r7, #12]
 8001932:	f000 fe93 	bl	800265c <lv_obj_get_height>
 8001936:	4603      	mov	r3, r0
 8001938:	b29b      	uxth	r3, r3
 800193a:	1ae3      	subs	r3, r4, r3
 800193c:	b29b      	uxth	r3, r3
 800193e:	83bb      	strh	r3, [r7, #28]
            break;
 8001940:	e035      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_OUT_RIGHT_TOP:
            new_x = lv_obj_get_width(base);
 8001942:	68b8      	ldr	r0, [r7, #8]
 8001944:	f000 fe68 	bl	8002618 <lv_obj_get_width>
 8001948:	4603      	mov	r3, r0
 800194a:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 800194c:	2300      	movs	r3, #0
 800194e:	83bb      	strh	r3, [r7, #28]
            break;
 8001950:	e02d      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_OUT_RIGHT_MID:
            new_x = lv_obj_get_width(base);
 8001952:	68b8      	ldr	r0, [r7, #8]
 8001954:	f000 fe60 	bl	8002618 <lv_obj_get_width>
 8001958:	4603      	mov	r3, r0
 800195a:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 800195c:	68b8      	ldr	r0, [r7, #8]
 800195e:	f000 fe7d 	bl	800265c <lv_obj_get_height>
 8001962:	4603      	mov	r3, r0
 8001964:	0fda      	lsrs	r2, r3, #31
 8001966:	4413      	add	r3, r2
 8001968:	105b      	asrs	r3, r3, #1
 800196a:	b21b      	sxth	r3, r3
 800196c:	b29c      	uxth	r4, r3
 800196e:	68f8      	ldr	r0, [r7, #12]
 8001970:	f000 fe74 	bl	800265c <lv_obj_get_height>
 8001974:	4603      	mov	r3, r0
 8001976:	0fda      	lsrs	r2, r3, #31
 8001978:	4413      	add	r3, r2
 800197a:	105b      	asrs	r3, r3, #1
 800197c:	b21b      	sxth	r3, r3
 800197e:	b29b      	uxth	r3, r3
 8001980:	1ae3      	subs	r3, r4, r3
 8001982:	b29b      	uxth	r3, r3
 8001984:	83bb      	strh	r3, [r7, #28]
            break;
 8001986:	e012      	b.n	80019ae <lv_obj_align+0x47e>

        case LV_ALIGN_OUT_RIGHT_BOTTOM:
            new_x = lv_obj_get_width(base);
 8001988:	68b8      	ldr	r0, [r7, #8]
 800198a:	f000 fe45 	bl	8002618 <lv_obj_get_width>
 800198e:	4603      	mov	r3, r0
 8001990:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 8001992:	68b8      	ldr	r0, [r7, #8]
 8001994:	f000 fe62 	bl	800265c <lv_obj_get_height>
 8001998:	4603      	mov	r3, r0
 800199a:	b29c      	uxth	r4, r3
 800199c:	68f8      	ldr	r0, [r7, #12]
 800199e:	f000 fe5d 	bl	800265c <lv_obj_get_height>
 80019a2:	4603      	mov	r3, r0
 80019a4:	b29b      	uxth	r3, r3
 80019a6:	1ae3      	subs	r3, r4, r3
 80019a8:	b29b      	uxth	r3, r3
 80019aa:	83bb      	strh	r3, [r7, #28]
            break;
 80019ac:	bf00      	nop
    }

    /*Bring together the coordination system of base and obj*/
    lv_obj_t * par        = lv_obj_get_parent(obj);
 80019ae:	68f8      	ldr	r0, [r7, #12]
 80019b0:	f000 fd56 	bl	8002460 <lv_obj_get_parent>
 80019b4:	61b8      	str	r0, [r7, #24]
    lv_coord_t base_abs_x = base->coords.x1;
 80019b6:	68bb      	ldr	r3, [r7, #8]
 80019b8:	8a1b      	ldrh	r3, [r3, #16]
 80019ba:	82fb      	strh	r3, [r7, #22]
    lv_coord_t base_abs_y = base->coords.y1;
 80019bc:	68bb      	ldr	r3, [r7, #8]
 80019be:	8a5b      	ldrh	r3, [r3, #18]
 80019c0:	82bb      	strh	r3, [r7, #20]
    lv_coord_t par_abs_x  = par->coords.x1;
 80019c2:	69bb      	ldr	r3, [r7, #24]
 80019c4:	8a1b      	ldrh	r3, [r3, #16]
 80019c6:	827b      	strh	r3, [r7, #18]
    lv_coord_t par_abs_y  = par->coords.y1;
 80019c8:	69bb      	ldr	r3, [r7, #24]
 80019ca:	8a5b      	ldrh	r3, [r3, #18]
 80019cc:	823b      	strh	r3, [r7, #16]
    new_x += x_mod + base_abs_x;
 80019ce:	88ba      	ldrh	r2, [r7, #4]
 80019d0:	8afb      	ldrh	r3, [r7, #22]
 80019d2:	4413      	add	r3, r2
 80019d4:	b29a      	uxth	r2, r3
 80019d6:	8bfb      	ldrh	r3, [r7, #30]
 80019d8:	4413      	add	r3, r2
 80019da:	b29b      	uxth	r3, r3
 80019dc:	83fb      	strh	r3, [r7, #30]
    new_y += y_mod + base_abs_y;
 80019de:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 80019e0:	8abb      	ldrh	r3, [r7, #20]
 80019e2:	4413      	add	r3, r2
 80019e4:	b29a      	uxth	r2, r3
 80019e6:	8bbb      	ldrh	r3, [r7, #28]
 80019e8:	4413      	add	r3, r2
 80019ea:	b29b      	uxth	r3, r3
 80019ec:	83bb      	strh	r3, [r7, #28]
    new_x -= par_abs_x;
 80019ee:	8bfa      	ldrh	r2, [r7, #30]
 80019f0:	8a7b      	ldrh	r3, [r7, #18]
 80019f2:	1ad3      	subs	r3, r2, r3
 80019f4:	b29b      	uxth	r3, r3
 80019f6:	83fb      	strh	r3, [r7, #30]
    new_y -= par_abs_y;
 80019f8:	8bba      	ldrh	r2, [r7, #28]
 80019fa:	8a3b      	ldrh	r3, [r7, #16]
 80019fc:	1ad3      	subs	r3, r2, r3
 80019fe:	b29b      	uxth	r3, r3
 8001a00:	83bb      	strh	r3, [r7, #28]

    lv_obj_set_pos(obj, new_x, new_y);
 8001a02:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 8001a06:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8001a0a:	4619      	mov	r1, r3
 8001a0c:	68f8      	ldr	r0, [r7, #12]
 8001a0e:	f7ff fbd1 	bl	80011b4 <lv_obj_set_pos>

#if LV_USE_OBJ_REALIGN
    /*Save the last align parameters to use them in `lv_obj_realign`*/
    obj->realign.align       = align;
 8001a12:	68fb      	ldr	r3, [r7, #12]
 8001a14:	79fa      	ldrb	r2, [r7, #7]
 8001a16:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    obj->realign.xofs        = x_mod;
 8001a1a:	68fb      	ldr	r3, [r7, #12]
 8001a1c:	88ba      	ldrh	r2, [r7, #4]
 8001a1e:	879a      	strh	r2, [r3, #60]	; 0x3c
    obj->realign.yofs        = y_mod;
 8001a20:	68fb      	ldr	r3, [r7, #12]
 8001a22:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 8001a24:	87da      	strh	r2, [r3, #62]	; 0x3e
    obj->realign.base        = base;
 8001a26:	68fb      	ldr	r3, [r7, #12]
 8001a28:	68ba      	ldr	r2, [r7, #8]
 8001a2a:	639a      	str	r2, [r3, #56]	; 0x38
    obj->realign.origo_align = 0;
 8001a2c:	68fa      	ldr	r2, [r7, #12]
 8001a2e:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8001a32:	f36f 0341 	bfc	r3, #1, #1
 8001a36:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif
}
 8001a3a:	bf00      	nop
 8001a3c:	3724      	adds	r7, #36	; 0x24
 8001a3e:	46bd      	mov	sp, r7
 8001a40:	bd90      	pop	{r4, r7, pc}
 8001a42:	bf00      	nop

08001a44 <lv_obj_align_origo>:
 * @param align type of alignment (see 'lv_align_t' enum)
 * @param x_mod x coordinate shift after alignment
 * @param y_mod y coordinate shift after alignment
 */
void lv_obj_align_origo(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_mod, lv_coord_t y_mod)
{
 8001a44:	b590      	push	{r4, r7, lr}
 8001a46:	b08b      	sub	sp, #44	; 0x2c
 8001a48:	af00      	add	r7, sp, #0
 8001a4a:	60f8      	str	r0, [r7, #12]
 8001a4c:	60b9      	str	r1, [r7, #8]
 8001a4e:	4611      	mov	r1, r2
 8001a50:	461a      	mov	r2, r3
 8001a52:	460b      	mov	r3, r1
 8001a54:	71fb      	strb	r3, [r7, #7]
 8001a56:	4613      	mov	r3, r2
 8001a58:	80bb      	strh	r3, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8001a5a:	68f8      	ldr	r0, [r7, #12]
 8001a5c:	f7fe fbcc 	bl	80001f8 <lv_debug_check_null>
 8001a60:	4603      	mov	r3, r0
 8001a62:	f083 0301 	eor.w	r3, r3, #1
 8001a66:	b2db      	uxtb	r3, r3
 8001a68:	2b00      	cmp	r3, #0
 8001a6a:	d008      	beq.n	8001a7e <lv_obj_align_origo+0x3a>
 8001a6c:	68fb      	ldr	r3, [r7, #12]
 8001a6e:	f04f 0400 	mov.w	r4, #0
 8001a72:	461a      	mov	r2, r3
 8001a74:	4623      	mov	r3, r4
 8001a76:	48a2      	ldr	r0, [pc, #648]	; (8001d00 <lv_obj_align_origo+0x2bc>)
 8001a78:	f7fe fbe8 	bl	800024c <lv_debug_log_error>
 8001a7c:	e7fe      	b.n	8001a7c <lv_obj_align_origo+0x38>

    lv_coord_t new_x = lv_obj_get_x(obj);
 8001a7e:	68f8      	ldr	r0, [r7, #12]
 8001a80:	f000 fd62 	bl	8002548 <lv_obj_get_x>
 8001a84:	4603      	mov	r3, r0
 8001a86:	84fb      	strh	r3, [r7, #38]	; 0x26
    lv_coord_t new_y = lv_obj_get_y(obj);
 8001a88:	68f8      	ldr	r0, [r7, #12]
 8001a8a:	f000 fd91 	bl	80025b0 <lv_obj_get_y>
 8001a8e:	4603      	mov	r3, r0
 8001a90:	84bb      	strh	r3, [r7, #36]	; 0x24

    lv_coord_t obj_w_half = lv_obj_get_width(obj) / 2;
 8001a92:	68f8      	ldr	r0, [r7, #12]
 8001a94:	f000 fdc0 	bl	8002618 <lv_obj_get_width>
 8001a98:	4603      	mov	r3, r0
 8001a9a:	0fda      	lsrs	r2, r3, #31
 8001a9c:	4413      	add	r3, r2
 8001a9e:	105b      	asrs	r3, r3, #1
 8001aa0:	847b      	strh	r3, [r7, #34]	; 0x22
    lv_coord_t obj_h_half = lv_obj_get_height(obj) / 2;
 8001aa2:	68f8      	ldr	r0, [r7, #12]
 8001aa4:	f000 fdda 	bl	800265c <lv_obj_get_height>
 8001aa8:	4603      	mov	r3, r0
 8001aaa:	0fda      	lsrs	r2, r3, #31
 8001aac:	4413      	add	r3, r2
 8001aae:	105b      	asrs	r3, r3, #1
 8001ab0:	843b      	strh	r3, [r7, #32]

    if(base == NULL) {
 8001ab2:	68bb      	ldr	r3, [r7, #8]
 8001ab4:	2b00      	cmp	r3, #0
 8001ab6:	d103      	bne.n	8001ac0 <lv_obj_align_origo+0x7c>
        base = lv_obj_get_parent(obj);
 8001ab8:	68f8      	ldr	r0, [r7, #12]
 8001aba:	f000 fcd1 	bl	8002460 <lv_obj_get_parent>
 8001abe:	60b8      	str	r0, [r7, #8]
    }

    LV_ASSERT_OBJ(base, LV_OBJX_NAME);
 8001ac0:	68b8      	ldr	r0, [r7, #8]
 8001ac2:	f7fe fb99 	bl	80001f8 <lv_debug_check_null>
 8001ac6:	4603      	mov	r3, r0
 8001ac8:	f083 0301 	eor.w	r3, r3, #1
 8001acc:	b2db      	uxtb	r3, r3
 8001ace:	2b00      	cmp	r3, #0
 8001ad0:	d008      	beq.n	8001ae4 <lv_obj_align_origo+0xa0>
 8001ad2:	68bb      	ldr	r3, [r7, #8]
 8001ad4:	f04f 0400 	mov.w	r4, #0
 8001ad8:	461a      	mov	r2, r3
 8001ada:	4623      	mov	r3, r4
 8001adc:	4888      	ldr	r0, [pc, #544]	; (8001d00 <lv_obj_align_origo+0x2bc>)
 8001ade:	f7fe fbb5 	bl	800024c <lv_debug_log_error>
 8001ae2:	e7fe      	b.n	8001ae2 <lv_obj_align_origo+0x9e>


    switch(align) {
 8001ae4:	79fb      	ldrb	r3, [r7, #7]
 8001ae6:	2b14      	cmp	r3, #20
 8001ae8:	f200 8197 	bhi.w	8001e1a <lv_obj_align_origo+0x3d6>
 8001aec:	a201      	add	r2, pc, #4	; (adr r2, 8001af4 <lv_obj_align_origo+0xb0>)
 8001aee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001af2:	bf00      	nop
 8001af4:	08001b49 	.word	0x08001b49
 8001af8:	08001b7f 	.word	0x08001b7f
 8001afc:	08001b91 	.word	0x08001b91
 8001b00:	08001bb5 	.word	0x08001bb5
 8001b04:	08001bd1 	.word	0x08001bd1
 8001b08:	08001bed 	.word	0x08001bed
 8001b0c:	08001c1b 	.word	0x08001c1b
 8001b10:	08001c41 	.word	0x08001c41
 8001b14:	08001c65 	.word	0x08001c65
 8001b18:	08001c93 	.word	0x08001c93
 8001b1c:	08001ca5 	.word	0x08001ca5
 8001b20:	08001cc9 	.word	0x08001cc9
 8001b24:	08001ce5 	.word	0x08001ce5
 8001b28:	08001d05 	.word	0x08001d05
 8001b2c:	08001d33 	.word	0x08001d33
 8001b30:	08001d59 	.word	0x08001d59
 8001b34:	08001d6b 	.word	0x08001d6b
 8001b38:	08001d8f 	.word	0x08001d8f
 8001b3c:	08001dab 	.word	0x08001dab
 8001b40:	08001dc7 	.word	0x08001dc7
 8001b44:	08001df5 	.word	0x08001df5
        case LV_ALIGN_CENTER:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 8001b48:	68b8      	ldr	r0, [r7, #8]
 8001b4a:	f000 fd65 	bl	8002618 <lv_obj_get_width>
 8001b4e:	4603      	mov	r3, r0
 8001b50:	0fda      	lsrs	r2, r3, #31
 8001b52:	4413      	add	r3, r2
 8001b54:	105b      	asrs	r3, r3, #1
 8001b56:	b21b      	sxth	r3, r3
 8001b58:	b29a      	uxth	r2, r3
 8001b5a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001b5c:	1ad3      	subs	r3, r2, r3
 8001b5e:	b29b      	uxth	r3, r3
 8001b60:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 8001b62:	68b8      	ldr	r0, [r7, #8]
 8001b64:	f000 fd7a 	bl	800265c <lv_obj_get_height>
 8001b68:	4603      	mov	r3, r0
 8001b6a:	0fda      	lsrs	r2, r3, #31
 8001b6c:	4413      	add	r3, r2
 8001b6e:	105b      	asrs	r3, r3, #1
 8001b70:	b21b      	sxth	r3, r3
 8001b72:	b29a      	uxth	r2, r3
 8001b74:	8c3b      	ldrh	r3, [r7, #32]
 8001b76:	1ad3      	subs	r3, r2, r3
 8001b78:	b29b      	uxth	r3, r3
 8001b7a:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001b7c:	e14d      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_IN_TOP_LEFT:
            new_x = -obj_w_half;
 8001b7e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001b80:	425b      	negs	r3, r3
 8001b82:	b29b      	uxth	r3, r3
 8001b84:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8001b86:	8c3b      	ldrh	r3, [r7, #32]
 8001b88:	425b      	negs	r3, r3
 8001b8a:	b29b      	uxth	r3, r3
 8001b8c:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001b8e:	e144      	b.n	8001e1a <lv_obj_align_origo+0x3d6>
        case LV_ALIGN_IN_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 8001b90:	68b8      	ldr	r0, [r7, #8]
 8001b92:	f000 fd41 	bl	8002618 <lv_obj_get_width>
 8001b96:	4603      	mov	r3, r0
 8001b98:	0fda      	lsrs	r2, r3, #31
 8001b9a:	4413      	add	r3, r2
 8001b9c:	105b      	asrs	r3, r3, #1
 8001b9e:	b21b      	sxth	r3, r3
 8001ba0:	b29a      	uxth	r2, r3
 8001ba2:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001ba4:	1ad3      	subs	r3, r2, r3
 8001ba6:	b29b      	uxth	r3, r3
 8001ba8:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8001baa:	8c3b      	ldrh	r3, [r7, #32]
 8001bac:	425b      	negs	r3, r3
 8001bae:	b29b      	uxth	r3, r3
 8001bb0:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001bb2:	e132      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_IN_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8001bb4:	68b8      	ldr	r0, [r7, #8]
 8001bb6:	f000 fd2f 	bl	8002618 <lv_obj_get_width>
 8001bba:	4603      	mov	r3, r0
 8001bbc:	b29a      	uxth	r2, r3
 8001bbe:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001bc0:	1ad3      	subs	r3, r2, r3
 8001bc2:	b29b      	uxth	r3, r3
 8001bc4:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8001bc6:	8c3b      	ldrh	r3, [r7, #32]
 8001bc8:	425b      	negs	r3, r3
 8001bca:	b29b      	uxth	r3, r3
 8001bcc:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001bce:	e124      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_IN_BOTTOM_LEFT:
            new_x = -obj_w_half;
 8001bd0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001bd2:	425b      	negs	r3, r3
 8001bd4:	b29b      	uxth	r3, r3
 8001bd6:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8001bd8:	68b8      	ldr	r0, [r7, #8]
 8001bda:	f000 fd3f 	bl	800265c <lv_obj_get_height>
 8001bde:	4603      	mov	r3, r0
 8001be0:	b29a      	uxth	r2, r3
 8001be2:	8c3b      	ldrh	r3, [r7, #32]
 8001be4:	1ad3      	subs	r3, r2, r3
 8001be6:	b29b      	uxth	r3, r3
 8001be8:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001bea:	e116      	b.n	8001e1a <lv_obj_align_origo+0x3d6>
        case LV_ALIGN_IN_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 8001bec:	68b8      	ldr	r0, [r7, #8]
 8001bee:	f000 fd13 	bl	8002618 <lv_obj_get_width>
 8001bf2:	4603      	mov	r3, r0
 8001bf4:	0fda      	lsrs	r2, r3, #31
 8001bf6:	4413      	add	r3, r2
 8001bf8:	105b      	asrs	r3, r3, #1
 8001bfa:	b21b      	sxth	r3, r3
 8001bfc:	b29a      	uxth	r2, r3
 8001bfe:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001c00:	1ad3      	subs	r3, r2, r3
 8001c02:	b29b      	uxth	r3, r3
 8001c04:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8001c06:	68b8      	ldr	r0, [r7, #8]
 8001c08:	f000 fd28 	bl	800265c <lv_obj_get_height>
 8001c0c:	4603      	mov	r3, r0
 8001c0e:	b29a      	uxth	r2, r3
 8001c10:	8c3b      	ldrh	r3, [r7, #32]
 8001c12:	1ad3      	subs	r3, r2, r3
 8001c14:	b29b      	uxth	r3, r3
 8001c16:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001c18:	e0ff      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_IN_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8001c1a:	68b8      	ldr	r0, [r7, #8]
 8001c1c:	f000 fcfc 	bl	8002618 <lv_obj_get_width>
 8001c20:	4603      	mov	r3, r0
 8001c22:	b29a      	uxth	r2, r3
 8001c24:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001c26:	1ad3      	subs	r3, r2, r3
 8001c28:	b29b      	uxth	r3, r3
 8001c2a:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8001c2c:	68b8      	ldr	r0, [r7, #8]
 8001c2e:	f000 fd15 	bl	800265c <lv_obj_get_height>
 8001c32:	4603      	mov	r3, r0
 8001c34:	b29a      	uxth	r2, r3
 8001c36:	8c3b      	ldrh	r3, [r7, #32]
 8001c38:	1ad3      	subs	r3, r2, r3
 8001c3a:	b29b      	uxth	r3, r3
 8001c3c:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001c3e:	e0ec      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_IN_LEFT_MID:
            new_x = -obj_w_half;
 8001c40:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001c42:	425b      	negs	r3, r3
 8001c44:	b29b      	uxth	r3, r3
 8001c46:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 8001c48:	68b8      	ldr	r0, [r7, #8]
 8001c4a:	f000 fd07 	bl	800265c <lv_obj_get_height>
 8001c4e:	4603      	mov	r3, r0
 8001c50:	0fda      	lsrs	r2, r3, #31
 8001c52:	4413      	add	r3, r2
 8001c54:	105b      	asrs	r3, r3, #1
 8001c56:	b21b      	sxth	r3, r3
 8001c58:	b29a      	uxth	r2, r3
 8001c5a:	8c3b      	ldrh	r3, [r7, #32]
 8001c5c:	1ad3      	subs	r3, r2, r3
 8001c5e:	b29b      	uxth	r3, r3
 8001c60:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001c62:	e0da      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_IN_RIGHT_MID:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8001c64:	68b8      	ldr	r0, [r7, #8]
 8001c66:	f000 fcd7 	bl	8002618 <lv_obj_get_width>
 8001c6a:	4603      	mov	r3, r0
 8001c6c:	b29a      	uxth	r2, r3
 8001c6e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001c70:	1ad3      	subs	r3, r2, r3
 8001c72:	b29b      	uxth	r3, r3
 8001c74:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 8001c76:	68b8      	ldr	r0, [r7, #8]
 8001c78:	f000 fcf0 	bl	800265c <lv_obj_get_height>
 8001c7c:	4603      	mov	r3, r0
 8001c7e:	0fda      	lsrs	r2, r3, #31
 8001c80:	4413      	add	r3, r2
 8001c82:	105b      	asrs	r3, r3, #1
 8001c84:	b21b      	sxth	r3, r3
 8001c86:	b29a      	uxth	r2, r3
 8001c88:	8c3b      	ldrh	r3, [r7, #32]
 8001c8a:	1ad3      	subs	r3, r2, r3
 8001c8c:	b29b      	uxth	r3, r3
 8001c8e:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001c90:	e0c3      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_OUT_TOP_LEFT:
            new_x = -obj_w_half;
 8001c92:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001c94:	425b      	negs	r3, r3
 8001c96:	b29b      	uxth	r3, r3
 8001c98:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8001c9a:	8c3b      	ldrh	r3, [r7, #32]
 8001c9c:	425b      	negs	r3, r3
 8001c9e:	b29b      	uxth	r3, r3
 8001ca0:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001ca2:	e0ba      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_OUT_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 8001ca4:	68b8      	ldr	r0, [r7, #8]
 8001ca6:	f000 fcb7 	bl	8002618 <lv_obj_get_width>
 8001caa:	4603      	mov	r3, r0
 8001cac:	0fda      	lsrs	r2, r3, #31
 8001cae:	4413      	add	r3, r2
 8001cb0:	105b      	asrs	r3, r3, #1
 8001cb2:	b21b      	sxth	r3, r3
 8001cb4:	b29a      	uxth	r2, r3
 8001cb6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001cb8:	1ad3      	subs	r3, r2, r3
 8001cba:	b29b      	uxth	r3, r3
 8001cbc:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8001cbe:	8c3b      	ldrh	r3, [r7, #32]
 8001cc0:	425b      	negs	r3, r3
 8001cc2:	b29b      	uxth	r3, r3
 8001cc4:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001cc6:	e0a8      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_OUT_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8001cc8:	68b8      	ldr	r0, [r7, #8]
 8001cca:	f000 fca5 	bl	8002618 <lv_obj_get_width>
 8001cce:	4603      	mov	r3, r0
 8001cd0:	b29a      	uxth	r2, r3
 8001cd2:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001cd4:	1ad3      	subs	r3, r2, r3
 8001cd6:	b29b      	uxth	r3, r3
 8001cd8:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8001cda:	8c3b      	ldrh	r3, [r7, #32]
 8001cdc:	425b      	negs	r3, r3
 8001cde:	b29b      	uxth	r3, r3
 8001ce0:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001ce2:	e09a      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_OUT_BOTTOM_LEFT:
            new_x = -obj_w_half;
 8001ce4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001ce6:	425b      	negs	r3, r3
 8001ce8:	b29b      	uxth	r3, r3
 8001cea:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8001cec:	68b8      	ldr	r0, [r7, #8]
 8001cee:	f000 fcb5 	bl	800265c <lv_obj_get_height>
 8001cf2:	4603      	mov	r3, r0
 8001cf4:	b29a      	uxth	r2, r3
 8001cf6:	8c3b      	ldrh	r3, [r7, #32]
 8001cf8:	1ad3      	subs	r3, r2, r3
 8001cfa:	b29b      	uxth	r3, r3
 8001cfc:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001cfe:	e08c      	b.n	8001e1a <lv_obj_align_origo+0x3d6>
 8001d00:	080137b8 	.word	0x080137b8

        case LV_ALIGN_OUT_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 8001d04:	68b8      	ldr	r0, [r7, #8]
 8001d06:	f000 fc87 	bl	8002618 <lv_obj_get_width>
 8001d0a:	4603      	mov	r3, r0
 8001d0c:	0fda      	lsrs	r2, r3, #31
 8001d0e:	4413      	add	r3, r2
 8001d10:	105b      	asrs	r3, r3, #1
 8001d12:	b21b      	sxth	r3, r3
 8001d14:	b29a      	uxth	r2, r3
 8001d16:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001d18:	1ad3      	subs	r3, r2, r3
 8001d1a:	b29b      	uxth	r3, r3
 8001d1c:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8001d1e:	68b8      	ldr	r0, [r7, #8]
 8001d20:	f000 fc9c 	bl	800265c <lv_obj_get_height>
 8001d24:	4603      	mov	r3, r0
 8001d26:	b29a      	uxth	r2, r3
 8001d28:	8c3b      	ldrh	r3, [r7, #32]
 8001d2a:	1ad3      	subs	r3, r2, r3
 8001d2c:	b29b      	uxth	r3, r3
 8001d2e:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001d30:	e073      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_OUT_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8001d32:	68b8      	ldr	r0, [r7, #8]
 8001d34:	f000 fc70 	bl	8002618 <lv_obj_get_width>
 8001d38:	4603      	mov	r3, r0
 8001d3a:	b29a      	uxth	r2, r3
 8001d3c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001d3e:	1ad3      	subs	r3, r2, r3
 8001d40:	b29b      	uxth	r3, r3
 8001d42:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8001d44:	68b8      	ldr	r0, [r7, #8]
 8001d46:	f000 fc89 	bl	800265c <lv_obj_get_height>
 8001d4a:	4603      	mov	r3, r0
 8001d4c:	b29a      	uxth	r2, r3
 8001d4e:	8c3b      	ldrh	r3, [r7, #32]
 8001d50:	1ad3      	subs	r3, r2, r3
 8001d52:	b29b      	uxth	r3, r3
 8001d54:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001d56:	e060      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_OUT_LEFT_TOP:
            new_x = -obj_w_half;
 8001d58:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001d5a:	425b      	negs	r3, r3
 8001d5c:	b29b      	uxth	r3, r3
 8001d5e:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8001d60:	8c3b      	ldrh	r3, [r7, #32]
 8001d62:	425b      	negs	r3, r3
 8001d64:	b29b      	uxth	r3, r3
 8001d66:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001d68:	e057      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_OUT_LEFT_MID:
            new_x = -obj_w_half;
 8001d6a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001d6c:	425b      	negs	r3, r3
 8001d6e:	b29b      	uxth	r3, r3
 8001d70:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 8001d72:	68b8      	ldr	r0, [r7, #8]
 8001d74:	f000 fc72 	bl	800265c <lv_obj_get_height>
 8001d78:	4603      	mov	r3, r0
 8001d7a:	0fda      	lsrs	r2, r3, #31
 8001d7c:	4413      	add	r3, r2
 8001d7e:	105b      	asrs	r3, r3, #1
 8001d80:	b21b      	sxth	r3, r3
 8001d82:	b29a      	uxth	r2, r3
 8001d84:	8c3b      	ldrh	r3, [r7, #32]
 8001d86:	1ad3      	subs	r3, r2, r3
 8001d88:	b29b      	uxth	r3, r3
 8001d8a:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001d8c:	e045      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_OUT_LEFT_BOTTOM:
            new_x = -obj_w_half;
 8001d8e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001d90:	425b      	negs	r3, r3
 8001d92:	b29b      	uxth	r3, r3
 8001d94:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8001d96:	68b8      	ldr	r0, [r7, #8]
 8001d98:	f000 fc60 	bl	800265c <lv_obj_get_height>
 8001d9c:	4603      	mov	r3, r0
 8001d9e:	b29a      	uxth	r2, r3
 8001da0:	8c3b      	ldrh	r3, [r7, #32]
 8001da2:	1ad3      	subs	r3, r2, r3
 8001da4:	b29b      	uxth	r3, r3
 8001da6:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001da8:	e037      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_OUT_RIGHT_TOP:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8001daa:	68b8      	ldr	r0, [r7, #8]
 8001dac:	f000 fc34 	bl	8002618 <lv_obj_get_width>
 8001db0:	4603      	mov	r3, r0
 8001db2:	b29a      	uxth	r2, r3
 8001db4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001db6:	1ad3      	subs	r3, r2, r3
 8001db8:	b29b      	uxth	r3, r3
 8001dba:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8001dbc:	8c3b      	ldrh	r3, [r7, #32]
 8001dbe:	425b      	negs	r3, r3
 8001dc0:	b29b      	uxth	r3, r3
 8001dc2:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001dc4:	e029      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_OUT_RIGHT_MID:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8001dc6:	68b8      	ldr	r0, [r7, #8]
 8001dc8:	f000 fc26 	bl	8002618 <lv_obj_get_width>
 8001dcc:	4603      	mov	r3, r0
 8001dce:	b29a      	uxth	r2, r3
 8001dd0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001dd2:	1ad3      	subs	r3, r2, r3
 8001dd4:	b29b      	uxth	r3, r3
 8001dd6:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 8001dd8:	68b8      	ldr	r0, [r7, #8]
 8001dda:	f000 fc3f 	bl	800265c <lv_obj_get_height>
 8001dde:	4603      	mov	r3, r0
 8001de0:	0fda      	lsrs	r2, r3, #31
 8001de2:	4413      	add	r3, r2
 8001de4:	105b      	asrs	r3, r3, #1
 8001de6:	b21b      	sxth	r3, r3
 8001de8:	b29a      	uxth	r2, r3
 8001dea:	8c3b      	ldrh	r3, [r7, #32]
 8001dec:	1ad3      	subs	r3, r2, r3
 8001dee:	b29b      	uxth	r3, r3
 8001df0:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001df2:	e012      	b.n	8001e1a <lv_obj_align_origo+0x3d6>

        case LV_ALIGN_OUT_RIGHT_BOTTOM:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8001df4:	68b8      	ldr	r0, [r7, #8]
 8001df6:	f000 fc0f 	bl	8002618 <lv_obj_get_width>
 8001dfa:	4603      	mov	r3, r0
 8001dfc:	b29a      	uxth	r2, r3
 8001dfe:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8001e00:	1ad3      	subs	r3, r2, r3
 8001e02:	b29b      	uxth	r3, r3
 8001e04:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8001e06:	68b8      	ldr	r0, [r7, #8]
 8001e08:	f000 fc28 	bl	800265c <lv_obj_get_height>
 8001e0c:	4603      	mov	r3, r0
 8001e0e:	b29a      	uxth	r2, r3
 8001e10:	8c3b      	ldrh	r3, [r7, #32]
 8001e12:	1ad3      	subs	r3, r2, r3
 8001e14:	b29b      	uxth	r3, r3
 8001e16:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8001e18:	bf00      	nop
    }

    /*Bring together the coordination system of base and obj*/
    lv_obj_t * par        = lv_obj_get_parent(obj);
 8001e1a:	68f8      	ldr	r0, [r7, #12]
 8001e1c:	f000 fb20 	bl	8002460 <lv_obj_get_parent>
 8001e20:	61f8      	str	r0, [r7, #28]
    lv_coord_t base_abs_x = base->coords.x1;
 8001e22:	68bb      	ldr	r3, [r7, #8]
 8001e24:	8a1b      	ldrh	r3, [r3, #16]
 8001e26:	837b      	strh	r3, [r7, #26]
    lv_coord_t base_abs_y = base->coords.y1;
 8001e28:	68bb      	ldr	r3, [r7, #8]
 8001e2a:	8a5b      	ldrh	r3, [r3, #18]
 8001e2c:	833b      	strh	r3, [r7, #24]
    lv_coord_t par_abs_x  = par->coords.x1;
 8001e2e:	69fb      	ldr	r3, [r7, #28]
 8001e30:	8a1b      	ldrh	r3, [r3, #16]
 8001e32:	82fb      	strh	r3, [r7, #22]
    lv_coord_t par_abs_y  = par->coords.y1;
 8001e34:	69fb      	ldr	r3, [r7, #28]
 8001e36:	8a5b      	ldrh	r3, [r3, #18]
 8001e38:	82bb      	strh	r3, [r7, #20]
    new_x += x_mod + base_abs_x;
 8001e3a:	88ba      	ldrh	r2, [r7, #4]
 8001e3c:	8b7b      	ldrh	r3, [r7, #26]
 8001e3e:	4413      	add	r3, r2
 8001e40:	b29a      	uxth	r2, r3
 8001e42:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8001e44:	4413      	add	r3, r2
 8001e46:	b29b      	uxth	r3, r3
 8001e48:	84fb      	strh	r3, [r7, #38]	; 0x26
    new_y += y_mod + base_abs_y;
 8001e4a:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 8001e4c:	8b3b      	ldrh	r3, [r7, #24]
 8001e4e:	4413      	add	r3, r2
 8001e50:	b29a      	uxth	r2, r3
 8001e52:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8001e54:	4413      	add	r3, r2
 8001e56:	b29b      	uxth	r3, r3
 8001e58:	84bb      	strh	r3, [r7, #36]	; 0x24
    new_x -= par_abs_x;
 8001e5a:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8001e5c:	8afb      	ldrh	r3, [r7, #22]
 8001e5e:	1ad3      	subs	r3, r2, r3
 8001e60:	b29b      	uxth	r3, r3
 8001e62:	84fb      	strh	r3, [r7, #38]	; 0x26
    new_y -= par_abs_y;
 8001e64:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8001e66:	8abb      	ldrh	r3, [r7, #20]
 8001e68:	1ad3      	subs	r3, r2, r3
 8001e6a:	b29b      	uxth	r3, r3
 8001e6c:	84bb      	strh	r3, [r7, #36]	; 0x24

    lv_obj_set_pos(obj, new_x, new_y);
 8001e6e:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8001e72:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8001e76:	4619      	mov	r1, r3
 8001e78:	68f8      	ldr	r0, [r7, #12]
 8001e7a:	f7ff f99b 	bl	80011b4 <lv_obj_set_pos>

#if LV_USE_OBJ_REALIGN
    /*Save the last align parameters to use them in `lv_obj_realign`*/
    obj->realign.align       = align;
 8001e7e:	68fb      	ldr	r3, [r7, #12]
 8001e80:	79fa      	ldrb	r2, [r7, #7]
 8001e82:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    obj->realign.xofs        = x_mod;
 8001e86:	68fb      	ldr	r3, [r7, #12]
 8001e88:	88ba      	ldrh	r2, [r7, #4]
 8001e8a:	879a      	strh	r2, [r3, #60]	; 0x3c
    obj->realign.yofs        = y_mod;
 8001e8c:	68fb      	ldr	r3, [r7, #12]
 8001e8e:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 8001e90:	87da      	strh	r2, [r3, #62]	; 0x3e
    obj->realign.base        = base;
 8001e92:	68fb      	ldr	r3, [r7, #12]
 8001e94:	68ba      	ldr	r2, [r7, #8]
 8001e96:	639a      	str	r2, [r3, #56]	; 0x38
    obj->realign.origo_align = 1;
 8001e98:	68fa      	ldr	r2, [r7, #12]
 8001e9a:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8001e9e:	f043 0302 	orr.w	r3, r3, #2
 8001ea2:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif
}
 8001ea6:	bf00      	nop
 8001ea8:	372c      	adds	r7, #44	; 0x2c
 8001eaa:	46bd      	mov	sp, r7
 8001eac:	bd90      	pop	{r4, r7, pc}
 8001eae:	bf00      	nop

08001eb0 <lv_obj_realign>:
/**
 * Realign the object based on the last `lv_obj_align` parameters.
 * @param obj pointer to an object
 */
void lv_obj_realign(lv_obj_t * obj)
{
 8001eb0:	b590      	push	{r4, r7, lr}
 8001eb2:	b085      	sub	sp, #20
 8001eb4:	af02      	add	r7, sp, #8
 8001eb6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8001eb8:	6878      	ldr	r0, [r7, #4]
 8001eba:	f7fe f99d 	bl	80001f8 <lv_debug_check_null>
 8001ebe:	4603      	mov	r3, r0
 8001ec0:	f083 0301 	eor.w	r3, r3, #1
 8001ec4:	b2db      	uxtb	r3, r3
 8001ec6:	2b00      	cmp	r3, #0
 8001ec8:	d008      	beq.n	8001edc <lv_obj_realign+0x2c>
 8001eca:	687b      	ldr	r3, [r7, #4]
 8001ecc:	f04f 0400 	mov.w	r4, #0
 8001ed0:	461a      	mov	r2, r3
 8001ed2:	4623      	mov	r3, r4
 8001ed4:	4818      	ldr	r0, [pc, #96]	; (8001f38 <lv_obj_realign+0x88>)
 8001ed6:	f7fe f9b9 	bl	800024c <lv_debug_log_error>
 8001eda:	e7fe      	b.n	8001eda <lv_obj_realign+0x2a>

#if LV_USE_OBJ_REALIGN
    if(obj->realign.origo_align)
 8001edc:	687b      	ldr	r3, [r7, #4]
 8001ede:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8001ee2:	f003 0302 	and.w	r3, r3, #2
 8001ee6:	b2db      	uxtb	r3, r3
 8001ee8:	2b00      	cmp	r3, #0
 8001eea:	d010      	beq.n	8001f0e <lv_obj_realign+0x5e>
        lv_obj_align_origo(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
 8001eec:	687b      	ldr	r3, [r7, #4]
 8001eee:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8001ef0:	687b      	ldr	r3, [r7, #4]
 8001ef2:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
 8001ef6:	687b      	ldr	r3, [r7, #4]
 8001ef8:	f9b3 003c 	ldrsh.w	r0, [r3, #60]	; 0x3c
 8001efc:	687b      	ldr	r3, [r7, #4]
 8001efe:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 8001f02:	9300      	str	r3, [sp, #0]
 8001f04:	4603      	mov	r3, r0
 8001f06:	6878      	ldr	r0, [r7, #4]
 8001f08:	f7ff fd9c 	bl	8001a44 <lv_obj_align_origo>
        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
#else
    (void)obj;
    LV_LOG_WARN("lv_obj_realaign: no effect because LV_USE_OBJ_REALIGN = 0");
#endif
}
 8001f0c:	e00f      	b.n	8001f2e <lv_obj_realign+0x7e>
        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
 8001f0e:	687b      	ldr	r3, [r7, #4]
 8001f10:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8001f12:	687b      	ldr	r3, [r7, #4]
 8001f14:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
 8001f18:	687b      	ldr	r3, [r7, #4]
 8001f1a:	f9b3 003c 	ldrsh.w	r0, [r3, #60]	; 0x3c
 8001f1e:	687b      	ldr	r3, [r7, #4]
 8001f20:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 8001f24:	9300      	str	r3, [sp, #0]
 8001f26:	4603      	mov	r3, r0
 8001f28:	6878      	ldr	r0, [r7, #4]
 8001f2a:	f7ff fb01 	bl	8001530 <lv_obj_align>
}
 8001f2e:	bf00      	nop
 8001f30:	370c      	adds	r7, #12
 8001f32:	46bd      	mov	sp, r7
 8001f34:	bd90      	pop	{r4, r7, pc}
 8001f36:	bf00      	nop
 8001f38:	080137b8 	.word	0x080137b8

08001f3c <lv_obj_set_style>:
 * Set a new style for an object
 * @param obj pointer to an object
 * @param style_p pointer to the new style
 */
void lv_obj_set_style(lv_obj_t * obj, const lv_style_t * style)
{
 8001f3c:	b590      	push	{r4, r7, lr}
 8001f3e:	b083      	sub	sp, #12
 8001f40:	af00      	add	r7, sp, #0
 8001f42:	6078      	str	r0, [r7, #4]
 8001f44:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8001f46:	6878      	ldr	r0, [r7, #4]
 8001f48:	f7fe f956 	bl	80001f8 <lv_debug_check_null>
 8001f4c:	4603      	mov	r3, r0
 8001f4e:	f083 0301 	eor.w	r3, r3, #1
 8001f52:	b2db      	uxtb	r3, r3
 8001f54:	2b00      	cmp	r3, #0
 8001f56:	d008      	beq.n	8001f6a <lv_obj_set_style+0x2e>
 8001f58:	687b      	ldr	r3, [r7, #4]
 8001f5a:	f04f 0400 	mov.w	r4, #0
 8001f5e:	461a      	mov	r2, r3
 8001f60:	4623      	mov	r3, r4
 8001f62:	4811      	ldr	r0, [pc, #68]	; (8001fa8 <lv_obj_set_style+0x6c>)
 8001f64:	f7fe f972 	bl	800024c <lv_debug_log_error>
 8001f68:	e7fe      	b.n	8001f68 <lv_obj_set_style+0x2c>
    LV_ASSERT_STYLE(style);
 8001f6a:	6838      	ldr	r0, [r7, #0]
 8001f6c:	f7fe f954 	bl	8000218 <lv_debug_check_style>
 8001f70:	4603      	mov	r3, r0
 8001f72:	f083 0301 	eor.w	r3, r3, #1
 8001f76:	b2db      	uxtb	r3, r3
 8001f78:	2b00      	cmp	r3, #0
 8001f7a:	d008      	beq.n	8001f8e <lv_obj_set_style+0x52>
 8001f7c:	683b      	ldr	r3, [r7, #0]
 8001f7e:	f04f 0400 	mov.w	r4, #0
 8001f82:	461a      	mov	r2, r3
 8001f84:	4623      	mov	r3, r4
 8001f86:	4809      	ldr	r0, [pc, #36]	; (8001fac <lv_obj_set_style+0x70>)
 8001f88:	f7fe f960 	bl	800024c <lv_debug_log_error>
 8001f8c:	e7fe      	b.n	8001f8c <lv_obj_set_style+0x50>

    obj->style_p = style;
 8001f8e:	687b      	ldr	r3, [r7, #4]
 8001f90:	683a      	ldr	r2, [r7, #0]
 8001f92:	629a      	str	r2, [r3, #40]	; 0x28

    /*Send a signal about style change to every children with NULL style*/
    refresh_children_style(obj);
 8001f94:	6878      	ldr	r0, [r7, #4]
 8001f96:	f000 febc 	bl	8002d12 <refresh_children_style>

    /*Notify the object about the style change too*/
    lv_obj_refresh_style(obj);
 8001f9a:	6878      	ldr	r0, [r7, #4]
 8001f9c:	f000 f808 	bl	8001fb0 <lv_obj_refresh_style>
}
 8001fa0:	bf00      	nop
 8001fa2:	370c      	adds	r7, #12
 8001fa4:	46bd      	mov	sp, r7
 8001fa6:	bd90      	pop	{r4, r7, pc}
 8001fa8:	080137b8 	.word	0x080137b8
 8001fac:	080137c8 	.word	0x080137c8

08001fb0 <lv_obj_refresh_style>:
/**
 * Notify an object about its style is modified
 * @param obj pointer to an object
 */
void lv_obj_refresh_style(lv_obj_t * obj)
{
 8001fb0:	b590      	push	{r4, r7, lr}
 8001fb2:	b083      	sub	sp, #12
 8001fb4:	af00      	add	r7, sp, #0
 8001fb6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8001fb8:	6878      	ldr	r0, [r7, #4]
 8001fba:	f7fe f91d 	bl	80001f8 <lv_debug_check_null>
 8001fbe:	4603      	mov	r3, r0
 8001fc0:	f083 0301 	eor.w	r3, r3, #1
 8001fc4:	b2db      	uxtb	r3, r3
 8001fc6:	2b00      	cmp	r3, #0
 8001fc8:	d008      	beq.n	8001fdc <lv_obj_refresh_style+0x2c>
 8001fca:	687b      	ldr	r3, [r7, #4]
 8001fcc:	f04f 0400 	mov.w	r4, #0
 8001fd0:	461a      	mov	r2, r3
 8001fd2:	4623      	mov	r3, r4
 8001fd4:	4809      	ldr	r0, [pc, #36]	; (8001ffc <lv_obj_refresh_style+0x4c>)
 8001fd6:	f7fe f939 	bl	800024c <lv_debug_log_error>
 8001fda:	e7fe      	b.n	8001fda <lv_obj_refresh_style+0x2a>

    lv_obj_invalidate(obj);
 8001fdc:	6878      	ldr	r0, [r7, #4]
 8001fde:	f7ff f85d 	bl	800109c <lv_obj_invalidate>
    obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);
 8001fe2:	687b      	ldr	r3, [r7, #4]
 8001fe4:	69db      	ldr	r3, [r3, #28]
 8001fe6:	2200      	movs	r2, #0
 8001fe8:	2104      	movs	r1, #4
 8001fea:	6878      	ldr	r0, [r7, #4]
 8001fec:	4798      	blx	r3
    lv_obj_invalidate(obj);
 8001fee:	6878      	ldr	r0, [r7, #4]
 8001ff0:	f7ff f854 	bl	800109c <lv_obj_invalidate>
}
 8001ff4:	bf00      	nop
 8001ff6:	370c      	adds	r7, #12
 8001ff8:	46bd      	mov	sp, r7
 8001ffa:	bd90      	pop	{r4, r7, pc}
 8001ffc:	080137b8 	.word	0x080137b8

08002000 <lv_obj_set_click>:
 * Enable or disable the clicking of an object
 * @param obj pointer to an object
 * @param en true: make the object clickable
 */
void lv_obj_set_click(lv_obj_t * obj, bool en)
{
 8002000:	b590      	push	{r4, r7, lr}
 8002002:	b083      	sub	sp, #12
 8002004:	af00      	add	r7, sp, #0
 8002006:	6078      	str	r0, [r7, #4]
 8002008:	460b      	mov	r3, r1
 800200a:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800200c:	6878      	ldr	r0, [r7, #4]
 800200e:	f7fe f8f3 	bl	80001f8 <lv_debug_check_null>
 8002012:	4603      	mov	r3, r0
 8002014:	f083 0301 	eor.w	r3, r3, #1
 8002018:	b2db      	uxtb	r3, r3
 800201a:	2b00      	cmp	r3, #0
 800201c:	d008      	beq.n	8002030 <lv_obj_set_click+0x30>
 800201e:	687b      	ldr	r3, [r7, #4]
 8002020:	f04f 0400 	mov.w	r4, #0
 8002024:	461a      	mov	r2, r3
 8002026:	4623      	mov	r3, r4
 8002028:	4807      	ldr	r0, [pc, #28]	; (8002048 <lv_obj_set_click+0x48>)
 800202a:	f7fe f90f 	bl	800024c <lv_debug_log_error>
 800202e:	e7fe      	b.n	800202e <lv_obj_set_click+0x2e>

    obj->click = (en == true ? 1 : 0);
 8002030:	78f9      	ldrb	r1, [r7, #3]
 8002032:	687a      	ldr	r2, [r7, #4]
 8002034:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8002038:	f361 0300 	bfi	r3, r1, #0, #1
 800203c:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
}
 8002040:	bf00      	nop
 8002042:	370c      	adds	r7, #12
 8002044:	46bd      	mov	sp, r7
 8002046:	bd90      	pop	{r4, r7, pc}
 8002048:	080137b8 	.word	0x080137b8

0800204c <lv_obj_set_protect>:
 * Set a bit or bits in the protect filed
 * @param obj pointer to an object
 * @param prot 'OR'-ed values from `lv_protect_t`
 */
void lv_obj_set_protect(lv_obj_t * obj, uint8_t prot)
{
 800204c:	b590      	push	{r4, r7, lr}
 800204e:	b083      	sub	sp, #12
 8002050:	af00      	add	r7, sp, #0
 8002052:	6078      	str	r0, [r7, #4]
 8002054:	460b      	mov	r3, r1
 8002056:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002058:	6878      	ldr	r0, [r7, #4]
 800205a:	f7fe f8cd 	bl	80001f8 <lv_debug_check_null>
 800205e:	4603      	mov	r3, r0
 8002060:	f083 0301 	eor.w	r3, r3, #1
 8002064:	b2db      	uxtb	r3, r3
 8002066:	2b00      	cmp	r3, #0
 8002068:	d008      	beq.n	800207c <lv_obj_set_protect+0x30>
 800206a:	687b      	ldr	r3, [r7, #4]
 800206c:	f04f 0400 	mov.w	r4, #0
 8002070:	461a      	mov	r2, r3
 8002072:	4623      	mov	r3, r4
 8002074:	4808      	ldr	r0, [pc, #32]	; (8002098 <lv_obj_set_protect+0x4c>)
 8002076:	f7fe f8e9 	bl	800024c <lv_debug_log_error>
 800207a:	e7fe      	b.n	800207a <lv_obj_set_protect+0x2e>

    obj->protect |= prot;
 800207c:	687b      	ldr	r3, [r7, #4]
 800207e:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8002082:	78fb      	ldrb	r3, [r7, #3]
 8002084:	4313      	orrs	r3, r2
 8002086:	b2da      	uxtb	r2, r3
 8002088:	687b      	ldr	r3, [r7, #4]
 800208a:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
 800208e:	bf00      	nop
 8002090:	370c      	adds	r7, #12
 8002092:	46bd      	mov	sp, r7
 8002094:	bd90      	pop	{r4, r7, pc}
 8002096:	bf00      	nop
 8002098:	080137b8 	.word	0x080137b8

0800209c <lv_obj_clear_protect>:
 * Clear a bit or bits in the protect filed
 * @param obj pointer to an object
 * @param prot 'OR'-ed values from `lv_protect_t`
 */
void lv_obj_clear_protect(lv_obj_t * obj, uint8_t prot)
{
 800209c:	b590      	push	{r4, r7, lr}
 800209e:	b083      	sub	sp, #12
 80020a0:	af00      	add	r7, sp, #0
 80020a2:	6078      	str	r0, [r7, #4]
 80020a4:	460b      	mov	r3, r1
 80020a6:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80020a8:	6878      	ldr	r0, [r7, #4]
 80020aa:	f7fe f8a5 	bl	80001f8 <lv_debug_check_null>
 80020ae:	4603      	mov	r3, r0
 80020b0:	f083 0301 	eor.w	r3, r3, #1
 80020b4:	b2db      	uxtb	r3, r3
 80020b6:	2b00      	cmp	r3, #0
 80020b8:	d008      	beq.n	80020cc <lv_obj_clear_protect+0x30>
 80020ba:	687b      	ldr	r3, [r7, #4]
 80020bc:	f04f 0400 	mov.w	r4, #0
 80020c0:	461a      	mov	r2, r3
 80020c2:	4623      	mov	r3, r4
 80020c4:	4809      	ldr	r0, [pc, #36]	; (80020ec <lv_obj_clear_protect+0x50>)
 80020c6:	f7fe f8c1 	bl	800024c <lv_debug_log_error>
 80020ca:	e7fe      	b.n	80020ca <lv_obj_clear_protect+0x2e>

    prot = (~prot) & 0xFF;
 80020cc:	78fb      	ldrb	r3, [r7, #3]
 80020ce:	43db      	mvns	r3, r3
 80020d0:	70fb      	strb	r3, [r7, #3]
    obj->protect &= prot;
 80020d2:	687b      	ldr	r3, [r7, #4]
 80020d4:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 80020d8:	78fb      	ldrb	r3, [r7, #3]
 80020da:	4013      	ands	r3, r2
 80020dc:	b2da      	uxtb	r2, r3
 80020de:	687b      	ldr	r3, [r7, #4]
 80020e0:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
 80020e4:	bf00      	nop
 80020e6:	370c      	adds	r7, #12
 80020e8:	46bd      	mov	sp, r7
 80020ea:	bd90      	pop	{r4, r7, pc}
 80020ec:	080137b8 	.word	0x080137b8

080020f0 <lv_event_send>:
 * @param event the type of the event from `lv_event_t`
 * @param data arbitrary data depending on the object type and the event. (Usually `NULL`)
 * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event
 */
lv_res_t lv_event_send(lv_obj_t * obj, lv_event_t event, const void * data)
{
 80020f0:	b590      	push	{r4, r7, lr}
 80020f2:	b087      	sub	sp, #28
 80020f4:	af00      	add	r7, sp, #0
 80020f6:	60f8      	str	r0, [r7, #12]
 80020f8:	460b      	mov	r3, r1
 80020fa:	607a      	str	r2, [r7, #4]
 80020fc:	72fb      	strb	r3, [r7, #11]
    if(obj == NULL) return LV_RES_OK;
 80020fe:	68fb      	ldr	r3, [r7, #12]
 8002100:	2b00      	cmp	r3, #0
 8002102:	d101      	bne.n	8002108 <lv_event_send+0x18>
 8002104:	2301      	movs	r3, #1
 8002106:	e01b      	b.n	8002140 <lv_event_send+0x50>

    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002108:	68f8      	ldr	r0, [r7, #12]
 800210a:	f7fe f875 	bl	80001f8 <lv_debug_check_null>
 800210e:	4603      	mov	r3, r0
 8002110:	f083 0301 	eor.w	r3, r3, #1
 8002114:	b2db      	uxtb	r3, r3
 8002116:	2b00      	cmp	r3, #0
 8002118:	d008      	beq.n	800212c <lv_event_send+0x3c>
 800211a:	68fb      	ldr	r3, [r7, #12]
 800211c:	f04f 0400 	mov.w	r4, #0
 8002120:	461a      	mov	r2, r3
 8002122:	4623      	mov	r3, r4
 8002124:	4808      	ldr	r0, [pc, #32]	; (8002148 <lv_event_send+0x58>)
 8002126:	f7fe f891 	bl	800024c <lv_debug_log_error>
 800212a:	e7fe      	b.n	800212a <lv_event_send+0x3a>

    lv_res_t res;
    res = lv_event_send_func(obj->event_cb, obj, event, data);
 800212c:	68fb      	ldr	r3, [r7, #12]
 800212e:	6998      	ldr	r0, [r3, #24]
 8002130:	7afa      	ldrb	r2, [r7, #11]
 8002132:	687b      	ldr	r3, [r7, #4]
 8002134:	68f9      	ldr	r1, [r7, #12]
 8002136:	f000 f809 	bl	800214c <lv_event_send_func>
 800213a:	4603      	mov	r3, r0
 800213c:	75fb      	strb	r3, [r7, #23]
    return res;
 800213e:	7dfb      	ldrb	r3, [r7, #23]
}
 8002140:	4618      	mov	r0, r3
 8002142:	371c      	adds	r7, #28
 8002144:	46bd      	mov	sp, r7
 8002146:	bd90      	pop	{r4, r7, pc}
 8002148:	080137b8 	.word	0x080137b8

0800214c <lv_event_send_func>:
 * @param event an event
 * @param data pointer to a custom data
 * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event
 */
lv_res_t lv_event_send_func(lv_event_cb_t event_xcb, lv_obj_t * obj, lv_event_t event, const void * data)
{
 800214c:	b590      	push	{r4, r7, lr}
 800214e:	b08b      	sub	sp, #44	; 0x2c
 8002150:	af00      	add	r7, sp, #0
 8002152:	60f8      	str	r0, [r7, #12]
 8002154:	60b9      	str	r1, [r7, #8]
 8002156:	603b      	str	r3, [r7, #0]
 8002158:	4613      	mov	r3, r2
 800215a:	71fb      	strb	r3, [r7, #7]
    if(obj != NULL) {
 800215c:	68bb      	ldr	r3, [r7, #8]
 800215e:	2b00      	cmp	r3, #0
 8002160:	d011      	beq.n	8002186 <lv_event_send_func+0x3a>
        LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002162:	68b8      	ldr	r0, [r7, #8]
 8002164:	f7fe f848 	bl	80001f8 <lv_debug_check_null>
 8002168:	4603      	mov	r3, r0
 800216a:	f083 0301 	eor.w	r3, r3, #1
 800216e:	b2db      	uxtb	r3, r3
 8002170:	2b00      	cmp	r3, #0
 8002172:	d008      	beq.n	8002186 <lv_event_send_func+0x3a>
 8002174:	68bb      	ldr	r3, [r7, #8]
 8002176:	f04f 0400 	mov.w	r4, #0
 800217a:	461a      	mov	r2, r3
 800217c:	4623      	mov	r3, r4
 800217e:	4831      	ldr	r0, [pc, #196]	; (8002244 <lv_event_send_func+0xf8>)
 8002180:	f7fe f864 	bl	800024c <lv_debug_log_error>
 8002184:	e7fe      	b.n	8002184 <lv_event_send_func+0x38>

    /* Build a simple linked list from the objects used in the events
     * It's important to know if an this object was deleted by a nested event
     * called from this `even_cb`. */
    lv_event_temp_data_t event_temp_data;
    event_temp_data.obj     = obj;
 8002186:	68bb      	ldr	r3, [r7, #8]
 8002188:	613b      	str	r3, [r7, #16]
    event_temp_data.deleted = false;
 800218a:	2300      	movs	r3, #0
 800218c:	753b      	strb	r3, [r7, #20]
    event_temp_data.prev    = NULL;
 800218e:	2300      	movs	r3, #0
 8002190:	61bb      	str	r3, [r7, #24]

    if(event_temp_data_head) {
 8002192:	4b2d      	ldr	r3, [pc, #180]	; (8002248 <lv_event_send_func+0xfc>)
 8002194:	681b      	ldr	r3, [r3, #0]
 8002196:	2b00      	cmp	r3, #0
 8002198:	d002      	beq.n	80021a0 <lv_event_send_func+0x54>
        event_temp_data.prev = event_temp_data_head;
 800219a:	4b2b      	ldr	r3, [pc, #172]	; (8002248 <lv_event_send_func+0xfc>)
 800219c:	681b      	ldr	r3, [r3, #0]
 800219e:	61bb      	str	r3, [r7, #24]
    }
    event_temp_data_head = &event_temp_data;
 80021a0:	4a29      	ldr	r2, [pc, #164]	; (8002248 <lv_event_send_func+0xfc>)
 80021a2:	f107 0310 	add.w	r3, r7, #16
 80021a6:	6013      	str	r3, [r2, #0]

    const void * event_act_data_save = event_act_data;
 80021a8:	4b28      	ldr	r3, [pc, #160]	; (800224c <lv_event_send_func+0x100>)
 80021aa:	681b      	ldr	r3, [r3, #0]
 80021ac:	627b      	str	r3, [r7, #36]	; 0x24
    event_act_data                   = data;
 80021ae:	4a27      	ldr	r2, [pc, #156]	; (800224c <lv_event_send_func+0x100>)
 80021b0:	683b      	ldr	r3, [r7, #0]
 80021b2:	6013      	str	r3, [r2, #0]

    /*Call the input device's feedback callback if set*/
    lv_indev_t * indev_act = lv_indev_get_act();
 80021b4:	f7fe fb1c 	bl	80007f0 <lv_indev_get_act>
 80021b8:	6238      	str	r0, [r7, #32]
    if(indev_act) {
 80021ba:	6a3b      	ldr	r3, [r7, #32]
 80021bc:	2b00      	cmp	r3, #0
 80021be:	d009      	beq.n	80021d4 <lv_event_send_func+0x88>
        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);
 80021c0:	6a3b      	ldr	r3, [r7, #32]
 80021c2:	689b      	ldr	r3, [r3, #8]
 80021c4:	2b00      	cmp	r3, #0
 80021c6:	d005      	beq.n	80021d4 <lv_event_send_func+0x88>
 80021c8:	6a3b      	ldr	r3, [r7, #32]
 80021ca:	689b      	ldr	r3, [r3, #8]
 80021cc:	6a3a      	ldr	r2, [r7, #32]
 80021ce:	79f9      	ldrb	r1, [r7, #7]
 80021d0:	4610      	mov	r0, r2
 80021d2:	4798      	blx	r3
    }

    /*Call the event callback itself*/
    if(event_xcb) event_xcb(obj, event);
 80021d4:	68fb      	ldr	r3, [r7, #12]
 80021d6:	2b00      	cmp	r3, #0
 80021d8:	d004      	beq.n	80021e4 <lv_event_send_func+0x98>
 80021da:	79fa      	ldrb	r2, [r7, #7]
 80021dc:	68fb      	ldr	r3, [r7, #12]
 80021de:	4611      	mov	r1, r2
 80021e0:	68b8      	ldr	r0, [r7, #8]
 80021e2:	4798      	blx	r3

    /*Restore the event data*/
    event_act_data = event_act_data_save;
 80021e4:	4a19      	ldr	r2, [pc, #100]	; (800224c <lv_event_send_func+0x100>)
 80021e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80021e8:	6013      	str	r3, [r2, #0]

    /*Remove this element from the list*/
    event_temp_data_head = event_temp_data_head->prev;
 80021ea:	4b17      	ldr	r3, [pc, #92]	; (8002248 <lv_event_send_func+0xfc>)
 80021ec:	681b      	ldr	r3, [r3, #0]
 80021ee:	689b      	ldr	r3, [r3, #8]
 80021f0:	4a15      	ldr	r2, [pc, #84]	; (8002248 <lv_event_send_func+0xfc>)
 80021f2:	6013      	str	r3, [r2, #0]

    if(event_temp_data.deleted) {
 80021f4:	7d3b      	ldrb	r3, [r7, #20]
 80021f6:	2b00      	cmp	r3, #0
 80021f8:	d001      	beq.n	80021fe <lv_event_send_func+0xb2>
        return LV_RES_INV;
 80021fa:	2300      	movs	r3, #0
 80021fc:	e01d      	b.n	800223a <lv_event_send_func+0xee>
    }

    if(obj) {
 80021fe:	68bb      	ldr	r3, [r7, #8]
 8002200:	2b00      	cmp	r3, #0
 8002202:	d019      	beq.n	8002238 <lv_event_send_func+0xec>
        if(obj->parent_event && obj->par) {
 8002204:	68bb      	ldr	r3, [r7, #8]
 8002206:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800220a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800220e:	b2db      	uxtb	r3, r3
 8002210:	2b00      	cmp	r3, #0
 8002212:	d011      	beq.n	8002238 <lv_event_send_func+0xec>
 8002214:	68bb      	ldr	r3, [r7, #8]
 8002216:	681b      	ldr	r3, [r3, #0]
 8002218:	2b00      	cmp	r3, #0
 800221a:	d00d      	beq.n	8002238 <lv_event_send_func+0xec>
            lv_res_t res = lv_event_send(obj->par, event, data);
 800221c:	68bb      	ldr	r3, [r7, #8]
 800221e:	681b      	ldr	r3, [r3, #0]
 8002220:	79f9      	ldrb	r1, [r7, #7]
 8002222:	683a      	ldr	r2, [r7, #0]
 8002224:	4618      	mov	r0, r3
 8002226:	f7ff ff63 	bl	80020f0 <lv_event_send>
 800222a:	4603      	mov	r3, r0
 800222c:	77fb      	strb	r3, [r7, #31]
            if(res != LV_RES_OK) {
 800222e:	7ffb      	ldrb	r3, [r7, #31]
 8002230:	2b01      	cmp	r3, #1
 8002232:	d001      	beq.n	8002238 <lv_event_send_func+0xec>
                return LV_RES_INV;
 8002234:	2300      	movs	r3, #0
 8002236:	e000      	b.n	800223a <lv_event_send_func+0xee>
            }
        }
    }

    return LV_RES_OK;
 8002238:	2301      	movs	r3, #1
}
 800223a:	4618      	mov	r0, r3
 800223c:	372c      	adds	r7, #44	; 0x2c
 800223e:	46bd      	mov	sp, r7
 8002240:	bd90      	pop	{r4, r7, pc}
 8002242:	bf00      	nop
 8002244:	080137b8 	.word	0x080137b8
 8002248:	20000098 	.word	0x20000098
 800224c:	2000009c 	.word	0x2000009c

08002250 <lv_obj_set_signal_cb>:
 * Always call the previous signal function in the new.
 * @param obj pointer to an object
 * @param cb the new signal function
 */
void lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb)
{
 8002250:	b590      	push	{r4, r7, lr}
 8002252:	b083      	sub	sp, #12
 8002254:	af00      	add	r7, sp, #0
 8002256:	6078      	str	r0, [r7, #4]
 8002258:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800225a:	6878      	ldr	r0, [r7, #4]
 800225c:	f7fd ffcc 	bl	80001f8 <lv_debug_check_null>
 8002260:	4603      	mov	r3, r0
 8002262:	f083 0301 	eor.w	r3, r3, #1
 8002266:	b2db      	uxtb	r3, r3
 8002268:	2b00      	cmp	r3, #0
 800226a:	d008      	beq.n	800227e <lv_obj_set_signal_cb+0x2e>
 800226c:	687b      	ldr	r3, [r7, #4]
 800226e:	f04f 0400 	mov.w	r4, #0
 8002272:	461a      	mov	r2, r3
 8002274:	4623      	mov	r3, r4
 8002276:	4805      	ldr	r0, [pc, #20]	; (800228c <lv_obj_set_signal_cb+0x3c>)
 8002278:	f7fd ffe8 	bl	800024c <lv_debug_log_error>
 800227c:	e7fe      	b.n	800227c <lv_obj_set_signal_cb+0x2c>

    obj->signal_cb = signal_cb;
 800227e:	687b      	ldr	r3, [r7, #4]
 8002280:	683a      	ldr	r2, [r7, #0]
 8002282:	61da      	str	r2, [r3, #28]
}
 8002284:	bf00      	nop
 8002286:	370c      	adds	r7, #12
 8002288:	46bd      	mov	sp, r7
 800228a:	bd90      	pop	{r4, r7, pc}
 800228c:	080137b8 	.word	0x080137b8

08002290 <lv_obj_set_design_cb>:
 * Set a new design function for an object
 * @param obj pointer to an object
 * @param design_cb the new design function
 */
void lv_obj_set_design_cb(lv_obj_t * obj, lv_design_cb_t design_cb)
{
 8002290:	b590      	push	{r4, r7, lr}
 8002292:	b083      	sub	sp, #12
 8002294:	af00      	add	r7, sp, #0
 8002296:	6078      	str	r0, [r7, #4]
 8002298:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800229a:	6878      	ldr	r0, [r7, #4]
 800229c:	f7fd ffac 	bl	80001f8 <lv_debug_check_null>
 80022a0:	4603      	mov	r3, r0
 80022a2:	f083 0301 	eor.w	r3, r3, #1
 80022a6:	b2db      	uxtb	r3, r3
 80022a8:	2b00      	cmp	r3, #0
 80022aa:	d008      	beq.n	80022be <lv_obj_set_design_cb+0x2e>
 80022ac:	687b      	ldr	r3, [r7, #4]
 80022ae:	f04f 0400 	mov.w	r4, #0
 80022b2:	461a      	mov	r2, r3
 80022b4:	4623      	mov	r3, r4
 80022b6:	4805      	ldr	r0, [pc, #20]	; (80022cc <lv_obj_set_design_cb+0x3c>)
 80022b8:	f7fd ffc8 	bl	800024c <lv_debug_log_error>
 80022bc:	e7fe      	b.n	80022bc <lv_obj_set_design_cb+0x2c>

    obj->design_cb = design_cb;
 80022be:	687b      	ldr	r3, [r7, #4]
 80022c0:	683a      	ldr	r2, [r7, #0]
 80022c2:	621a      	str	r2, [r3, #32]
}
 80022c4:	bf00      	nop
 80022c6:	370c      	adds	r7, #12
 80022c8:	46bd      	mov	sp, r7
 80022ca:	bd90      	pop	{r4, r7, pc}
 80022cc:	080137b8 	.word	0x080137b8

080022d0 <lv_obj_allocate_ext_attr>:
 * @param obj pointer to an object
 * @param ext_size the size of the new ext. data
 * @return Normal pointer to the allocated ext
 */
void * lv_obj_allocate_ext_attr(lv_obj_t * obj, uint16_t ext_size)
{
 80022d0:	b590      	push	{r4, r7, lr}
 80022d2:	b083      	sub	sp, #12
 80022d4:	af00      	add	r7, sp, #0
 80022d6:	6078      	str	r0, [r7, #4]
 80022d8:	460b      	mov	r3, r1
 80022da:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80022dc:	6878      	ldr	r0, [r7, #4]
 80022de:	f7fd ff8b 	bl	80001f8 <lv_debug_check_null>
 80022e2:	4603      	mov	r3, r0
 80022e4:	f083 0301 	eor.w	r3, r3, #1
 80022e8:	b2db      	uxtb	r3, r3
 80022ea:	2b00      	cmp	r3, #0
 80022ec:	d008      	beq.n	8002300 <lv_obj_allocate_ext_attr+0x30>
 80022ee:	687b      	ldr	r3, [r7, #4]
 80022f0:	f04f 0400 	mov.w	r4, #0
 80022f4:	461a      	mov	r2, r3
 80022f6:	4623      	mov	r3, r4
 80022f8:	4809      	ldr	r0, [pc, #36]	; (8002320 <lv_obj_allocate_ext_attr+0x50>)
 80022fa:	f7fd ffa7 	bl	800024c <lv_debug_log_error>
 80022fe:	e7fe      	b.n	80022fe <lv_obj_allocate_ext_attr+0x2e>

    obj->ext_attr = lv_mem_realloc(obj->ext_attr, ext_size);
 8002300:	687b      	ldr	r3, [r7, #4]
 8002302:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002304:	887a      	ldrh	r2, [r7, #2]
 8002306:	4611      	mov	r1, r2
 8002308:	4618      	mov	r0, r3
 800230a:	f00a fcf5 	bl	800ccf8 <lv_mem_realloc>
 800230e:	4602      	mov	r2, r0
 8002310:	687b      	ldr	r3, [r7, #4]
 8002312:	625a      	str	r2, [r3, #36]	; 0x24

    return (void *)obj->ext_attr;
 8002314:	687b      	ldr	r3, [r7, #4]
 8002316:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8002318:	4618      	mov	r0, r3
 800231a:	370c      	adds	r7, #12
 800231c:	46bd      	mov	sp, r7
 800231e:	bd90      	pop	{r4, r7, pc}
 8002320:	080137b8 	.word	0x080137b8

08002324 <lv_obj_refresh_ext_draw_pad>:
/**
 * Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object
 * @param obj pointer to an object
 */
void lv_obj_refresh_ext_draw_pad(lv_obj_t * obj)
{
 8002324:	b590      	push	{r4, r7, lr}
 8002326:	b083      	sub	sp, #12
 8002328:	af00      	add	r7, sp, #0
 800232a:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800232c:	6878      	ldr	r0, [r7, #4]
 800232e:	f7fd ff63 	bl	80001f8 <lv_debug_check_null>
 8002332:	4603      	mov	r3, r0
 8002334:	f083 0301 	eor.w	r3, r3, #1
 8002338:	b2db      	uxtb	r3, r3
 800233a:	2b00      	cmp	r3, #0
 800233c:	d008      	beq.n	8002350 <lv_obj_refresh_ext_draw_pad+0x2c>
 800233e:	687b      	ldr	r3, [r7, #4]
 8002340:	f04f 0400 	mov.w	r4, #0
 8002344:	461a      	mov	r2, r3
 8002346:	4623      	mov	r3, r4
 8002348:	4809      	ldr	r0, [pc, #36]	; (8002370 <lv_obj_refresh_ext_draw_pad+0x4c>)
 800234a:	f7fd ff7f 	bl	800024c <lv_debug_log_error>
 800234e:	e7fe      	b.n	800234e <lv_obj_refresh_ext_draw_pad+0x2a>

    obj->ext_draw_pad = 0;
 8002350:	687b      	ldr	r3, [r7, #4]
 8002352:	2200      	movs	r2, #0
 8002354:	869a      	strh	r2, [r3, #52]	; 0x34
    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
 8002356:	687b      	ldr	r3, [r7, #4]
 8002358:	69db      	ldr	r3, [r3, #28]
 800235a:	2200      	movs	r2, #0
 800235c:	2106      	movs	r1, #6
 800235e:	6878      	ldr	r0, [r7, #4]
 8002360:	4798      	blx	r3

    lv_obj_invalidate(obj);
 8002362:	6878      	ldr	r0, [r7, #4]
 8002364:	f7fe fe9a 	bl	800109c <lv_obj_invalidate>
}
 8002368:	bf00      	nop
 800236a:	370c      	adds	r7, #12
 800236c:	46bd      	mov	sp, r7
 800236e:	bd90      	pop	{r4, r7, pc}
 8002370:	080137b8 	.word	0x080137b8

08002374 <lv_obj_get_screen>:
 * Return with the screen of an object
 * @param obj pointer to an object
 * @return pointer to a screen
 */
lv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)
{
 8002374:	b590      	push	{r4, r7, lr}
 8002376:	b085      	sub	sp, #20
 8002378:	af00      	add	r7, sp, #0
 800237a:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800237c:	6878      	ldr	r0, [r7, #4]
 800237e:	f7fd ff3b 	bl	80001f8 <lv_debug_check_null>
 8002382:	4603      	mov	r3, r0
 8002384:	f083 0301 	eor.w	r3, r3, #1
 8002388:	b2db      	uxtb	r3, r3
 800238a:	2b00      	cmp	r3, #0
 800238c:	d008      	beq.n	80023a0 <lv_obj_get_screen+0x2c>
 800238e:	687b      	ldr	r3, [r7, #4]
 8002390:	f04f 0400 	mov.w	r4, #0
 8002394:	461a      	mov	r2, r3
 8002396:	4623      	mov	r3, r4
 8002398:	4809      	ldr	r0, [pc, #36]	; (80023c0 <lv_obj_get_screen+0x4c>)
 800239a:	f7fd ff57 	bl	800024c <lv_debug_log_error>
 800239e:	e7fe      	b.n	800239e <lv_obj_get_screen+0x2a>

    const lv_obj_t * par = obj;
 80023a0:	687b      	ldr	r3, [r7, #4]
 80023a2:	60fb      	str	r3, [r7, #12]
    const lv_obj_t * act_p;

    do {
        act_p = par;
 80023a4:	68fb      	ldr	r3, [r7, #12]
 80023a6:	60bb      	str	r3, [r7, #8]
        par   = lv_obj_get_parent(act_p);
 80023a8:	68b8      	ldr	r0, [r7, #8]
 80023aa:	f000 f859 	bl	8002460 <lv_obj_get_parent>
 80023ae:	60f8      	str	r0, [r7, #12]
    } while(par != NULL);
 80023b0:	68fb      	ldr	r3, [r7, #12]
 80023b2:	2b00      	cmp	r3, #0
 80023b4:	d1f6      	bne.n	80023a4 <lv_obj_get_screen+0x30>

    return (lv_obj_t *)act_p;
 80023b6:	68bb      	ldr	r3, [r7, #8]
}
 80023b8:	4618      	mov	r0, r3
 80023ba:	3714      	adds	r7, #20
 80023bc:	46bd      	mov	sp, r7
 80023be:	bd90      	pop	{r4, r7, pc}
 80023c0:	080137b8 	.word	0x080137b8

080023c4 <lv_obj_get_disp>:
 * Get the display of an object
 * @param scr pointer to an object
 * @return pointer the object's display
 */
lv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)
{
 80023c4:	b590      	push	{r4, r7, lr}
 80023c6:	b087      	sub	sp, #28
 80023c8:	af00      	add	r7, sp, #0
 80023ca:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80023cc:	6878      	ldr	r0, [r7, #4]
 80023ce:	f7fd ff13 	bl	80001f8 <lv_debug_check_null>
 80023d2:	4603      	mov	r3, r0
 80023d4:	f083 0301 	eor.w	r3, r3, #1
 80023d8:	b2db      	uxtb	r3, r3
 80023da:	2b00      	cmp	r3, #0
 80023dc:	d008      	beq.n	80023f0 <lv_obj_get_disp+0x2c>
 80023de:	687b      	ldr	r3, [r7, #4]
 80023e0:	f04f 0400 	mov.w	r4, #0
 80023e4:	461a      	mov	r2, r3
 80023e6:	4623      	mov	r3, r4
 80023e8:	481b      	ldr	r0, [pc, #108]	; (8002458 <lv_obj_get_disp+0x94>)
 80023ea:	f7fd ff2f 	bl	800024c <lv_debug_log_error>
 80023ee:	e7fe      	b.n	80023ee <lv_obj_get_disp+0x2a>

    const lv_obj_t * scr;

    if(obj->par == NULL)
 80023f0:	687b      	ldr	r3, [r7, #4]
 80023f2:	681b      	ldr	r3, [r3, #0]
 80023f4:	2b00      	cmp	r3, #0
 80023f6:	d102      	bne.n	80023fe <lv_obj_get_disp+0x3a>
        scr = obj; /*`obj` is a screen*/
 80023f8:	687b      	ldr	r3, [r7, #4]
 80023fa:	617b      	str	r3, [r7, #20]
 80023fc:	e003      	b.n	8002406 <lv_obj_get_disp+0x42>
    else
        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/
 80023fe:	6878      	ldr	r0, [r7, #4]
 8002400:	f7ff ffb8 	bl	8002374 <lv_obj_get_screen>
 8002404:	6178      	str	r0, [r7, #20]

    lv_disp_t * d;
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
 8002406:	4815      	ldr	r0, [pc, #84]	; (800245c <lv_obj_get_disp+0x98>)
 8002408:	f00a fad8 	bl	800c9bc <lv_ll_get_head>
 800240c:	6138      	str	r0, [r7, #16]
 800240e:	e01b      	b.n	8002448 <lv_obj_get_disp+0x84>
    {
        lv_obj_t * s;
        LV_LL_READ(d->scr_ll, s)
 8002410:	693b      	ldr	r3, [r7, #16]
 8002412:	332c      	adds	r3, #44	; 0x2c
 8002414:	4618      	mov	r0, r3
 8002416:	f00a fad1 	bl	800c9bc <lv_ll_get_head>
 800241a:	60f8      	str	r0, [r7, #12]
 800241c:	e00c      	b.n	8002438 <lv_obj_get_disp+0x74>
        {
            if(s == scr) return d;
 800241e:	68fa      	ldr	r2, [r7, #12]
 8002420:	697b      	ldr	r3, [r7, #20]
 8002422:	429a      	cmp	r2, r3
 8002424:	d101      	bne.n	800242a <lv_obj_get_disp+0x66>
 8002426:	693b      	ldr	r3, [r7, #16]
 8002428:	e012      	b.n	8002450 <lv_obj_get_disp+0x8c>
        LV_LL_READ(d->scr_ll, s)
 800242a:	693b      	ldr	r3, [r7, #16]
 800242c:	332c      	adds	r3, #44	; 0x2c
 800242e:	68f9      	ldr	r1, [r7, #12]
 8002430:	4618      	mov	r0, r3
 8002432:	f00a fae9 	bl	800ca08 <lv_ll_get_next>
 8002436:	60f8      	str	r0, [r7, #12]
 8002438:	68fb      	ldr	r3, [r7, #12]
 800243a:	2b00      	cmp	r3, #0
 800243c:	d1ef      	bne.n	800241e <lv_obj_get_disp+0x5a>
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
 800243e:	6939      	ldr	r1, [r7, #16]
 8002440:	4806      	ldr	r0, [pc, #24]	; (800245c <lv_obj_get_disp+0x98>)
 8002442:	f00a fae1 	bl	800ca08 <lv_ll_get_next>
 8002446:	6138      	str	r0, [r7, #16]
 8002448:	693b      	ldr	r3, [r7, #16]
 800244a:	2b00      	cmp	r3, #0
 800244c:	d1e0      	bne.n	8002410 <lv_obj_get_disp+0x4c>
        }
    }

    LV_LOG_WARN("lv_scr_get_disp: screen not found")
    return NULL;
 800244e:	2300      	movs	r3, #0
}
 8002450:	4618      	mov	r0, r3
 8002452:	371c      	adds	r7, #28
 8002454:	46bd      	mov	sp, r7
 8002456:	bd90      	pop	{r4, r7, pc}
 8002458:	080137b8 	.word	0x080137b8
 800245c:	2000995c 	.word	0x2000995c

08002460 <lv_obj_get_parent>:
 * Returns with the parent of an object
 * @param obj pointer to an object
 * @return pointer to the parent of  'obj'
 */
lv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)
{
 8002460:	b590      	push	{r4, r7, lr}
 8002462:	b083      	sub	sp, #12
 8002464:	af00      	add	r7, sp, #0
 8002466:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002468:	6878      	ldr	r0, [r7, #4]
 800246a:	f7fd fec5 	bl	80001f8 <lv_debug_check_null>
 800246e:	4603      	mov	r3, r0
 8002470:	f083 0301 	eor.w	r3, r3, #1
 8002474:	b2db      	uxtb	r3, r3
 8002476:	2b00      	cmp	r3, #0
 8002478:	d008      	beq.n	800248c <lv_obj_get_parent+0x2c>
 800247a:	687b      	ldr	r3, [r7, #4]
 800247c:	f04f 0400 	mov.w	r4, #0
 8002480:	461a      	mov	r2, r3
 8002482:	4623      	mov	r3, r4
 8002484:	4804      	ldr	r0, [pc, #16]	; (8002498 <lv_obj_get_parent+0x38>)
 8002486:	f7fd fee1 	bl	800024c <lv_debug_log_error>
 800248a:	e7fe      	b.n	800248a <lv_obj_get_parent+0x2a>

    return obj->par;
 800248c:	687b      	ldr	r3, [r7, #4]
 800248e:	681b      	ldr	r3, [r3, #0]
}
 8002490:	4618      	mov	r0, r3
 8002492:	370c      	adds	r7, #12
 8002494:	46bd      	mov	sp, r7
 8002496:	bd90      	pop	{r4, r7, pc}
 8002498:	080137b8 	.word	0x080137b8

0800249c <lv_obj_get_child>:
 * @param child NULL at first call to get the next children
 *                  and the previous return value later
 * @return the child after 'act_child' or NULL if no more child
 */
lv_obj_t * lv_obj_get_child(const lv_obj_t * obj, const lv_obj_t * child)
{
 800249c:	b590      	push	{r4, r7, lr}
 800249e:	b085      	sub	sp, #20
 80024a0:	af00      	add	r7, sp, #0
 80024a2:	6078      	str	r0, [r7, #4]
 80024a4:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80024a6:	6878      	ldr	r0, [r7, #4]
 80024a8:	f7fd fea6 	bl	80001f8 <lv_debug_check_null>
 80024ac:	4603      	mov	r3, r0
 80024ae:	f083 0301 	eor.w	r3, r3, #1
 80024b2:	b2db      	uxtb	r3, r3
 80024b4:	2b00      	cmp	r3, #0
 80024b6:	d008      	beq.n	80024ca <lv_obj_get_child+0x2e>
 80024b8:	687b      	ldr	r3, [r7, #4]
 80024ba:	f04f 0400 	mov.w	r4, #0
 80024be:	461a      	mov	r2, r3
 80024c0:	4623      	mov	r3, r4
 80024c2:	480e      	ldr	r0, [pc, #56]	; (80024fc <lv_obj_get_child+0x60>)
 80024c4:	f7fd fec2 	bl	800024c <lv_debug_log_error>
 80024c8:	e7fe      	b.n	80024c8 <lv_obj_get_child+0x2c>

    lv_obj_t * result = NULL;
 80024ca:	2300      	movs	r3, #0
 80024cc:	60fb      	str	r3, [r7, #12]

    if(child == NULL) {
 80024ce:	683b      	ldr	r3, [r7, #0]
 80024d0:	2b00      	cmp	r3, #0
 80024d2:	d106      	bne.n	80024e2 <lv_obj_get_child+0x46>
        result = lv_ll_get_head(&obj->child_ll);
 80024d4:	687b      	ldr	r3, [r7, #4]
 80024d6:	3304      	adds	r3, #4
 80024d8:	4618      	mov	r0, r3
 80024da:	f00a fa6f 	bl	800c9bc <lv_ll_get_head>
 80024de:	60f8      	str	r0, [r7, #12]
 80024e0:	e006      	b.n	80024f0 <lv_obj_get_child+0x54>
    } else {
        result = lv_ll_get_next(&obj->child_ll, child);
 80024e2:	687b      	ldr	r3, [r7, #4]
 80024e4:	3304      	adds	r3, #4
 80024e6:	6839      	ldr	r1, [r7, #0]
 80024e8:	4618      	mov	r0, r3
 80024ea:	f00a fa8d 	bl	800ca08 <lv_ll_get_next>
 80024ee:	60f8      	str	r0, [r7, #12]
    }

    return result;
 80024f0:	68fb      	ldr	r3, [r7, #12]
}
 80024f2:	4618      	mov	r0, r3
 80024f4:	3714      	adds	r7, #20
 80024f6:	46bd      	mov	sp, r7
 80024f8:	bd90      	pop	{r4, r7, pc}
 80024fa:	bf00      	nop
 80024fc:	080137b8 	.word	0x080137b8

08002500 <lv_obj_get_coords>:
 * Copy the coordinates of an object to an area
 * @param obj pointer to an object
 * @param cords_p pointer to an area to store the coordinates
 */
void lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p)
{
 8002500:	b590      	push	{r4, r7, lr}
 8002502:	b083      	sub	sp, #12
 8002504:	af00      	add	r7, sp, #0
 8002506:	6078      	str	r0, [r7, #4]
 8002508:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800250a:	6878      	ldr	r0, [r7, #4]
 800250c:	f7fd fe74 	bl	80001f8 <lv_debug_check_null>
 8002510:	4603      	mov	r3, r0
 8002512:	f083 0301 	eor.w	r3, r3, #1
 8002516:	b2db      	uxtb	r3, r3
 8002518:	2b00      	cmp	r3, #0
 800251a:	d008      	beq.n	800252e <lv_obj_get_coords+0x2e>
 800251c:	687b      	ldr	r3, [r7, #4]
 800251e:	f04f 0400 	mov.w	r4, #0
 8002522:	461a      	mov	r2, r3
 8002524:	4623      	mov	r3, r4
 8002526:	4807      	ldr	r0, [pc, #28]	; (8002544 <lv_obj_get_coords+0x44>)
 8002528:	f7fd fe90 	bl	800024c <lv_debug_log_error>
 800252c:	e7fe      	b.n	800252c <lv_obj_get_coords+0x2c>

    lv_area_copy(cords_p, &obj->coords);
 800252e:	687b      	ldr	r3, [r7, #4]
 8002530:	3310      	adds	r3, #16
 8002532:	4619      	mov	r1, r3
 8002534:	6838      	ldr	r0, [r7, #0]
 8002536:	f7fe f9b1 	bl	800089c <lv_area_copy>
}
 800253a:	bf00      	nop
 800253c:	370c      	adds	r7, #12
 800253e:	46bd      	mov	sp, r7
 8002540:	bd90      	pop	{r4, r7, pc}
 8002542:	bf00      	nop
 8002544:	080137b8 	.word	0x080137b8

08002548 <lv_obj_get_x>:
 * Get the x coordinate of object
 * @param obj pointer to an object
 * @return distance of 'obj' from the left side of its parent
 */
lv_coord_t lv_obj_get_x(const lv_obj_t * obj)
{
 8002548:	b590      	push	{r4, r7, lr}
 800254a:	b085      	sub	sp, #20
 800254c:	af00      	add	r7, sp, #0
 800254e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002550:	6878      	ldr	r0, [r7, #4]
 8002552:	f7fd fe51 	bl	80001f8 <lv_debug_check_null>
 8002556:	4603      	mov	r3, r0
 8002558:	f083 0301 	eor.w	r3, r3, #1
 800255c:	b2db      	uxtb	r3, r3
 800255e:	2b00      	cmp	r3, #0
 8002560:	d008      	beq.n	8002574 <lv_obj_get_x+0x2c>
 8002562:	687b      	ldr	r3, [r7, #4]
 8002564:	f04f 0400 	mov.w	r4, #0
 8002568:	461a      	mov	r2, r3
 800256a:	4623      	mov	r3, r4
 800256c:	480f      	ldr	r0, [pc, #60]	; (80025ac <lv_obj_get_x+0x64>)
 800256e:	f7fd fe6d 	bl	800024c <lv_debug_log_error>
 8002572:	e7fe      	b.n	8002572 <lv_obj_get_x+0x2a>

    lv_coord_t rel_x;
    lv_obj_t * parent = lv_obj_get_parent(obj);
 8002574:	6878      	ldr	r0, [r7, #4]
 8002576:	f7ff ff73 	bl	8002460 <lv_obj_get_parent>
 800257a:	60b8      	str	r0, [r7, #8]
    if(parent) {
 800257c:	68bb      	ldr	r3, [r7, #8]
 800257e:	2b00      	cmp	r3, #0
 8002580:	d00b      	beq.n	800259a <lv_obj_get_x+0x52>
        rel_x             = obj->coords.x1 - parent->coords.x1;
 8002582:	687b      	ldr	r3, [r7, #4]
 8002584:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8002588:	b29a      	uxth	r2, r3
 800258a:	68bb      	ldr	r3, [r7, #8]
 800258c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8002590:	b29b      	uxth	r3, r3
 8002592:	1ad3      	subs	r3, r2, r3
 8002594:	b29b      	uxth	r3, r3
 8002596:	81fb      	strh	r3, [r7, #14]
 8002598:	e002      	b.n	80025a0 <lv_obj_get_x+0x58>
    } else {
        rel_x = obj->coords.x1;
 800259a:	687b      	ldr	r3, [r7, #4]
 800259c:	8a1b      	ldrh	r3, [r3, #16]
 800259e:	81fb      	strh	r3, [r7, #14]
    }
    return rel_x;
 80025a0:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
 80025a4:	4618      	mov	r0, r3
 80025a6:	3714      	adds	r7, #20
 80025a8:	46bd      	mov	sp, r7
 80025aa:	bd90      	pop	{r4, r7, pc}
 80025ac:	080137b8 	.word	0x080137b8

080025b0 <lv_obj_get_y>:
 * Get the y coordinate of object
 * @param obj pointer to an object
 * @return distance of 'obj' from the top of its parent
 */
lv_coord_t lv_obj_get_y(const lv_obj_t * obj)
{
 80025b0:	b590      	push	{r4, r7, lr}
 80025b2:	b085      	sub	sp, #20
 80025b4:	af00      	add	r7, sp, #0
 80025b6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80025b8:	6878      	ldr	r0, [r7, #4]
 80025ba:	f7fd fe1d 	bl	80001f8 <lv_debug_check_null>
 80025be:	4603      	mov	r3, r0
 80025c0:	f083 0301 	eor.w	r3, r3, #1
 80025c4:	b2db      	uxtb	r3, r3
 80025c6:	2b00      	cmp	r3, #0
 80025c8:	d008      	beq.n	80025dc <lv_obj_get_y+0x2c>
 80025ca:	687b      	ldr	r3, [r7, #4]
 80025cc:	f04f 0400 	mov.w	r4, #0
 80025d0:	461a      	mov	r2, r3
 80025d2:	4623      	mov	r3, r4
 80025d4:	480f      	ldr	r0, [pc, #60]	; (8002614 <lv_obj_get_y+0x64>)
 80025d6:	f7fd fe39 	bl	800024c <lv_debug_log_error>
 80025da:	e7fe      	b.n	80025da <lv_obj_get_y+0x2a>

    lv_coord_t rel_y;
    lv_obj_t * parent = lv_obj_get_parent(obj);
 80025dc:	6878      	ldr	r0, [r7, #4]
 80025de:	f7ff ff3f 	bl	8002460 <lv_obj_get_parent>
 80025e2:	60b8      	str	r0, [r7, #8]
   if(parent) {
 80025e4:	68bb      	ldr	r3, [r7, #8]
 80025e6:	2b00      	cmp	r3, #0
 80025e8:	d00b      	beq.n	8002602 <lv_obj_get_y+0x52>
       rel_y             = obj->coords.y1 - parent->coords.y1;
 80025ea:	687b      	ldr	r3, [r7, #4]
 80025ec:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80025f0:	b29a      	uxth	r2, r3
 80025f2:	68bb      	ldr	r3, [r7, #8]
 80025f4:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80025f8:	b29b      	uxth	r3, r3
 80025fa:	1ad3      	subs	r3, r2, r3
 80025fc:	b29b      	uxth	r3, r3
 80025fe:	81fb      	strh	r3, [r7, #14]
 8002600:	e002      	b.n	8002608 <lv_obj_get_y+0x58>
   } else {
       rel_y = obj->coords.y1;
 8002602:	687b      	ldr	r3, [r7, #4]
 8002604:	8a5b      	ldrh	r3, [r3, #18]
 8002606:	81fb      	strh	r3, [r7, #14]
   }
    return rel_y;
 8002608:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
 800260c:	4618      	mov	r0, r3
 800260e:	3714      	adds	r7, #20
 8002610:	46bd      	mov	sp, r7
 8002612:	bd90      	pop	{r4, r7, pc}
 8002614:	080137b8 	.word	0x080137b8

08002618 <lv_obj_get_width>:
 * Get the width of an object
 * @param obj pointer to an object
 * @return the width
 */
lv_coord_t lv_obj_get_width(const lv_obj_t * obj)
{
 8002618:	b590      	push	{r4, r7, lr}
 800261a:	b083      	sub	sp, #12
 800261c:	af00      	add	r7, sp, #0
 800261e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002620:	6878      	ldr	r0, [r7, #4]
 8002622:	f7fd fde9 	bl	80001f8 <lv_debug_check_null>
 8002626:	4603      	mov	r3, r0
 8002628:	f083 0301 	eor.w	r3, r3, #1
 800262c:	b2db      	uxtb	r3, r3
 800262e:	2b00      	cmp	r3, #0
 8002630:	d008      	beq.n	8002644 <lv_obj_get_width+0x2c>
 8002632:	687b      	ldr	r3, [r7, #4]
 8002634:	f04f 0400 	mov.w	r4, #0
 8002638:	461a      	mov	r2, r3
 800263a:	4623      	mov	r3, r4
 800263c:	4806      	ldr	r0, [pc, #24]	; (8002658 <lv_obj_get_width+0x40>)
 800263e:	f7fd fe05 	bl	800024c <lv_debug_log_error>
 8002642:	e7fe      	b.n	8002642 <lv_obj_get_width+0x2a>

    return lv_area_get_width(&obj->coords);
 8002644:	687b      	ldr	r3, [r7, #4]
 8002646:	3310      	adds	r3, #16
 8002648:	4618      	mov	r0, r3
 800264a:	f7fe f935 	bl	80008b8 <lv_area_get_width>
 800264e:	4603      	mov	r3, r0
}
 8002650:	4618      	mov	r0, r3
 8002652:	370c      	adds	r7, #12
 8002654:	46bd      	mov	sp, r7
 8002656:	bd90      	pop	{r4, r7, pc}
 8002658:	080137b8 	.word	0x080137b8

0800265c <lv_obj_get_height>:
 * Get the height of an object
 * @param obj pointer to an object
 * @return the height
 */
lv_coord_t lv_obj_get_height(const lv_obj_t * obj)
{
 800265c:	b590      	push	{r4, r7, lr}
 800265e:	b083      	sub	sp, #12
 8002660:	af00      	add	r7, sp, #0
 8002662:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002664:	6878      	ldr	r0, [r7, #4]
 8002666:	f7fd fdc7 	bl	80001f8 <lv_debug_check_null>
 800266a:	4603      	mov	r3, r0
 800266c:	f083 0301 	eor.w	r3, r3, #1
 8002670:	b2db      	uxtb	r3, r3
 8002672:	2b00      	cmp	r3, #0
 8002674:	d008      	beq.n	8002688 <lv_obj_get_height+0x2c>
 8002676:	687b      	ldr	r3, [r7, #4]
 8002678:	f04f 0400 	mov.w	r4, #0
 800267c:	461a      	mov	r2, r3
 800267e:	4623      	mov	r3, r4
 8002680:	4806      	ldr	r0, [pc, #24]	; (800269c <lv_obj_get_height+0x40>)
 8002682:	f7fd fde3 	bl	800024c <lv_debug_log_error>
 8002686:	e7fe      	b.n	8002686 <lv_obj_get_height+0x2a>

    return lv_area_get_height(&obj->coords);
 8002688:	687b      	ldr	r3, [r7, #4]
 800268a:	3310      	adds	r3, #16
 800268c:	4618      	mov	r0, r3
 800268e:	f7fe f92a 	bl	80008e6 <lv_area_get_height>
 8002692:	4603      	mov	r3, r0
}
 8002694:	4618      	mov	r0, r3
 8002696:	370c      	adds	r7, #12
 8002698:	46bd      	mov	sp, r7
 800269a:	bd90      	pop	{r4, r7, pc}
 800269c:	080137b8 	.word	0x080137b8

080026a0 <lv_obj_get_width_fit>:
 * Get that width reduced by the left and right padding.
 * @param obj pointer to an object
 * @return the width which still fits into the container
 */
lv_coord_t lv_obj_get_width_fit(const lv_obj_t * obj)
{
 80026a0:	b590      	push	{r4, r7, lr}
 80026a2:	b085      	sub	sp, #20
 80026a4:	af00      	add	r7, sp, #0
 80026a6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80026a8:	6878      	ldr	r0, [r7, #4]
 80026aa:	f7fd fda5 	bl	80001f8 <lv_debug_check_null>
 80026ae:	4603      	mov	r3, r0
 80026b0:	f083 0301 	eor.w	r3, r3, #1
 80026b4:	b2db      	uxtb	r3, r3
 80026b6:	2b00      	cmp	r3, #0
 80026b8:	d008      	beq.n	80026cc <lv_obj_get_width_fit+0x2c>
 80026ba:	687b      	ldr	r3, [r7, #4]
 80026bc:	f04f 0400 	mov.w	r4, #0
 80026c0:	461a      	mov	r2, r3
 80026c2:	4623      	mov	r3, r4
 80026c4:	480e      	ldr	r0, [pc, #56]	; (8002700 <lv_obj_get_width_fit+0x60>)
 80026c6:	f7fd fdc1 	bl	800024c <lv_debug_log_error>
 80026ca:	e7fe      	b.n	80026ca <lv_obj_get_width_fit+0x2a>

    const lv_style_t * style = lv_obj_get_style(obj);
 80026cc:	6878      	ldr	r0, [r7, #4]
 80026ce:	f000 f83f 	bl	8002750 <lv_obj_get_style>
 80026d2:	60f8      	str	r0, [r7, #12]

    return lv_obj_get_width(obj) - style->body.padding.left - style->body.padding.right;
 80026d4:	6878      	ldr	r0, [r7, #4]
 80026d6:	f7ff ff9f 	bl	8002618 <lv_obj_get_width>
 80026da:	4603      	mov	r3, r0
 80026dc:	b29a      	uxth	r2, r3
 80026de:	68fb      	ldr	r3, [r7, #12]
 80026e0:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 80026e4:	b29b      	uxth	r3, r3
 80026e6:	1ad3      	subs	r3, r2, r3
 80026e8:	b29a      	uxth	r2, r3
 80026ea:	68fb      	ldr	r3, [r7, #12]
 80026ec:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 80026f0:	b29b      	uxth	r3, r3
 80026f2:	1ad3      	subs	r3, r2, r3
 80026f4:	b29b      	uxth	r3, r3
 80026f6:	b21b      	sxth	r3, r3
}
 80026f8:	4618      	mov	r0, r3
 80026fa:	3714      	adds	r7, #20
 80026fc:	46bd      	mov	sp, r7
 80026fe:	bd90      	pop	{r4, r7, pc}
 8002700:	080137b8 	.word	0x080137b8

08002704 <lv_obj_get_auto_realign>:
 * Get the automatic realign property of the object.
 * @param obj pointer to an object
 * @return  true: auto realign is enabled; false: auto realign is disabled
 */
bool lv_obj_get_auto_realign(const lv_obj_t * obj)
{
 8002704:	b590      	push	{r4, r7, lr}
 8002706:	b083      	sub	sp, #12
 8002708:	af00      	add	r7, sp, #0
 800270a:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800270c:	6878      	ldr	r0, [r7, #4]
 800270e:	f7fd fd73 	bl	80001f8 <lv_debug_check_null>
 8002712:	4603      	mov	r3, r0
 8002714:	f083 0301 	eor.w	r3, r3, #1
 8002718:	b2db      	uxtb	r3, r3
 800271a:	2b00      	cmp	r3, #0
 800271c:	d008      	beq.n	8002730 <lv_obj_get_auto_realign+0x2c>
 800271e:	687b      	ldr	r3, [r7, #4]
 8002720:	f04f 0400 	mov.w	r4, #0
 8002724:	461a      	mov	r2, r3
 8002726:	4623      	mov	r3, r4
 8002728:	4808      	ldr	r0, [pc, #32]	; (800274c <lv_obj_get_auto_realign+0x48>)
 800272a:	f7fd fd8f 	bl	800024c <lv_debug_log_error>
 800272e:	e7fe      	b.n	800272e <lv_obj_get_auto_realign+0x2a>

#if LV_USE_OBJ_REALIGN
    return obj->realign.auto_realign ? true : false;
 8002730:	687b      	ldr	r3, [r7, #4]
 8002732:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8002736:	f003 0301 	and.w	r3, r3, #1
 800273a:	2b00      	cmp	r3, #0
 800273c:	bf14      	ite	ne
 800273e:	2301      	movne	r3, #1
 8002740:	2300      	moveq	r3, #0
 8002742:	b2db      	uxtb	r3, r3
#else
    (void)obj;
    return false;
#endif
}
 8002744:	4618      	mov	r0, r3
 8002746:	370c      	adds	r7, #12
 8002748:	46bd      	mov	sp, r7
 800274a:	bd90      	pop	{r4, r7, pc}
 800274c:	080137b8 	.word	0x080137b8

08002750 <lv_obj_get_style>:
 * Get the style pointer of an object (if NULL get style of the parent)
 * @param obj pointer to an object
 * @return pointer to a style
 */
const lv_style_t * lv_obj_get_style(const lv_obj_t * obj)
{
 8002750:	b590      	push	{r4, r7, lr}
 8002752:	b087      	sub	sp, #28
 8002754:	af00      	add	r7, sp, #0
 8002756:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002758:	6878      	ldr	r0, [r7, #4]
 800275a:	f7fd fd4d 	bl	80001f8 <lv_debug_check_null>
 800275e:	4603      	mov	r3, r0
 8002760:	f083 0301 	eor.w	r3, r3, #1
 8002764:	b2db      	uxtb	r3, r3
 8002766:	2b00      	cmp	r3, #0
 8002768:	d008      	beq.n	800277c <lv_obj_get_style+0x2c>
 800276a:	687b      	ldr	r3, [r7, #4]
 800276c:	f04f 0400 	mov.w	r4, #0
 8002770:	461a      	mov	r2, r3
 8002772:	4623      	mov	r3, r4
 8002774:	482a      	ldr	r0, [pc, #168]	; (8002820 <lv_obj_get_style+0xd0>)
 8002776:	f7fd fd69 	bl	800024c <lv_debug_log_error>
 800277a:	e7fe      	b.n	800277a <lv_obj_get_style+0x2a>

    const lv_style_t * style_act = obj->style_p;
 800277c:	687b      	ldr	r3, [r7, #4]
 800277e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002780:	617b      	str	r3, [r7, #20]
    if(style_act == NULL) {
 8002782:	697b      	ldr	r3, [r7, #20]
 8002784:	2b00      	cmp	r3, #0
 8002786:	d12c      	bne.n	80027e2 <lv_obj_get_style+0x92>
        lv_obj_t * par = obj->par;
 8002788:	687b      	ldr	r3, [r7, #4]
 800278a:	681b      	ldr	r3, [r3, #0]
 800278c:	613b      	str	r3, [r7, #16]

        while(par) {
 800278e:	e025      	b.n	80027dc <lv_obj_get_style+0x8c>
            if(par->style_p) {
 8002790:	693b      	ldr	r3, [r7, #16]
 8002792:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002794:	2b00      	cmp	r3, #0
 8002796:	d01e      	beq.n	80027d6 <lv_obj_get_style+0x86>
                if(par->style_p->glass == 0) {
 8002798:	693b      	ldr	r3, [r7, #16]
 800279a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800279c:	781b      	ldrb	r3, [r3, #0]
 800279e:	f003 0301 	and.w	r3, r3, #1
 80027a2:	b2db      	uxtb	r3, r3
 80027a4:	2b00      	cmp	r3, #0
 80027a6:	d116      	bne.n	80027d6 <lv_obj_get_style+0x86>
#if LV_USE_GROUP == 0
                    style_act = par->style_p;
#else
                    /*If a parent is focused then use then focused style*/
                    lv_group_t * g = lv_obj_get_group(par);
 80027a8:	6938      	ldr	r0, [r7, #16]
 80027aa:	f000 f929 	bl	8002a00 <lv_obj_get_group>
 80027ae:	60f8      	str	r0, [r7, #12]
                    if(lv_group_get_focused(g) == par) {
 80027b0:	68f8      	ldr	r0, [r7, #12]
 80027b2:	f7fd fedb 	bl	800056c <lv_group_get_focused>
 80027b6:	4602      	mov	r2, r0
 80027b8:	693b      	ldr	r3, [r7, #16]
 80027ba:	4293      	cmp	r3, r2
 80027bc:	d107      	bne.n	80027ce <lv_obj_get_style+0x7e>
                        style_act = lv_group_mod_style(g, par->style_p);
 80027be:	693b      	ldr	r3, [r7, #16]
 80027c0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80027c2:	4619      	mov	r1, r3
 80027c4:	68f8      	ldr	r0, [r7, #12]
 80027c6:	f7fd fea1 	bl	800050c <lv_group_mod_style>
 80027ca:	6178      	str	r0, [r7, #20]
                    } else {
                        style_act = par->style_p;
                    }
#endif
                    break;
 80027cc:	e009      	b.n	80027e2 <lv_obj_get_style+0x92>
                        style_act = par->style_p;
 80027ce:	693b      	ldr	r3, [r7, #16]
 80027d0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80027d2:	617b      	str	r3, [r7, #20]
                    break;
 80027d4:	e005      	b.n	80027e2 <lv_obj_get_style+0x92>
                }
            }
            par = par->par;
 80027d6:	693b      	ldr	r3, [r7, #16]
 80027d8:	681b      	ldr	r3, [r3, #0]
 80027da:	613b      	str	r3, [r7, #16]
        while(par) {
 80027dc:	693b      	ldr	r3, [r7, #16]
 80027de:	2b00      	cmp	r3, #0
 80027e0:	d1d6      	bne.n	8002790 <lv_obj_get_style+0x40>
        }
    }
#if LV_USE_GROUP
    if(obj->group_p) {
 80027e2:	687b      	ldr	r3, [r7, #4]
 80027e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80027e6:	2b00      	cmp	r3, #0
 80027e8:	d00f      	beq.n	800280a <lv_obj_get_style+0xba>
        if(lv_group_get_focused(obj->group_p) == obj) {
 80027ea:	687b      	ldr	r3, [r7, #4]
 80027ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80027ee:	4618      	mov	r0, r3
 80027f0:	f7fd febc 	bl	800056c <lv_group_get_focused>
 80027f4:	4602      	mov	r2, r0
 80027f6:	687b      	ldr	r3, [r7, #4]
 80027f8:	4293      	cmp	r3, r2
 80027fa:	d106      	bne.n	800280a <lv_obj_get_style+0xba>
            style_act = lv_group_mod_style(obj->group_p, style_act);
 80027fc:	687b      	ldr	r3, [r7, #4]
 80027fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002800:	6979      	ldr	r1, [r7, #20]
 8002802:	4618      	mov	r0, r3
 8002804:	f7fd fe82 	bl	800050c <lv_group_mod_style>
 8002808:	6178      	str	r0, [r7, #20]
        }
    }
#endif

    if(style_act == NULL) style_act = &lv_style_plain;
 800280a:	697b      	ldr	r3, [r7, #20]
 800280c:	2b00      	cmp	r3, #0
 800280e:	d101      	bne.n	8002814 <lv_obj_get_style+0xc4>
 8002810:	4b04      	ldr	r3, [pc, #16]	; (8002824 <lv_obj_get_style+0xd4>)
 8002812:	617b      	str	r3, [r7, #20]

    return style_act;
 8002814:	697b      	ldr	r3, [r7, #20]
}
 8002816:	4618      	mov	r0, r3
 8002818:	371c      	adds	r7, #28
 800281a:	46bd      	mov	sp, r7
 800281c:	bd90      	pop	{r4, r7, pc}
 800281e:	bf00      	nop
 8002820:	080137b8 	.word	0x080137b8
 8002824:	20009800 	.word	0x20009800

08002828 <lv_obj_get_hidden>:
 * Get the hidden attribute of an object
 * @param obj pointer to an object
 * @return true: the object is hidden
 */
bool lv_obj_get_hidden(const lv_obj_t * obj)
{
 8002828:	b590      	push	{r4, r7, lr}
 800282a:	b083      	sub	sp, #12
 800282c:	af00      	add	r7, sp, #0
 800282e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002830:	6878      	ldr	r0, [r7, #4]
 8002832:	f7fd fce1 	bl	80001f8 <lv_debug_check_null>
 8002836:	4603      	mov	r3, r0
 8002838:	f083 0301 	eor.w	r3, r3, #1
 800283c:	b2db      	uxtb	r3, r3
 800283e:	2b00      	cmp	r3, #0
 8002840:	d008      	beq.n	8002854 <lv_obj_get_hidden+0x2c>
 8002842:	687b      	ldr	r3, [r7, #4]
 8002844:	f04f 0400 	mov.w	r4, #0
 8002848:	461a      	mov	r2, r3
 800284a:	4623      	mov	r3, r4
 800284c:	4809      	ldr	r0, [pc, #36]	; (8002874 <lv_obj_get_hidden+0x4c>)
 800284e:	f7fd fcfd 	bl	800024c <lv_debug_log_error>
 8002852:	e7fe      	b.n	8002852 <lv_obj_get_hidden+0x2a>

    return obj->hidden == 0 ? false : true;
 8002854:	687b      	ldr	r3, [r7, #4]
 8002856:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800285a:	f003 0310 	and.w	r3, r3, #16
 800285e:	b2db      	uxtb	r3, r3
 8002860:	2b00      	cmp	r3, #0
 8002862:	bf14      	ite	ne
 8002864:	2301      	movne	r3, #1
 8002866:	2300      	moveq	r3, #0
 8002868:	b2db      	uxtb	r3, r3
}
 800286a:	4618      	mov	r0, r3
 800286c:	370c      	adds	r7, #12
 800286e:	46bd      	mov	sp, r7
 8002870:	bd90      	pop	{r4, r7, pc}
 8002872:	bf00      	nop
 8002874:	080137b8 	.word	0x080137b8

08002878 <lv_obj_get_base_dir>:
    return obj->parent_event == 0 ? false : true;
}


lv_bidi_dir_t lv_obj_get_base_dir(const lv_obj_t * obj)
{
 8002878:	b480      	push	{r7}
 800287a:	b083      	sub	sp, #12
 800287c:	af00      	add	r7, sp, #0
 800287e:	6078      	str	r0, [r7, #4]
    }

    return LV_BIDI_BASE_DIR_DEF;
#else
    (void) obj;  /*Unused*/
    return LV_BIDI_DIR_LTR;
 8002880:	2300      	movs	r3, #0
#endif
}
 8002882:	4618      	mov	r0, r3
 8002884:	370c      	adds	r7, #12
 8002886:	46bd      	mov	sp, r7
 8002888:	f85d 7b04 	ldr.w	r7, [sp], #4
 800288c:	4770      	bx	lr
	...

08002890 <lv_obj_get_opa_scale>:
 * Get the opa scale parameter of an object
 * @param obj pointer to an object
 * @return opa scale [0..255]
 */
lv_opa_t lv_obj_get_opa_scale(const lv_obj_t * obj)
{
 8002890:	b590      	push	{r4, r7, lr}
 8002892:	b085      	sub	sp, #20
 8002894:	af00      	add	r7, sp, #0
 8002896:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002898:	6878      	ldr	r0, [r7, #4]
 800289a:	f7fd fcad 	bl	80001f8 <lv_debug_check_null>
 800289e:	4603      	mov	r3, r0
 80028a0:	f083 0301 	eor.w	r3, r3, #1
 80028a4:	b2db      	uxtb	r3, r3
 80028a6:	2b00      	cmp	r3, #0
 80028a8:	d008      	beq.n	80028bc <lv_obj_get_opa_scale+0x2c>
 80028aa:	687b      	ldr	r3, [r7, #4]
 80028ac:	f04f 0400 	mov.w	r4, #0
 80028b0:	461a      	mov	r2, r3
 80028b2:	4623      	mov	r3, r4
 80028b4:	480f      	ldr	r0, [pc, #60]	; (80028f4 <lv_obj_get_opa_scale+0x64>)
 80028b6:	f7fd fcc9 	bl	800024c <lv_debug_log_error>
 80028ba:	e7fe      	b.n	80028ba <lv_obj_get_opa_scale+0x2a>

    const lv_obj_t * parent = obj;
 80028bc:	687b      	ldr	r3, [r7, #4]
 80028be:	60fb      	str	r3, [r7, #12]

    while(parent) {
 80028c0:	e00f      	b.n	80028e2 <lv_obj_get_opa_scale+0x52>
        if(parent->opa_scale_en) return parent->opa_scale;
 80028c2:	68fb      	ldr	r3, [r7, #12]
 80028c4:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80028c8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80028cc:	b2db      	uxtb	r3, r3
 80028ce:	2b00      	cmp	r3, #0
 80028d0:	d003      	beq.n	80028da <lv_obj_get_opa_scale+0x4a>
 80028d2:	68fb      	ldr	r3, [r7, #12]
 80028d4:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 80028d8:	e007      	b.n	80028ea <lv_obj_get_opa_scale+0x5a>
        parent = lv_obj_get_parent(parent);
 80028da:	68f8      	ldr	r0, [r7, #12]
 80028dc:	f7ff fdc0 	bl	8002460 <lv_obj_get_parent>
 80028e0:	60f8      	str	r0, [r7, #12]
    while(parent) {
 80028e2:	68fb      	ldr	r3, [r7, #12]
 80028e4:	2b00      	cmp	r3, #0
 80028e6:	d1ec      	bne.n	80028c2 <lv_obj_get_opa_scale+0x32>
    }

    return LV_OPA_COVER;
 80028e8:	23ff      	movs	r3, #255	; 0xff
}
 80028ea:	4618      	mov	r0, r3
 80028ec:	3714      	adds	r7, #20
 80028ee:	46bd      	mov	sp, r7
 80028f0:	bd90      	pop	{r4, r7, pc}
 80028f2:	bf00      	nop
 80028f4:	080137b8 	.word	0x080137b8

080028f8 <lv_obj_is_protected>:
 * @param obj pointer to an object
 * @param prot protect bits to test ('OR'ed values of `lv_protect_t`)
 * @return false: none of the given bits are set, true: at least one bit is set
 */
bool lv_obj_is_protected(const lv_obj_t * obj, uint8_t prot)
{
 80028f8:	b590      	push	{r4, r7, lr}
 80028fa:	b083      	sub	sp, #12
 80028fc:	af00      	add	r7, sp, #0
 80028fe:	6078      	str	r0, [r7, #4]
 8002900:	460b      	mov	r3, r1
 8002902:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002904:	6878      	ldr	r0, [r7, #4]
 8002906:	f7fd fc77 	bl	80001f8 <lv_debug_check_null>
 800290a:	4603      	mov	r3, r0
 800290c:	f083 0301 	eor.w	r3, r3, #1
 8002910:	b2db      	uxtb	r3, r3
 8002912:	2b00      	cmp	r3, #0
 8002914:	d008      	beq.n	8002928 <lv_obj_is_protected+0x30>
 8002916:	687b      	ldr	r3, [r7, #4]
 8002918:	f04f 0400 	mov.w	r4, #0
 800291c:	461a      	mov	r2, r3
 800291e:	4623      	mov	r3, r4
 8002920:	4809      	ldr	r0, [pc, #36]	; (8002948 <lv_obj_is_protected+0x50>)
 8002922:	f7fd fc93 	bl	800024c <lv_debug_log_error>
 8002926:	e7fe      	b.n	8002926 <lv_obj_is_protected+0x2e>

    return (obj->protect & prot) == 0 ? false : true;
 8002928:	687b      	ldr	r3, [r7, #4]
 800292a:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 800292e:	78fb      	ldrb	r3, [r7, #3]
 8002930:	4013      	ands	r3, r2
 8002932:	b2db      	uxtb	r3, r3
 8002934:	2b00      	cmp	r3, #0
 8002936:	bf14      	ite	ne
 8002938:	2301      	movne	r3, #1
 800293a:	2300      	moveq	r3, #0
 800293c:	b2db      	uxtb	r3, r3
}
 800293e:	4618      	mov	r0, r3
 8002940:	370c      	adds	r7, #12
 8002942:	46bd      	mov	sp, r7
 8002944:	bd90      	pop	{r4, r7, pc}
 8002946:	bf00      	nop
 8002948:	080137b8 	.word	0x080137b8

0800294c <lv_obj_get_signal_cb>:
 * Get the signal function of an object
 * @param obj pointer to an object
 * @return the signal function
 */
lv_signal_cb_t lv_obj_get_signal_cb(const lv_obj_t * obj)
{
 800294c:	b590      	push	{r4, r7, lr}
 800294e:	b083      	sub	sp, #12
 8002950:	af00      	add	r7, sp, #0
 8002952:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002954:	6878      	ldr	r0, [r7, #4]
 8002956:	f7fd fc4f 	bl	80001f8 <lv_debug_check_null>
 800295a:	4603      	mov	r3, r0
 800295c:	f083 0301 	eor.w	r3, r3, #1
 8002960:	b2db      	uxtb	r3, r3
 8002962:	2b00      	cmp	r3, #0
 8002964:	d008      	beq.n	8002978 <lv_obj_get_signal_cb+0x2c>
 8002966:	687b      	ldr	r3, [r7, #4]
 8002968:	f04f 0400 	mov.w	r4, #0
 800296c:	461a      	mov	r2, r3
 800296e:	4623      	mov	r3, r4
 8002970:	4804      	ldr	r0, [pc, #16]	; (8002984 <lv_obj_get_signal_cb+0x38>)
 8002972:	f7fd fc6b 	bl	800024c <lv_debug_log_error>
 8002976:	e7fe      	b.n	8002976 <lv_obj_get_signal_cb+0x2a>

    return obj->signal_cb;
 8002978:	687b      	ldr	r3, [r7, #4]
 800297a:	69db      	ldr	r3, [r3, #28]
}
 800297c:	4618      	mov	r0, r3
 800297e:	370c      	adds	r7, #12
 8002980:	46bd      	mov	sp, r7
 8002982:	bd90      	pop	{r4, r7, pc}
 8002984:	080137b8 	.word	0x080137b8

08002988 <lv_obj_get_design_cb>:
 * Get the design function of an object
 * @param obj pointer to an object
 * @return the design function
 */
lv_design_cb_t lv_obj_get_design_cb(const lv_obj_t * obj)
{
 8002988:	b590      	push	{r4, r7, lr}
 800298a:	b083      	sub	sp, #12
 800298c:	af00      	add	r7, sp, #0
 800298e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002990:	6878      	ldr	r0, [r7, #4]
 8002992:	f7fd fc31 	bl	80001f8 <lv_debug_check_null>
 8002996:	4603      	mov	r3, r0
 8002998:	f083 0301 	eor.w	r3, r3, #1
 800299c:	b2db      	uxtb	r3, r3
 800299e:	2b00      	cmp	r3, #0
 80029a0:	d008      	beq.n	80029b4 <lv_obj_get_design_cb+0x2c>
 80029a2:	687b      	ldr	r3, [r7, #4]
 80029a4:	f04f 0400 	mov.w	r4, #0
 80029a8:	461a      	mov	r2, r3
 80029aa:	4623      	mov	r3, r4
 80029ac:	4804      	ldr	r0, [pc, #16]	; (80029c0 <lv_obj_get_design_cb+0x38>)
 80029ae:	f7fd fc4d 	bl	800024c <lv_debug_log_error>
 80029b2:	e7fe      	b.n	80029b2 <lv_obj_get_design_cb+0x2a>

    return obj->design_cb;
 80029b4:	687b      	ldr	r3, [r7, #4]
 80029b6:	6a1b      	ldr	r3, [r3, #32]
}
 80029b8:	4618      	mov	r0, r3
 80029ba:	370c      	adds	r7, #12
 80029bc:	46bd      	mov	sp, r7
 80029be:	bd90      	pop	{r4, r7, pc}
 80029c0:	080137b8 	.word	0x080137b8

080029c4 <lv_obj_get_ext_attr>:
 * @param obj pointer to an object
 * @return the ext pointer but not the dynamic version
 *         Use it as ext->data1, and NOT da(ext)->data1
 */
void * lv_obj_get_ext_attr(const lv_obj_t * obj)
{
 80029c4:	b590      	push	{r4, r7, lr}
 80029c6:	b083      	sub	sp, #12
 80029c8:	af00      	add	r7, sp, #0
 80029ca:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80029cc:	6878      	ldr	r0, [r7, #4]
 80029ce:	f7fd fc13 	bl	80001f8 <lv_debug_check_null>
 80029d2:	4603      	mov	r3, r0
 80029d4:	f083 0301 	eor.w	r3, r3, #1
 80029d8:	b2db      	uxtb	r3, r3
 80029da:	2b00      	cmp	r3, #0
 80029dc:	d008      	beq.n	80029f0 <lv_obj_get_ext_attr+0x2c>
 80029de:	687b      	ldr	r3, [r7, #4]
 80029e0:	f04f 0400 	mov.w	r4, #0
 80029e4:	461a      	mov	r2, r3
 80029e6:	4623      	mov	r3, r4
 80029e8:	4804      	ldr	r0, [pc, #16]	; (80029fc <lv_obj_get_ext_attr+0x38>)
 80029ea:	f7fd fc2f 	bl	800024c <lv_debug_log_error>
 80029ee:	e7fe      	b.n	80029ee <lv_obj_get_ext_attr+0x2a>

    return obj->ext_attr;
 80029f0:	687b      	ldr	r3, [r7, #4]
 80029f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80029f4:	4618      	mov	r0, r3
 80029f6:	370c      	adds	r7, #12
 80029f8:	46bd      	mov	sp, r7
 80029fa:	bd90      	pop	{r4, r7, pc}
 80029fc:	080137b8 	.word	0x080137b8

08002a00 <lv_obj_get_group>:
 * Get the group of the object
 * @param obj pointer to an object
 * @return the pointer to group of the object
 */
void * lv_obj_get_group(const lv_obj_t * obj)
{
 8002a00:	b590      	push	{r4, r7, lr}
 8002a02:	b083      	sub	sp, #12
 8002a04:	af00      	add	r7, sp, #0
 8002a06:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002a08:	6878      	ldr	r0, [r7, #4]
 8002a0a:	f7fd fbf5 	bl	80001f8 <lv_debug_check_null>
 8002a0e:	4603      	mov	r3, r0
 8002a10:	f083 0301 	eor.w	r3, r3, #1
 8002a14:	b2db      	uxtb	r3, r3
 8002a16:	2b00      	cmp	r3, #0
 8002a18:	d008      	beq.n	8002a2c <lv_obj_get_group+0x2c>
 8002a1a:	687b      	ldr	r3, [r7, #4]
 8002a1c:	f04f 0400 	mov.w	r4, #0
 8002a20:	461a      	mov	r2, r3
 8002a22:	4623      	mov	r3, r4
 8002a24:	4804      	ldr	r0, [pc, #16]	; (8002a38 <lv_obj_get_group+0x38>)
 8002a26:	f7fd fc11 	bl	800024c <lv_debug_log_error>
 8002a2a:	e7fe      	b.n	8002a2a <lv_obj_get_group+0x2a>

    return obj->group_p;
 8002a2c:	687b      	ldr	r3, [r7, #4]
 8002a2e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
 8002a30:	4618      	mov	r0, r3
 8002a32:	370c      	adds	r7, #12
 8002a34:	46bd      	mov	sp, r7
 8002a36:	bd90      	pop	{r4, r7, pc}
 8002a38:	080137b8 	.word	0x080137b8

08002a3c <lv_obj_is_focused>:
 * Tell whether the object is the focused object of a group or not.
 * @param obj pointer to an object
 * @return true: the object is focused, false: the object is not focused or not in a group
 */
bool lv_obj_is_focused(const lv_obj_t * obj)
{
 8002a3c:	b590      	push	{r4, r7, lr}
 8002a3e:	b083      	sub	sp, #12
 8002a40:	af00      	add	r7, sp, #0
 8002a42:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8002a44:	6878      	ldr	r0, [r7, #4]
 8002a46:	f7fd fbd7 	bl	80001f8 <lv_debug_check_null>
 8002a4a:	4603      	mov	r3, r0
 8002a4c:	f083 0301 	eor.w	r3, r3, #1
 8002a50:	b2db      	uxtb	r3, r3
 8002a52:	2b00      	cmp	r3, #0
 8002a54:	d008      	beq.n	8002a68 <lv_obj_is_focused+0x2c>
 8002a56:	687b      	ldr	r3, [r7, #4]
 8002a58:	f04f 0400 	mov.w	r4, #0
 8002a5c:	461a      	mov	r2, r3
 8002a5e:	4623      	mov	r3, r4
 8002a60:	480b      	ldr	r0, [pc, #44]	; (8002a90 <lv_obj_is_focused+0x54>)
 8002a62:	f7fd fbf3 	bl	800024c <lv_debug_log_error>
 8002a66:	e7fe      	b.n	8002a66 <lv_obj_is_focused+0x2a>

    if(obj->group_p) {
 8002a68:	687b      	ldr	r3, [r7, #4]
 8002a6a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002a6c:	2b00      	cmp	r3, #0
 8002a6e:	d00a      	beq.n	8002a86 <lv_obj_is_focused+0x4a>
        if(lv_group_get_focused(obj->group_p) == obj) return true;
 8002a70:	687b      	ldr	r3, [r7, #4]
 8002a72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002a74:	4618      	mov	r0, r3
 8002a76:	f7fd fd79 	bl	800056c <lv_group_get_focused>
 8002a7a:	4602      	mov	r2, r0
 8002a7c:	687b      	ldr	r3, [r7, #4]
 8002a7e:	4293      	cmp	r3, r2
 8002a80:	d101      	bne.n	8002a86 <lv_obj_is_focused+0x4a>
 8002a82:	2301      	movs	r3, #1
 8002a84:	e000      	b.n	8002a88 <lv_obj_is_focused+0x4c>
    }

    return false;
 8002a86:	2300      	movs	r3, #0
}
 8002a88:	4618      	mov	r0, r3
 8002a8a:	370c      	adds	r7, #12
 8002a8c:	46bd      	mov	sp, r7
 8002a8e:	bd90      	pop	{r4, r7, pc}
 8002a90:	080137b8 	.word	0x080137b8

08002a94 <lv_obj_handle_get_type_signal>:
 * @param buf pointer to `lv_obj_type_t`. (`param` in the signal callback)
 * @param name name of the object. E.g. "lv_btn". (Only the pointer is saved)
 * @return LV_RES_OK
 */
lv_res_t lv_obj_handle_get_type_signal(lv_obj_type_t * buf, const char * name)
{
 8002a94:	b480      	push	{r7}
 8002a96:	b085      	sub	sp, #20
 8002a98:	af00      	add	r7, sp, #0
 8002a9a:	6078      	str	r0, [r7, #4]
 8002a9c:	6039      	str	r1, [r7, #0]
    uint8_t i;
    for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 8002a9e:	2300      	movs	r3, #0
 8002aa0:	73fb      	strb	r3, [r7, #15]
 8002aa2:	e008      	b.n	8002ab6 <lv_obj_handle_get_type_signal+0x22>
        if(buf->type[i] == NULL) break;
 8002aa4:	7bfa      	ldrb	r2, [r7, #15]
 8002aa6:	687b      	ldr	r3, [r7, #4]
 8002aa8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002aac:	2b00      	cmp	r3, #0
 8002aae:	d006      	beq.n	8002abe <lv_obj_handle_get_type_signal+0x2a>
    for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 8002ab0:	7bfb      	ldrb	r3, [r7, #15]
 8002ab2:	3301      	adds	r3, #1
 8002ab4:	73fb      	strb	r3, [r7, #15]
 8002ab6:	7bfb      	ldrb	r3, [r7, #15]
 8002ab8:	2b06      	cmp	r3, #6
 8002aba:	d9f3      	bls.n	8002aa4 <lv_obj_handle_get_type_signal+0x10>
 8002abc:	e000      	b.n	8002ac0 <lv_obj_handle_get_type_signal+0x2c>
        if(buf->type[i] == NULL) break;
 8002abe:	bf00      	nop
    }
    buf->type[i] = name;
 8002ac0:	7bfa      	ldrb	r2, [r7, #15]
 8002ac2:	687b      	ldr	r3, [r7, #4]
 8002ac4:	6839      	ldr	r1, [r7, #0]
 8002ac6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

    return LV_RES_OK;
 8002aca:	2301      	movs	r3, #1
}
 8002acc:	4618      	mov	r0, r3
 8002ace:	3714      	adds	r7, #20
 8002ad0:	46bd      	mov	sp, r7
 8002ad2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ad6:	4770      	bx	lr

08002ad8 <lv_obj_design>:
 *                                  (return 'true' if yes)
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 * @param return true/false, depends on 'mode'
 */
static bool lv_obj_design(lv_obj_t * obj, const lv_area_t * mask_p, lv_design_mode_t mode)
{
 8002ad8:	b590      	push	{r4, r7, lr}
 8002ada:	b08b      	sub	sp, #44	; 0x2c
 8002adc:	af00      	add	r7, sp, #0
 8002ade:	60f8      	str	r0, [r7, #12]
 8002ae0:	60b9      	str	r1, [r7, #8]
 8002ae2:	4613      	mov	r3, r2
 8002ae4:	71fb      	strb	r3, [r7, #7]
    if(mode == LV_DESIGN_COVER_CHK) {
 8002ae6:	79fb      	ldrb	r3, [r7, #7]
 8002ae8:	2b02      	cmp	r3, #2
 8002aea:	d16a      	bne.n	8002bc2 <lv_obj_design+0xea>

        /*Most trivial test. Is the mask fully IN the object? If no it surely doesn't cover it*/
        if(lv_area_is_in(mask_p, &obj->coords) == false) return false;
 8002aec:	68fb      	ldr	r3, [r7, #12]
 8002aee:	3310      	adds	r3, #16
 8002af0:	4619      	mov	r1, r3
 8002af2:	68b8      	ldr	r0, [r7, #8]
 8002af4:	f009 fba1 	bl	800c23a <lv_area_is_in>
 8002af8:	4603      	mov	r3, r0
 8002afa:	f083 0301 	eor.w	r3, r3, #1
 8002afe:	b2db      	uxtb	r3, r3
 8002b00:	2b00      	cmp	r3, #0
 8002b02:	d001      	beq.n	8002b08 <lv_obj_design+0x30>
 8002b04:	2300      	movs	r3, #0
 8002b06:	e070      	b.n	8002bea <lv_obj_design+0x112>

        /*Can cover the area only if fully solid (no opacity)*/
        const lv_style_t * style = lv_obj_get_style(obj);
 8002b08:	68f8      	ldr	r0, [r7, #12]
 8002b0a:	f7ff fe21 	bl	8002750 <lv_obj_get_style>
 8002b0e:	6238      	str	r0, [r7, #32]
        if(style->body.opa < LV_OPA_MAX) return false;
 8002b10:	6a3b      	ldr	r3, [r7, #32]
 8002b12:	7a1b      	ldrb	r3, [r3, #8]
 8002b14:	2bfa      	cmp	r3, #250	; 0xfa
 8002b16:	d801      	bhi.n	8002b1c <lv_obj_design+0x44>
 8002b18:	2300      	movs	r3, #0
 8002b1a:	e066      	b.n	8002bea <lv_obj_design+0x112>

        /* Because of the radius it is not sure the area is covered
         * Check the areas where there is no radius*/
        lv_coord_t r = style->body.radius;
 8002b1c:	6a3b      	ldr	r3, [r7, #32]
 8002b1e:	88db      	ldrh	r3, [r3, #6]
 8002b20:	83fb      	strh	r3, [r7, #30]

        if(r == LV_RADIUS_CIRCLE) return false;
 8002b22:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8002b26:	f647 4218 	movw	r2, #31768	; 0x7c18
 8002b2a:	4293      	cmp	r3, r2
 8002b2c:	d101      	bne.n	8002b32 <lv_obj_design+0x5a>
 8002b2e:	2300      	movs	r3, #0
 8002b30:	e05b      	b.n	8002bea <lv_obj_design+0x112>

        lv_area_t area_tmp;

        /*Check horizontally without radius*/
        lv_obj_get_coords(obj, &area_tmp);
 8002b32:	f107 0314 	add.w	r3, r7, #20
 8002b36:	4619      	mov	r1, r3
 8002b38:	68f8      	ldr	r0, [r7, #12]
 8002b3a:	f7ff fce1 	bl	8002500 <lv_obj_get_coords>
        area_tmp.x1 += r;
 8002b3e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8002b42:	b29a      	uxth	r2, r3
 8002b44:	8bfb      	ldrh	r3, [r7, #30]
 8002b46:	4413      	add	r3, r2
 8002b48:	b29b      	uxth	r3, r3
 8002b4a:	b21b      	sxth	r3, r3
 8002b4c:	82bb      	strh	r3, [r7, #20]
        area_tmp.x2 -= r;
 8002b4e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8002b52:	b29a      	uxth	r2, r3
 8002b54:	8bfb      	ldrh	r3, [r7, #30]
 8002b56:	1ad3      	subs	r3, r2, r3
 8002b58:	b29b      	uxth	r3, r3
 8002b5a:	b21b      	sxth	r3, r3
 8002b5c:	833b      	strh	r3, [r7, #24]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
 8002b5e:	f107 0314 	add.w	r3, r7, #20
 8002b62:	4619      	mov	r1, r3
 8002b64:	68b8      	ldr	r0, [r7, #8]
 8002b66:	f009 fb68 	bl	800c23a <lv_area_is_in>
 8002b6a:	4603      	mov	r3, r0
 8002b6c:	f083 0301 	eor.w	r3, r3, #1
 8002b70:	b2db      	uxtb	r3, r3
 8002b72:	2b00      	cmp	r3, #0
 8002b74:	d001      	beq.n	8002b7a <lv_obj_design+0xa2>
 8002b76:	2300      	movs	r3, #0
 8002b78:	e037      	b.n	8002bea <lv_obj_design+0x112>

        /*Check vertically without radius*/
        lv_obj_get_coords(obj, &area_tmp);
 8002b7a:	f107 0314 	add.w	r3, r7, #20
 8002b7e:	4619      	mov	r1, r3
 8002b80:	68f8      	ldr	r0, [r7, #12]
 8002b82:	f7ff fcbd 	bl	8002500 <lv_obj_get_coords>
        area_tmp.y1 += r;
 8002b86:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8002b8a:	b29a      	uxth	r2, r3
 8002b8c:	8bfb      	ldrh	r3, [r7, #30]
 8002b8e:	4413      	add	r3, r2
 8002b90:	b29b      	uxth	r3, r3
 8002b92:	b21b      	sxth	r3, r3
 8002b94:	82fb      	strh	r3, [r7, #22]
        area_tmp.y2 -= r;
 8002b96:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8002b9a:	b29a      	uxth	r2, r3
 8002b9c:	8bfb      	ldrh	r3, [r7, #30]
 8002b9e:	1ad3      	subs	r3, r2, r3
 8002ba0:	b29b      	uxth	r3, r3
 8002ba2:	b21b      	sxth	r3, r3
 8002ba4:	837b      	strh	r3, [r7, #26]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
 8002ba6:	f107 0314 	add.w	r3, r7, #20
 8002baa:	4619      	mov	r1, r3
 8002bac:	68b8      	ldr	r0, [r7, #8]
 8002bae:	f009 fb44 	bl	800c23a <lv_area_is_in>
 8002bb2:	4603      	mov	r3, r0
 8002bb4:	f083 0301 	eor.w	r3, r3, #1
 8002bb8:	b2db      	uxtb	r3, r3
 8002bba:	2b00      	cmp	r3, #0
 8002bbc:	d014      	beq.n	8002be8 <lv_obj_design+0x110>
 8002bbe:	2300      	movs	r3, #0
 8002bc0:	e013      	b.n	8002bea <lv_obj_design+0x112>

    } else if(mode == LV_DESIGN_DRAW_MAIN) {
 8002bc2:	79fb      	ldrb	r3, [r7, #7]
 8002bc4:	2b00      	cmp	r3, #0
 8002bc6:	d10f      	bne.n	8002be8 <lv_obj_design+0x110>
        const lv_style_t * style = lv_obj_get_style(obj);
 8002bc8:	68f8      	ldr	r0, [r7, #12]
 8002bca:	f7ff fdc1 	bl	8002750 <lv_obj_get_style>
 8002bce:	6278      	str	r0, [r7, #36]	; 0x24
        lv_draw_rect(&obj->coords, mask_p, style, lv_obj_get_opa_scale(obj));
 8002bd0:	68fb      	ldr	r3, [r7, #12]
 8002bd2:	f103 0410 	add.w	r4, r3, #16
 8002bd6:	68f8      	ldr	r0, [r7, #12]
 8002bd8:	f7ff fe5a 	bl	8002890 <lv_obj_get_opa_scale>
 8002bdc:	4603      	mov	r3, r0
 8002bde:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002be0:	68b9      	ldr	r1, [r7, #8]
 8002be2:	4620      	mov	r0, r4
 8002be4:	f002 ffa7 	bl	8005b36 <lv_draw_rect>
    }

    return true;
 8002be8:	2301      	movs	r3, #1
}
 8002bea:	4618      	mov	r0, r3
 8002bec:	372c      	adds	r7, #44	; 0x2c
 8002bee:	46bd      	mov	sp, r7
 8002bf0:	bd90      	pop	{r4, r7, pc}
	...

08002bf4 <lv_obj_signal>:
 * @param sign signal type
 * @param param parameter for the signal (depends on signal type)
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_obj_signal(lv_obj_t * obj, lv_signal_t sign, void * param)
{
 8002bf4:	b580      	push	{r7, lr}
 8002bf6:	b086      	sub	sp, #24
 8002bf8:	af00      	add	r7, sp, #0
 8002bfa:	60f8      	str	r0, [r7, #12]
 8002bfc:	460b      	mov	r3, r1
 8002bfe:	607a      	str	r2, [r7, #4]
 8002c00:	72fb      	strb	r3, [r7, #11]
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
 8002c02:	7afb      	ldrb	r3, [r7, #11]
 8002c04:	2b07      	cmp	r3, #7
 8002c06:	d105      	bne.n	8002c14 <lv_obj_signal+0x20>
 8002c08:	491a      	ldr	r1, [pc, #104]	; (8002c74 <lv_obj_signal+0x80>)
 8002c0a:	6878      	ldr	r0, [r7, #4]
 8002c0c:	f7ff ff42 	bl	8002a94 <lv_obj_handle_get_type_signal>
 8002c10:	4603      	mov	r3, r0
 8002c12:	e02a      	b.n	8002c6a <lv_obj_signal+0x76>

    lv_res_t res = LV_RES_OK;
 8002c14:	2301      	movs	r3, #1
 8002c16:	75fb      	strb	r3, [r7, #23]

    if(sign == LV_SIGNAL_CHILD_CHG) {
 8002c18:	7afb      	ldrb	r3, [r7, #11]
 8002c1a:	2b01      	cmp	r3, #1
 8002c1c:	d109      	bne.n	8002c32 <lv_obj_signal+0x3e>
        /*Return 'invalid' if the child change signal is not enabled*/
        if(lv_obj_is_protected(obj, LV_PROTECT_CHILD_CHG) != false) res = LV_RES_INV;
 8002c1e:	2101      	movs	r1, #1
 8002c20:	68f8      	ldr	r0, [r7, #12]
 8002c22:	f7ff fe69 	bl	80028f8 <lv_obj_is_protected>
 8002c26:	4603      	mov	r3, r0
 8002c28:	2b00      	cmp	r3, #0
 8002c2a:	d01d      	beq.n	8002c68 <lv_obj_signal+0x74>
 8002c2c:	2300      	movs	r3, #0
 8002c2e:	75fb      	strb	r3, [r7, #23]
 8002c30:	e01a      	b.n	8002c68 <lv_obj_signal+0x74>
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 8002c32:	7afb      	ldrb	r3, [r7, #11]
 8002c34:	2b06      	cmp	r3, #6
 8002c36:	d111      	bne.n	8002c5c <lv_obj_signal+0x68>
        const lv_style_t * style = lv_obj_get_style(obj);
 8002c38:	68f8      	ldr	r0, [r7, #12]
 8002c3a:	f7ff fd89 	bl	8002750 <lv_obj_get_style>
 8002c3e:	6138      	str	r0, [r7, #16]
        if(style->body.shadow.width > obj->ext_draw_pad) obj->ext_draw_pad = style->body.shadow.width;
 8002c40:	693b      	ldr	r3, [r7, #16]
 8002c42:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 8002c46:	68fb      	ldr	r3, [r7, #12]
 8002c48:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 8002c4c:	429a      	cmp	r2, r3
 8002c4e:	dd0b      	ble.n	8002c68 <lv_obj_signal+0x74>
 8002c50:	693b      	ldr	r3, [r7, #16]
 8002c52:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 8002c56:	68fb      	ldr	r3, [r7, #12]
 8002c58:	869a      	strh	r2, [r3, #52]	; 0x34
 8002c5a:	e005      	b.n	8002c68 <lv_obj_signal+0x74>
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
 8002c5c:	7afb      	ldrb	r3, [r7, #11]
 8002c5e:	2b04      	cmp	r3, #4
 8002c60:	d102      	bne.n	8002c68 <lv_obj_signal+0x74>
        lv_obj_refresh_ext_draw_pad(obj);
 8002c62:	68f8      	ldr	r0, [r7, #12]
 8002c64:	f7ff fb5e 	bl	8002324 <lv_obj_refresh_ext_draw_pad>
    }
    return res;
 8002c68:	7dfb      	ldrb	r3, [r7, #23]
}
 8002c6a:	4618      	mov	r0, r3
 8002c6c:	3718      	adds	r7, #24
 8002c6e:	46bd      	mov	sp, r7
 8002c70:	bd80      	pop	{r7, pc}
 8002c72:	bf00      	nop
 8002c74:	080137d8 	.word	0x080137d8

08002c78 <refresh_children_position>:
 * @param obj pointer to an object which children will be repositioned
 * @param x_diff x coordinate shift
 * @param y_diff y coordinate shift
 */
static void refresh_children_position(lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff)
{
 8002c78:	b580      	push	{r7, lr}
 8002c7a:	b084      	sub	sp, #16
 8002c7c:	af00      	add	r7, sp, #0
 8002c7e:	6078      	str	r0, [r7, #4]
 8002c80:	460b      	mov	r3, r1
 8002c82:	807b      	strh	r3, [r7, #2]
 8002c84:	4613      	mov	r3, r2
 8002c86:	803b      	strh	r3, [r7, #0]
    lv_obj_t * i;
    LV_LL_READ(obj->child_ll, i)
 8002c88:	687b      	ldr	r3, [r7, #4]
 8002c8a:	3304      	adds	r3, #4
 8002c8c:	4618      	mov	r0, r3
 8002c8e:	f009 fe95 	bl	800c9bc <lv_ll_get_head>
 8002c92:	60f8      	str	r0, [r7, #12]
 8002c94:	e036      	b.n	8002d04 <refresh_children_position+0x8c>
    {
        i->coords.x1 += x_diff;
 8002c96:	68fb      	ldr	r3, [r7, #12]
 8002c98:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8002c9c:	b29a      	uxth	r2, r3
 8002c9e:	887b      	ldrh	r3, [r7, #2]
 8002ca0:	4413      	add	r3, r2
 8002ca2:	b29b      	uxth	r3, r3
 8002ca4:	b21a      	sxth	r2, r3
 8002ca6:	68fb      	ldr	r3, [r7, #12]
 8002ca8:	821a      	strh	r2, [r3, #16]
        i->coords.y1 += y_diff;
 8002caa:	68fb      	ldr	r3, [r7, #12]
 8002cac:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8002cb0:	b29a      	uxth	r2, r3
 8002cb2:	883b      	ldrh	r3, [r7, #0]
 8002cb4:	4413      	add	r3, r2
 8002cb6:	b29b      	uxth	r3, r3
 8002cb8:	b21a      	sxth	r2, r3
 8002cba:	68fb      	ldr	r3, [r7, #12]
 8002cbc:	825a      	strh	r2, [r3, #18]
        i->coords.x2 += x_diff;
 8002cbe:	68fb      	ldr	r3, [r7, #12]
 8002cc0:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8002cc4:	b29a      	uxth	r2, r3
 8002cc6:	887b      	ldrh	r3, [r7, #2]
 8002cc8:	4413      	add	r3, r2
 8002cca:	b29b      	uxth	r3, r3
 8002ccc:	b21a      	sxth	r2, r3
 8002cce:	68fb      	ldr	r3, [r7, #12]
 8002cd0:	829a      	strh	r2, [r3, #20]
        i->coords.y2 += y_diff;
 8002cd2:	68fb      	ldr	r3, [r7, #12]
 8002cd4:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8002cd8:	b29a      	uxth	r2, r3
 8002cda:	883b      	ldrh	r3, [r7, #0]
 8002cdc:	4413      	add	r3, r2
 8002cde:	b29b      	uxth	r3, r3
 8002ce0:	b21a      	sxth	r2, r3
 8002ce2:	68fb      	ldr	r3, [r7, #12]
 8002ce4:	82da      	strh	r2, [r3, #22]

        refresh_children_position(i, x_diff, y_diff);
 8002ce6:	f9b7 2000 	ldrsh.w	r2, [r7]
 8002cea:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8002cee:	4619      	mov	r1, r3
 8002cf0:	68f8      	ldr	r0, [r7, #12]
 8002cf2:	f7ff ffc1 	bl	8002c78 <refresh_children_position>
    LV_LL_READ(obj->child_ll, i)
 8002cf6:	687b      	ldr	r3, [r7, #4]
 8002cf8:	3304      	adds	r3, #4
 8002cfa:	68f9      	ldr	r1, [r7, #12]
 8002cfc:	4618      	mov	r0, r3
 8002cfe:	f009 fe83 	bl	800ca08 <lv_ll_get_next>
 8002d02:	60f8      	str	r0, [r7, #12]
 8002d04:	68fb      	ldr	r3, [r7, #12]
 8002d06:	2b00      	cmp	r3, #0
 8002d08:	d1c5      	bne.n	8002c96 <refresh_children_position+0x1e>
    }
}
 8002d0a:	bf00      	nop
 8002d0c:	3710      	adds	r7, #16
 8002d0e:	46bd      	mov	sp, r7
 8002d10:	bd80      	pop	{r7, pc}

08002d12 <refresh_children_style>:
 * Recursively refresh the style of the children. Go deeper until a not NULL style is found
 * because the NULL styles are inherited from the parent
 * @param obj pointer to an object
 */
static void refresh_children_style(lv_obj_t * obj)
{
 8002d12:	b580      	push	{r7, lr}
 8002d14:	b084      	sub	sp, #16
 8002d16:	af00      	add	r7, sp, #0
 8002d18:	6078      	str	r0, [r7, #4]
    lv_obj_t * child = lv_obj_get_child(obj, NULL);
 8002d1a:	2100      	movs	r1, #0
 8002d1c:	6878      	ldr	r0, [r7, #4]
 8002d1e:	f7ff fbbd 	bl	800249c <lv_obj_get_child>
 8002d22:	60f8      	str	r0, [r7, #12]
    while(child != NULL) {
 8002d24:	e01a      	b.n	8002d5c <refresh_children_style+0x4a>
        if(child->style_p == NULL) {
 8002d26:	68fb      	ldr	r3, [r7, #12]
 8002d28:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002d2a:	2b00      	cmp	r3, #0
 8002d2c:	d106      	bne.n	8002d3c <refresh_children_style+0x2a>
            refresh_children_style(child); /*Check children too*/
 8002d2e:	68f8      	ldr	r0, [r7, #12]
 8002d30:	f7ff ffef 	bl	8002d12 <refresh_children_style>
            lv_obj_refresh_style(child);   /*Notify the child about the style change*/
 8002d34:	68f8      	ldr	r0, [r7, #12]
 8002d36:	f7ff f93b 	bl	8001fb0 <lv_obj_refresh_style>
 8002d3a:	e00a      	b.n	8002d52 <refresh_children_style+0x40>
        } else if(child->style_p->glass) {
 8002d3c:	68fb      	ldr	r3, [r7, #12]
 8002d3e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002d40:	781b      	ldrb	r3, [r3, #0]
 8002d42:	f003 0301 	and.w	r3, r3, #1
 8002d46:	b2db      	uxtb	r3, r3
 8002d48:	2b00      	cmp	r3, #0
 8002d4a:	d002      	beq.n	8002d52 <refresh_children_style+0x40>
            /*Children with 'glass' parent might be effected if their style == NULL*/
            refresh_children_style(child);
 8002d4c:	68f8      	ldr	r0, [r7, #12]
 8002d4e:	f7ff ffe0 	bl	8002d12 <refresh_children_style>
        }
        child = lv_obj_get_child(obj, child);
 8002d52:	68f9      	ldr	r1, [r7, #12]
 8002d54:	6878      	ldr	r0, [r7, #4]
 8002d56:	f7ff fba1 	bl	800249c <lv_obj_get_child>
 8002d5a:	60f8      	str	r0, [r7, #12]
    while(child != NULL) {
 8002d5c:	68fb      	ldr	r3, [r7, #12]
 8002d5e:	2b00      	cmp	r3, #0
 8002d60:	d1e1      	bne.n	8002d26 <refresh_children_style+0x14>
    }
}
 8002d62:	bf00      	nop
 8002d64:	3710      	adds	r7, #16
 8002d66:	46bd      	mov	sp, r7
 8002d68:	bd80      	pop	{r7, pc}

08002d6a <lv_area_copy>:
{
 8002d6a:	b580      	push	{r7, lr}
 8002d6c:	b082      	sub	sp, #8
 8002d6e:	af00      	add	r7, sp, #0
 8002d70:	6078      	str	r0, [r7, #4]
 8002d72:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 8002d74:	2208      	movs	r2, #8
 8002d76:	6839      	ldr	r1, [r7, #0]
 8002d78:	6878      	ldr	r0, [r7, #4]
 8002d7a:	f010 fce5 	bl	8013748 <memcpy>
}
 8002d7e:	bf00      	nop
 8002d80:	3708      	adds	r7, #8
 8002d82:	46bd      	mov	sp, r7
 8002d84:	bd80      	pop	{r7, pc}

08002d86 <lv_area_get_width>:
{
 8002d86:	b480      	push	{r7}
 8002d88:	b083      	sub	sp, #12
 8002d8a:	af00      	add	r7, sp, #0
 8002d8c:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 8002d8e:	687b      	ldr	r3, [r7, #4]
 8002d90:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8002d94:	b29a      	uxth	r2, r3
 8002d96:	687b      	ldr	r3, [r7, #4]
 8002d98:	f9b3 3000 	ldrsh.w	r3, [r3]
 8002d9c:	b29b      	uxth	r3, r3
 8002d9e:	1ad3      	subs	r3, r2, r3
 8002da0:	b29b      	uxth	r3, r3
 8002da2:	3301      	adds	r3, #1
 8002da4:	b29b      	uxth	r3, r3
 8002da6:	b21b      	sxth	r3, r3
}
 8002da8:	4618      	mov	r0, r3
 8002daa:	370c      	adds	r7, #12
 8002dac:	46bd      	mov	sp, r7
 8002dae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002db2:	4770      	bx	lr

08002db4 <lv_area_get_height>:
{
 8002db4:	b480      	push	{r7}
 8002db6:	b083      	sub	sp, #12
 8002db8:	af00      	add	r7, sp, #0
 8002dba:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 8002dbc:	687b      	ldr	r3, [r7, #4]
 8002dbe:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8002dc2:	b29a      	uxth	r2, r3
 8002dc4:	687b      	ldr	r3, [r7, #4]
 8002dc6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8002dca:	b29b      	uxth	r3, r3
 8002dcc:	1ad3      	subs	r3, r2, r3
 8002dce:	b29b      	uxth	r3, r3
 8002dd0:	3301      	adds	r3, #1
 8002dd2:	b29b      	uxth	r3, r3
 8002dd4:	b21b      	sxth	r3, r3
}
 8002dd6:	4618      	mov	r0, r3
 8002dd8:	370c      	adds	r7, #12
 8002dda:	46bd      	mov	sp, r7
 8002ddc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002de0:	4770      	bx	lr

08002de2 <lv_refr_init>:

/**
 * Initialize the screen refresh subsystem
 */
void lv_refr_init(void)
{
 8002de2:	b480      	push	{r7}
 8002de4:	af00      	add	r7, sp, #0
    /*Nothing to do*/
}
 8002de6:	bf00      	nop
 8002de8:	46bd      	mov	sp, r7
 8002dea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002dee:	4770      	bx	lr

08002df0 <lv_inv_area>:
 * @param area_p pointer to area which should be invalidated (NULL: delete the invalidated areas)
 * @param disp pointer to display where the area should be invalidated (NULL can be used if there is
 * only one display)
 */
void lv_inv_area(lv_disp_t * disp, const lv_area_t * area_p)
{
 8002df0:	b580      	push	{r7, lr}
 8002df2:	b088      	sub	sp, #32
 8002df4:	af00      	add	r7, sp, #0
 8002df6:	6078      	str	r0, [r7, #4]
 8002df8:	6039      	str	r1, [r7, #0]
    if(!disp) disp = lv_disp_get_default();
 8002dfa:	687b      	ldr	r3, [r7, #4]
 8002dfc:	2b00      	cmp	r3, #0
 8002dfe:	d102      	bne.n	8002e06 <lv_inv_area+0x16>
 8002e00:	f008 fdda 	bl	800b9b8 <lv_disp_get_default>
 8002e04:	6078      	str	r0, [r7, #4]
    if(!disp) return;
 8002e06:	687b      	ldr	r3, [r7, #4]
 8002e08:	2b00      	cmp	r3, #0
 8002e0a:	f000 809c 	beq.w	8002f46 <lv_inv_area+0x156>

    /*Clear the invalidate buffer if the parameter is NULL*/
    if(area_p == NULL) {
 8002e0e:	683b      	ldr	r3, [r7, #0]
 8002e10:	2b00      	cmp	r3, #0
 8002e12:	d107      	bne.n	8002e24 <lv_inv_area+0x34>
        disp->inv_p = 0;
 8002e14:	687a      	ldr	r2, [r7, #4]
 8002e16:	f8b2 3164 	ldrh.w	r3, [r2, #356]	; 0x164
 8002e1a:	f36f 0309 	bfc	r3, #0, #10
 8002e1e:	f8a2 3164 	strh.w	r3, [r2, #356]	; 0x164
        return;
 8002e22:	e093      	b.n	8002f4c <lv_inv_area+0x15c>
    }

    lv_area_t scr_area;
    scr_area.x1 = 0;
 8002e24:	2300      	movs	r3, #0
 8002e26:	82bb      	strh	r3, [r7, #20]
    scr_area.y1 = 0;
 8002e28:	2300      	movs	r3, #0
 8002e2a:	82fb      	strh	r3, [r7, #22]
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
 8002e2c:	6878      	ldr	r0, [r7, #4]
 8002e2e:	f008 fdcf 	bl	800b9d0 <lv_disp_get_hor_res>
 8002e32:	4603      	mov	r3, r0
 8002e34:	b29b      	uxth	r3, r3
 8002e36:	3b01      	subs	r3, #1
 8002e38:	b29b      	uxth	r3, r3
 8002e3a:	b21b      	sxth	r3, r3
 8002e3c:	833b      	strh	r3, [r7, #24]
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
 8002e3e:	6878      	ldr	r0, [r7, #4]
 8002e40:	f008 fde7 	bl	800ba12 <lv_disp_get_ver_res>
 8002e44:	4603      	mov	r3, r0
 8002e46:	b29b      	uxth	r3, r3
 8002e48:	3b01      	subs	r3, #1
 8002e4a:	b29b      	uxth	r3, r3
 8002e4c:	b21b      	sxth	r3, r3
 8002e4e:	837b      	strh	r3, [r7, #26]

    lv_area_t com_area;
    bool suc;

    suc = lv_area_intersect(&com_area, area_p, &scr_area);
 8002e50:	f107 0214 	add.w	r2, r7, #20
 8002e54:	f107 030c 	add.w	r3, r7, #12
 8002e58:	6839      	ldr	r1, [r7, #0]
 8002e5a:	4618      	mov	r0, r3
 8002e5c:	f009 f932 	bl	800c0c4 <lv_area_intersect>
 8002e60:	4603      	mov	r3, r0
 8002e62:	777b      	strb	r3, [r7, #29]

    /*The area is truncated to the screen*/
    if(suc != false) {
 8002e64:	7f7b      	ldrb	r3, [r7, #29]
 8002e66:	2b00      	cmp	r3, #0
 8002e68:	d070      	beq.n	8002f4c <lv_inv_area+0x15c>
        if(disp->driver.rounder_cb) disp->driver.rounder_cb(&disp->driver, &com_area);
 8002e6a:	687b      	ldr	r3, [r7, #4]
 8002e6c:	691b      	ldr	r3, [r3, #16]
 8002e6e:	2b00      	cmp	r3, #0
 8002e70:	d006      	beq.n	8002e80 <lv_inv_area+0x90>
 8002e72:	687b      	ldr	r3, [r7, #4]
 8002e74:	691b      	ldr	r3, [r3, #16]
 8002e76:	687a      	ldr	r2, [r7, #4]
 8002e78:	f107 010c 	add.w	r1, r7, #12
 8002e7c:	4610      	mov	r0, r2
 8002e7e:	4798      	blx	r3

        /*Save only if this area is not in one of the saved areas*/
        uint16_t i;
        for(i = 0; i < disp->inv_p; i++) {
 8002e80:	2300      	movs	r3, #0
 8002e82:	83fb      	strh	r3, [r7, #30]
 8002e84:	e011      	b.n	8002eaa <lv_inv_area+0xba>
            if(lv_area_is_in(&com_area, &disp->inv_areas[i]) != false) return;
 8002e86:	8bfb      	ldrh	r3, [r7, #30]
 8002e88:	3308      	adds	r3, #8
 8002e8a:	00db      	lsls	r3, r3, #3
 8002e8c:	687a      	ldr	r2, [r7, #4]
 8002e8e:	4413      	add	r3, r2
 8002e90:	1d1a      	adds	r2, r3, #4
 8002e92:	f107 030c 	add.w	r3, r7, #12
 8002e96:	4611      	mov	r1, r2
 8002e98:	4618      	mov	r0, r3
 8002e9a:	f009 f9ce 	bl	800c23a <lv_area_is_in>
 8002e9e:	4603      	mov	r3, r0
 8002ea0:	2b00      	cmp	r3, #0
 8002ea2:	d152      	bne.n	8002f4a <lv_inv_area+0x15a>
        for(i = 0; i < disp->inv_p; i++) {
 8002ea4:	8bfb      	ldrh	r3, [r7, #30]
 8002ea6:	3301      	adds	r3, #1
 8002ea8:	83fb      	strh	r3, [r7, #30]
 8002eaa:	687b      	ldr	r3, [r7, #4]
 8002eac:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 8002eb0:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8002eb4:	b29b      	uxth	r3, r3
 8002eb6:	461a      	mov	r2, r3
 8002eb8:	8bfb      	ldrh	r3, [r7, #30]
 8002eba:	4293      	cmp	r3, r2
 8002ebc:	d3e3      	bcc.n	8002e86 <lv_inv_area+0x96>
        }

        /*Save the area*/
        if(disp->inv_p < LV_INV_BUF_SIZE) {
 8002ebe:	687b      	ldr	r3, [r7, #4]
 8002ec0:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 8002ec4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8002ec8:	b29b      	uxth	r3, r3
 8002eca:	2b1f      	cmp	r3, #31
 8002ecc:	d811      	bhi.n	8002ef2 <lv_inv_area+0x102>
            lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);
 8002ece:	687b      	ldr	r3, [r7, #4]
 8002ed0:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 8002ed4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8002ed8:	b29b      	uxth	r3, r3
 8002eda:	3308      	adds	r3, #8
 8002edc:	00db      	lsls	r3, r3, #3
 8002ede:	687a      	ldr	r2, [r7, #4]
 8002ee0:	4413      	add	r3, r2
 8002ee2:	3304      	adds	r3, #4
 8002ee4:	f107 020c 	add.w	r2, r7, #12
 8002ee8:	4611      	mov	r1, r2
 8002eea:	4618      	mov	r0, r3
 8002eec:	f7ff ff3d 	bl	8002d6a <lv_area_copy>
 8002ef0:	e017      	b.n	8002f22 <lv_inv_area+0x132>
        } else { /*If no place for the area add the screen*/
            disp->inv_p = 0;
 8002ef2:	687a      	ldr	r2, [r7, #4]
 8002ef4:	f8b2 3164 	ldrh.w	r3, [r2, #356]	; 0x164
 8002ef8:	f36f 0309 	bfc	r3, #0, #10
 8002efc:	f8a2 3164 	strh.w	r3, [r2, #356]	; 0x164
            lv_area_copy(&disp->inv_areas[disp->inv_p], &scr_area);
 8002f00:	687b      	ldr	r3, [r7, #4]
 8002f02:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 8002f06:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8002f0a:	b29b      	uxth	r3, r3
 8002f0c:	3308      	adds	r3, #8
 8002f0e:	00db      	lsls	r3, r3, #3
 8002f10:	687a      	ldr	r2, [r7, #4]
 8002f12:	4413      	add	r3, r2
 8002f14:	3304      	adds	r3, #4
 8002f16:	f107 0214 	add.w	r2, r7, #20
 8002f1a:	4611      	mov	r1, r2
 8002f1c:	4618      	mov	r0, r3
 8002f1e:	f7ff ff24 	bl	8002d6a <lv_area_copy>
        }
        disp->inv_p++;
 8002f22:	687b      	ldr	r3, [r7, #4]
 8002f24:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 8002f28:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8002f2c:	b29b      	uxth	r3, r3
 8002f2e:	3301      	adds	r3, #1
 8002f30:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8002f34:	b299      	uxth	r1, r3
 8002f36:	687a      	ldr	r2, [r7, #4]
 8002f38:	f8b2 3164 	ldrh.w	r3, [r2, #356]	; 0x164
 8002f3c:	f361 0309 	bfi	r3, r1, #0, #10
 8002f40:	f8a2 3164 	strh.w	r3, [r2, #356]	; 0x164
 8002f44:	e002      	b.n	8002f4c <lv_inv_area+0x15c>
    if(!disp) return;
 8002f46:	bf00      	nop
 8002f48:	e000      	b.n	8002f4c <lv_inv_area+0x15c>
            if(lv_area_is_in(&com_area, &disp->inv_areas[i]) != false) return;
 8002f4a:	bf00      	nop
    }
}
 8002f4c:	3720      	adds	r7, #32
 8002f4e:	46bd      	mov	sp, r7
 8002f50:	bd80      	pop	{r7, pc}
	...

08002f54 <lv_refr_get_disp_refreshing>:
/**
 * Get the display which is being refreshed
 * @return the display being refreshed
 */
lv_disp_t * lv_refr_get_disp_refreshing(void)
{
 8002f54:	b480      	push	{r7}
 8002f56:	af00      	add	r7, sp, #0
    return disp_refr;
 8002f58:	4b03      	ldr	r3, [pc, #12]	; (8002f68 <lv_refr_get_disp_refreshing+0x14>)
 8002f5a:	681b      	ldr	r3, [r3, #0]
}
 8002f5c:	4618      	mov	r0, r3
 8002f5e:	46bd      	mov	sp, r7
 8002f60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f64:	4770      	bx	lr
 8002f66:	bf00      	nop
 8002f68:	200000a4 	.word	0x200000a4

08002f6c <lv_disp_refr_task>:
/**
 * Called periodically to handle the refreshing
 * @param task pointer to the task itself
 */
void lv_disp_refr_task(lv_task_t * task)
{
 8002f6c:	b5b0      	push	{r4, r5, r7, lr}
 8002f6e:	b08a      	sub	sp, #40	; 0x28
 8002f70:	af00      	add	r7, sp, #0
 8002f72:	6078      	str	r0, [r7, #4]
    LV_LOG_TRACE("lv_refr_task: started");

    uint32_t start = lv_tick_get();
 8002f74:	f008 fe10 	bl	800bb98 <lv_tick_get>
 8002f78:	61f8      	str	r0, [r7, #28]

    disp_refr = task->user_data;
 8002f7a:	687b      	ldr	r3, [r7, #4]
 8002f7c:	68db      	ldr	r3, [r3, #12]
 8002f7e:	4a6d      	ldr	r2, [pc, #436]	; (8003134 <lv_disp_refr_task+0x1c8>)
 8002f80:	6013      	str	r3, [r2, #0]

    lv_refr_join_area();
 8002f82:	f000 f8db 	bl	800313c <lv_refr_join_area>

    lv_refr_areas();
 8002f86:	f000 f97d 	bl	8003284 <lv_refr_areas>

    /*If refresh happened ...*/
    if(disp_refr->inv_p != 0) {
 8002f8a:	4b6a      	ldr	r3, [pc, #424]	; (8003134 <lv_disp_refr_task+0x1c8>)
 8002f8c:	681b      	ldr	r3, [r3, #0]
 8002f8e:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 8002f92:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8002f96:	b29b      	uxth	r3, r3
 8002f98:	2b00      	cmp	r3, #0
 8002f9a:	f000 80c5 	beq.w	8003128 <lv_disp_refr_task+0x1bc>
        /*In true double buffered mode copy the refreshed areas to the new VDB to keep it up to
         * date*/
        if(lv_disp_is_true_double_buf(disp_refr)) {
 8002f9e:	4b65      	ldr	r3, [pc, #404]	; (8003134 <lv_disp_refr_task+0x1c8>)
 8002fa0:	681b      	ldr	r3, [r3, #0]
 8002fa2:	4618      	mov	r0, r3
 8002fa4:	f008 fda6 	bl	800baf4 <lv_disp_is_true_double_buf>
 8002fa8:	4603      	mov	r3, r0
 8002faa:	2b00      	cmp	r3, #0
 8002fac:	f000 808e 	beq.w	80030cc <lv_disp_refr_task+0x160>
            lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 8002fb0:	4b60      	ldr	r3, [pc, #384]	; (8003134 <lv_disp_refr_task+0x1c8>)
 8002fb2:	681b      	ldr	r3, [r3, #0]
 8002fb4:	4618      	mov	r0, r3
 8002fb6:	f008 fd7a 	bl	800baae <lv_disp_get_buf>
 8002fba:	61b8      	str	r0, [r7, #24]

            /*Flush the content of the VDB*/
            lv_refr_vdb_flush();
 8002fbc:	f000 fc6a 	bl	8003894 <lv_refr_vdb_flush>

            /* With true double buffering the flushing should be only the address change of the
             * current frame buffer. Wait until the address change is ready and copy the changed
             * content to the other frame buffer (new active VDB) to keep the buffers synchronized*/
            while(vdb->flushing)
 8002fc0:	bf00      	nop
 8002fc2:	69bb      	ldr	r3, [r7, #24]
 8002fc4:	699b      	ldr	r3, [r3, #24]
 8002fc6:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8002fca:	b2db      	uxtb	r3, r3
 8002fcc:	2b00      	cmp	r3, #0
 8002fce:	d1f8      	bne.n	8002fc2 <lv_disp_refr_task+0x56>
                ;

            uint8_t * buf_act = (uint8_t *)vdb->buf_act;
 8002fd0:	69bb      	ldr	r3, [r7, #24]
 8002fd2:	689b      	ldr	r3, [r3, #8]
 8002fd4:	617b      	str	r3, [r7, #20]
            uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
 8002fd6:	69bb      	ldr	r3, [r7, #24]
 8002fd8:	689a      	ldr	r2, [r3, #8]
 8002fda:	69bb      	ldr	r3, [r7, #24]
 8002fdc:	681b      	ldr	r3, [r3, #0]
 8002fde:	429a      	cmp	r2, r3
 8002fe0:	d102      	bne.n	8002fe8 <lv_disp_refr_task+0x7c>
 8002fe2:	69bb      	ldr	r3, [r7, #24]
 8002fe4:	685b      	ldr	r3, [r3, #4]
 8002fe6:	e001      	b.n	8002fec <lv_disp_refr_task+0x80>
 8002fe8:	69bb      	ldr	r3, [r7, #24]
 8002fea:	681b      	ldr	r3, [r3, #0]
 8002fec:	613b      	str	r3, [r7, #16]

            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
 8002fee:	4b51      	ldr	r3, [pc, #324]	; (8003134 <lv_disp_refr_task+0x1c8>)
 8002ff0:	681b      	ldr	r3, [r3, #0]
 8002ff2:	4618      	mov	r0, r3
 8002ff4:	f008 fcec 	bl	800b9d0 <lv_disp_get_hor_res>
 8002ff8:	4603      	mov	r3, r0
 8002ffa:	81fb      	strh	r3, [r7, #14]
            uint16_t a;
            for(a = 0; a < disp_refr->inv_p; a++) {
 8002ffc:	2300      	movs	r3, #0
 8002ffe:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003000:	e059      	b.n	80030b6 <lv_disp_refr_task+0x14a>
                if(disp_refr->inv_area_joined[a] == 0) {
 8003002:	4b4c      	ldr	r3, [pc, #304]	; (8003134 <lv_disp_refr_task+0x1c8>)
 8003004:	681a      	ldr	r2, [r3, #0]
 8003006:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003008:	4413      	add	r3, r2
 800300a:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 800300e:	2b00      	cmp	r3, #0
 8003010:	d14e      	bne.n	80030b0 <lv_disp_refr_task+0x144>
                    lv_coord_t y;
                    uint32_t start_offs =
                        (hres * disp_refr->inv_areas[a].y1 + disp_refr->inv_areas[a].x1) * sizeof(lv_color_t);
 8003012:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8003016:	4b47      	ldr	r3, [pc, #284]	; (8003134 <lv_disp_refr_task+0x1c8>)
 8003018:	6819      	ldr	r1, [r3, #0]
 800301a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800301c:	3308      	adds	r3, #8
 800301e:	00db      	lsls	r3, r3, #3
 8003020:	440b      	add	r3, r1
 8003022:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8003026:	fb03 f202 	mul.w	r2, r3, r2
 800302a:	4b42      	ldr	r3, [pc, #264]	; (8003134 <lv_disp_refr_task+0x1c8>)
 800302c:	6819      	ldr	r1, [r3, #0]
 800302e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003030:	3308      	adds	r3, #8
 8003032:	00db      	lsls	r3, r3, #3
 8003034:	440b      	add	r3, r1
 8003036:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800303a:	4413      	add	r3, r2
                    uint32_t start_offs =
 800303c:	005b      	lsls	r3, r3, #1
 800303e:	623b      	str	r3, [r7, #32]
                    uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
 8003040:	4b3c      	ldr	r3, [pc, #240]	; (8003134 <lv_disp_refr_task+0x1c8>)
 8003042:	681a      	ldr	r2, [r3, #0]
 8003044:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003046:	3308      	adds	r3, #8
 8003048:	00db      	lsls	r3, r3, #3
 800304a:	4413      	add	r3, r2
 800304c:	3304      	adds	r3, #4
 800304e:	4618      	mov	r0, r3
 8003050:	f7ff fe99 	bl	8002d86 <lv_area_get_width>
 8003054:	4603      	mov	r3, r0
 8003056:	005b      	lsls	r3, r3, #1
 8003058:	60bb      	str	r3, [r7, #8]

                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
 800305a:	4b36      	ldr	r3, [pc, #216]	; (8003134 <lv_disp_refr_task+0x1c8>)
 800305c:	681a      	ldr	r2, [r3, #0]
 800305e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003060:	3308      	adds	r3, #8
 8003062:	00db      	lsls	r3, r3, #3
 8003064:	4413      	add	r3, r2
 8003066:	88db      	ldrh	r3, [r3, #6]
 8003068:	84bb      	strh	r3, [r7, #36]	; 0x24
 800306a:	e015      	b.n	8003098 <lv_disp_refr_task+0x12c>
                        memcpy(buf_act + start_offs, buf_ina + start_offs, line_length);
 800306c:	697a      	ldr	r2, [r7, #20]
 800306e:	6a3b      	ldr	r3, [r7, #32]
 8003070:	18d0      	adds	r0, r2, r3
 8003072:	693a      	ldr	r2, [r7, #16]
 8003074:	6a3b      	ldr	r3, [r7, #32]
 8003076:	4413      	add	r3, r2
 8003078:	68ba      	ldr	r2, [r7, #8]
 800307a:	4619      	mov	r1, r3
 800307c:	f010 fb64 	bl	8013748 <memcpy>
                        start_offs += hres * sizeof(lv_color_t);
 8003080:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8003084:	005b      	lsls	r3, r3, #1
 8003086:	6a3a      	ldr	r2, [r7, #32]
 8003088:	4413      	add	r3, r2
 800308a:	623b      	str	r3, [r7, #32]
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
 800308c:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003090:	b29b      	uxth	r3, r3
 8003092:	3301      	adds	r3, #1
 8003094:	b29b      	uxth	r3, r3
 8003096:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003098:	4b26      	ldr	r3, [pc, #152]	; (8003134 <lv_disp_refr_task+0x1c8>)
 800309a:	681a      	ldr	r2, [r3, #0]
 800309c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800309e:	3308      	adds	r3, #8
 80030a0:	00db      	lsls	r3, r3, #3
 80030a2:	4413      	add	r3, r2
 80030a4:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 80030a8:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 80030ac:	429a      	cmp	r2, r3
 80030ae:	dddd      	ble.n	800306c <lv_disp_refr_task+0x100>
            for(a = 0; a < disp_refr->inv_p; a++) {
 80030b0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80030b2:	3301      	adds	r3, #1
 80030b4:	84fb      	strh	r3, [r7, #38]	; 0x26
 80030b6:	4b1f      	ldr	r3, [pc, #124]	; (8003134 <lv_disp_refr_task+0x1c8>)
 80030b8:	681b      	ldr	r3, [r3, #0]
 80030ba:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 80030be:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80030c2:	b29b      	uxth	r3, r3
 80030c4:	461a      	mov	r2, r3
 80030c6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80030c8:	4293      	cmp	r3, r2
 80030ca:	d39a      	bcc.n	8003002 <lv_disp_refr_task+0x96>
                }
            }
        } /*End of true double buffer handling*/

        /*Clean up*/
        memset(disp_refr->inv_areas, 0, sizeof(disp_refr->inv_areas));
 80030cc:	4b19      	ldr	r3, [pc, #100]	; (8003134 <lv_disp_refr_task+0x1c8>)
 80030ce:	681b      	ldr	r3, [r3, #0]
 80030d0:	3344      	adds	r3, #68	; 0x44
 80030d2:	f44f 7280 	mov.w	r2, #256	; 0x100
 80030d6:	2100      	movs	r1, #0
 80030d8:	4618      	mov	r0, r3
 80030da:	f010 fb40 	bl	801375e <memset>
        memset(disp_refr->inv_area_joined, 0, sizeof(disp_refr->inv_area_joined));
 80030de:	4b15      	ldr	r3, [pc, #84]	; (8003134 <lv_disp_refr_task+0x1c8>)
 80030e0:	681b      	ldr	r3, [r3, #0]
 80030e2:	f503 73a2 	add.w	r3, r3, #324	; 0x144
 80030e6:	2220      	movs	r2, #32
 80030e8:	2100      	movs	r1, #0
 80030ea:	4618      	mov	r0, r3
 80030ec:	f010 fb37 	bl	801375e <memset>
        disp_refr->inv_p = 0;
 80030f0:	4b10      	ldr	r3, [pc, #64]	; (8003134 <lv_disp_refr_task+0x1c8>)
 80030f2:	681a      	ldr	r2, [r3, #0]
 80030f4:	f8b2 3164 	ldrh.w	r3, [r2, #356]	; 0x164
 80030f8:	f36f 0309 	bfc	r3, #0, #10
 80030fc:	f8a2 3164 	strh.w	r3, [r2, #356]	; 0x164

        /*Call monitor cb if present*/
        if(disp_refr->driver.monitor_cb) {
 8003100:	4b0c      	ldr	r3, [pc, #48]	; (8003134 <lv_disp_refr_task+0x1c8>)
 8003102:	681b      	ldr	r3, [r3, #0]
 8003104:	699b      	ldr	r3, [r3, #24]
 8003106:	2b00      	cmp	r3, #0
 8003108:	d00e      	beq.n	8003128 <lv_disp_refr_task+0x1bc>
            disp_refr->driver.monitor_cb(&disp_refr->driver, lv_tick_elaps(start), px_num);
 800310a:	4b0a      	ldr	r3, [pc, #40]	; (8003134 <lv_disp_refr_task+0x1c8>)
 800310c:	681b      	ldr	r3, [r3, #0]
 800310e:	699c      	ldr	r4, [r3, #24]
 8003110:	4b08      	ldr	r3, [pc, #32]	; (8003134 <lv_disp_refr_task+0x1c8>)
 8003112:	681b      	ldr	r3, [r3, #0]
 8003114:	461d      	mov	r5, r3
 8003116:	69f8      	ldr	r0, [r7, #28]
 8003118:	f008 fd58 	bl	800bbcc <lv_tick_elaps>
 800311c:	4601      	mov	r1, r0
 800311e:	4b06      	ldr	r3, [pc, #24]	; (8003138 <lv_disp_refr_task+0x1cc>)
 8003120:	681b      	ldr	r3, [r3, #0]
 8003122:	461a      	mov	r2, r3
 8003124:	4628      	mov	r0, r5
 8003126:	47a0      	blx	r4
        }
    }

    lv_draw_free_buf();
 8003128:	f000 fef0 	bl	8003f0c <lv_draw_free_buf>

    LV_LOG_TRACE("lv_refr_task: ready");
}
 800312c:	bf00      	nop
 800312e:	3728      	adds	r7, #40	; 0x28
 8003130:	46bd      	mov	sp, r7
 8003132:	bdb0      	pop	{r4, r5, r7, pc}
 8003134:	200000a4 	.word	0x200000a4
 8003138:	200000a0 	.word	0x200000a0

0800313c <lv_refr_join_area>:

/**
 * Join the areas which has got common parts
 */
static void lv_refr_join_area(void)
{
 800313c:	b5b0      	push	{r4, r5, r7, lr}
 800313e:	b084      	sub	sp, #16
 8003140:	af00      	add	r7, sp, #0
    uint32_t join_from;
    uint32_t join_in;
    lv_area_t joined_area;
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
 8003142:	2300      	movs	r3, #0
 8003144:	60bb      	str	r3, [r7, #8]
 8003146:	e08a      	b.n	800325e <lv_refr_join_area+0x122>
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
 8003148:	4b4d      	ldr	r3, [pc, #308]	; (8003280 <lv_refr_join_area+0x144>)
 800314a:	681a      	ldr	r2, [r3, #0]
 800314c:	68bb      	ldr	r3, [r7, #8]
 800314e:	4413      	add	r3, r2
 8003150:	f503 73a2 	add.w	r3, r3, #324	; 0x144
 8003154:	781b      	ldrb	r3, [r3, #0]
 8003156:	2b00      	cmp	r3, #0
 8003158:	d17d      	bne.n	8003256 <lv_refr_join_area+0x11a>

        /*Check all areas to join them in 'join_in'*/
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
 800315a:	2300      	movs	r3, #0
 800315c:	60fb      	str	r3, [r7, #12]
 800315e:	e06e      	b.n	800323e <lv_refr_join_area+0x102>
            /*Handle only unjoined areas and ignore itself*/
            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {
 8003160:	4b47      	ldr	r3, [pc, #284]	; (8003280 <lv_refr_join_area+0x144>)
 8003162:	681a      	ldr	r2, [r3, #0]
 8003164:	68fb      	ldr	r3, [r7, #12]
 8003166:	4413      	add	r3, r2
 8003168:	f503 73a2 	add.w	r3, r3, #324	; 0x144
 800316c:	781b      	ldrb	r3, [r3, #0]
 800316e:	2b00      	cmp	r3, #0
 8003170:	d15f      	bne.n	8003232 <lv_refr_join_area+0xf6>
 8003172:	68ba      	ldr	r2, [r7, #8]
 8003174:	68fb      	ldr	r3, [r7, #12]
 8003176:	429a      	cmp	r2, r3
 8003178:	d05b      	beq.n	8003232 <lv_refr_join_area+0xf6>
                continue;
            }

            /*Check if the areas are on each other*/
            if(lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {
 800317a:	4b41      	ldr	r3, [pc, #260]	; (8003280 <lv_refr_join_area+0x144>)
 800317c:	681a      	ldr	r2, [r3, #0]
 800317e:	68bb      	ldr	r3, [r7, #8]
 8003180:	3308      	adds	r3, #8
 8003182:	00db      	lsls	r3, r3, #3
 8003184:	4413      	add	r3, r2
 8003186:	1d18      	adds	r0, r3, #4
 8003188:	4b3d      	ldr	r3, [pc, #244]	; (8003280 <lv_refr_join_area+0x144>)
 800318a:	681a      	ldr	r2, [r3, #0]
 800318c:	68fb      	ldr	r3, [r7, #12]
 800318e:	3308      	adds	r3, #8
 8003190:	00db      	lsls	r3, r3, #3
 8003192:	4413      	add	r3, r2
 8003194:	3304      	adds	r3, #4
 8003196:	4619      	mov	r1, r3
 8003198:	f009 f821 	bl	800c1de <lv_area_is_on>
 800319c:	4603      	mov	r3, r0
 800319e:	f083 0301 	eor.w	r3, r3, #1
 80031a2:	b2db      	uxtb	r3, r3
 80031a4:	2b00      	cmp	r3, #0
 80031a6:	d146      	bne.n	8003236 <lv_refr_join_area+0xfa>
                continue;
            }

            lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);
 80031a8:	4b35      	ldr	r3, [pc, #212]	; (8003280 <lv_refr_join_area+0x144>)
 80031aa:	681a      	ldr	r2, [r3, #0]
 80031ac:	68bb      	ldr	r3, [r7, #8]
 80031ae:	3308      	adds	r3, #8
 80031b0:	00db      	lsls	r3, r3, #3
 80031b2:	4413      	add	r3, r2
 80031b4:	1d19      	adds	r1, r3, #4
 80031b6:	4b32      	ldr	r3, [pc, #200]	; (8003280 <lv_refr_join_area+0x144>)
 80031b8:	681a      	ldr	r2, [r3, #0]
 80031ba:	68fb      	ldr	r3, [r7, #12]
 80031bc:	3308      	adds	r3, #8
 80031be:	00db      	lsls	r3, r3, #3
 80031c0:	4413      	add	r3, r2
 80031c2:	1d1a      	adds	r2, r3, #4
 80031c4:	463b      	mov	r3, r7
 80031c6:	4618      	mov	r0, r3
 80031c8:	f008 ffcd 	bl	800c166 <lv_area_join>

            /*Join two area only if the joined area size is smaller*/
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
 80031cc:	463b      	mov	r3, r7
 80031ce:	4618      	mov	r0, r3
 80031d0:	f008 ff57 	bl	800c082 <lv_area_get_size>
 80031d4:	4604      	mov	r4, r0
 80031d6:	4b2a      	ldr	r3, [pc, #168]	; (8003280 <lv_refr_join_area+0x144>)
 80031d8:	681a      	ldr	r2, [r3, #0]
 80031da:	68bb      	ldr	r3, [r7, #8]
 80031dc:	3308      	adds	r3, #8
 80031de:	00db      	lsls	r3, r3, #3
 80031e0:	4413      	add	r3, r2
 80031e2:	3304      	adds	r3, #4
 80031e4:	4618      	mov	r0, r3
 80031e6:	f008 ff4c 	bl	800c082 <lv_area_get_size>
 80031ea:	4605      	mov	r5, r0
                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {
 80031ec:	4b24      	ldr	r3, [pc, #144]	; (8003280 <lv_refr_join_area+0x144>)
 80031ee:	681a      	ldr	r2, [r3, #0]
 80031f0:	68fb      	ldr	r3, [r7, #12]
 80031f2:	3308      	adds	r3, #8
 80031f4:	00db      	lsls	r3, r3, #3
 80031f6:	4413      	add	r3, r2
 80031f8:	3304      	adds	r3, #4
 80031fa:	4618      	mov	r0, r3
 80031fc:	f008 ff41 	bl	800c082 <lv_area_get_size>
 8003200:	4603      	mov	r3, r0
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
 8003202:	442b      	add	r3, r5
 8003204:	429c      	cmp	r4, r3
 8003206:	d217      	bcs.n	8003238 <lv_refr_join_area+0xfc>
                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);
 8003208:	4b1d      	ldr	r3, [pc, #116]	; (8003280 <lv_refr_join_area+0x144>)
 800320a:	681a      	ldr	r2, [r3, #0]
 800320c:	68bb      	ldr	r3, [r7, #8]
 800320e:	3308      	adds	r3, #8
 8003210:	00db      	lsls	r3, r3, #3
 8003212:	4413      	add	r3, r2
 8003214:	3304      	adds	r3, #4
 8003216:	463a      	mov	r2, r7
 8003218:	4611      	mov	r1, r2
 800321a:	4618      	mov	r0, r3
 800321c:	f7ff fda5 	bl	8002d6a <lv_area_copy>

                /*Mark 'join_form' is joined into 'join_in'*/
                disp_refr->inv_area_joined[join_from] = 1;
 8003220:	4b17      	ldr	r3, [pc, #92]	; (8003280 <lv_refr_join_area+0x144>)
 8003222:	681a      	ldr	r2, [r3, #0]
 8003224:	68fb      	ldr	r3, [r7, #12]
 8003226:	4413      	add	r3, r2
 8003228:	f503 73a2 	add.w	r3, r3, #324	; 0x144
 800322c:	2201      	movs	r2, #1
 800322e:	701a      	strb	r2, [r3, #0]
 8003230:	e002      	b.n	8003238 <lv_refr_join_area+0xfc>
                continue;
 8003232:	bf00      	nop
 8003234:	e000      	b.n	8003238 <lv_refr_join_area+0xfc>
                continue;
 8003236:	bf00      	nop
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
 8003238:	68fb      	ldr	r3, [r7, #12]
 800323a:	3301      	adds	r3, #1
 800323c:	60fb      	str	r3, [r7, #12]
 800323e:	4b10      	ldr	r3, [pc, #64]	; (8003280 <lv_refr_join_area+0x144>)
 8003240:	681b      	ldr	r3, [r3, #0]
 8003242:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 8003246:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800324a:	b29b      	uxth	r3, r3
 800324c:	461a      	mov	r2, r3
 800324e:	68fb      	ldr	r3, [r7, #12]
 8003250:	4293      	cmp	r3, r2
 8003252:	d385      	bcc.n	8003160 <lv_refr_join_area+0x24>
 8003254:	e000      	b.n	8003258 <lv_refr_join_area+0x11c>
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
 8003256:	bf00      	nop
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
 8003258:	68bb      	ldr	r3, [r7, #8]
 800325a:	3301      	adds	r3, #1
 800325c:	60bb      	str	r3, [r7, #8]
 800325e:	4b08      	ldr	r3, [pc, #32]	; (8003280 <lv_refr_join_area+0x144>)
 8003260:	681b      	ldr	r3, [r3, #0]
 8003262:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 8003266:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800326a:	b29b      	uxth	r3, r3
 800326c:	461a      	mov	r2, r3
 800326e:	68bb      	ldr	r3, [r7, #8]
 8003270:	4293      	cmp	r3, r2
 8003272:	f4ff af69 	bcc.w	8003148 <lv_refr_join_area+0xc>
            }
        }
    }
}
 8003276:	bf00      	nop
 8003278:	3710      	adds	r7, #16
 800327a:	46bd      	mov	sp, r7
 800327c:	bdb0      	pop	{r4, r5, r7, pc}
 800327e:	bf00      	nop
 8003280:	200000a4 	.word	0x200000a4

08003284 <lv_refr_areas>:

/**
 * Refresh the joined areas
 */
static void lv_refr_areas(void)
{
 8003284:	b580      	push	{r7, lr}
 8003286:	b082      	sub	sp, #8
 8003288:	af00      	add	r7, sp, #0
    px_num = 0;
 800328a:	4b20      	ldr	r3, [pc, #128]	; (800330c <lv_refr_areas+0x88>)
 800328c:	2200      	movs	r2, #0
 800328e:	601a      	str	r2, [r3, #0]
    uint32_t i;

    for(i = 0; i < disp_refr->inv_p; i++) {
 8003290:	2300      	movs	r3, #0
 8003292:	607b      	str	r3, [r7, #4]
 8003294:	e02a      	b.n	80032ec <lv_refr_areas+0x68>
        /*Refresh the unjoined areas*/
        if(disp_refr->inv_area_joined[i] == 0) {
 8003296:	4b1e      	ldr	r3, [pc, #120]	; (8003310 <lv_refr_areas+0x8c>)
 8003298:	681a      	ldr	r2, [r3, #0]
 800329a:	687b      	ldr	r3, [r7, #4]
 800329c:	4413      	add	r3, r2
 800329e:	f503 73a2 	add.w	r3, r3, #324	; 0x144
 80032a2:	781b      	ldrb	r3, [r3, #0]
 80032a4:	2b00      	cmp	r3, #0
 80032a6:	d11e      	bne.n	80032e6 <lv_refr_areas+0x62>

            lv_refr_area(&disp_refr->inv_areas[i]);
 80032a8:	4b19      	ldr	r3, [pc, #100]	; (8003310 <lv_refr_areas+0x8c>)
 80032aa:	681a      	ldr	r2, [r3, #0]
 80032ac:	687b      	ldr	r3, [r7, #4]
 80032ae:	3308      	adds	r3, #8
 80032b0:	00db      	lsls	r3, r3, #3
 80032b2:	4413      	add	r3, r2
 80032b4:	3304      	adds	r3, #4
 80032b6:	4618      	mov	r0, r3
 80032b8:	f000 f82c 	bl	8003314 <lv_refr_area>

            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
 80032bc:	4b14      	ldr	r3, [pc, #80]	; (8003310 <lv_refr_areas+0x8c>)
 80032be:	681b      	ldr	r3, [r3, #0]
 80032c0:	699b      	ldr	r3, [r3, #24]
 80032c2:	2b00      	cmp	r3, #0
 80032c4:	d00f      	beq.n	80032e6 <lv_refr_areas+0x62>
 80032c6:	4b12      	ldr	r3, [pc, #72]	; (8003310 <lv_refr_areas+0x8c>)
 80032c8:	681a      	ldr	r2, [r3, #0]
 80032ca:	687b      	ldr	r3, [r7, #4]
 80032cc:	3308      	adds	r3, #8
 80032ce:	00db      	lsls	r3, r3, #3
 80032d0:	4413      	add	r3, r2
 80032d2:	3304      	adds	r3, #4
 80032d4:	4618      	mov	r0, r3
 80032d6:	f008 fed4 	bl	800c082 <lv_area_get_size>
 80032da:	4602      	mov	r2, r0
 80032dc:	4b0b      	ldr	r3, [pc, #44]	; (800330c <lv_refr_areas+0x88>)
 80032de:	681b      	ldr	r3, [r3, #0]
 80032e0:	4413      	add	r3, r2
 80032e2:	4a0a      	ldr	r2, [pc, #40]	; (800330c <lv_refr_areas+0x88>)
 80032e4:	6013      	str	r3, [r2, #0]
    for(i = 0; i < disp_refr->inv_p; i++) {
 80032e6:	687b      	ldr	r3, [r7, #4]
 80032e8:	3301      	adds	r3, #1
 80032ea:	607b      	str	r3, [r7, #4]
 80032ec:	4b08      	ldr	r3, [pc, #32]	; (8003310 <lv_refr_areas+0x8c>)
 80032ee:	681b      	ldr	r3, [r3, #0]
 80032f0:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 80032f4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80032f8:	b29b      	uxth	r3, r3
 80032fa:	461a      	mov	r2, r3
 80032fc:	687b      	ldr	r3, [r7, #4]
 80032fe:	4293      	cmp	r3, r2
 8003300:	d3c9      	bcc.n	8003296 <lv_refr_areas+0x12>
        }
    }
}
 8003302:	bf00      	nop
 8003304:	3708      	adds	r7, #8
 8003306:	46bd      	mov	sp, r7
 8003308:	bd80      	pop	{r7, pc}
 800330a:	bf00      	nop
 800330c:	200000a0 	.word	0x200000a0
 8003310:	200000a4 	.word	0x200000a4

08003314 <lv_refr_area>:
/**
 * Refresh an area if there is Virtual Display Buffer
 * @param area_p  pointer to an area to refresh
 */
static void lv_refr_area(const lv_area_t * area_p)
{
 8003314:	b590      	push	{r4, r7, lr}
 8003316:	b08d      	sub	sp, #52	; 0x34
 8003318:	af00      	add	r7, sp, #0
 800331a:	6078      	str	r0, [r7, #4]
    /*True double buffering: there are two screen sized buffers. Just redraw directly into a
     * buffer*/
    if(lv_disp_is_true_double_buf(disp_refr)) {
 800331c:	4b7f      	ldr	r3, [pc, #508]	; (800351c <lv_refr_area+0x208>)
 800331e:	681b      	ldr	r3, [r3, #0]
 8003320:	4618      	mov	r0, r3
 8003322:	f008 fbe7 	bl	800baf4 <lv_disp_is_true_double_buf>
 8003326:	4603      	mov	r3, r0
 8003328:	2b00      	cmp	r3, #0
 800332a:	d027      	beq.n	800337c <lv_refr_area+0x68>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 800332c:	4b7b      	ldr	r3, [pc, #492]	; (800351c <lv_refr_area+0x208>)
 800332e:	681b      	ldr	r3, [r3, #0]
 8003330:	4618      	mov	r0, r3
 8003332:	f008 fbbc 	bl	800baae <lv_disp_get_buf>
 8003336:	6178      	str	r0, [r7, #20]
        vdb->area.x1        = 0;
 8003338:	697b      	ldr	r3, [r7, #20]
 800333a:	2200      	movs	r2, #0
 800333c:	821a      	strh	r2, [r3, #16]
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
 800333e:	4b77      	ldr	r3, [pc, #476]	; (800351c <lv_refr_area+0x208>)
 8003340:	681b      	ldr	r3, [r3, #0]
 8003342:	4618      	mov	r0, r3
 8003344:	f008 fb44 	bl	800b9d0 <lv_disp_get_hor_res>
 8003348:	4603      	mov	r3, r0
 800334a:	b29b      	uxth	r3, r3
 800334c:	3b01      	subs	r3, #1
 800334e:	b29b      	uxth	r3, r3
 8003350:	b21a      	sxth	r2, r3
 8003352:	697b      	ldr	r3, [r7, #20]
 8003354:	829a      	strh	r2, [r3, #20]
        vdb->area.y1        = 0;
 8003356:	697b      	ldr	r3, [r7, #20]
 8003358:	2200      	movs	r2, #0
 800335a:	825a      	strh	r2, [r3, #18]
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
 800335c:	4b6f      	ldr	r3, [pc, #444]	; (800351c <lv_refr_area+0x208>)
 800335e:	681b      	ldr	r3, [r3, #0]
 8003360:	4618      	mov	r0, r3
 8003362:	f008 fb56 	bl	800ba12 <lv_disp_get_ver_res>
 8003366:	4603      	mov	r3, r0
 8003368:	b29b      	uxth	r3, r3
 800336a:	3b01      	subs	r3, #1
 800336c:	b29b      	uxth	r3, r3
 800336e:	b21a      	sxth	r2, r3
 8003370:	697b      	ldr	r3, [r7, #20]
 8003372:	82da      	strh	r2, [r3, #22]
        lv_refr_area_part(area_p);
 8003374:	6878      	ldr	r0, [r7, #4]
 8003376:	f000 f8d3 	bl	8003520 <lv_refr_area_part>
 800337a:	e0cb      	b.n	8003514 <lv_refr_area+0x200>
    }
    /*The buffer is smaller: refresh the area in parts*/
    else {
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 800337c:	4b67      	ldr	r3, [pc, #412]	; (800351c <lv_refr_area+0x208>)
 800337e:	681b      	ldr	r3, [r3, #0]
 8003380:	4618      	mov	r0, r3
 8003382:	f008 fb94 	bl	800baae <lv_disp_get_buf>
 8003386:	6238      	str	r0, [r7, #32]
        /*Calculate the max row num*/
        lv_coord_t w = lv_area_get_width(area_p);
 8003388:	6878      	ldr	r0, [r7, #4]
 800338a:	f7ff fcfc 	bl	8002d86 <lv_area_get_width>
 800338e:	4603      	mov	r3, r0
 8003390:	83fb      	strh	r3, [r7, #30]
        lv_coord_t h = lv_area_get_height(area_p);
 8003392:	6878      	ldr	r0, [r7, #4]
 8003394:	f7ff fd0e 	bl	8002db4 <lv_area_get_height>
 8003398:	4603      	mov	r3, r0
 800339a:	83bb      	strh	r3, [r7, #28]
        lv_coord_t y2 =
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
 800339c:	687b      	ldr	r3, [r7, #4]
 800339e:	f9b3 4006 	ldrsh.w	r4, [r3, #6]
 80033a2:	4b5e      	ldr	r3, [pc, #376]	; (800351c <lv_refr_area+0x208>)
 80033a4:	681b      	ldr	r3, [r3, #0]
 80033a6:	4618      	mov	r0, r3
 80033a8:	f008 fb33 	bl	800ba12 <lv_disp_get_ver_res>
 80033ac:	4603      	mov	r3, r0
        lv_coord_t y2 =
 80033ae:	429c      	cmp	r4, r3
 80033b0:	db0c      	blt.n	80033cc <lv_refr_area+0xb8>
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
 80033b2:	4b5a      	ldr	r3, [pc, #360]	; (800351c <lv_refr_area+0x208>)
 80033b4:	681b      	ldr	r3, [r3, #0]
 80033b6:	4618      	mov	r0, r3
 80033b8:	f008 fb2b 	bl	800ba12 <lv_disp_get_ver_res>
 80033bc:	4603      	mov	r3, r0
 80033be:	b29b      	uxth	r3, r3
 80033c0:	3b01      	subs	r3, #1
 80033c2:	b29b      	uxth	r3, r3
 80033c4:	837b      	strh	r3, [r7, #26]
        lv_coord_t y2 =
 80033c6:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80033ca:	e002      	b.n	80033d2 <lv_refr_area+0xbe>
 80033cc:	687b      	ldr	r3, [r7, #4]
 80033ce:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80033d2:	837b      	strh	r3, [r7, #26]

        int32_t max_row = (uint32_t)vdb->size / w;
 80033d4:	6a3b      	ldr	r3, [r7, #32]
 80033d6:	68da      	ldr	r2, [r3, #12]
 80033d8:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80033dc:	fbb2 f3f3 	udiv	r3, r2, r3
 80033e0:	62fb      	str	r3, [r7, #44]	; 0x2c

        if(max_row > h) max_row = h;
 80033e2:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 80033e6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80033e8:	429a      	cmp	r2, r3
 80033ea:	dd02      	ble.n	80033f2 <lv_refr_area+0xde>
 80033ec:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 80033f0:	62fb      	str	r3, [r7, #44]	; 0x2c

        /*Round down the lines of VDB if rounding is added*/
        if(disp_refr->driver.rounder_cb) {
 80033f2:	4b4a      	ldr	r3, [pc, #296]	; (800351c <lv_refr_area+0x208>)
 80033f4:	681b      	ldr	r3, [r3, #0]
 80033f6:	691b      	ldr	r3, [r3, #16]
 80033f8:	2b00      	cmp	r3, #0
 80033fa:	d034      	beq.n	8003466 <lv_refr_area+0x152>
            lv_area_t tmp;
            tmp.x1 = 0;
 80033fc:	2300      	movs	r3, #0
 80033fe:	81bb      	strh	r3, [r7, #12]
            tmp.x2 = 0;
 8003400:	2300      	movs	r3, #0
 8003402:	823b      	strh	r3, [r7, #16]
            tmp.y1 = 0;
 8003404:	2300      	movs	r3, #0
 8003406:	81fb      	strh	r3, [r7, #14]

            lv_coord_t h_tmp = max_row;
 8003408:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800340a:	857b      	strh	r3, [r7, #42]	; 0x2a
            do {
                tmp.y2 = h_tmp - 1;
 800340c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800340e:	3b01      	subs	r3, #1
 8003410:	b29b      	uxth	r3, r3
 8003412:	b21b      	sxth	r3, r3
 8003414:	827b      	strh	r3, [r7, #18]
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
 8003416:	4b41      	ldr	r3, [pc, #260]	; (800351c <lv_refr_area+0x208>)
 8003418:	681b      	ldr	r3, [r3, #0]
 800341a:	691b      	ldr	r3, [r3, #16]
 800341c:	4a3f      	ldr	r2, [pc, #252]	; (800351c <lv_refr_area+0x208>)
 800341e:	6812      	ldr	r2, [r2, #0]
 8003420:	4610      	mov	r0, r2
 8003422:	f107 020c 	add.w	r2, r7, #12
 8003426:	4611      	mov	r1, r2
 8003428:	4798      	blx	r3

                /*If this height fits into `max_row` then fine*/
                if(lv_area_get_height(&tmp) <= max_row) break;
 800342a:	f107 030c 	add.w	r3, r7, #12
 800342e:	4618      	mov	r0, r3
 8003430:	f7ff fcc0 	bl	8002db4 <lv_area_get_height>
 8003434:	4603      	mov	r3, r0
 8003436:	461a      	mov	r2, r3
 8003438:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800343a:	4293      	cmp	r3, r2
 800343c:	da0a      	bge.n	8003454 <lv_refr_area+0x140>

                /*Decrement the height of the area until it fits into `max_row` after rounding*/
                h_tmp--;
 800343e:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8003442:	b29b      	uxth	r3, r3
 8003444:	3b01      	subs	r3, #1
 8003446:	b29b      	uxth	r3, r3
 8003448:	857b      	strh	r3, [r7, #42]	; 0x2a
            } while(h_tmp > 0);
 800344a:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 800344e:	2b00      	cmp	r3, #0
 8003450:	dcdc      	bgt.n	800340c <lv_refr_area+0xf8>
 8003452:	e000      	b.n	8003456 <lv_refr_area+0x142>
                if(lv_area_get_height(&tmp) <= max_row) break;
 8003454:	bf00      	nop

            if(h_tmp <= 0) {
 8003456:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 800345a:	2b00      	cmp	r3, #0
 800345c:	dd59      	ble.n	8003512 <lv_refr_area+0x1fe>
                LV_LOG_WARN("Can't set VDB height using the round function. (Wrong round_cb or to "
                            "small VDB)");
                return;
            } else {
                max_row = tmp.y2 + 1;
 800345e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8003462:	3301      	adds	r3, #1
 8003464:	62fb      	str	r3, [r7, #44]	; 0x2c
            }
        }

        /*Always use the full row*/
        lv_coord_t row;
        lv_coord_t row_last = 0;
 8003466:	2300      	movs	r3, #0
 8003468:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
 800346a:	687b      	ldr	r3, [r7, #4]
 800346c:	885b      	ldrh	r3, [r3, #2]
 800346e:	853b      	strh	r3, [r7, #40]	; 0x28
 8003470:	e02c      	b.n	80034cc <lv_refr_area+0x1b8>
            /*Calc. the next y coordinates of VDB*/
            vdb->area.x1 = area_p->x1;
 8003472:	687b      	ldr	r3, [r7, #4]
 8003474:	f9b3 2000 	ldrsh.w	r2, [r3]
 8003478:	6a3b      	ldr	r3, [r7, #32]
 800347a:	821a      	strh	r2, [r3, #16]
            vdb->area.x2 = area_p->x2;
 800347c:	687b      	ldr	r3, [r7, #4]
 800347e:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 8003482:	6a3b      	ldr	r3, [r7, #32]
 8003484:	829a      	strh	r2, [r3, #20]
            vdb->area.y1 = row;
 8003486:	6a3b      	ldr	r3, [r7, #32]
 8003488:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 800348a:	825a      	strh	r2, [r3, #18]
            vdb->area.y2 = row + max_row - 1;
 800348c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800348e:	b29a      	uxth	r2, r3
 8003490:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8003492:	4413      	add	r3, r2
 8003494:	b29b      	uxth	r3, r3
 8003496:	3b01      	subs	r3, #1
 8003498:	b29b      	uxth	r3, r3
 800349a:	b21a      	sxth	r2, r3
 800349c:	6a3b      	ldr	r3, [r7, #32]
 800349e:	82da      	strh	r2, [r3, #22]
            if(vdb->area.y2 > y2) vdb->area.y2 = y2;
 80034a0:	6a3b      	ldr	r3, [r7, #32]
 80034a2:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 80034a6:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 80034aa:	429a      	cmp	r2, r3
 80034ac:	da02      	bge.n	80034b4 <lv_refr_area+0x1a0>
 80034ae:	6a3b      	ldr	r3, [r7, #32]
 80034b0:	8b7a      	ldrh	r2, [r7, #26]
 80034b2:	82da      	strh	r2, [r3, #22]
            row_last = vdb->area.y2;
 80034b4:	6a3b      	ldr	r3, [r7, #32]
 80034b6:	8adb      	ldrh	r3, [r3, #22]
 80034b8:	84fb      	strh	r3, [r7, #38]	; 0x26
            lv_refr_area_part(area_p);
 80034ba:	6878      	ldr	r0, [r7, #4]
 80034bc:	f000 f830 	bl	8003520 <lv_refr_area_part>
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
 80034c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80034c2:	b29a      	uxth	r2, r3
 80034c4:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80034c6:	4413      	add	r3, r2
 80034c8:	b29b      	uxth	r3, r3
 80034ca:	853b      	strh	r3, [r7, #40]	; 0x28
 80034cc:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
 80034d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80034d2:	4413      	add	r3, r2
 80034d4:	1e5a      	subs	r2, r3, #1
 80034d6:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80034da:	429a      	cmp	r2, r3
 80034dc:	ddc9      	ble.n	8003472 <lv_refr_area+0x15e>
        }

        /*If the last y coordinates are not handled yet ...*/
        if(y2 != row_last) {
 80034de:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 80034e2:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 80034e6:	429a      	cmp	r2, r3
 80034e8:	d014      	beq.n	8003514 <lv_refr_area+0x200>
            /*Calc. the next y coordinates of VDB*/
            vdb->area.x1 = area_p->x1;
 80034ea:	687b      	ldr	r3, [r7, #4]
 80034ec:	f9b3 2000 	ldrsh.w	r2, [r3]
 80034f0:	6a3b      	ldr	r3, [r7, #32]
 80034f2:	821a      	strh	r2, [r3, #16]
            vdb->area.x2 = area_p->x2;
 80034f4:	687b      	ldr	r3, [r7, #4]
 80034f6:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 80034fa:	6a3b      	ldr	r3, [r7, #32]
 80034fc:	829a      	strh	r2, [r3, #20]
            vdb->area.y1 = row;
 80034fe:	6a3b      	ldr	r3, [r7, #32]
 8003500:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8003502:	825a      	strh	r2, [r3, #18]
            vdb->area.y2 = y2;
 8003504:	6a3b      	ldr	r3, [r7, #32]
 8003506:	8b7a      	ldrh	r2, [r7, #26]
 8003508:	82da      	strh	r2, [r3, #22]

            /*Refresh this part too*/
            lv_refr_area_part(area_p);
 800350a:	6878      	ldr	r0, [r7, #4]
 800350c:	f000 f808 	bl	8003520 <lv_refr_area_part>
 8003510:	e000      	b.n	8003514 <lv_refr_area+0x200>
                return;
 8003512:	bf00      	nop
        }
    }
}
 8003514:	3734      	adds	r7, #52	; 0x34
 8003516:	46bd      	mov	sp, r7
 8003518:	bd90      	pop	{r4, r7, pc}
 800351a:	bf00      	nop
 800351c:	200000a4 	.word	0x200000a4

08003520 <lv_refr_area_part>:
/**
 * Refresh a part of an area which is on the actual Virtual Display Buffer
 * @param area_p pointer to an area to refresh
 */
static void lv_refr_area_part(const lv_area_t * area_p)
{
 8003520:	b580      	push	{r7, lr}
 8003522:	b086      	sub	sp, #24
 8003524:	af00      	add	r7, sp, #0
 8003526:	6078      	str	r0, [r7, #4]

    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 8003528:	4b2e      	ldr	r3, [pc, #184]	; (80035e4 <lv_refr_area_part+0xc4>)
 800352a:	681b      	ldr	r3, [r3, #0]
 800352c:	4618      	mov	r0, r3
 800352e:	f008 fabe 	bl	800baae <lv_disp_get_buf>
 8003532:	6178      	str	r0, [r7, #20]

    /*In non double buffered mode, before rendering the next part wait until the previous image is
     * flushed*/
    if(lv_disp_is_double_buf(disp_refr) == false) {
 8003534:	4b2b      	ldr	r3, [pc, #172]	; (80035e4 <lv_refr_area_part+0xc4>)
 8003536:	681b      	ldr	r3, [r3, #0]
 8003538:	4618      	mov	r0, r3
 800353a:	f008 fac4 	bl	800bac6 <lv_disp_is_double_buf>
 800353e:	4603      	mov	r3, r0
 8003540:	f083 0301 	eor.w	r3, r3, #1
 8003544:	b2db      	uxtb	r3, r3
 8003546:	2b00      	cmp	r3, #0
 8003548:	d007      	beq.n	800355a <lv_refr_area_part+0x3a>
        while(vdb->flushing)
 800354a:	bf00      	nop
 800354c:	697b      	ldr	r3, [r7, #20]
 800354e:	699b      	ldr	r3, [r3, #24]
 8003550:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8003554:	b2db      	uxtb	r3, r3
 8003556:	2b00      	cmp	r3, #0
 8003558:	d1f8      	bne.n	800354c <lv_refr_area_part+0x2c>
    lv_obj_t * top_p;

    /*Get the new mask from the original area and the act. VDB
     It will be a part of 'area_p'*/
    lv_area_t start_mask;
    lv_area_intersect(&start_mask, area_p, &vdb->area);
 800355a:	697b      	ldr	r3, [r7, #20]
 800355c:	f103 0210 	add.w	r2, r3, #16
 8003560:	f107 0308 	add.w	r3, r7, #8
 8003564:	6879      	ldr	r1, [r7, #4]
 8003566:	4618      	mov	r0, r3
 8003568:	f008 fdac 	bl	800c0c4 <lv_area_intersect>

    /*Get the most top object which is not covered by others*/
    top_p = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));
 800356c:	4b1d      	ldr	r3, [pc, #116]	; (80035e4 <lv_refr_area_part+0xc4>)
 800356e:	681b      	ldr	r3, [r3, #0]
 8003570:	4618      	mov	r0, r3
 8003572:	f7fc fefb 	bl	800036c <lv_disp_get_scr_act>
 8003576:	4602      	mov	r2, r0
 8003578:	f107 0308 	add.w	r3, r7, #8
 800357c:	4611      	mov	r1, r2
 800357e:	4618      	mov	r0, r3
 8003580:	f000 f832 	bl	80035e8 <lv_refr_get_top_obj>
 8003584:	6138      	str	r0, [r7, #16]

    /*Do the refreshing from the top object*/
    lv_refr_obj_and_children(top_p, &start_mask);
 8003586:	f107 0308 	add.w	r3, r7, #8
 800358a:	4619      	mov	r1, r3
 800358c:	6938      	ldr	r0, [r7, #16]
 800358e:	f000 f87f 	bl	8003690 <lv_refr_obj_and_children>

    /*Also refresh top and sys layer unconditionally*/
    lv_refr_obj_and_children(lv_disp_get_layer_top(disp_refr), &start_mask);
 8003592:	4b14      	ldr	r3, [pc, #80]	; (80035e4 <lv_refr_area_part+0xc4>)
 8003594:	681b      	ldr	r3, [r3, #0]
 8003596:	4618      	mov	r0, r3
 8003598:	f7fc fefd 	bl	8000396 <lv_disp_get_layer_top>
 800359c:	4602      	mov	r2, r0
 800359e:	f107 0308 	add.w	r3, r7, #8
 80035a2:	4619      	mov	r1, r3
 80035a4:	4610      	mov	r0, r2
 80035a6:	f000 f873 	bl	8003690 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_sys(disp_refr), &start_mask);
 80035aa:	4b0e      	ldr	r3, [pc, #56]	; (80035e4 <lv_refr_area_part+0xc4>)
 80035ac:	681b      	ldr	r3, [r3, #0]
 80035ae:	4618      	mov	r0, r3
 80035b0:	f7fc ff06 	bl	80003c0 <lv_disp_get_layer_sys>
 80035b4:	4602      	mov	r2, r0
 80035b6:	f107 0308 	add.w	r3, r7, #8
 80035ba:	4619      	mov	r1, r3
 80035bc:	4610      	mov	r0, r2
 80035be:	f000 f867 	bl	8003690 <lv_refr_obj_and_children>

    /* In true double buffered mode flush only once when all areas were rendered.
     * In normal mode flush after every area */
    if(lv_disp_is_true_double_buf(disp_refr) == false) {
 80035c2:	4b08      	ldr	r3, [pc, #32]	; (80035e4 <lv_refr_area_part+0xc4>)
 80035c4:	681b      	ldr	r3, [r3, #0]
 80035c6:	4618      	mov	r0, r3
 80035c8:	f008 fa94 	bl	800baf4 <lv_disp_is_true_double_buf>
 80035cc:	4603      	mov	r3, r0
 80035ce:	f083 0301 	eor.w	r3, r3, #1
 80035d2:	b2db      	uxtb	r3, r3
 80035d4:	2b00      	cmp	r3, #0
 80035d6:	d001      	beq.n	80035dc <lv_refr_area_part+0xbc>
        lv_refr_vdb_flush();
 80035d8:	f000 f95c 	bl	8003894 <lv_refr_vdb_flush>
    }
}
 80035dc:	bf00      	nop
 80035de:	3718      	adds	r7, #24
 80035e0:	46bd      	mov	sp, r7
 80035e2:	bd80      	pop	{r7, pc}
 80035e4:	200000a4 	.word	0x200000a4

080035e8 <lv_refr_get_top_obj>:
 * @param area_p pointer to an area
 * @param obj the first object to start the searching (typically a screen)
 * @return
 */
static lv_obj_t * lv_refr_get_top_obj(const lv_area_t * area_p, lv_obj_t * obj)
{
 80035e8:	b580      	push	{r7, lr}
 80035ea:	b086      	sub	sp, #24
 80035ec:	af00      	add	r7, sp, #0
 80035ee:	6078      	str	r0, [r7, #4]
 80035f0:	6039      	str	r1, [r7, #0]
    lv_obj_t * found_p = NULL;
 80035f2:	2300      	movs	r3, #0
 80035f4:	617b      	str	r3, [r7, #20]

    /*If this object is fully cover the draw area check the children too */
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
 80035f6:	683b      	ldr	r3, [r7, #0]
 80035f8:	3310      	adds	r3, #16
 80035fa:	4619      	mov	r1, r3
 80035fc:	6878      	ldr	r0, [r7, #4]
 80035fe:	f008 fe1c 	bl	800c23a <lv_area_is_in>
 8003602:	4603      	mov	r3, r0
 8003604:	2b00      	cmp	r3, #0
 8003606:	d03e      	beq.n	8003686 <lv_refr_get_top_obj+0x9e>
 8003608:	683b      	ldr	r3, [r7, #0]
 800360a:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800360e:	f003 0310 	and.w	r3, r3, #16
 8003612:	b2db      	uxtb	r3, r3
 8003614:	2b00      	cmp	r3, #0
 8003616:	d136      	bne.n	8003686 <lv_refr_get_top_obj+0x9e>
        lv_obj_t * i;
        LV_LL_READ(obj->child_ll, i)
 8003618:	683b      	ldr	r3, [r7, #0]
 800361a:	3304      	adds	r3, #4
 800361c:	4618      	mov	r0, r3
 800361e:	f009 f9cd 	bl	800c9bc <lv_ll_get_head>
 8003622:	6138      	str	r0, [r7, #16]
 8003624:	e00e      	b.n	8003644 <lv_refr_get_top_obj+0x5c>
        {
            found_p = lv_refr_get_top_obj(area_p, i);
 8003626:	6939      	ldr	r1, [r7, #16]
 8003628:	6878      	ldr	r0, [r7, #4]
 800362a:	f7ff ffdd 	bl	80035e8 <lv_refr_get_top_obj>
 800362e:	6178      	str	r0, [r7, #20]

            /*If a children is ok then break*/
            if(found_p != NULL) {
 8003630:	697b      	ldr	r3, [r7, #20]
 8003632:	2b00      	cmp	r3, #0
 8003634:	d10a      	bne.n	800364c <lv_refr_get_top_obj+0x64>
        LV_LL_READ(obj->child_ll, i)
 8003636:	683b      	ldr	r3, [r7, #0]
 8003638:	3304      	adds	r3, #4
 800363a:	6939      	ldr	r1, [r7, #16]
 800363c:	4618      	mov	r0, r3
 800363e:	f009 f9e3 	bl	800ca08 <lv_ll_get_next>
 8003642:	6138      	str	r0, [r7, #16]
 8003644:	693b      	ldr	r3, [r7, #16]
 8003646:	2b00      	cmp	r3, #0
 8003648:	d1ed      	bne.n	8003626 <lv_refr_get_top_obj+0x3e>
 800364a:	e000      	b.n	800364e <lv_refr_get_top_obj+0x66>
                break;
 800364c:	bf00      	nop
            }
        }

        /*If no better children check this object*/
        if(found_p == NULL) {
 800364e:	697b      	ldr	r3, [r7, #20]
 8003650:	2b00      	cmp	r3, #0
 8003652:	d118      	bne.n	8003686 <lv_refr_get_top_obj+0x9e>
            const lv_style_t * style = lv_obj_get_style(obj);
 8003654:	6838      	ldr	r0, [r7, #0]
 8003656:	f7ff f87b 	bl	8002750 <lv_obj_get_style>
 800365a:	60f8      	str	r0, [r7, #12]
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
 800365c:	68fb      	ldr	r3, [r7, #12]
 800365e:	7a1b      	ldrb	r3, [r3, #8]
 8003660:	2bff      	cmp	r3, #255	; 0xff
 8003662:	d110      	bne.n	8003686 <lv_refr_get_top_obj+0x9e>
 8003664:	683b      	ldr	r3, [r7, #0]
 8003666:	6a1b      	ldr	r3, [r3, #32]
 8003668:	2202      	movs	r2, #2
 800366a:	6879      	ldr	r1, [r7, #4]
 800366c:	6838      	ldr	r0, [r7, #0]
 800366e:	4798      	blx	r3
 8003670:	4603      	mov	r3, r0
 8003672:	2b00      	cmp	r3, #0
 8003674:	d007      	beq.n	8003686 <lv_refr_get_top_obj+0x9e>
               lv_obj_get_opa_scale(obj) == LV_OPA_COVER) {
 8003676:	6838      	ldr	r0, [r7, #0]
 8003678:	f7ff f90a 	bl	8002890 <lv_obj_get_opa_scale>
 800367c:	4603      	mov	r3, r0
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
 800367e:	2bff      	cmp	r3, #255	; 0xff
 8003680:	d101      	bne.n	8003686 <lv_refr_get_top_obj+0x9e>
                found_p = obj;
 8003682:	683b      	ldr	r3, [r7, #0]
 8003684:	617b      	str	r3, [r7, #20]
            }
        }
    }

    return found_p;
 8003686:	697b      	ldr	r3, [r7, #20]
}
 8003688:	4618      	mov	r0, r3
 800368a:	3718      	adds	r7, #24
 800368c:	46bd      	mov	sp, r7
 800368e:	bd80      	pop	{r7, pc}

08003690 <lv_refr_obj_and_children>:
 * Make the refreshing from an object. Draw all its children and the youngers too.
 * @param top_p pointer to an objects. Start the drawing from it.
 * @param mask_p pointer to an area, the objects will be drawn only here
 */
static void lv_refr_obj_and_children(lv_obj_t * top_p, const lv_area_t * mask_p)
{
 8003690:	b580      	push	{r7, lr}
 8003692:	b086      	sub	sp, #24
 8003694:	af00      	add	r7, sp, #0
 8003696:	6078      	str	r0, [r7, #4]
 8003698:	6039      	str	r1, [r7, #0]
    /* Normally always will be a top_obj (at least the screen)
     * but in special cases (e.g. if the screen has alpha) it won't.
     * In this case use the screen directly */
    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);
 800369a:	687b      	ldr	r3, [r7, #4]
 800369c:	2b00      	cmp	r3, #0
 800369e:	d105      	bne.n	80036ac <lv_refr_obj_and_children+0x1c>
 80036a0:	4b1c      	ldr	r3, [pc, #112]	; (8003714 <lv_refr_obj_and_children+0x84>)
 80036a2:	681b      	ldr	r3, [r3, #0]
 80036a4:	4618      	mov	r0, r3
 80036a6:	f7fc fe61 	bl	800036c <lv_disp_get_scr_act>
 80036aa:	6078      	str	r0, [r7, #4]

    /*Refresh the top object and its children*/
    lv_refr_obj(top_p, mask_p);
 80036ac:	6839      	ldr	r1, [r7, #0]
 80036ae:	6878      	ldr	r0, [r7, #4]
 80036b0:	f000 f832 	bl	8003718 <lv_refr_obj>

    /*Draw the 'younger' sibling objects because they can be on top_obj */
    lv_obj_t * par;
    lv_obj_t * border_p = top_p;
 80036b4:	687b      	ldr	r3, [r7, #4]
 80036b6:	613b      	str	r3, [r7, #16]

    par = lv_obj_get_parent(top_p);
 80036b8:	6878      	ldr	r0, [r7, #4]
 80036ba:	f7fe fed1 	bl	8002460 <lv_obj_get_parent>
 80036be:	6178      	str	r0, [r7, #20]

    /*Do until not reach the screen*/
    while(par != NULL) {
 80036c0:	e021      	b.n	8003706 <lv_refr_obj_and_children+0x76>
        /*object before border_p has to be redrawn*/
        lv_obj_t * i = lv_ll_get_prev(&(par->child_ll), border_p);
 80036c2:	697b      	ldr	r3, [r7, #20]
 80036c4:	3304      	adds	r3, #4
 80036c6:	6939      	ldr	r1, [r7, #16]
 80036c8:	4618      	mov	r0, r3
 80036ca:	f009 f9b7 	bl	800ca3c <lv_ll_get_prev>
 80036ce:	60f8      	str	r0, [r7, #12]

        while(i != NULL) {
 80036d0:	e00a      	b.n	80036e8 <lv_refr_obj_and_children+0x58>
            /*Refresh the objects*/
            lv_refr_obj(i, mask_p);
 80036d2:	6839      	ldr	r1, [r7, #0]
 80036d4:	68f8      	ldr	r0, [r7, #12]
 80036d6:	f000 f81f 	bl	8003718 <lv_refr_obj>
            i = lv_ll_get_prev(&(par->child_ll), i);
 80036da:	697b      	ldr	r3, [r7, #20]
 80036dc:	3304      	adds	r3, #4
 80036de:	68f9      	ldr	r1, [r7, #12]
 80036e0:	4618      	mov	r0, r3
 80036e2:	f009 f9ab 	bl	800ca3c <lv_ll_get_prev>
 80036e6:	60f8      	str	r0, [r7, #12]
        while(i != NULL) {
 80036e8:	68fb      	ldr	r3, [r7, #12]
 80036ea:	2b00      	cmp	r3, #0
 80036ec:	d1f1      	bne.n	80036d2 <lv_refr_obj_and_children+0x42>
        }

        /*Call the post draw design function of the parents of the to object*/
        par->design_cb(par, mask_p, LV_DESIGN_DRAW_POST);
 80036ee:	697b      	ldr	r3, [r7, #20]
 80036f0:	6a1b      	ldr	r3, [r3, #32]
 80036f2:	2201      	movs	r2, #1
 80036f4:	6839      	ldr	r1, [r7, #0]
 80036f6:	6978      	ldr	r0, [r7, #20]
 80036f8:	4798      	blx	r3

        /*The new border will be there last parents,
         *so the 'younger' brothers of parent will be refreshed*/
        border_p = par;
 80036fa:	697b      	ldr	r3, [r7, #20]
 80036fc:	613b      	str	r3, [r7, #16]
        /*Go a level deeper*/
        par = lv_obj_get_parent(par);
 80036fe:	6978      	ldr	r0, [r7, #20]
 8003700:	f7fe feae 	bl	8002460 <lv_obj_get_parent>
 8003704:	6178      	str	r0, [r7, #20]
    while(par != NULL) {
 8003706:	697b      	ldr	r3, [r7, #20]
 8003708:	2b00      	cmp	r3, #0
 800370a:	d1da      	bne.n	80036c2 <lv_refr_obj_and_children+0x32>
    }
}
 800370c:	bf00      	nop
 800370e:	3718      	adds	r7, #24
 8003710:	46bd      	mov	sp, r7
 8003712:	bd80      	pop	{r7, pc}
 8003714:	200000a4 	.word	0x200000a4

08003718 <lv_refr_obj>:
 * Refresh an object an all of its children. (Called recursively)
 * @param obj pointer to an object to refresh
 * @param mask_ori_p pointer to an area, the objects will be drawn only here
 */
static void lv_refr_obj(lv_obj_t * obj, const lv_area_t * mask_ori_p)
{
 8003718:	b580      	push	{r7, lr}
 800371a:	b08e      	sub	sp, #56	; 0x38
 800371c:	af00      	add	r7, sp, #0
 800371e:	6078      	str	r0, [r7, #4]
 8003720:	6039      	str	r1, [r7, #0]
    /*Do not refresh hidden objects*/
    if(obj->hidden != 0) return;
 8003722:	687b      	ldr	r3, [r7, #4]
 8003724:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8003728:	f003 0310 	and.w	r3, r3, #16
 800372c:	b2db      	uxtb	r3, r3
 800372e:	2b00      	cmp	r3, #0
 8003730:	f040 80ac 	bne.w	800388c <lv_refr_obj+0x174>
    /* Truncate the original mask to the coordinates of the parent
     * because the parent and its children are visible only here */
    lv_area_t obj_mask;
    lv_area_t obj_ext_mask;
    lv_area_t obj_area;
    lv_coord_t ext_size = obj->ext_draw_pad;
 8003734:	687b      	ldr	r3, [r7, #4]
 8003736:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8003738:	867b      	strh	r3, [r7, #50]	; 0x32
    lv_obj_get_coords(obj, &obj_area);
 800373a:	f107 0318 	add.w	r3, r7, #24
 800373e:	4619      	mov	r1, r3
 8003740:	6878      	ldr	r0, [r7, #4]
 8003742:	f7fe fedd 	bl	8002500 <lv_obj_get_coords>
    obj_area.x1 -= ext_size;
 8003746:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800374a:	b29a      	uxth	r2, r3
 800374c:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800374e:	1ad3      	subs	r3, r2, r3
 8003750:	b29b      	uxth	r3, r3
 8003752:	b21b      	sxth	r3, r3
 8003754:	833b      	strh	r3, [r7, #24]
    obj_area.y1 -= ext_size;
 8003756:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800375a:	b29a      	uxth	r2, r3
 800375c:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800375e:	1ad3      	subs	r3, r2, r3
 8003760:	b29b      	uxth	r3, r3
 8003762:	b21b      	sxth	r3, r3
 8003764:	837b      	strh	r3, [r7, #26]
    obj_area.x2 += ext_size;
 8003766:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 800376a:	b29a      	uxth	r2, r3
 800376c:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800376e:	4413      	add	r3, r2
 8003770:	b29b      	uxth	r3, r3
 8003772:	b21b      	sxth	r3, r3
 8003774:	83bb      	strh	r3, [r7, #28]
    obj_area.y2 += ext_size;
 8003776:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800377a:	b29a      	uxth	r2, r3
 800377c:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800377e:	4413      	add	r3, r2
 8003780:	b29b      	uxth	r3, r3
 8003782:	b21b      	sxth	r3, r3
 8003784:	83fb      	strh	r3, [r7, #30]
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
 8003786:	f107 0218 	add.w	r2, r7, #24
 800378a:	f107 0320 	add.w	r3, r7, #32
 800378e:	6839      	ldr	r1, [r7, #0]
 8003790:	4618      	mov	r0, r3
 8003792:	f008 fc97 	bl	800c0c4 <lv_area_intersect>
 8003796:	4603      	mov	r3, r0
 8003798:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31

    /*Draw the parent and its children only if they ore on 'mask_parent'*/
    if(union_ok != false) {
 800379c:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 80037a0:	2b00      	cmp	r3, #0
 80037a2:	d074      	beq.n	800388e <lv_refr_obj+0x176>

        /* Redraw the object */
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_MAIN);
 80037a4:	687b      	ldr	r3, [r7, #4]
 80037a6:	6a1b      	ldr	r3, [r3, #32]
 80037a8:	f107 0120 	add.w	r1, r7, #32
 80037ac:	2200      	movs	r2, #0
 80037ae:	6878      	ldr	r0, [r7, #4]
 80037b0:	4798      	blx	r3
        lv_draw_fill(&obj_ext_mask, &obj_ext_mask, debug_color, LV_OPA_50);
        debug_color.full *= 17;
        debug_color.full += 0xA1;
#endif
        /*Create a new 'obj_mask' without 'ext_size' because the children can't be visible there*/
        lv_obj_get_coords(obj, &obj_area);
 80037b2:	f107 0318 	add.w	r3, r7, #24
 80037b6:	4619      	mov	r1, r3
 80037b8:	6878      	ldr	r0, [r7, #4]
 80037ba:	f7fe fea1 	bl	8002500 <lv_obj_get_coords>
        union_ok = lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);
 80037be:	f107 0218 	add.w	r2, r7, #24
 80037c2:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80037c6:	6839      	ldr	r1, [r7, #0]
 80037c8:	4618      	mov	r0, r3
 80037ca:	f008 fc7b 	bl	800c0c4 <lv_area_intersect>
 80037ce:	4603      	mov	r3, r0
 80037d0:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
        if(union_ok != false) {
 80037d4:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 80037d8:	2b00      	cmp	r3, #0
 80037da:	d04f      	beq.n	800387c <lv_refr_obj+0x164>
            lv_area_t mask_child; /*Mask from obj and its child*/
            lv_obj_t * child_p;
            lv_area_t child_area;
            LV_LL_READ_BACK(obj->child_ll, child_p)
 80037dc:	687b      	ldr	r3, [r7, #4]
 80037de:	3304      	adds	r3, #4
 80037e0:	4618      	mov	r0, r3
 80037e2:	f009 f8fe 	bl	800c9e2 <lv_ll_get_tail>
 80037e6:	6378      	str	r0, [r7, #52]	; 0x34
 80037e8:	e045      	b.n	8003876 <lv_refr_obj+0x15e>
            {
                lv_obj_get_coords(child_p, &child_area);
 80037ea:	f107 0308 	add.w	r3, r7, #8
 80037ee:	4619      	mov	r1, r3
 80037f0:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80037f2:	f7fe fe85 	bl	8002500 <lv_obj_get_coords>
                ext_size = child_p->ext_draw_pad;
 80037f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80037f8:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 80037fa:	867b      	strh	r3, [r7, #50]	; 0x32
                child_area.x1 -= ext_size;
 80037fc:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8003800:	b29a      	uxth	r2, r3
 8003802:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8003804:	1ad3      	subs	r3, r2, r3
 8003806:	b29b      	uxth	r3, r3
 8003808:	b21b      	sxth	r3, r3
 800380a:	813b      	strh	r3, [r7, #8]
                child_area.y1 -= ext_size;
 800380c:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8003810:	b29a      	uxth	r2, r3
 8003812:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8003814:	1ad3      	subs	r3, r2, r3
 8003816:	b29b      	uxth	r3, r3
 8003818:	b21b      	sxth	r3, r3
 800381a:	817b      	strh	r3, [r7, #10]
                child_area.x2 += ext_size;
 800381c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8003820:	b29a      	uxth	r2, r3
 8003822:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8003824:	4413      	add	r3, r2
 8003826:	b29b      	uxth	r3, r3
 8003828:	b21b      	sxth	r3, r3
 800382a:	81bb      	strh	r3, [r7, #12]
                child_area.y2 += ext_size;
 800382c:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8003830:	b29a      	uxth	r2, r3
 8003832:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8003834:	4413      	add	r3, r2
 8003836:	b29b      	uxth	r3, r3
 8003838:	b21b      	sxth	r3, r3
 800383a:	81fb      	strh	r3, [r7, #14]
                /* Get the union (common parts) of original mask (from obj)
                 * and its child */
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
 800383c:	f107 0208 	add.w	r2, r7, #8
 8003840:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8003844:	f107 0310 	add.w	r3, r7, #16
 8003848:	4618      	mov	r0, r3
 800384a:	f008 fc3b 	bl	800c0c4 <lv_area_intersect>
 800384e:	4603      	mov	r3, r0
 8003850:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31

                /*If the parent and the child has common area then refresh the child */
                if(union_ok) {
 8003854:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 8003858:	2b00      	cmp	r3, #0
 800385a:	d005      	beq.n	8003868 <lv_refr_obj+0x150>
                    /*Refresh the next children*/
                    lv_refr_obj(child_p, &mask_child);
 800385c:	f107 0310 	add.w	r3, r7, #16
 8003860:	4619      	mov	r1, r3
 8003862:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8003864:	f7ff ff58 	bl	8003718 <lv_refr_obj>
            LV_LL_READ_BACK(obj->child_ll, child_p)
 8003868:	687b      	ldr	r3, [r7, #4]
 800386a:	3304      	adds	r3, #4
 800386c:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800386e:	4618      	mov	r0, r3
 8003870:	f009 f8e4 	bl	800ca3c <lv_ll_get_prev>
 8003874:	6378      	str	r0, [r7, #52]	; 0x34
 8003876:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003878:	2b00      	cmp	r3, #0
 800387a:	d1b6      	bne.n	80037ea <lv_refr_obj+0xd2>
                }
            }
        }

        /* If all the children are redrawn make 'post draw' design */
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_POST);
 800387c:	687b      	ldr	r3, [r7, #4]
 800387e:	6a1b      	ldr	r3, [r3, #32]
 8003880:	f107 0120 	add.w	r1, r7, #32
 8003884:	2201      	movs	r2, #1
 8003886:	6878      	ldr	r0, [r7, #4]
 8003888:	4798      	blx	r3
 800388a:	e000      	b.n	800388e <lv_refr_obj+0x176>
    if(obj->hidden != 0) return;
 800388c:	bf00      	nop
    }
}
 800388e:	3738      	adds	r7, #56	; 0x38
 8003890:	46bd      	mov	sp, r7
 8003892:	bd80      	pop	{r7, pc}

08003894 <lv_refr_vdb_flush>:

/**
 * Flush the content of the VDB
 */
static void lv_refr_vdb_flush(void)
{
 8003894:	b580      	push	{r7, lr}
 8003896:	b082      	sub	sp, #8
 8003898:	af00      	add	r7, sp, #0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 800389a:	4b23      	ldr	r3, [pc, #140]	; (8003928 <lv_refr_vdb_flush+0x94>)
 800389c:	681b      	ldr	r3, [r3, #0]
 800389e:	4618      	mov	r0, r3
 80038a0:	f008 f905 	bl	800baae <lv_disp_get_buf>
 80038a4:	6078      	str	r0, [r7, #4]

    /*In double buffered mode wait until the other buffer is flushed before flushing the current
     * one*/
    if(lv_disp_is_double_buf(disp_refr)) {
 80038a6:	4b20      	ldr	r3, [pc, #128]	; (8003928 <lv_refr_vdb_flush+0x94>)
 80038a8:	681b      	ldr	r3, [r3, #0]
 80038aa:	4618      	mov	r0, r3
 80038ac:	f008 f90b 	bl	800bac6 <lv_disp_is_double_buf>
 80038b0:	4603      	mov	r3, r0
 80038b2:	2b00      	cmp	r3, #0
 80038b4:	d007      	beq.n	80038c6 <lv_refr_vdb_flush+0x32>
        while(vdb->flushing)
 80038b6:	bf00      	nop
 80038b8:	687b      	ldr	r3, [r7, #4]
 80038ba:	699b      	ldr	r3, [r3, #24]
 80038bc:	f3c3 0300 	ubfx	r3, r3, #0, #1
 80038c0:	b2db      	uxtb	r3, r3
 80038c2:	2b00      	cmp	r3, #0
 80038c4:	d1f8      	bne.n	80038b8 <lv_refr_vdb_flush+0x24>
            ;
    }

    vdb->flushing = 1;
 80038c6:	687a      	ldr	r2, [r7, #4]
 80038c8:	7e13      	ldrb	r3, [r2, #24]
 80038ca:	f043 0301 	orr.w	r3, r3, #1
 80038ce:	7613      	strb	r3, [r2, #24]

    /*Flush the rendered content to the display*/
    lv_disp_t * disp = lv_refr_get_disp_refreshing();
 80038d0:	f7ff fb40 	bl	8002f54 <lv_refr_get_disp_refreshing>
 80038d4:	6038      	str	r0, [r7, #0]
    if(disp->driver.flush_cb) disp->driver.flush_cb(&disp->driver, &vdb->area, vdb->buf_act);
 80038d6:	683b      	ldr	r3, [r7, #0]
 80038d8:	68db      	ldr	r3, [r3, #12]
 80038da:	2b00      	cmp	r3, #0
 80038dc:	d008      	beq.n	80038f0 <lv_refr_vdb_flush+0x5c>
 80038de:	683b      	ldr	r3, [r7, #0]
 80038e0:	68db      	ldr	r3, [r3, #12]
 80038e2:	6838      	ldr	r0, [r7, #0]
 80038e4:	687a      	ldr	r2, [r7, #4]
 80038e6:	f102 0110 	add.w	r1, r2, #16
 80038ea:	687a      	ldr	r2, [r7, #4]
 80038ec:	6892      	ldr	r2, [r2, #8]
 80038ee:	4798      	blx	r3

    if(vdb->buf1 && vdb->buf2) {
 80038f0:	687b      	ldr	r3, [r7, #4]
 80038f2:	681b      	ldr	r3, [r3, #0]
 80038f4:	2b00      	cmp	r3, #0
 80038f6:	d012      	beq.n	800391e <lv_refr_vdb_flush+0x8a>
 80038f8:	687b      	ldr	r3, [r7, #4]
 80038fa:	685b      	ldr	r3, [r3, #4]
 80038fc:	2b00      	cmp	r3, #0
 80038fe:	d00e      	beq.n	800391e <lv_refr_vdb_flush+0x8a>
        if(vdb->buf_act == vdb->buf1)
 8003900:	687b      	ldr	r3, [r7, #4]
 8003902:	689a      	ldr	r2, [r3, #8]
 8003904:	687b      	ldr	r3, [r7, #4]
 8003906:	681b      	ldr	r3, [r3, #0]
 8003908:	429a      	cmp	r2, r3
 800390a:	d104      	bne.n	8003916 <lv_refr_vdb_flush+0x82>
            vdb->buf_act = vdb->buf2;
 800390c:	687b      	ldr	r3, [r7, #4]
 800390e:	685a      	ldr	r2, [r3, #4]
 8003910:	687b      	ldr	r3, [r7, #4]
 8003912:	609a      	str	r2, [r3, #8]
        else
            vdb->buf_act = vdb->buf1;
    }
}
 8003914:	e003      	b.n	800391e <lv_refr_vdb_flush+0x8a>
            vdb->buf_act = vdb->buf1;
 8003916:	687b      	ldr	r3, [r7, #4]
 8003918:	681a      	ldr	r2, [r3, #0]
 800391a:	687b      	ldr	r3, [r7, #4]
 800391c:	609a      	str	r2, [r3, #8]
}
 800391e:	bf00      	nop
 8003920:	3708      	adds	r7, #8
 8003922:	46bd      	mov	sp, r7
 8003924:	bd80      	pop	{r7, pc}
 8003926:	bf00      	nop
 8003928:	200000a4 	.word	0x200000a4

0800392c <lv_color_make>:
#elif LV_COLOR_DEPTH == 32
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8, g8, r8, 0xff}}) /*Fix 0xff alpha*/
#endif

static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
 800392c:	b490      	push	{r4, r7}
 800392e:	b082      	sub	sp, #8
 8003930:	af00      	add	r7, sp, #0
 8003932:	4604      	mov	r4, r0
 8003934:	4608      	mov	r0, r1
 8003936:	4611      	mov	r1, r2
 8003938:	4622      	mov	r2, r4
 800393a:	71fa      	strb	r2, [r7, #7]
 800393c:	4602      	mov	r2, r0
 800393e:	71ba      	strb	r2, [r7, #6]
 8003940:	460a      	mov	r2, r1
 8003942:	717a      	strb	r2, [r7, #5]
    return LV_COLOR_MAKE(r, g, b);
 8003944:	797a      	ldrb	r2, [r7, #5]
 8003946:	08d2      	lsrs	r2, r2, #3
 8003948:	b2d2      	uxtb	r2, r2
 800394a:	f002 021f 	and.w	r2, r2, #31
 800394e:	b2d0      	uxtb	r0, r2
 8003950:	79ba      	ldrb	r2, [r7, #6]
 8003952:	0892      	lsrs	r2, r2, #2
 8003954:	b2d2      	uxtb	r2, r2
 8003956:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 800395a:	b2d1      	uxtb	r1, r2
 800395c:	79fa      	ldrb	r2, [r7, #7]
 800395e:	08d2      	lsrs	r2, r2, #3
 8003960:	b2d2      	uxtb	r2, r2
 8003962:	f002 021f 	and.w	r2, r2, #31
 8003966:	b2d2      	uxtb	r2, r2
 8003968:	f360 0304 	bfi	r3, r0, #0, #5
 800396c:	f361 134a 	bfi	r3, r1, #5, #6
 8003970:	f362 23cf 	bfi	r3, r2, #11, #5
}
 8003974:	4618      	mov	r0, r3
 8003976:	3708      	adds	r7, #8
 8003978:	46bd      	mov	sp, r7
 800397a:	bc90      	pop	{r4, r7}
 800397c:	4770      	bx	lr
	...

08003980 <lv_style_init>:

/**
 *  Init the basic styles
 */
void lv_style_init(void)
{
 8003980:	b598      	push	{r3, r4, r7, lr}
 8003982:	af00      	add	r7, sp, #0
    /* Not White/Black/Gray colors are created by HSV model with
     * HUE = 210*/

    /*Screen style*/
    lv_style_scr.glass               = 0;
 8003984:	4aae      	ldr	r2, [pc, #696]	; (8003c40 <lv_style_init+0x2c0>)
 8003986:	7813      	ldrb	r3, [r2, #0]
 8003988:	f36f 0300 	bfc	r3, #0, #1
 800398c:	7013      	strb	r3, [r2, #0]
    lv_style_scr.body.opa            = LV_OPA_COVER;
 800398e:	4bac      	ldr	r3, [pc, #688]	; (8003c40 <lv_style_init+0x2c0>)
 8003990:	22ff      	movs	r2, #255	; 0xff
 8003992:	721a      	strb	r2, [r3, #8]
    lv_style_scr.body.main_color     = LV_COLOR_WHITE;
 8003994:	4aaa      	ldr	r2, [pc, #680]	; (8003c40 <lv_style_init+0x2c0>)
 8003996:	4bab      	ldr	r3, [pc, #684]	; (8003c44 <lv_style_init+0x2c4>)
 8003998:	881b      	ldrh	r3, [r3, #0]
 800399a:	8053      	strh	r3, [r2, #2]
    lv_style_scr.body.grad_color     = LV_COLOR_WHITE;
 800399c:	4aa8      	ldr	r2, [pc, #672]	; (8003c40 <lv_style_init+0x2c0>)
 800399e:	4ba9      	ldr	r3, [pc, #676]	; (8003c44 <lv_style_init+0x2c4>)
 80039a0:	881b      	ldrh	r3, [r3, #0]
 80039a2:	8093      	strh	r3, [r2, #4]
    lv_style_scr.body.radius         = 0;
 80039a4:	4ba6      	ldr	r3, [pc, #664]	; (8003c40 <lv_style_init+0x2c0>)
 80039a6:	2200      	movs	r2, #0
 80039a8:	80da      	strh	r2, [r3, #6]
    lv_style_scr.body.padding.left   = 0;
 80039aa:	4ba5      	ldr	r3, [pc, #660]	; (8003c40 <lv_style_init+0x2c0>)
 80039ac:	2200      	movs	r2, #0
 80039ae:	835a      	strh	r2, [r3, #26]
    lv_style_scr.body.padding.right  = 0;
 80039b0:	4ba3      	ldr	r3, [pc, #652]	; (8003c40 <lv_style_init+0x2c0>)
 80039b2:	2200      	movs	r2, #0
 80039b4:	839a      	strh	r2, [r3, #28]
    lv_style_scr.body.padding.top    = 0;
 80039b6:	4ba2      	ldr	r3, [pc, #648]	; (8003c40 <lv_style_init+0x2c0>)
 80039b8:	2200      	movs	r2, #0
 80039ba:	82da      	strh	r2, [r3, #22]
    lv_style_scr.body.padding.bottom = 0;
 80039bc:	4ba0      	ldr	r3, [pc, #640]	; (8003c40 <lv_style_init+0x2c0>)
 80039be:	2200      	movs	r2, #0
 80039c0:	831a      	strh	r2, [r3, #24]
    lv_style_scr.body.padding.inner  = LV_DPI / 20;
 80039c2:	4b9f      	ldr	r3, [pc, #636]	; (8003c40 <lv_style_init+0x2c0>)
 80039c4:	2205      	movs	r2, #5
 80039c6:	83da      	strh	r2, [r3, #30]

    lv_style_scr.body.border.color = LV_COLOR_BLACK;
 80039c8:	4a9d      	ldr	r2, [pc, #628]	; (8003c40 <lv_style_init+0x2c0>)
 80039ca:	7a93      	ldrb	r3, [r2, #10]
 80039cc:	f36f 0304 	bfc	r3, #0, #5
 80039d0:	7293      	strb	r3, [r2, #10]
 80039d2:	4a9b      	ldr	r2, [pc, #620]	; (8003c40 <lv_style_init+0x2c0>)
 80039d4:	8953      	ldrh	r3, [r2, #10]
 80039d6:	f36f 134a 	bfc	r3, #5, #6
 80039da:	8153      	strh	r3, [r2, #10]
 80039dc:	4a98      	ldr	r2, [pc, #608]	; (8003c40 <lv_style_init+0x2c0>)
 80039de:	7ad3      	ldrb	r3, [r2, #11]
 80039e0:	f36f 03c7 	bfc	r3, #3, #5
 80039e4:	72d3      	strb	r3, [r2, #11]
    lv_style_scr.body.border.opa   = LV_OPA_COVER;
 80039e6:	4b96      	ldr	r3, [pc, #600]	; (8003c40 <lv_style_init+0x2c0>)
 80039e8:	22ff      	movs	r2, #255	; 0xff
 80039ea:	73da      	strb	r2, [r3, #15]
    lv_style_scr.body.border.width = 0;
 80039ec:	4b94      	ldr	r3, [pc, #592]	; (8003c40 <lv_style_init+0x2c0>)
 80039ee:	2200      	movs	r2, #0
 80039f0:	819a      	strh	r2, [r3, #12]
    lv_style_scr.body.border.part  = LV_BORDER_FULL;
 80039f2:	4b93      	ldr	r3, [pc, #588]	; (8003c40 <lv_style_init+0x2c0>)
 80039f4:	220f      	movs	r2, #15
 80039f6:	739a      	strb	r2, [r3, #14]

    lv_style_scr.body.shadow.color = LV_COLOR_GRAY;
 80039f8:	4a91      	ldr	r2, [pc, #580]	; (8003c40 <lv_style_init+0x2c0>)
 80039fa:	4b93      	ldr	r3, [pc, #588]	; (8003c48 <lv_style_init+0x2c8>)
 80039fc:	881b      	ldrh	r3, [r3, #0]
 80039fe:	8213      	strh	r3, [r2, #16]
    lv_style_scr.body.shadow.type  = LV_SHADOW_FULL;
 8003a00:	4b8f      	ldr	r3, [pc, #572]	; (8003c40 <lv_style_init+0x2c0>)
 8003a02:	2201      	movs	r2, #1
 8003a04:	751a      	strb	r2, [r3, #20]
    lv_style_scr.body.shadow.width = 0;
 8003a06:	4b8e      	ldr	r3, [pc, #568]	; (8003c40 <lv_style_init+0x2c0>)
 8003a08:	2200      	movs	r2, #0
 8003a0a:	825a      	strh	r2, [r3, #18]

    lv_style_scr.text.opa          = LV_OPA_COVER;
 8003a0c:	4b8c      	ldr	r3, [pc, #560]	; (8003c40 <lv_style_init+0x2c0>)
 8003a0e:	22ff      	movs	r2, #255	; 0xff
 8003a10:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    lv_style_scr.text.color        = lv_color_make(0x30, 0x30, 0x30);
 8003a14:	4c8a      	ldr	r4, [pc, #552]	; (8003c40 <lv_style_init+0x2c0>)
 8003a16:	2230      	movs	r2, #48	; 0x30
 8003a18:	2130      	movs	r1, #48	; 0x30
 8003a1a:	2030      	movs	r0, #48	; 0x30
 8003a1c:	f7ff ff86 	bl	800392c <lv_color_make>
 8003a20:	8420      	strh	r0, [r4, #32]
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
 8003a22:	4c87      	ldr	r4, [pc, #540]	; (8003c40 <lv_style_init+0x2c0>)
 8003a24:	22d8      	movs	r2, #216	; 0xd8
 8003a26:	2196      	movs	r1, #150	; 0x96
 8003a28:	2055      	movs	r0, #85	; 0x55
 8003a2a:	f7ff ff7f 	bl	800392c <lv_color_make>
 8003a2e:	8460      	strh	r0, [r4, #34]	; 0x22
    lv_style_scr.text.font         = LV_FONT_DEFAULT;
 8003a30:	4b83      	ldr	r3, [pc, #524]	; (8003c40 <lv_style_init+0x2c0>)
 8003a32:	4a86      	ldr	r2, [pc, #536]	; (8003c4c <lv_style_init+0x2cc>)
 8003a34:	625a      	str	r2, [r3, #36]	; 0x24
    lv_style_scr.text.letter_space = 0;
 8003a36:	4b82      	ldr	r3, [pc, #520]	; (8003c40 <lv_style_init+0x2c0>)
 8003a38:	2200      	movs	r2, #0
 8003a3a:	851a      	strh	r2, [r3, #40]	; 0x28
    lv_style_scr.text.line_space   = 2;
 8003a3c:	4b80      	ldr	r3, [pc, #512]	; (8003c40 <lv_style_init+0x2c0>)
 8003a3e:	2202      	movs	r2, #2
 8003a40:	855a      	strh	r2, [r3, #42]	; 0x2a

    lv_style_scr.image.opa     = LV_OPA_COVER;
 8003a42:	4b7f      	ldr	r3, [pc, #508]	; (8003c40 <lv_style_init+0x2c0>)
 8003a44:	22ff      	movs	r2, #255	; 0xff
 8003a46:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
    lv_style_scr.image.color   = lv_color_make(0x20, 0x20, 0x20);
 8003a4a:	4c7d      	ldr	r4, [pc, #500]	; (8003c40 <lv_style_init+0x2c0>)
 8003a4c:	2220      	movs	r2, #32
 8003a4e:	2120      	movs	r1, #32
 8003a50:	2020      	movs	r0, #32
 8003a52:	f7ff ff6b 	bl	800392c <lv_color_make>
 8003a56:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_scr.image.intense = LV_OPA_TRANSP;
 8003a58:	4b79      	ldr	r3, [pc, #484]	; (8003c40 <lv_style_init+0x2c0>)
 8003a5a:	2200      	movs	r2, #0
 8003a5c:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32

    lv_style_scr.line.opa     = LV_OPA_COVER;
 8003a60:	4b77      	ldr	r3, [pc, #476]	; (8003c40 <lv_style_init+0x2c0>)
 8003a62:	22ff      	movs	r2, #255	; 0xff
 8003a64:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    lv_style_scr.line.color   = lv_color_make(0x20, 0x20, 0x20);
 8003a68:	4c75      	ldr	r4, [pc, #468]	; (8003c40 <lv_style_init+0x2c0>)
 8003a6a:	2220      	movs	r2, #32
 8003a6c:	2120      	movs	r1, #32
 8003a6e:	2020      	movs	r0, #32
 8003a70:	f7ff ff5c 	bl	800392c <lv_color_make>
 8003a74:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_scr.line.width   = 2;
 8003a76:	4b72      	ldr	r3, [pc, #456]	; (8003c40 <lv_style_init+0x2c0>)
 8003a78:	2202      	movs	r2, #2
 8003a7a:	86da      	strh	r2, [r3, #54]	; 0x36
    lv_style_scr.line.rounded = 0;
 8003a7c:	4a70      	ldr	r2, [pc, #448]	; (8003c40 <lv_style_init+0x2c0>)
 8003a7e:	f892 3039 	ldrb.w	r3, [r2, #57]	; 0x39
 8003a82:	f36f 0300 	bfc	r3, #0, #1
 8003a86:	f882 3039 	strb.w	r3, [r2, #57]	; 0x39

#if LV_USE_DEBUG
#if LV_USE_ASSERT_STYLE
    lv_style_scr.debug_sentinel = LV_STYLE_DEGUG_SENTINEL_VALUE;
 8003a8a:	4b6d      	ldr	r3, [pc, #436]	; (8003c40 <lv_style_init+0x2c0>)
 8003a8c:	4a70      	ldr	r2, [pc, #448]	; (8003c50 <lv_style_init+0x2d0>)
 8003a8e:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#endif

    /*Plain style (by default near the same as the screen style)*/
    lv_style_copy(&lv_style_plain, &lv_style_scr);
 8003a90:	496b      	ldr	r1, [pc, #428]	; (8003c40 <lv_style_init+0x2c0>)
 8003a92:	4870      	ldr	r0, [pc, #448]	; (8003c54 <lv_style_init+0x2d4>)
 8003a94:	f000 f9d0 	bl	8003e38 <lv_style_copy>
    lv_style_plain.body.padding.left   = LV_DPI / 20;
 8003a98:	4b6e      	ldr	r3, [pc, #440]	; (8003c54 <lv_style_init+0x2d4>)
 8003a9a:	2205      	movs	r2, #5
 8003a9c:	835a      	strh	r2, [r3, #26]
    lv_style_plain.body.padding.right  = LV_DPI / 20;
 8003a9e:	4b6d      	ldr	r3, [pc, #436]	; (8003c54 <lv_style_init+0x2d4>)
 8003aa0:	2205      	movs	r2, #5
 8003aa2:	839a      	strh	r2, [r3, #28]
    lv_style_plain.body.padding.top    = LV_DPI / 20;
 8003aa4:	4b6b      	ldr	r3, [pc, #428]	; (8003c54 <lv_style_init+0x2d4>)
 8003aa6:	2205      	movs	r2, #5
 8003aa8:	82da      	strh	r2, [r3, #22]
    lv_style_plain.body.padding.bottom = LV_DPI / 20;
 8003aaa:	4b6a      	ldr	r3, [pc, #424]	; (8003c54 <lv_style_init+0x2d4>)
 8003aac:	2205      	movs	r2, #5
 8003aae:	831a      	strh	r2, [r3, #24]

    /*Plain color style*/
    lv_style_copy(&lv_style_plain_color, &lv_style_plain);
 8003ab0:	4968      	ldr	r1, [pc, #416]	; (8003c54 <lv_style_init+0x2d4>)
 8003ab2:	4869      	ldr	r0, [pc, #420]	; (8003c58 <lv_style_init+0x2d8>)
 8003ab4:	f000 f9c0 	bl	8003e38 <lv_style_copy>
    lv_style_plain_color.text.color      = lv_color_make(0xf0, 0xf0, 0xf0);
 8003ab8:	4c67      	ldr	r4, [pc, #412]	; (8003c58 <lv_style_init+0x2d8>)
 8003aba:	22f0      	movs	r2, #240	; 0xf0
 8003abc:	21f0      	movs	r1, #240	; 0xf0
 8003abe:	20f0      	movs	r0, #240	; 0xf0
 8003ac0:	f7ff ff34 	bl	800392c <lv_color_make>
 8003ac4:	8420      	strh	r0, [r4, #32]
    lv_style_plain_color.image.color     = lv_color_make(0xf0, 0xf0, 0xf0);
 8003ac6:	4c64      	ldr	r4, [pc, #400]	; (8003c58 <lv_style_init+0x2d8>)
 8003ac8:	22f0      	movs	r2, #240	; 0xf0
 8003aca:	21f0      	movs	r1, #240	; 0xf0
 8003acc:	20f0      	movs	r0, #240	; 0xf0
 8003ace:	f7ff ff2d 	bl	800392c <lv_color_make>
 8003ad2:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_plain_color.line.color      = lv_color_make(0xf0, 0xf0, 0xf0);
 8003ad4:	4c60      	ldr	r4, [pc, #384]	; (8003c58 <lv_style_init+0x2d8>)
 8003ad6:	22f0      	movs	r2, #240	; 0xf0
 8003ad8:	21f0      	movs	r1, #240	; 0xf0
 8003ada:	20f0      	movs	r0, #240	; 0xf0
 8003adc:	f7ff ff26 	bl	800392c <lv_color_make>
 8003ae0:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_plain_color.body.main_color = lv_color_make(0x55, 0x96, 0xd8);
 8003ae2:	4c5d      	ldr	r4, [pc, #372]	; (8003c58 <lv_style_init+0x2d8>)
 8003ae4:	22d8      	movs	r2, #216	; 0xd8
 8003ae6:	2196      	movs	r1, #150	; 0x96
 8003ae8:	2055      	movs	r0, #85	; 0x55
 8003aea:	f7ff ff1f 	bl	800392c <lv_color_make>
 8003aee:	8060      	strh	r0, [r4, #2]
    lv_style_plain_color.body.grad_color = lv_style_plain_color.body.main_color;
 8003af0:	4a59      	ldr	r2, [pc, #356]	; (8003c58 <lv_style_init+0x2d8>)
 8003af2:	4b59      	ldr	r3, [pc, #356]	; (8003c58 <lv_style_init+0x2d8>)
 8003af4:	885b      	ldrh	r3, [r3, #2]
 8003af6:	8093      	strh	r3, [r2, #4]

    /*Pretty style */
    lv_style_copy(&lv_style_pretty, &lv_style_plain);
 8003af8:	4956      	ldr	r1, [pc, #344]	; (8003c54 <lv_style_init+0x2d4>)
 8003afa:	4858      	ldr	r0, [pc, #352]	; (8003c5c <lv_style_init+0x2dc>)
 8003afc:	f000 f99c 	bl	8003e38 <lv_style_copy>
    lv_style_pretty.text.color        = lv_color_make(0x20, 0x20, 0x20);
 8003b00:	4c56      	ldr	r4, [pc, #344]	; (8003c5c <lv_style_init+0x2dc>)
 8003b02:	2220      	movs	r2, #32
 8003b04:	2120      	movs	r1, #32
 8003b06:	2020      	movs	r0, #32
 8003b08:	f7ff ff10 	bl	800392c <lv_color_make>
 8003b0c:	8420      	strh	r0, [r4, #32]
    lv_style_pretty.image.color       = lv_color_make(0x20, 0x20, 0x20);
 8003b0e:	4c53      	ldr	r4, [pc, #332]	; (8003c5c <lv_style_init+0x2dc>)
 8003b10:	2220      	movs	r2, #32
 8003b12:	2120      	movs	r1, #32
 8003b14:	2020      	movs	r0, #32
 8003b16:	f7ff ff09 	bl	800392c <lv_color_make>
 8003b1a:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_pretty.line.color        = lv_color_make(0x20, 0x20, 0x20);
 8003b1c:	4c4f      	ldr	r4, [pc, #316]	; (8003c5c <lv_style_init+0x2dc>)
 8003b1e:	2220      	movs	r2, #32
 8003b20:	2120      	movs	r1, #32
 8003b22:	2020      	movs	r0, #32
 8003b24:	f7ff ff02 	bl	800392c <lv_color_make>
 8003b28:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_pretty.body.main_color   = LV_COLOR_WHITE;
 8003b2a:	4a4c      	ldr	r2, [pc, #304]	; (8003c5c <lv_style_init+0x2dc>)
 8003b2c:	4b45      	ldr	r3, [pc, #276]	; (8003c44 <lv_style_init+0x2c4>)
 8003b2e:	881b      	ldrh	r3, [r3, #0]
 8003b30:	8053      	strh	r3, [r2, #2]
    lv_style_pretty.body.grad_color   = LV_COLOR_SILVER;
 8003b32:	4a4a      	ldr	r2, [pc, #296]	; (8003c5c <lv_style_init+0x2dc>)
 8003b34:	4b4a      	ldr	r3, [pc, #296]	; (8003c60 <lv_style_init+0x2e0>)
 8003b36:	881b      	ldrh	r3, [r3, #0]
 8003b38:	8093      	strh	r3, [r2, #4]
    lv_style_pretty.body.radius       = LV_DPI / 15;
 8003b3a:	4b48      	ldr	r3, [pc, #288]	; (8003c5c <lv_style_init+0x2dc>)
 8003b3c:	2206      	movs	r2, #6
 8003b3e:	80da      	strh	r2, [r3, #6]
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
 8003b40:	4c46      	ldr	r4, [pc, #280]	; (8003c5c <lv_style_init+0x2dc>)
 8003b42:	2240      	movs	r2, #64	; 0x40
 8003b44:	2140      	movs	r1, #64	; 0x40
 8003b46:	2040      	movs	r0, #64	; 0x40
 8003b48:	f7ff fef0 	bl	800392c <lv_color_make>
 8003b4c:	8160      	strh	r0, [r4, #10]
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
 8003b4e:	4b43      	ldr	r3, [pc, #268]	; (8003c5c <lv_style_init+0x2dc>)
 8003b50:	2202      	movs	r2, #2
 8003b52:	819a      	strh	r2, [r3, #12]
    lv_style_pretty.body.border.opa   = LV_OPA_30;
 8003b54:	4b41      	ldr	r3, [pc, #260]	; (8003c5c <lv_style_init+0x2dc>)
 8003b56:	224c      	movs	r2, #76	; 0x4c
 8003b58:	73da      	strb	r2, [r3, #15]

    /*Pretty color style*/
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
 8003b5a:	4940      	ldr	r1, [pc, #256]	; (8003c5c <lv_style_init+0x2dc>)
 8003b5c:	4841      	ldr	r0, [pc, #260]	; (8003c64 <lv_style_init+0x2e4>)
 8003b5e:	f000 f96b 	bl	8003e38 <lv_style_copy>
    lv_style_pretty_color.text.color        = lv_color_make(0xe0, 0xe0, 0xe0);
 8003b62:	4c40      	ldr	r4, [pc, #256]	; (8003c64 <lv_style_init+0x2e4>)
 8003b64:	22e0      	movs	r2, #224	; 0xe0
 8003b66:	21e0      	movs	r1, #224	; 0xe0
 8003b68:	20e0      	movs	r0, #224	; 0xe0
 8003b6a:	f7ff fedf 	bl	800392c <lv_color_make>
 8003b6e:	8420      	strh	r0, [r4, #32]
    lv_style_pretty_color.image.color       = lv_color_make(0xe0, 0xe0, 0xe0);
 8003b70:	4c3c      	ldr	r4, [pc, #240]	; (8003c64 <lv_style_init+0x2e4>)
 8003b72:	22e0      	movs	r2, #224	; 0xe0
 8003b74:	21e0      	movs	r1, #224	; 0xe0
 8003b76:	20e0      	movs	r0, #224	; 0xe0
 8003b78:	f7ff fed8 	bl	800392c <lv_color_make>
 8003b7c:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_pretty_color.line.color        = lv_color_make(0xc0, 0xc0, 0xc0);
 8003b7e:	4c39      	ldr	r4, [pc, #228]	; (8003c64 <lv_style_init+0x2e4>)
 8003b80:	22c0      	movs	r2, #192	; 0xc0
 8003b82:	21c0      	movs	r1, #192	; 0xc0
 8003b84:	20c0      	movs	r0, #192	; 0xc0
 8003b86:	f7ff fed1 	bl	800392c <lv_color_make>
 8003b8a:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_pretty_color.body.main_color   = lv_color_make(0x6b, 0x9a, 0xc7);
 8003b8c:	4c35      	ldr	r4, [pc, #212]	; (8003c64 <lv_style_init+0x2e4>)
 8003b8e:	22c7      	movs	r2, #199	; 0xc7
 8003b90:	219a      	movs	r1, #154	; 0x9a
 8003b92:	206b      	movs	r0, #107	; 0x6b
 8003b94:	f7ff feca 	bl	800392c <lv_color_make>
 8003b98:	8060      	strh	r0, [r4, #2]
    lv_style_pretty_color.body.grad_color   = lv_color_make(0x2b, 0x59, 0x8b);
 8003b9a:	4c32      	ldr	r4, [pc, #200]	; (8003c64 <lv_style_init+0x2e4>)
 8003b9c:	228b      	movs	r2, #139	; 0x8b
 8003b9e:	2159      	movs	r1, #89	; 0x59
 8003ba0:	202b      	movs	r0, #43	; 0x2b
 8003ba2:	f7ff fec3 	bl	800392c <lv_color_make>
 8003ba6:	80a0      	strh	r0, [r4, #4]
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);
 8003ba8:	4c2e      	ldr	r4, [pc, #184]	; (8003c64 <lv_style_init+0x2e4>)
 8003baa:	2242      	movs	r2, #66	; 0x42
 8003bac:	212c      	movs	r1, #44	; 0x2c
 8003bae:	2015      	movs	r0, #21
 8003bb0:	f7ff febc 	bl	800392c <lv_color_make>
 8003bb4:	8160      	strh	r0, [r4, #10]

    /*Transparent style*/
    lv_style_copy(&lv_style_transp, &lv_style_plain);
 8003bb6:	4927      	ldr	r1, [pc, #156]	; (8003c54 <lv_style_init+0x2d4>)
 8003bb8:	482b      	ldr	r0, [pc, #172]	; (8003c68 <lv_style_init+0x2e8>)
 8003bba:	f000 f93d 	bl	8003e38 <lv_style_copy>
    lv_style_transp.glass             = 1;
 8003bbe:	4a2a      	ldr	r2, [pc, #168]	; (8003c68 <lv_style_init+0x2e8>)
 8003bc0:	7813      	ldrb	r3, [r2, #0]
 8003bc2:	f043 0301 	orr.w	r3, r3, #1
 8003bc6:	7013      	strb	r3, [r2, #0]
    lv_style_transp.body.border.width = 0;
 8003bc8:	4b27      	ldr	r3, [pc, #156]	; (8003c68 <lv_style_init+0x2e8>)
 8003bca:	2200      	movs	r2, #0
 8003bcc:	819a      	strh	r2, [r3, #12]
    lv_style_transp.body.opa          = LV_OPA_TRANSP;
 8003bce:	4b26      	ldr	r3, [pc, #152]	; (8003c68 <lv_style_init+0x2e8>)
 8003bd0:	2200      	movs	r2, #0
 8003bd2:	721a      	strb	r2, [r3, #8]

    /*Transparent fitting size*/
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
 8003bd4:	4924      	ldr	r1, [pc, #144]	; (8003c68 <lv_style_init+0x2e8>)
 8003bd6:	4825      	ldr	r0, [pc, #148]	; (8003c6c <lv_style_init+0x2ec>)
 8003bd8:	f000 f92e 	bl	8003e38 <lv_style_copy>
    lv_style_transp_fit.body.padding.left   = 0;
 8003bdc:	4b23      	ldr	r3, [pc, #140]	; (8003c6c <lv_style_init+0x2ec>)
 8003bde:	2200      	movs	r2, #0
 8003be0:	835a      	strh	r2, [r3, #26]
    lv_style_transp_fit.body.padding.right  = 0;
 8003be2:	4b22      	ldr	r3, [pc, #136]	; (8003c6c <lv_style_init+0x2ec>)
 8003be4:	2200      	movs	r2, #0
 8003be6:	839a      	strh	r2, [r3, #28]
    lv_style_transp_fit.body.padding.top    = 0;
 8003be8:	4b20      	ldr	r3, [pc, #128]	; (8003c6c <lv_style_init+0x2ec>)
 8003bea:	2200      	movs	r2, #0
 8003bec:	82da      	strh	r2, [r3, #22]
    lv_style_transp_fit.body.padding.bottom = 0;
 8003bee:	4b1f      	ldr	r3, [pc, #124]	; (8003c6c <lv_style_init+0x2ec>)
 8003bf0:	2200      	movs	r2, #0
 8003bf2:	831a      	strh	r2, [r3, #24]

    /*Transparent tight style*/
    lv_style_copy(&lv_style_transp_tight, &lv_style_transp_fit);
 8003bf4:	491d      	ldr	r1, [pc, #116]	; (8003c6c <lv_style_init+0x2ec>)
 8003bf6:	481e      	ldr	r0, [pc, #120]	; (8003c70 <lv_style_init+0x2f0>)
 8003bf8:	f000 f91e 	bl	8003e38 <lv_style_copy>
    lv_style_transp_tight.body.padding.inner = 0;
 8003bfc:	4b1c      	ldr	r3, [pc, #112]	; (8003c70 <lv_style_init+0x2f0>)
 8003bfe:	2200      	movs	r2, #0
 8003c00:	83da      	strh	r2, [r3, #30]

    /*Button released style*/
    lv_style_copy(&lv_style_btn_rel, &lv_style_plain);
 8003c02:	4914      	ldr	r1, [pc, #80]	; (8003c54 <lv_style_init+0x2d4>)
 8003c04:	481b      	ldr	r0, [pc, #108]	; (8003c74 <lv_style_init+0x2f4>)
 8003c06:	f000 f917 	bl	8003e38 <lv_style_copy>
    lv_style_btn_rel.body.main_color     = lv_color_make(0x76, 0xa2, 0xd0);
 8003c0a:	4c1a      	ldr	r4, [pc, #104]	; (8003c74 <lv_style_init+0x2f4>)
 8003c0c:	22d0      	movs	r2, #208	; 0xd0
 8003c0e:	21a2      	movs	r1, #162	; 0xa2
 8003c10:	2076      	movs	r0, #118	; 0x76
 8003c12:	f7ff fe8b 	bl	800392c <lv_color_make>
 8003c16:	8060      	strh	r0, [r4, #2]
    lv_style_btn_rel.body.grad_color     = lv_color_make(0x19, 0x3a, 0x5d);
 8003c18:	4c16      	ldr	r4, [pc, #88]	; (8003c74 <lv_style_init+0x2f4>)
 8003c1a:	225d      	movs	r2, #93	; 0x5d
 8003c1c:	213a      	movs	r1, #58	; 0x3a
 8003c1e:	2019      	movs	r0, #25
 8003c20:	f7ff fe84 	bl	800392c <lv_color_make>
 8003c24:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_rel.body.radius         = LV_DPI / 15;
 8003c26:	4b13      	ldr	r3, [pc, #76]	; (8003c74 <lv_style_init+0x2f4>)
 8003c28:	2206      	movs	r2, #6
 8003c2a:	80da      	strh	r2, [r3, #6]
    lv_style_btn_rel.body.padding.left   = LV_DPI / 4;
 8003c2c:	4b11      	ldr	r3, [pc, #68]	; (8003c74 <lv_style_init+0x2f4>)
 8003c2e:	2219      	movs	r2, #25
 8003c30:	835a      	strh	r2, [r3, #26]
    lv_style_btn_rel.body.padding.right  = LV_DPI / 4;
 8003c32:	4b10      	ldr	r3, [pc, #64]	; (8003c74 <lv_style_init+0x2f4>)
 8003c34:	2219      	movs	r2, #25
 8003c36:	839a      	strh	r2, [r3, #28]
    lv_style_btn_rel.body.padding.top    = LV_DPI / 6;
 8003c38:	4b0e      	ldr	r3, [pc, #56]	; (8003c74 <lv_style_init+0x2f4>)
 8003c3a:	2210      	movs	r2, #16
 8003c3c:	82da      	strh	r2, [r3, #22]
 8003c3e:	e01b      	b.n	8003c78 <lv_style_init+0x2f8>
 8003c40:	20009880 	.word	0x20009880
 8003c44:	080137e0 	.word	0x080137e0
 8003c48:	080137e4 	.word	0x080137e4
 8003c4c:	20000040 	.word	0x20000040
 8003c50:	12345678 	.word	0x12345678
 8003c54:	20009800 	.word	0x20009800
 8003c58:	20009900 	.word	0x20009900
 8003c5c:	20009700 	.word	0x20009700
 8003c60:	080137e8 	.word	0x080137e8
 8003c64:	20009600 	.word	0x20009600
 8003c68:	20009640 	.word	0x20009640
 8003c6c:	200097c0 	.word	0x200097c0
 8003c70:	20009740 	.word	0x20009740
 8003c74:	20009680 	.word	0x20009680
    lv_style_btn_rel.body.padding.bottom = LV_DPI / 6;
 8003c78:	4b69      	ldr	r3, [pc, #420]	; (8003e20 <lv_style_init+0x4a0>)
 8003c7a:	2210      	movs	r2, #16
 8003c7c:	831a      	strh	r2, [r3, #24]
    lv_style_btn_rel.body.padding.inner  = LV_DPI / 10;
 8003c7e:	4b68      	ldr	r3, [pc, #416]	; (8003e20 <lv_style_init+0x4a0>)
 8003c80:	220a      	movs	r2, #10
 8003c82:	83da      	strh	r2, [r3, #30]
    lv_style_btn_rel.body.border.color   = lv_color_make(0x0b, 0x19, 0x28);
 8003c84:	4c66      	ldr	r4, [pc, #408]	; (8003e20 <lv_style_init+0x4a0>)
 8003c86:	2228      	movs	r2, #40	; 0x28
 8003c88:	2119      	movs	r1, #25
 8003c8a:	200b      	movs	r0, #11
 8003c8c:	f7ff fe4e 	bl	800392c <lv_color_make>
 8003c90:	8160      	strh	r0, [r4, #10]
    lv_style_btn_rel.body.border.width   = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
 8003c92:	4b63      	ldr	r3, [pc, #396]	; (8003e20 <lv_style_init+0x4a0>)
 8003c94:	2202      	movs	r2, #2
 8003c96:	819a      	strh	r2, [r3, #12]
    lv_style_btn_rel.body.border.opa     = LV_OPA_70;
 8003c98:	4b61      	ldr	r3, [pc, #388]	; (8003e20 <lv_style_init+0x4a0>)
 8003c9a:	22b2      	movs	r2, #178	; 0xb2
 8003c9c:	73da      	strb	r2, [r3, #15]
    lv_style_btn_rel.body.shadow.color   = LV_COLOR_GRAY;
 8003c9e:	4a60      	ldr	r2, [pc, #384]	; (8003e20 <lv_style_init+0x4a0>)
 8003ca0:	4b60      	ldr	r3, [pc, #384]	; (8003e24 <lv_style_init+0x4a4>)
 8003ca2:	881b      	ldrh	r3, [r3, #0]
 8003ca4:	8213      	strh	r3, [r2, #16]
    lv_style_btn_rel.body.shadow.width   = 0;
 8003ca6:	4b5e      	ldr	r3, [pc, #376]	; (8003e20 <lv_style_init+0x4a0>)
 8003ca8:	2200      	movs	r2, #0
 8003caa:	825a      	strh	r2, [r3, #18]
    lv_style_btn_rel.text.color          = lv_color_make(0xff, 0xff, 0xff);
 8003cac:	4c5c      	ldr	r4, [pc, #368]	; (8003e20 <lv_style_init+0x4a0>)
 8003cae:	22ff      	movs	r2, #255	; 0xff
 8003cb0:	21ff      	movs	r1, #255	; 0xff
 8003cb2:	20ff      	movs	r0, #255	; 0xff
 8003cb4:	f7ff fe3a 	bl	800392c <lv_color_make>
 8003cb8:	8420      	strh	r0, [r4, #32]
    lv_style_btn_rel.image.color         = lv_color_make(0xff, 0xff, 0xff);
 8003cba:	4c59      	ldr	r4, [pc, #356]	; (8003e20 <lv_style_init+0x4a0>)
 8003cbc:	22ff      	movs	r2, #255	; 0xff
 8003cbe:	21ff      	movs	r1, #255	; 0xff
 8003cc0:	20ff      	movs	r0, #255	; 0xff
 8003cc2:	f7ff fe33 	bl	800392c <lv_color_make>
 8003cc6:	8620      	strh	r0, [r4, #48]	; 0x30

    /*Button pressed style*/
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
 8003cc8:	4955      	ldr	r1, [pc, #340]	; (8003e20 <lv_style_init+0x4a0>)
 8003cca:	4857      	ldr	r0, [pc, #348]	; (8003e28 <lv_style_init+0x4a8>)
 8003ccc:	f000 f8b4 	bl	8003e38 <lv_style_copy>
    lv_style_btn_pr.body.main_color = lv_color_make(0x33, 0x62, 0x94);
 8003cd0:	4c55      	ldr	r4, [pc, #340]	; (8003e28 <lv_style_init+0x4a8>)
 8003cd2:	2294      	movs	r2, #148	; 0x94
 8003cd4:	2162      	movs	r1, #98	; 0x62
 8003cd6:	2033      	movs	r0, #51	; 0x33
 8003cd8:	f7ff fe28 	bl	800392c <lv_color_make>
 8003cdc:	8060      	strh	r0, [r4, #2]
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
 8003cde:	4c52      	ldr	r4, [pc, #328]	; (8003e28 <lv_style_init+0x4a8>)
 8003ce0:	223c      	movs	r2, #60	; 0x3c
 8003ce2:	2126      	movs	r1, #38	; 0x26
 8003ce4:	2010      	movs	r0, #16
 8003ce6:	f7ff fe21 	bl	800392c <lv_color_make>
 8003cea:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 8003cec:	4c4e      	ldr	r4, [pc, #312]	; (8003e28 <lv_style_init+0x4a8>)
 8003cee:	22c6      	movs	r2, #198	; 0xc6
 8003cf0:	21b5      	movs	r1, #181	; 0xb5
 8003cf2:	20a4      	movs	r0, #164	; 0xa4
 8003cf4:	f7ff fe1a 	bl	800392c <lv_color_make>
 8003cf8:	8420      	strh	r0, [r4, #32]
    lv_style_btn_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
 8003cfa:	4c4b      	ldr	r4, [pc, #300]	; (8003e28 <lv_style_init+0x4a8>)
 8003cfc:	22c6      	movs	r2, #198	; 0xc6
 8003cfe:	21b5      	movs	r1, #181	; 0xb5
 8003d00:	20a4      	movs	r0, #164	; 0xa4
 8003d02:	f7ff fe13 	bl	800392c <lv_color_make>
 8003d06:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 8003d08:	4c47      	ldr	r4, [pc, #284]	; (8003e28 <lv_style_init+0x4a8>)
 8003d0a:	22c6      	movs	r2, #198	; 0xc6
 8003d0c:	21b5      	movs	r1, #181	; 0xb5
 8003d0e:	20a4      	movs	r0, #164	; 0xa4
 8003d10:	f7ff fe0c 	bl	800392c <lv_color_make>
 8003d14:	86a0      	strh	r0, [r4, #52]	; 0x34

    /*Button toggle released style*/
    lv_style_copy(&lv_style_btn_tgl_rel, &lv_style_btn_rel);
 8003d16:	4942      	ldr	r1, [pc, #264]	; (8003e20 <lv_style_init+0x4a0>)
 8003d18:	4844      	ldr	r0, [pc, #272]	; (8003e2c <lv_style_init+0x4ac>)
 8003d1a:	f000 f88d 	bl	8003e38 <lv_style_copy>
    lv_style_btn_tgl_rel.body.main_color   = lv_color_make(0x0a, 0x11, 0x22);
 8003d1e:	4c43      	ldr	r4, [pc, #268]	; (8003e2c <lv_style_init+0x4ac>)
 8003d20:	2222      	movs	r2, #34	; 0x22
 8003d22:	2111      	movs	r1, #17
 8003d24:	200a      	movs	r0, #10
 8003d26:	f7ff fe01 	bl	800392c <lv_color_make>
 8003d2a:	8060      	strh	r0, [r4, #2]
    lv_style_btn_tgl_rel.body.grad_color   = lv_color_make(0x37, 0x62, 0x90);
 8003d2c:	4c3f      	ldr	r4, [pc, #252]	; (8003e2c <lv_style_init+0x4ac>)
 8003d2e:	2290      	movs	r2, #144	; 0x90
 8003d30:	2162      	movs	r1, #98	; 0x62
 8003d32:	2037      	movs	r0, #55	; 0x37
 8003d34:	f7ff fdfa 	bl	800392c <lv_color_make>
 8003d38:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_tgl_rel.body.border.color = lv_color_make(0x01, 0x07, 0x0d);
 8003d3a:	4c3c      	ldr	r4, [pc, #240]	; (8003e2c <lv_style_init+0x4ac>)
 8003d3c:	220d      	movs	r2, #13
 8003d3e:	2107      	movs	r1, #7
 8003d40:	2001      	movs	r0, #1
 8003d42:	f7ff fdf3 	bl	800392c <lv_color_make>
 8003d46:	8160      	strh	r0, [r4, #10]
    lv_style_btn_tgl_rel.text.color        = lv_color_make(0xc8, 0xdd, 0xf4);
 8003d48:	4c38      	ldr	r4, [pc, #224]	; (8003e2c <lv_style_init+0x4ac>)
 8003d4a:	22f4      	movs	r2, #244	; 0xf4
 8003d4c:	21dd      	movs	r1, #221	; 0xdd
 8003d4e:	20c8      	movs	r0, #200	; 0xc8
 8003d50:	f7ff fdec 	bl	800392c <lv_color_make>
 8003d54:	8420      	strh	r0, [r4, #32]
    lv_style_btn_tgl_rel.image.color       = lv_color_make(0xc8, 0xdd, 0xf4);
 8003d56:	4c35      	ldr	r4, [pc, #212]	; (8003e2c <lv_style_init+0x4ac>)
 8003d58:	22f4      	movs	r2, #244	; 0xf4
 8003d5a:	21dd      	movs	r1, #221	; 0xdd
 8003d5c:	20c8      	movs	r0, #200	; 0xc8
 8003d5e:	f7ff fde5 	bl	800392c <lv_color_make>
 8003d62:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_tgl_rel.line.color        = lv_color_make(0xc8, 0xdd, 0xf4);
 8003d64:	4c31      	ldr	r4, [pc, #196]	; (8003e2c <lv_style_init+0x4ac>)
 8003d66:	22f4      	movs	r2, #244	; 0xf4
 8003d68:	21dd      	movs	r1, #221	; 0xdd
 8003d6a:	20c8      	movs	r0, #200	; 0xc8
 8003d6c:	f7ff fdde 	bl	800392c <lv_color_make>
 8003d70:	86a0      	strh	r0, [r4, #52]	; 0x34

    /*Button toggle pressed style*/
    lv_style_copy(&lv_style_btn_tgl_pr, &lv_style_btn_tgl_rel);
 8003d72:	492e      	ldr	r1, [pc, #184]	; (8003e2c <lv_style_init+0x4ac>)
 8003d74:	482e      	ldr	r0, [pc, #184]	; (8003e30 <lv_style_init+0x4b0>)
 8003d76:	f000 f85f 	bl	8003e38 <lv_style_copy>
    lv_style_btn_tgl_pr.body.main_color = lv_color_make(0x02, 0x14, 0x27);
 8003d7a:	4c2d      	ldr	r4, [pc, #180]	; (8003e30 <lv_style_init+0x4b0>)
 8003d7c:	2227      	movs	r2, #39	; 0x27
 8003d7e:	2114      	movs	r1, #20
 8003d80:	2002      	movs	r0, #2
 8003d82:	f7ff fdd3 	bl	800392c <lv_color_make>
 8003d86:	8060      	strh	r0, [r4, #2]
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
 8003d88:	4c29      	ldr	r4, [pc, #164]	; (8003e30 <lv_style_init+0x4b0>)
 8003d8a:	2270      	movs	r2, #112	; 0x70
 8003d8c:	214c      	movs	r1, #76	; 0x4c
 8003d8e:	202b      	movs	r0, #43	; 0x2b
 8003d90:	f7ff fdcc 	bl	800392c <lv_color_make>
 8003d94:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_tgl_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 8003d96:	4c26      	ldr	r4, [pc, #152]	; (8003e30 <lv_style_init+0x4b0>)
 8003d98:	22c6      	movs	r2, #198	; 0xc6
 8003d9a:	21b5      	movs	r1, #181	; 0xb5
 8003d9c:	20a4      	movs	r0, #164	; 0xa4
 8003d9e:	f7ff fdc5 	bl	800392c <lv_color_make>
 8003da2:	8420      	strh	r0, [r4, #32]
    lv_style_btn_tgl_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
 8003da4:	4c22      	ldr	r4, [pc, #136]	; (8003e30 <lv_style_init+0x4b0>)
 8003da6:	22c6      	movs	r2, #198	; 0xc6
 8003da8:	21b5      	movs	r1, #181	; 0xb5
 8003daa:	20a4      	movs	r0, #164	; 0xa4
 8003dac:	f7ff fdbe 	bl	800392c <lv_color_make>
 8003db0:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_tgl_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 8003db2:	4c1f      	ldr	r4, [pc, #124]	; (8003e30 <lv_style_init+0x4b0>)
 8003db4:	22c6      	movs	r2, #198	; 0xc6
 8003db6:	21b5      	movs	r1, #181	; 0xb5
 8003db8:	20a4      	movs	r0, #164	; 0xa4
 8003dba:	f7ff fdb7 	bl	800392c <lv_color_make>
 8003dbe:	86a0      	strh	r0, [r4, #52]	; 0x34

    /*Button inactive style*/
    lv_style_copy(&lv_style_btn_ina, &lv_style_btn_rel);
 8003dc0:	4917      	ldr	r1, [pc, #92]	; (8003e20 <lv_style_init+0x4a0>)
 8003dc2:	481c      	ldr	r0, [pc, #112]	; (8003e34 <lv_style_init+0x4b4>)
 8003dc4:	f000 f838 	bl	8003e38 <lv_style_copy>
    lv_style_btn_ina.body.main_color   = lv_color_make(0xd8, 0xd8, 0xd8);
 8003dc8:	4c1a      	ldr	r4, [pc, #104]	; (8003e34 <lv_style_init+0x4b4>)
 8003dca:	22d8      	movs	r2, #216	; 0xd8
 8003dcc:	21d8      	movs	r1, #216	; 0xd8
 8003dce:	20d8      	movs	r0, #216	; 0xd8
 8003dd0:	f7ff fdac 	bl	800392c <lv_color_make>
 8003dd4:	8060      	strh	r0, [r4, #2]
    lv_style_btn_ina.body.grad_color   = lv_color_make(0xd8, 0xd8, 0xd8);
 8003dd6:	4c17      	ldr	r4, [pc, #92]	; (8003e34 <lv_style_init+0x4b4>)
 8003dd8:	22d8      	movs	r2, #216	; 0xd8
 8003dda:	21d8      	movs	r1, #216	; 0xd8
 8003ddc:	20d8      	movs	r0, #216	; 0xd8
 8003dde:	f7ff fda5 	bl	800392c <lv_color_make>
 8003de2:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_ina.body.border.color = lv_color_make(0x90, 0x90, 0x90);
 8003de4:	4c13      	ldr	r4, [pc, #76]	; (8003e34 <lv_style_init+0x4b4>)
 8003de6:	2290      	movs	r2, #144	; 0x90
 8003de8:	2190      	movs	r1, #144	; 0x90
 8003dea:	2090      	movs	r0, #144	; 0x90
 8003dec:	f7ff fd9e 	bl	800392c <lv_color_make>
 8003df0:	8160      	strh	r0, [r4, #10]
    lv_style_btn_ina.text.color        = lv_color_make(0x70, 0x70, 0x70);
 8003df2:	4c10      	ldr	r4, [pc, #64]	; (8003e34 <lv_style_init+0x4b4>)
 8003df4:	2270      	movs	r2, #112	; 0x70
 8003df6:	2170      	movs	r1, #112	; 0x70
 8003df8:	2070      	movs	r0, #112	; 0x70
 8003dfa:	f7ff fd97 	bl	800392c <lv_color_make>
 8003dfe:	8420      	strh	r0, [r4, #32]
    lv_style_btn_ina.image.color       = lv_color_make(0x70, 0x70, 0x70);
 8003e00:	4c0c      	ldr	r4, [pc, #48]	; (8003e34 <lv_style_init+0x4b4>)
 8003e02:	2270      	movs	r2, #112	; 0x70
 8003e04:	2170      	movs	r1, #112	; 0x70
 8003e06:	2070      	movs	r0, #112	; 0x70
 8003e08:	f7ff fd90 	bl	800392c <lv_color_make>
 8003e0c:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_ina.line.color        = lv_color_make(0x70, 0x70, 0x70);
 8003e0e:	4c09      	ldr	r4, [pc, #36]	; (8003e34 <lv_style_init+0x4b4>)
 8003e10:	2270      	movs	r2, #112	; 0x70
 8003e12:	2170      	movs	r1, #112	; 0x70
 8003e14:	2070      	movs	r0, #112	; 0x70
 8003e16:	f7ff fd89 	bl	800392c <lv_color_make>
 8003e1a:	86a0      	strh	r0, [r4, #52]	; 0x34
}
 8003e1c:	bf00      	nop
 8003e1e:	bd98      	pop	{r3, r4, r7, pc}
 8003e20:	20009680 	.word	0x20009680
 8003e24:	080137e4 	.word	0x080137e4
 8003e28:	200096c0 	.word	0x200096c0
 8003e2c:	20009840 	.word	0x20009840
 8003e30:	200098c0 	.word	0x200098c0
 8003e34:	20009780 	.word	0x20009780

08003e38 <lv_style_copy>:
 * Copy a style to an other
 * @param dest pointer to the destination style
 * @param src pointer to the source style
 */
void lv_style_copy(lv_style_t * dest, const lv_style_t * src)
{
 8003e38:	b580      	push	{r7, lr}
 8003e3a:	b082      	sub	sp, #8
 8003e3c:	af00      	add	r7, sp, #0
 8003e3e:	6078      	str	r0, [r7, #4]
 8003e40:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_style_t));
 8003e42:	2240      	movs	r2, #64	; 0x40
 8003e44:	6839      	ldr	r1, [r7, #0]
 8003e46:	6878      	ldr	r0, [r7, #4]
 8003e48:	f00f fc7e 	bl	8013748 <memcpy>
}
 8003e4c:	bf00      	nop
 8003e4e:	3708      	adds	r7, #8
 8003e50:	46bd      	mov	sp, r7
 8003e52:	bd80      	pop	{r7, pc}

08003e54 <lv_draw_get_buf>:
 * Give a buffer with the given to use during drawing.
 * Be careful to not use the buffer while other processes are using it.
 * @param size the required size
 */
void * lv_draw_get_buf(uint32_t size)
{
 8003e54:	b590      	push	{r4, r7, lr}
 8003e56:	b083      	sub	sp, #12
 8003e58:	af00      	add	r7, sp, #0
 8003e5a:	6078      	str	r0, [r7, #4]
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
 8003e5c:	4b28      	ldr	r3, [pc, #160]	; (8003f00 <lv_draw_get_buf+0xac>)
 8003e5e:	681b      	ldr	r3, [r3, #0]
 8003e60:	687a      	ldr	r2, [r7, #4]
 8003e62:	429a      	cmp	r2, r3
 8003e64:	d802      	bhi.n	8003e6c <lv_draw_get_buf+0x18>
 8003e66:	4b27      	ldr	r3, [pc, #156]	; (8003f04 <lv_draw_get_buf+0xb0>)
 8003e68:	681b      	ldr	r3, [r3, #0]
 8003e6a:	e044      	b.n	8003ef6 <lv_draw_get_buf+0xa2>

    LV_LOG_TRACE("lv_draw_get_buf: allocate");

    draw_buf_size = size;
 8003e6c:	4a24      	ldr	r2, [pc, #144]	; (8003f00 <lv_draw_get_buf+0xac>)
 8003e6e:	687b      	ldr	r3, [r7, #4]
 8003e70:	6013      	str	r3, [r2, #0]

    if(LV_GC_ROOT(_lv_draw_buf) == NULL) {
 8003e72:	4b24      	ldr	r3, [pc, #144]	; (8003f04 <lv_draw_get_buf+0xb0>)
 8003e74:	681b      	ldr	r3, [r3, #0]
 8003e76:	2b00      	cmp	r3, #0
 8003e78:	d11d      	bne.n	8003eb6 <lv_draw_get_buf+0x62>
        LV_GC_ROOT(_lv_draw_buf) = lv_mem_alloc(size);
 8003e7a:	6878      	ldr	r0, [r7, #4]
 8003e7c:	f008 fec6 	bl	800cc0c <lv_mem_alloc>
 8003e80:	4602      	mov	r2, r0
 8003e82:	4b20      	ldr	r3, [pc, #128]	; (8003f04 <lv_draw_get_buf+0xb0>)
 8003e84:	601a      	str	r2, [r3, #0]
        LV_ASSERT_MEM(LV_GC_ROOT(_lv_draw_buf));
 8003e86:	4b1f      	ldr	r3, [pc, #124]	; (8003f04 <lv_draw_get_buf+0xb0>)
 8003e88:	681b      	ldr	r3, [r3, #0]
 8003e8a:	4618      	mov	r0, r3
 8003e8c:	f7fc f9b4 	bl	80001f8 <lv_debug_check_null>
 8003e90:	4603      	mov	r3, r0
 8003e92:	f083 0301 	eor.w	r3, r3, #1
 8003e96:	b2db      	uxtb	r3, r3
 8003e98:	2b00      	cmp	r3, #0
 8003e9a:	d009      	beq.n	8003eb0 <lv_draw_get_buf+0x5c>
 8003e9c:	4b19      	ldr	r3, [pc, #100]	; (8003f04 <lv_draw_get_buf+0xb0>)
 8003e9e:	681b      	ldr	r3, [r3, #0]
 8003ea0:	f04f 0400 	mov.w	r4, #0
 8003ea4:	461a      	mov	r2, r3
 8003ea6:	4623      	mov	r3, r4
 8003ea8:	4817      	ldr	r0, [pc, #92]	; (8003f08 <lv_draw_get_buf+0xb4>)
 8003eaa:	f7fc f9cf 	bl	800024c <lv_debug_log_error>
 8003eae:	e7fe      	b.n	8003eae <lv_draw_get_buf+0x5a>
        return LV_GC_ROOT(_lv_draw_buf);
 8003eb0:	4b14      	ldr	r3, [pc, #80]	; (8003f04 <lv_draw_get_buf+0xb0>)
 8003eb2:	681b      	ldr	r3, [r3, #0]
 8003eb4:	e01f      	b.n	8003ef6 <lv_draw_get_buf+0xa2>
    }

    LV_GC_ROOT(_lv_draw_buf) = lv_mem_realloc(LV_GC_ROOT(_lv_draw_buf), size);
 8003eb6:	4b13      	ldr	r3, [pc, #76]	; (8003f04 <lv_draw_get_buf+0xb0>)
 8003eb8:	681b      	ldr	r3, [r3, #0]
 8003eba:	6879      	ldr	r1, [r7, #4]
 8003ebc:	4618      	mov	r0, r3
 8003ebe:	f008 ff1b 	bl	800ccf8 <lv_mem_realloc>
 8003ec2:	4602      	mov	r2, r0
 8003ec4:	4b0f      	ldr	r3, [pc, #60]	; (8003f04 <lv_draw_get_buf+0xb0>)
 8003ec6:	601a      	str	r2, [r3, #0]
    LV_ASSERT_MEM(LV_GC_ROOT(_lv_draw_buf));
 8003ec8:	4b0e      	ldr	r3, [pc, #56]	; (8003f04 <lv_draw_get_buf+0xb0>)
 8003eca:	681b      	ldr	r3, [r3, #0]
 8003ecc:	4618      	mov	r0, r3
 8003ece:	f7fc f993 	bl	80001f8 <lv_debug_check_null>
 8003ed2:	4603      	mov	r3, r0
 8003ed4:	f083 0301 	eor.w	r3, r3, #1
 8003ed8:	b2db      	uxtb	r3, r3
 8003eda:	2b00      	cmp	r3, #0
 8003edc:	d009      	beq.n	8003ef2 <lv_draw_get_buf+0x9e>
 8003ede:	4b09      	ldr	r3, [pc, #36]	; (8003f04 <lv_draw_get_buf+0xb0>)
 8003ee0:	681b      	ldr	r3, [r3, #0]
 8003ee2:	f04f 0400 	mov.w	r4, #0
 8003ee6:	461a      	mov	r2, r3
 8003ee8:	4623      	mov	r3, r4
 8003eea:	4807      	ldr	r0, [pc, #28]	; (8003f08 <lv_draw_get_buf+0xb4>)
 8003eec:	f7fc f9ae 	bl	800024c <lv_debug_log_error>
 8003ef0:	e7fe      	b.n	8003ef0 <lv_draw_get_buf+0x9c>
    return LV_GC_ROOT(_lv_draw_buf);
 8003ef2:	4b04      	ldr	r3, [pc, #16]	; (8003f04 <lv_draw_get_buf+0xb0>)
 8003ef4:	681b      	ldr	r3, [r3, #0]
}
 8003ef6:	4618      	mov	r0, r3
 8003ef8:	370c      	adds	r7, #12
 8003efa:	46bd      	mov	sp, r7
 8003efc:	bd90      	pop	{r4, r7, pc}
 8003efe:	bf00      	nop
 8003f00:	200000a8 	.word	0x200000a8
 8003f04:	20009958 	.word	0x20009958
 8003f08:	080137fc 	.word	0x080137fc

08003f0c <lv_draw_free_buf>:

/**
 * Free the draw buffer
 */
void lv_draw_free_buf(void)
{
 8003f0c:	b580      	push	{r7, lr}
 8003f0e:	af00      	add	r7, sp, #0
    if(LV_GC_ROOT(_lv_draw_buf)) {
 8003f10:	4b08      	ldr	r3, [pc, #32]	; (8003f34 <lv_draw_free_buf+0x28>)
 8003f12:	681b      	ldr	r3, [r3, #0]
 8003f14:	2b00      	cmp	r3, #0
 8003f16:	d00a      	beq.n	8003f2e <lv_draw_free_buf+0x22>
        lv_mem_free(LV_GC_ROOT(_lv_draw_buf));
 8003f18:	4b06      	ldr	r3, [pc, #24]	; (8003f34 <lv_draw_free_buf+0x28>)
 8003f1a:	681b      	ldr	r3, [r3, #0]
 8003f1c:	4618      	mov	r0, r3
 8003f1e:	f008 fea7 	bl	800cc70 <lv_mem_free>
        LV_GC_ROOT(_lv_draw_buf) = NULL;
 8003f22:	4b04      	ldr	r3, [pc, #16]	; (8003f34 <lv_draw_free_buf+0x28>)
 8003f24:	2200      	movs	r2, #0
 8003f26:	601a      	str	r2, [r3, #0]
        draw_buf_size = 0;
 8003f28:	4b03      	ldr	r3, [pc, #12]	; (8003f38 <lv_draw_free_buf+0x2c>)
 8003f2a:	2200      	movs	r2, #0
 8003f2c:	601a      	str	r2, [r3, #0]
    }
}
 8003f2e:	bf00      	nop
 8003f30:	bd80      	pop	{r7, pc}
 8003f32:	bf00      	nop
 8003f34:	20009958 	.word	0x20009958
 8003f38:	200000a8 	.word	0x200000a8

08003f3c <lv_draw_aa_get_opa>:
 * @param px_id position of  of a pixel which opacity should be get [0..seg-1]
 * @param base_opa the base opacity
 * @return the opacity of the given pixel
 */
lv_opa_t lv_draw_aa_get_opa(lv_coord_t seg, lv_coord_t px_id, lv_opa_t base_opa)
{
 8003f3c:	b480      	push	{r7}
 8003f3e:	b083      	sub	sp, #12
 8003f40:	af00      	add	r7, sp, #0
 8003f42:	4603      	mov	r3, r0
 8003f44:	80fb      	strh	r3, [r7, #6]
 8003f46:	460b      	mov	r3, r1
 8003f48:	80bb      	strh	r3, [r7, #4]
 8003f4a:	4613      	mov	r3, r2
 8003f4c:	70fb      	strb	r3, [r7, #3]
    static const lv_opa_t seg7[7] = {18, 55, 91, 128, 164, 200, 237};
    static const lv_opa_t seg8[8] = {16, 48, 80, 112, 143, 175, 207, 239};

    static const lv_opa_t * seg_map[] = {seg1, seg2, seg3, seg4, seg5, seg6, seg7, seg8};

    if(seg == 0)
 8003f4e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003f52:	2b00      	cmp	r3, #0
 8003f54:	d101      	bne.n	8003f5a <lv_draw_aa_get_opa+0x1e>
        return LV_OPA_TRANSP;
 8003f56:	2300      	movs	r3, #0
 8003f58:	e021      	b.n	8003f9e <lv_draw_aa_get_opa+0x62>
    else if(seg < 8)
 8003f5a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003f5e:	2b07      	cmp	r3, #7
 8003f60:	dc10      	bgt.n	8003f84 <lv_draw_aa_get_opa+0x48>
        return (uint32_t)((uint32_t)seg_map[seg - 1][px_id] * base_opa) >> 8;
 8003f62:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003f66:	3b01      	subs	r3, #1
 8003f68:	4a10      	ldr	r2, [pc, #64]	; (8003fac <lv_draw_aa_get_opa+0x70>)
 8003f6a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8003f6e:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8003f72:	4413      	add	r3, r2
 8003f74:	781b      	ldrb	r3, [r3, #0]
 8003f76:	461a      	mov	r2, r3
 8003f78:	78fb      	ldrb	r3, [r7, #3]
 8003f7a:	fb03 f302 	mul.w	r3, r3, r2
 8003f7e:	0a1b      	lsrs	r3, r3, #8
 8003f80:	b2db      	uxtb	r3, r3
 8003f82:	e00c      	b.n	8003f9e <lv_draw_aa_get_opa+0x62>
    else {
        return ((px_id * 2 + 1) * base_opa) / (2 * seg);
 8003f84:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8003f88:	005b      	lsls	r3, r3, #1
 8003f8a:	3301      	adds	r3, #1
 8003f8c:	78fa      	ldrb	r2, [r7, #3]
 8003f8e:	fb02 f203 	mul.w	r2, r2, r3
 8003f92:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003f96:	005b      	lsls	r3, r3, #1
 8003f98:	fb92 f3f3 	sdiv	r3, r2, r3
 8003f9c:	b2db      	uxtb	r3, r3
    }
}
 8003f9e:	4618      	mov	r0, r3
 8003fa0:	370c      	adds	r7, #12
 8003fa2:	46bd      	mov	sp, r7
 8003fa4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003fa8:	4770      	bx	lr
 8003faa:	bf00      	nop
 8003fac:	20000000 	.word	0x20000000

08003fb0 <lv_color_mix>:
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
 8003fb0:	b480      	push	{r7}
 8003fb2:	b085      	sub	sp, #20
 8003fb4:	af00      	add	r7, sp, #0
 8003fb6:	80b8      	strh	r0, [r7, #4]
 8003fb8:	8039      	strh	r1, [r7, #0]
 8003fba:	4613      	mov	r3, r2
 8003fbc:	70fb      	strb	r3, [r7, #3]
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
 8003fbe:	797b      	ldrb	r3, [r7, #5]
 8003fc0:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8003fc4:	b2db      	uxtb	r3, r3
 8003fc6:	b29a      	uxth	r2, r3
 8003fc8:	78fb      	ldrb	r3, [r7, #3]
 8003fca:	b29b      	uxth	r3, r3
 8003fcc:	fb12 f303 	smulbb	r3, r2, r3
 8003fd0:	b29a      	uxth	r2, r3
 8003fd2:	787b      	ldrb	r3, [r7, #1]
 8003fd4:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8003fd8:	b2db      	uxtb	r3, r3
 8003fda:	b299      	uxth	r1, r3
 8003fdc:	78fb      	ldrb	r3, [r7, #3]
 8003fde:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8003fe2:	b29b      	uxth	r3, r3
 8003fe4:	fb11 f303 	smulbb	r3, r1, r3
 8003fe8:	b29b      	uxth	r3, r3
 8003fea:	4413      	add	r3, r2
 8003fec:	b29b      	uxth	r3, r3
 8003fee:	0a1b      	lsrs	r3, r3, #8
 8003ff0:	b29b      	uxth	r3, r3
 8003ff2:	f003 031f 	and.w	r3, r3, #31
 8003ff6:	b2da      	uxtb	r2, r3
 8003ff8:	7b7b      	ldrb	r3, [r7, #13]
 8003ffa:	f362 03c7 	bfi	r3, r2, #3, #5
 8003ffe:	737b      	strb	r3, [r7, #13]
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
 8004000:	88bb      	ldrh	r3, [r7, #4]
 8004002:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8004006:	b2db      	uxtb	r3, r3
 8004008:	b29a      	uxth	r2, r3
 800400a:	78fb      	ldrb	r3, [r7, #3]
 800400c:	b29b      	uxth	r3, r3
 800400e:	fb12 f303 	smulbb	r3, r2, r3
 8004012:	b29a      	uxth	r2, r3
 8004014:	883b      	ldrh	r3, [r7, #0]
 8004016:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800401a:	b2db      	uxtb	r3, r3
 800401c:	b299      	uxth	r1, r3
 800401e:	78fb      	ldrb	r3, [r7, #3]
 8004020:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8004024:	b29b      	uxth	r3, r3
 8004026:	fb11 f303 	smulbb	r3, r1, r3
 800402a:	b29b      	uxth	r3, r3
 800402c:	4413      	add	r3, r2
 800402e:	b29b      	uxth	r3, r3
 8004030:	0a1b      	lsrs	r3, r3, #8
 8004032:	b29b      	uxth	r3, r3
 8004034:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8004038:	b2da      	uxtb	r2, r3
 800403a:	89bb      	ldrh	r3, [r7, #12]
 800403c:	f362 134a 	bfi	r3, r2, #5, #6
 8004040:	81bb      	strh	r3, [r7, #12]
    LV_COLOR_SET_B(ret, (uint16_t)((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) * (255 - mix)) >> 8);
 8004042:	793b      	ldrb	r3, [r7, #4]
 8004044:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8004048:	b2db      	uxtb	r3, r3
 800404a:	b29a      	uxth	r2, r3
 800404c:	78fb      	ldrb	r3, [r7, #3]
 800404e:	b29b      	uxth	r3, r3
 8004050:	fb12 f303 	smulbb	r3, r2, r3
 8004054:	b29a      	uxth	r2, r3
 8004056:	783b      	ldrb	r3, [r7, #0]
 8004058:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800405c:	b2db      	uxtb	r3, r3
 800405e:	b299      	uxth	r1, r3
 8004060:	78fb      	ldrb	r3, [r7, #3]
 8004062:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8004066:	b29b      	uxth	r3, r3
 8004068:	fb11 f303 	smulbb	r3, r1, r3
 800406c:	b29b      	uxth	r3, r3
 800406e:	4413      	add	r3, r2
 8004070:	b29b      	uxth	r3, r3
 8004072:	0a1b      	lsrs	r3, r3, #8
 8004074:	b29b      	uxth	r3, r3
 8004076:	f003 031f 	and.w	r3, r3, #31
 800407a:	b2da      	uxtb	r2, r3
 800407c:	7b3b      	ldrb	r3, [r7, #12]
 800407e:	f362 0304 	bfi	r3, r2, #0, #5
 8004082:	733b      	strb	r3, [r7, #12]
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
 8004084:	89bb      	ldrh	r3, [r7, #12]
}
 8004086:	4618      	mov	r0, r3
 8004088:	3714      	adds	r7, #20
 800408a:	46bd      	mov	sp, r7
 800408c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004090:	4770      	bx	lr

08004092 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 8004092:	b480      	push	{r7}
 8004094:	b083      	sub	sp, #12
 8004096:	af00      	add	r7, sp, #0
 8004098:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 800409a:	687b      	ldr	r3, [r7, #4]
 800409c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80040a0:	b29a      	uxth	r2, r3
 80040a2:	687b      	ldr	r3, [r7, #4]
 80040a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80040a8:	b29b      	uxth	r3, r3
 80040aa:	1ad3      	subs	r3, r2, r3
 80040ac:	b29b      	uxth	r3, r3
 80040ae:	3301      	adds	r3, #1
 80040b0:	b29b      	uxth	r3, r3
 80040b2:	b21b      	sxth	r3, r3
}
 80040b4:	4618      	mov	r0, r3
 80040b6:	370c      	adds	r7, #12
 80040b8:	46bd      	mov	sp, r7
 80040ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040be:	4770      	bx	lr

080040c0 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 80040c0:	b480      	push	{r7}
 80040c2:	b083      	sub	sp, #12
 80040c4:	af00      	add	r7, sp, #0
 80040c6:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 80040c8:	687b      	ldr	r3, [r7, #4]
 80040ca:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80040ce:	b29a      	uxth	r2, r3
 80040d0:	687b      	ldr	r3, [r7, #4]
 80040d2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80040d6:	b29b      	uxth	r3, r3
 80040d8:	1ad3      	subs	r3, r2, r3
 80040da:	b29b      	uxth	r3, r3
 80040dc:	3301      	adds	r3, #1
 80040de:	b29b      	uxth	r3, r3
 80040e0:	b21b      	sxth	r3, r3
}
 80040e2:	4618      	mov	r0, r3
 80040e4:	370c      	adds	r7, #12
 80040e6:	46bd      	mov	sp, r7
 80040e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040ec:	4770      	bx	lr

080040ee <lv_draw_px>:
 * @param mask_p fill only on this mask (truncated to VDB area)
 * @param color pixel color
 * @param opa opacity of the area (0..255)
 */
void lv_draw_px(lv_coord_t x, lv_coord_t y, const lv_area_t * mask_p, lv_color_t color, lv_opa_t opa)
{
 80040ee:	b5b0      	push	{r4, r5, r7, lr}
 80040f0:	b08e      	sub	sp, #56	; 0x38
 80040f2:	af04      	add	r7, sp, #16
 80040f4:	60ba      	str	r2, [r7, #8]
 80040f6:	80bb      	strh	r3, [r7, #4]
 80040f8:	4603      	mov	r3, r0
 80040fa:	81fb      	strh	r3, [r7, #14]
 80040fc:	460b      	mov	r3, r1
 80040fe:	81bb      	strh	r3, [r7, #12]

    if(opa < LV_OPA_MIN) return;
 8004100:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8004104:	2b0f      	cmp	r3, #15
 8004106:	f240 8084 	bls.w	8004212 <lv_draw_px+0x124>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 800410a:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 800410e:	2bfb      	cmp	r3, #251	; 0xfb
 8004110:	d902      	bls.n	8004118 <lv_draw_px+0x2a>
 8004112:	23ff      	movs	r3, #255	; 0xff
 8004114:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38

    /*Pixel out of the mask*/
    if(x < mask_p->x1 || x > mask_p->x2 || y < mask_p->y1 || y > mask_p->y2) {
 8004118:	68bb      	ldr	r3, [r7, #8]
 800411a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800411e:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8004122:	429a      	cmp	r2, r3
 8004124:	db77      	blt.n	8004216 <lv_draw_px+0x128>
 8004126:	68bb      	ldr	r3, [r7, #8]
 8004128:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800412c:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8004130:	429a      	cmp	r2, r3
 8004132:	dc70      	bgt.n	8004216 <lv_draw_px+0x128>
 8004134:	68bb      	ldr	r3, [r7, #8]
 8004136:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800413a:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 800413e:	429a      	cmp	r2, r3
 8004140:	db69      	blt.n	8004216 <lv_draw_px+0x128>
 8004142:	68bb      	ldr	r3, [r7, #8]
 8004144:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8004148:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 800414c:	429a      	cmp	r2, r3
 800414e:	dc62      	bgt.n	8004216 <lv_draw_px+0x128>
        return;
    }

    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
 8004150:	f7fe ff00 	bl	8002f54 <lv_refr_get_disp_refreshing>
 8004154:	6278      	str	r0, [r7, #36]	; 0x24
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8004156:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8004158:	f007 fca9 	bl	800baae <lv_disp_get_buf>
 800415c:	6238      	str	r0, [r7, #32]
    uint32_t vdb_width  = lv_area_get_width(&vdb->area);
 800415e:	6a3b      	ldr	r3, [r7, #32]
 8004160:	3310      	adds	r3, #16
 8004162:	4618      	mov	r0, r3
 8004164:	f7ff ff95 	bl	8004092 <lv_area_get_width>
 8004168:	4603      	mov	r3, r0
 800416a:	61fb      	str	r3, [r7, #28]

    /*Make the coordinates relative to VDB*/
    x -= vdb->area.x1;
 800416c:	89fa      	ldrh	r2, [r7, #14]
 800416e:	6a3b      	ldr	r3, [r7, #32]
 8004170:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8004174:	b29b      	uxth	r3, r3
 8004176:	1ad3      	subs	r3, r2, r3
 8004178:	b29b      	uxth	r3, r3
 800417a:	81fb      	strh	r3, [r7, #14]
    y -= vdb->area.y1;
 800417c:	89ba      	ldrh	r2, [r7, #12]
 800417e:	6a3b      	ldr	r3, [r7, #32]
 8004180:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8004184:	b29b      	uxth	r3, r3
 8004186:	1ad3      	subs	r3, r2, r3
 8004188:	b29b      	uxth	r3, r3
 800418a:	81bb      	strh	r3, [r7, #12]

    if(disp->driver.set_px_cb) {
 800418c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800418e:	695b      	ldr	r3, [r3, #20]
 8004190:	2b00      	cmp	r3, #0
 8004192:	d014      	beq.n	80041be <lv_draw_px+0xd0>
        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, x, y, color, opa);
 8004194:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004196:	695c      	ldr	r4, [r3, #20]
 8004198:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800419a:	6a3b      	ldr	r3, [r7, #32]
 800419c:	6899      	ldr	r1, [r3, #8]
 800419e:	69fb      	ldr	r3, [r7, #28]
 80041a0:	b21a      	sxth	r2, r3
 80041a2:	f9b7 500e 	ldrsh.w	r5, [r7, #14]
 80041a6:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 80041aa:	9302      	str	r3, [sp, #8]
 80041ac:	88bb      	ldrh	r3, [r7, #4]
 80041ae:	f8ad 3004 	strh.w	r3, [sp, #4]
 80041b2:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80041b6:	9300      	str	r3, [sp, #0]
 80041b8:	462b      	mov	r3, r5
 80041ba:	47a0      	blx	r4
 80041bc:	e02c      	b.n	8004218 <lv_draw_px+0x12a>
    } else {
        bool scr_transp = false;
 80041be:	2300      	movs	r3, #0
 80041c0:	76fb      	strb	r3, [r7, #27]
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
        scr_transp = disp->driver.screen_transp;
#endif

        lv_color_t * vdb_px_p = vdb->buf_act;
 80041c2:	6a3b      	ldr	r3, [r7, #32]
 80041c4:	689b      	ldr	r3, [r3, #8]
 80041c6:	617b      	str	r3, [r7, #20]
        vdb_px_p += y * vdb_width + x;
 80041c8:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80041cc:	69fa      	ldr	r2, [r7, #28]
 80041ce:	fb02 f203 	mul.w	r2, r2, r3
 80041d2:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80041d6:	4413      	add	r3, r2
 80041d8:	005b      	lsls	r3, r3, #1
 80041da:	697a      	ldr	r2, [r7, #20]
 80041dc:	4413      	add	r3, r2
 80041de:	617b      	str	r3, [r7, #20]

        if(scr_transp == false) {
 80041e0:	7efb      	ldrb	r3, [r7, #27]
 80041e2:	f083 0301 	eor.w	r3, r3, #1
 80041e6:	b2db      	uxtb	r3, r3
 80041e8:	2b00      	cmp	r3, #0
 80041ea:	d015      	beq.n	8004218 <lv_draw_px+0x12a>
            if(opa == LV_OPA_COVER) {
 80041ec:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 80041f0:	2bff      	cmp	r3, #255	; 0xff
 80041f2:	d103      	bne.n	80041fc <lv_draw_px+0x10e>
                *vdb_px_p = color;
 80041f4:	697b      	ldr	r3, [r7, #20]
 80041f6:	88ba      	ldrh	r2, [r7, #4]
 80041f8:	801a      	strh	r2, [r3, #0]
 80041fa:	e00d      	b.n	8004218 <lv_draw_px+0x12a>
            } else {
                *vdb_px_p = lv_color_mix(color, *vdb_px_p, opa);
 80041fc:	f897 2038 	ldrb.w	r2, [r7, #56]	; 0x38
 8004200:	697b      	ldr	r3, [r7, #20]
 8004202:	8819      	ldrh	r1, [r3, #0]
 8004204:	88b8      	ldrh	r0, [r7, #4]
 8004206:	f7ff fed3 	bl	8003fb0 <lv_color_mix>
 800420a:	4602      	mov	r2, r0
 800420c:	697b      	ldr	r3, [r7, #20]
 800420e:	801a      	strh	r2, [r3, #0]
 8004210:	e002      	b.n	8004218 <lv_draw_px+0x12a>
    if(opa < LV_OPA_MIN) return;
 8004212:	bf00      	nop
 8004214:	e000      	b.n	8004218 <lv_draw_px+0x12a>
        return;
 8004216:	bf00      	nop
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
            *vdb_px_p = color_mix_2_alpha(*vdb_px_p, (*vdb_px_p).ch.alpha, color, opa);
#endif
        }
    }
}
 8004218:	3728      	adds	r7, #40	; 0x28
 800421a:	46bd      	mov	sp, r7
 800421c:	bdb0      	pop	{r4, r5, r7, pc}
	...

08004220 <lv_draw_fill>:
 * @param mask_p fill only o this mask  (truncated to VDB area)
 * @param color fill color
 * @param opa opacity of the area (0..255)
 */
void lv_draw_fill(const lv_area_t * cords_p, const lv_area_t * mask_p, lv_color_t color, lv_opa_t opa)
{
 8004220:	b5b0      	push	{r4, r5, r7, lr}
 8004222:	b092      	sub	sp, #72	; 0x48
 8004224:	af02      	add	r7, sp, #8
 8004226:	60f8      	str	r0, [r7, #12]
 8004228:	60b9      	str	r1, [r7, #8]
 800422a:	80ba      	strh	r2, [r7, #4]
 800422c:	71fb      	strb	r3, [r7, #7]
    if(opa < LV_OPA_MIN) return;
 800422e:	79fb      	ldrb	r3, [r7, #7]
 8004230:	2b0f      	cmp	r3, #15
 8004232:	f240 8139 	bls.w	80044a8 <lv_draw_fill+0x288>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 8004236:	79fb      	ldrb	r3, [r7, #7]
 8004238:	2bfb      	cmp	r3, #251	; 0xfb
 800423a:	d901      	bls.n	8004240 <lv_draw_fill+0x20>
 800423c:	23ff      	movs	r3, #255	; 0xff
 800423e:	71fb      	strb	r3, [r7, #7]
    bool union_ok;

    /*Get the union of cord and mask*/
    /* The mask is already truncated to the vdb size
     * in 'lv_refr_area_with_vdb' function */
    union_ok = lv_area_intersect(&res_a, cords_p, mask_p);
 8004240:	f107 0318 	add.w	r3, r7, #24
 8004244:	68ba      	ldr	r2, [r7, #8]
 8004246:	68f9      	ldr	r1, [r7, #12]
 8004248:	4618      	mov	r0, r3
 800424a:	f007 ff3b 	bl	800c0c4 <lv_area_intersect>
 800424e:	4603      	mov	r3, r0
 8004250:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

    /*If there are common part of the three area then draw to the vdb*/
    if(union_ok == false) {
 8004254:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8004258:	f083 0301 	eor.w	r3, r3, #1
 800425c:	b2db      	uxtb	r3, r3
 800425e:	2b00      	cmp	r3, #0
 8004260:	f040 8124 	bne.w	80044ac <lv_draw_fill+0x28c>
        return;
    }

    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
 8004264:	f7fe fe76 	bl	8002f54 <lv_refr_get_disp_refreshing>
 8004268:	62f8      	str	r0, [r7, #44]	; 0x2c
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 800426a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800426c:	f007 fc1f 	bl	800baae <lv_disp_get_buf>
 8004270:	62b8      	str	r0, [r7, #40]	; 0x28

    lv_area_t vdb_rel_a; /*Stores relative coordinates on vdb*/
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
 8004272:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8004276:	b29a      	uxth	r2, r3
 8004278:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800427a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 800427e:	b29b      	uxth	r3, r3
 8004280:	1ad3      	subs	r3, r2, r3
 8004282:	b29b      	uxth	r3, r3
 8004284:	b21b      	sxth	r3, r3
 8004286:	823b      	strh	r3, [r7, #16]
    vdb_rel_a.y1 = res_a.y1 - vdb->area.y1;
 8004288:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800428c:	b29a      	uxth	r2, r3
 800428e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004290:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8004294:	b29b      	uxth	r3, r3
 8004296:	1ad3      	subs	r3, r2, r3
 8004298:	b29b      	uxth	r3, r3
 800429a:	b21b      	sxth	r3, r3
 800429c:	827b      	strh	r3, [r7, #18]
    vdb_rel_a.x2 = res_a.x2 - vdb->area.x1;
 800429e:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 80042a2:	b29a      	uxth	r2, r3
 80042a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80042a6:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80042aa:	b29b      	uxth	r3, r3
 80042ac:	1ad3      	subs	r3, r2, r3
 80042ae:	b29b      	uxth	r3, r3
 80042b0:	b21b      	sxth	r3, r3
 80042b2:	82bb      	strh	r3, [r7, #20]
    vdb_rel_a.y2 = res_a.y2 - vdb->area.y1;
 80042b4:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80042b8:	b29a      	uxth	r2, r3
 80042ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80042bc:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80042c0:	b29b      	uxth	r3, r3
 80042c2:	1ad3      	subs	r3, r2, r3
 80042c4:	b29b      	uxth	r3, r3
 80042c6:	b21b      	sxth	r3, r3
 80042c8:	82fb      	strh	r3, [r7, #22]

    lv_color_t * vdb_buf_tmp = vdb->buf_act;
 80042ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80042cc:	689b      	ldr	r3, [r3, #8]
 80042ce:	63fb      	str	r3, [r7, #60]	; 0x3c
    uint32_t vdb_width       = lv_area_get_width(&vdb->area);
 80042d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80042d2:	3310      	adds	r3, #16
 80042d4:	4618      	mov	r0, r3
 80042d6:	f7ff fedc 	bl	8004092 <lv_area_get_width>
 80042da:	4603      	mov	r3, r0
 80042dc:	627b      	str	r3, [r7, #36]	; 0x24
    /*Move the vdb_tmp to the first row*/
    vdb_buf_tmp += vdb_width * vdb_rel_a.y1;
 80042de:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80042e2:	461a      	mov	r2, r3
 80042e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80042e6:	fb03 f302 	mul.w	r3, r3, r2
 80042ea:	005b      	lsls	r3, r3, #1
 80042ec:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80042ee:	4413      	add	r3, r2
 80042f0:	63fb      	str	r3, [r7, #60]	; 0x3c

#if LV_USE_GPU
    static LV_ATTRIBUTE_MEM_ALIGN lv_color_t color_array_tmp[LV_HOR_RES_MAX]; /*Used by 'lv_disp_mem_blend'*/
    static lv_coord_t last_width = -1;

    lv_coord_t w = lv_area_get_width(&vdb_rel_a);
 80042f2:	f107 0310 	add.w	r3, r7, #16
 80042f6:	4618      	mov	r0, r3
 80042f8:	f7ff fecb 	bl	8004092 <lv_area_get_width>
 80042fc:	4603      	mov	r3, r0
 80042fe:	847b      	strh	r3, [r7, #34]	; 0x22
    /*Don't use hw. acc. for every small fill (because of the init overhead)*/
    if(w < VFILL_HW_ACC_SIZE_LIMIT) {
 8004300:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8004304:	2b31      	cmp	r3, #49	; 0x31
 8004306:	dc0b      	bgt.n	8004320 <lv_draw_fill+0x100>
        sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
 8004308:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800430a:	6898      	ldr	r0, [r3, #8]
 800430c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800430e:	b219      	sxth	r1, r3
 8004310:	f107 0210 	add.w	r2, r7, #16
 8004314:	79fb      	ldrb	r3, [r7, #7]
 8004316:	9300      	str	r3, [sp, #0]
 8004318:	88bb      	ldrh	r3, [r7, #4]
 800431a:	f000 fd49 	bl	8004db0 <sw_color_fill>
 800431e:	e0c6      	b.n	80044ae <lv_draw_fill+0x28e>
    }
    /*Not opaque fill*/
    else if(opa == LV_OPA_COVER) {
 8004320:	79fb      	ldrb	r3, [r7, #7]
 8004322:	2bff      	cmp	r3, #255	; 0xff
 8004324:	d16d      	bne.n	8004402 <lv_draw_fill+0x1e2>
        /*Use hw fill if present*/
        if(disp->driver.gpu_fill_cb) {
 8004326:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004328:	6a1b      	ldr	r3, [r3, #32]
 800432a:	2b00      	cmp	r3, #0
 800432c:	d00e      	beq.n	800434c <lv_draw_fill+0x12c>
            disp->driver.gpu_fill_cb(&disp->driver, vdb->buf_act, vdb_width, &vdb_rel_a, color);
 800432e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004330:	6a1c      	ldr	r4, [r3, #32]
 8004332:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8004334:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004336:	6899      	ldr	r1, [r3, #8]
 8004338:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800433a:	b21a      	sxth	r2, r3
 800433c:	f107 0510 	add.w	r5, r7, #16
 8004340:	88bb      	ldrh	r3, [r7, #4]
 8004342:	f8ad 3000 	strh.w	r3, [sp]
 8004346:	462b      	mov	r3, r5
 8004348:	47a0      	blx	r4
 800434a:	e0b0      	b.n	80044ae <lv_draw_fill+0x28e>
        }
        /*Use hw blend if present and the area is not too small*/
        else if(lv_area_get_height(&vdb_rel_a) > VFILL_HW_ACC_SIZE_LIMIT && disp->driver.gpu_blend_cb) {
 800434c:	f107 0310 	add.w	r3, r7, #16
 8004350:	4618      	mov	r0, r3
 8004352:	f7ff feb5 	bl	80040c0 <lv_area_get_height>
 8004356:	4603      	mov	r3, r0
 8004358:	2b32      	cmp	r3, #50	; 0x32
 800435a:	dd46      	ble.n	80043ea <lv_draw_fill+0x1ca>
 800435c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800435e:	69db      	ldr	r3, [r3, #28]
 8004360:	2b00      	cmp	r3, #0
 8004362:	d042      	beq.n	80043ea <lv_draw_fill+0x1ca>
            /*Fill a  one line sized buffer with a color and blend this later*/
            if(color_array_tmp[0].full != color.full || last_width != w) {
 8004364:	4b53      	ldr	r3, [pc, #332]	; (80044b4 <lv_draw_fill+0x294>)
 8004366:	881a      	ldrh	r2, [r3, #0]
 8004368:	88bb      	ldrh	r3, [r7, #4]
 800436a:	429a      	cmp	r2, r3
 800436c:	d106      	bne.n	800437c <lv_draw_fill+0x15c>
 800436e:	4b52      	ldr	r3, [pc, #328]	; (80044b8 <lv_draw_fill+0x298>)
 8004370:	f9b3 3000 	ldrsh.w	r3, [r3]
 8004374:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 8004378:	429a      	cmp	r2, r3
 800437a:	d012      	beq.n	80043a2 <lv_draw_fill+0x182>
                uint16_t i;
                for(i = 0; i < w; i++) {
 800437c:	2300      	movs	r3, #0
 800437e:	877b      	strh	r3, [r7, #58]	; 0x3a
 8004380:	e007      	b.n	8004392 <lv_draw_fill+0x172>
                    color_array_tmp[i].full = color.full;
 8004382:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8004384:	88b9      	ldrh	r1, [r7, #4]
 8004386:	4a4b      	ldr	r2, [pc, #300]	; (80044b4 <lv_draw_fill+0x294>)
 8004388:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
                for(i = 0; i < w; i++) {
 800438c:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 800438e:	3301      	adds	r3, #1
 8004390:	877b      	strh	r3, [r7, #58]	; 0x3a
 8004392:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 8004394:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8004398:	429a      	cmp	r2, r3
 800439a:	dbf2      	blt.n	8004382 <lv_draw_fill+0x162>
                }
                last_width = w;
 800439c:	4a46      	ldr	r2, [pc, #280]	; (80044b8 <lv_draw_fill+0x298>)
 800439e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80043a0:	8013      	strh	r3, [r2, #0]
            }

            /*Blend the filled line to every line VDB line-by-line*/
            lv_coord_t row;
            for(row = vdb_rel_a.y1; row <= vdb_rel_a.y2; row++) {
 80043a2:	8a7b      	ldrh	r3, [r7, #18]
 80043a4:	873b      	strh	r3, [r7, #56]	; 0x38
 80043a6:	e019      	b.n	80043dc <lv_draw_fill+0x1bc>
                disp->driver.gpu_blend_cb(&disp->driver, &vdb_buf_tmp[vdb_rel_a.x1], color_array_tmp, w, opa);
 80043a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80043aa:	69dc      	ldr	r4, [r3, #28]
 80043ac:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80043ae:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80043b2:	005b      	lsls	r3, r3, #1
 80043b4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80043b6:	18d1      	adds	r1, r2, r3
 80043b8:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 80043bc:	79fb      	ldrb	r3, [r7, #7]
 80043be:	9300      	str	r3, [sp, #0]
 80043c0:	4613      	mov	r3, r2
 80043c2:	4a3c      	ldr	r2, [pc, #240]	; (80044b4 <lv_draw_fill+0x294>)
 80043c4:	47a0      	blx	r4
                vdb_buf_tmp += vdb_width;
 80043c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80043c8:	005b      	lsls	r3, r3, #1
 80043ca:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80043cc:	4413      	add	r3, r2
 80043ce:	63fb      	str	r3, [r7, #60]	; 0x3c
            for(row = vdb_rel_a.y1; row <= vdb_rel_a.y2; row++) {
 80043d0:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80043d4:	b29b      	uxth	r3, r3
 80043d6:	3301      	adds	r3, #1
 80043d8:	b29b      	uxth	r3, r3
 80043da:	873b      	strh	r3, [r7, #56]	; 0x38
 80043dc:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80043e0:	f9b7 2038 	ldrsh.w	r2, [r7, #56]	; 0x38
 80043e4:	429a      	cmp	r2, r3
 80043e6:	dddf      	ble.n	80043a8 <lv_draw_fill+0x188>
        else if(lv_area_get_height(&vdb_rel_a) > VFILL_HW_ACC_SIZE_LIMIT && disp->driver.gpu_blend_cb) {
 80043e8:	e061      	b.n	80044ae <lv_draw_fill+0x28e>
            }

        }
        /*Else use sw fill if no better option*/
        else {
            sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
 80043ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80043ec:	6898      	ldr	r0, [r3, #8]
 80043ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80043f0:	b219      	sxth	r1, r3
 80043f2:	f107 0210 	add.w	r2, r7, #16
 80043f6:	79fb      	ldrb	r3, [r7, #7]
 80043f8:	9300      	str	r3, [sp, #0]
 80043fa:	88bb      	ldrh	r3, [r7, #4]
 80043fc:	f000 fcd8 	bl	8004db0 <sw_color_fill>
 8004400:	e055      	b.n	80044ae <lv_draw_fill+0x28e>

    }
    /*Fill with opacity*/
    else {
        /*Use hw blend if present*/
        if(disp->driver.gpu_blend_cb) {
 8004402:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004404:	69db      	ldr	r3, [r3, #28]
 8004406:	2b00      	cmp	r3, #0
 8004408:	d042      	beq.n	8004490 <lv_draw_fill+0x270>
            if(color_array_tmp[0].full != color.full || last_width != w) {
 800440a:	4b2a      	ldr	r3, [pc, #168]	; (80044b4 <lv_draw_fill+0x294>)
 800440c:	881a      	ldrh	r2, [r3, #0]
 800440e:	88bb      	ldrh	r3, [r7, #4]
 8004410:	429a      	cmp	r2, r3
 8004412:	d106      	bne.n	8004422 <lv_draw_fill+0x202>
 8004414:	4b28      	ldr	r3, [pc, #160]	; (80044b8 <lv_draw_fill+0x298>)
 8004416:	f9b3 3000 	ldrsh.w	r3, [r3]
 800441a:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 800441e:	429a      	cmp	r2, r3
 8004420:	d012      	beq.n	8004448 <lv_draw_fill+0x228>
                uint16_t i;
                for(i = 0; i < w; i++) {
 8004422:	2300      	movs	r3, #0
 8004424:	86fb      	strh	r3, [r7, #54]	; 0x36
 8004426:	e007      	b.n	8004438 <lv_draw_fill+0x218>
                    color_array_tmp[i].full = color.full;
 8004428:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800442a:	88b9      	ldrh	r1, [r7, #4]
 800442c:	4a21      	ldr	r2, [pc, #132]	; (80044b4 <lv_draw_fill+0x294>)
 800442e:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
                for(i = 0; i < w; i++) {
 8004432:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8004434:	3301      	adds	r3, #1
 8004436:	86fb      	strh	r3, [r7, #54]	; 0x36
 8004438:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 800443a:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 800443e:	429a      	cmp	r2, r3
 8004440:	dbf2      	blt.n	8004428 <lv_draw_fill+0x208>
                }

                last_width = w;
 8004442:	4a1d      	ldr	r2, [pc, #116]	; (80044b8 <lv_draw_fill+0x298>)
 8004444:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8004446:	8013      	strh	r3, [r2, #0]
            }
            lv_coord_t row;
            for(row = vdb_rel_a.y1; row <= vdb_rel_a.y2; row++) {
 8004448:	8a7b      	ldrh	r3, [r7, #18]
 800444a:	86bb      	strh	r3, [r7, #52]	; 0x34
 800444c:	e019      	b.n	8004482 <lv_draw_fill+0x262>
                disp->driver.gpu_blend_cb(&disp->driver, &vdb_buf_tmp[vdb_rel_a.x1], color_array_tmp, w, opa);
 800444e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004450:	69dc      	ldr	r4, [r3, #28]
 8004452:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8004454:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8004458:	005b      	lsls	r3, r3, #1
 800445a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800445c:	18d1      	adds	r1, r2, r3
 800445e:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 8004462:	79fb      	ldrb	r3, [r7, #7]
 8004464:	9300      	str	r3, [sp, #0]
 8004466:	4613      	mov	r3, r2
 8004468:	4a12      	ldr	r2, [pc, #72]	; (80044b4 <lv_draw_fill+0x294>)
 800446a:	47a0      	blx	r4
                vdb_buf_tmp += vdb_width;
 800446c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800446e:	005b      	lsls	r3, r3, #1
 8004470:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8004472:	4413      	add	r3, r2
 8004474:	63fb      	str	r3, [r7, #60]	; 0x3c
            for(row = vdb_rel_a.y1; row <= vdb_rel_a.y2; row++) {
 8004476:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 800447a:	b29b      	uxth	r3, r3
 800447c:	3301      	adds	r3, #1
 800447e:	b29b      	uxth	r3, r3
 8004480:	86bb      	strh	r3, [r7, #52]	; 0x34
 8004482:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8004486:	f9b7 2034 	ldrsh.w	r2, [r7, #52]	; 0x34
 800448a:	429a      	cmp	r2, r3
 800448c:	dddf      	ble.n	800444e <lv_draw_fill+0x22e>
 800448e:	e00e      	b.n	80044ae <lv_draw_fill+0x28e>
            }

        }
        /*Use sw fill with opa if no better option*/
        else {
            sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
 8004490:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004492:	6898      	ldr	r0, [r3, #8]
 8004494:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004496:	b219      	sxth	r1, r3
 8004498:	f107 0210 	add.w	r2, r7, #16
 800449c:	79fb      	ldrb	r3, [r7, #7]
 800449e:	9300      	str	r3, [sp, #0]
 80044a0:	88bb      	ldrh	r3, [r7, #4]
 80044a2:	f000 fc85 	bl	8004db0 <sw_color_fill>
 80044a6:	e002      	b.n	80044ae <lv_draw_fill+0x28e>
    if(opa < LV_OPA_MIN) return;
 80044a8:	bf00      	nop
 80044aa:	e000      	b.n	80044ae <lv_draw_fill+0x28e>
        return;
 80044ac:	bf00      	nop
        }
    }
#else
    sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
#endif
}
 80044ae:	3740      	adds	r7, #64	; 0x40
 80044b0:	46bd      	mov	sp, r7
 80044b2:	bdb0      	pop	{r4, r5, r7, pc}
 80044b4:	200000ac 	.word	0x200000ac
 80044b8:	20000020 	.word	0x20000020

080044bc <lv_draw_letter>:
 * @param color color of letter
 * @param opa opacity of letter (0..255)
 */
void lv_draw_letter(const lv_point_t * pos_p, const lv_area_t * mask_p, const lv_font_t * font_p, uint32_t letter,
                    lv_color_t color, lv_opa_t opa)
{
 80044bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80044be:	b0a5      	sub	sp, #148	; 0x94
 80044c0:	af04      	add	r7, sp, #16
 80044c2:	60f8      	str	r0, [r7, #12]
 80044c4:	60b9      	str	r1, [r7, #8]
 80044c6:	607a      	str	r2, [r7, #4]
 80044c8:	603b      	str	r3, [r7, #0]
    /*clang-format off*/
    const uint8_t bpp1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
 80044ca:	2300      	movs	r3, #0
 80044cc:	f887 3040 	strb.w	r3, [r7, #64]	; 0x40
 80044d0:	23ff      	movs	r3, #255	; 0xff
 80044d2:	f887 3041 	strb.w	r3, [r7, #65]	; 0x41
    const uint8_t bpp2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
 80044d6:	4bc2      	ldr	r3, [pc, #776]	; (80047e0 <lv_draw_letter+0x324>)
 80044d8:	681b      	ldr	r3, [r3, #0]
 80044da:	63fb      	str	r3, [r7, #60]	; 0x3c
    const uint8_t bpp4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
 80044dc:	4bc1      	ldr	r3, [pc, #772]	; (80047e4 <lv_draw_letter+0x328>)
 80044de:	f107 042c 	add.w	r4, r7, #44	; 0x2c
 80044e2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80044e4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                                        68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};
    /*clang-format on*/

    if(opa < LV_OPA_MIN) return;
 80044e8:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 80044ec:	2b0f      	cmp	r3, #15
 80044ee:	f240 844e 	bls.w	8004d8e <lv_draw_letter+0x8d2>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 80044f2:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 80044f6:	2bfb      	cmp	r3, #251	; 0xfb
 80044f8:	d902      	bls.n	8004500 <lv_draw_letter+0x44>
 80044fa:	23ff      	movs	r3, #255	; 0xff
 80044fc:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c

    if(font_p == NULL) {
 8004500:	687b      	ldr	r3, [r7, #4]
 8004502:	2b00      	cmp	r3, #0
 8004504:	f000 8445 	beq.w	8004d92 <lv_draw_letter+0x8d6>
        LV_LOG_WARN("Font: character's bitmap not found");
        return;
    }

    lv_font_glyph_dsc_t g;
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
 8004508:	f107 0124 	add.w	r1, r7, #36	; 0x24
 800450c:	2300      	movs	r3, #0
 800450e:	683a      	ldr	r2, [r7, #0]
 8004510:	6878      	ldr	r0, [r7, #4]
 8004512:	f006 fb4c 	bl	800abae <lv_font_get_glyph_dsc>
 8004516:	4603      	mov	r3, r0
 8004518:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
    if(g_ret == false) return;
 800451c:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 8004520:	f083 0301 	eor.w	r3, r3, #1
 8004524:	b2db      	uxtb	r3, r3
 8004526:	2b00      	cmp	r3, #0
 8004528:	f040 8435 	bne.w	8004d96 <lv_draw_letter+0x8da>


    lv_coord_t pos_x = pos_p->x + g.ofs_x;
 800452c:	68fb      	ldr	r3, [r7, #12]
 800452e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8004532:	b29a      	uxth	r2, r3
 8004534:	f997 3028 	ldrsb.w	r3, [r7, #40]	; 0x28
 8004538:	b29b      	uxth	r3, r3
 800453a:	4413      	add	r3, r2
 800453c:	b29b      	uxth	r3, r3
 800453e:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
 8004542:	68fb      	ldr	r3, [r7, #12]
 8004544:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8004548:	b29a      	uxth	r2, r3
 800454a:	687b      	ldr	r3, [r7, #4]
 800454c:	7a1b      	ldrb	r3, [r3, #8]
 800454e:	b219      	sxth	r1, r3
 8004550:	687b      	ldr	r3, [r7, #4]
 8004552:	f993 3009 	ldrsb.w	r3, [r3, #9]
 8004556:	b21b      	sxth	r3, r3
 8004558:	1acb      	subs	r3, r1, r3
 800455a:	b21b      	sxth	r3, r3
 800455c:	b29b      	uxth	r3, r3
 800455e:	4413      	add	r3, r2
 8004560:	b29a      	uxth	r2, r3
 8004562:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8004566:	b29b      	uxth	r3, r3
 8004568:	1ad3      	subs	r3, r2, r3
 800456a:	b29a      	uxth	r2, r3
 800456c:	f997 3029 	ldrsb.w	r3, [r7, #41]	; 0x29
 8004570:	b29b      	uxth	r3, r3
 8004572:	1ad3      	subs	r3, r2, r3
 8004574:	b29b      	uxth	r3, r3
 8004576:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
    const uint8_t * bpp_opa_table;
    uint8_t bitmask_init;
    uint8_t bitmask;

    /*bpp = 3 should be converted to bpp = 4 in lv_font_get_glyph_bitmap */
    if(g.bpp == 3) g.bpp = 4;
 800457a:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800457e:	2b03      	cmp	r3, #3
 8004580:	d102      	bne.n	8004588 <lv_draw_letter+0xcc>
 8004582:	2304      	movs	r3, #4
 8004584:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a

    switch(g.bpp) {
 8004588:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800458c:	3b01      	subs	r3, #1
 800458e:	2b07      	cmp	r3, #7
 8004590:	f200 8403 	bhi.w	8004d9a <lv_draw_letter+0x8de>
 8004594:	a201      	add	r2, pc, #4	; (adr r2, 800459c <lv_draw_letter+0xe0>)
 8004596:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800459a:	bf00      	nop
 800459c:	080045bd 	.word	0x080045bd
 80045a0:	080045cb 	.word	0x080045cb
 80045a4:	08004d9b 	.word	0x08004d9b
 80045a8:	080045d9 	.word	0x080045d9
 80045ac:	08004d9b 	.word	0x08004d9b
 80045b0:	08004d9b 	.word	0x08004d9b
 80045b4:	08004d9b 	.word	0x08004d9b
 80045b8:	080045e7 	.word	0x080045e7
        case 1:
            bpp_opa_table = bpp1_opa_table;
 80045bc:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80045c0:	67fb      	str	r3, [r7, #124]	; 0x7c
            bitmask_init  = 0x80;
 80045c2:	2380      	movs	r3, #128	; 0x80
 80045c4:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
            break;
 80045c8:	e013      	b.n	80045f2 <lv_draw_letter+0x136>
        case 2:
            bpp_opa_table = bpp2_opa_table;
 80045ca:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 80045ce:	67fb      	str	r3, [r7, #124]	; 0x7c
            bitmask_init  = 0xC0;
 80045d0:	23c0      	movs	r3, #192	; 0xc0
 80045d2:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
            break;
 80045d6:	e00c      	b.n	80045f2 <lv_draw_letter+0x136>
        case 4:
            bpp_opa_table = bpp4_opa_table;
 80045d8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80045dc:	67fb      	str	r3, [r7, #124]	; 0x7c
            bitmask_init  = 0xF0;
 80045de:	23f0      	movs	r3, #240	; 0xf0
 80045e0:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
            break;
 80045e4:	e005      	b.n	80045f2 <lv_draw_letter+0x136>
        case 8:
            bpp_opa_table = NULL;
 80045e6:	2300      	movs	r3, #0
 80045e8:	67fb      	str	r3, [r7, #124]	; 0x7c
            bitmask_init  = 0xFF;
 80045ea:	23ff      	movs	r3, #255	; 0xff
 80045ec:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
            break;       /*No opa table, pixel value will be used directly*/
 80045f0:	bf00      	nop
        default: return; /*Invalid bpp. Can't render the letter*/
    }

    const uint8_t * map_p = lv_font_get_glyph_bitmap(font_p, letter);
 80045f2:	6839      	ldr	r1, [r7, #0]
 80045f4:	6878      	ldr	r0, [r7, #4]
 80045f6:	f006 facb 	bl	800ab90 <lv_font_get_glyph_bitmap>
 80045fa:	6778      	str	r0, [r7, #116]	; 0x74

    if(map_p == NULL) return;
 80045fc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80045fe:	2b00      	cmp	r3, #0
 8004600:	f000 83cd 	beq.w	8004d9e <lv_draw_letter+0x8e2>

    /*If the letter is completely out of mask don't draw it */
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
 8004604:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8004608:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 800460c:	4413      	add	r3, r2
 800460e:	68ba      	ldr	r2, [r7, #8]
 8004610:	f9b2 2000 	ldrsh.w	r2, [r2]
 8004614:	4293      	cmp	r3, r2
 8004616:	f2c0 83c4 	blt.w	8004da2 <lv_draw_letter+0x8e6>
 800461a:	68bb      	ldr	r3, [r7, #8]
 800461c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8004620:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 8004624:	429a      	cmp	r2, r3
 8004626:	f300 83bc 	bgt.w	8004da2 <lv_draw_letter+0x8e6>
 800462a:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 800462e:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8004632:	4413      	add	r3, r2
 8004634:	68ba      	ldr	r2, [r7, #8]
 8004636:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 800463a:	4293      	cmp	r3, r2
 800463c:	f2c0 83b1 	blt.w	8004da2 <lv_draw_letter+0x8e6>
 8004640:	68bb      	ldr	r3, [r7, #8]
 8004642:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8004646:	f9b7 205a 	ldrsh.w	r2, [r7, #90]	; 0x5a
 800464a:	429a      	cmp	r2, r3
 800464c:	f300 83a9 	bgt.w	8004da2 <lv_draw_letter+0x8e6>

    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
 8004650:	f7fe fc80 	bl	8002f54 <lv_refr_get_disp_refreshing>
 8004654:	6578      	str	r0, [r7, #84]	; 0x54
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8004656:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8004658:	f007 fa29 	bl	800baae <lv_disp_get_buf>
 800465c:	6538      	str	r0, [r7, #80]	; 0x50

    lv_coord_t vdb_width     = lv_area_get_width(&vdb->area);
 800465e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8004660:	3310      	adds	r3, #16
 8004662:	4618      	mov	r0, r3
 8004664:	f7ff fd15 	bl	8004092 <lv_area_get_width>
 8004668:	4603      	mov	r3, r0
 800466a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
 800466e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8004670:	689b      	ldr	r3, [r3, #8]
 8004672:	673b      	str	r3, [r7, #112]	; 0x70
    lv_coord_t col, row;

    uint8_t width_byte_scr = g.box_w >> 3; /*Width in bytes (on the screen finally) (e.g. w = 11 -> 2 bytes wide)*/
 8004674:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8004678:	08db      	lsrs	r3, r3, #3
 800467a:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d
    if(g.box_w & 0x7) width_byte_scr++;
 800467e:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8004682:	f003 0307 	and.w	r3, r3, #7
 8004686:	2b00      	cmp	r3, #0
 8004688:	d004      	beq.n	8004694 <lv_draw_letter+0x1d8>
 800468a:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800468e:	3301      	adds	r3, #1
 8004690:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
 8004694:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8004698:	b29a      	uxth	r2, r3
 800469a:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800469e:	b29b      	uxth	r3, r3
 80046a0:	fb12 f303 	smulbb	r3, r2, r3
 80046a4:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a

    bool subpx = font_p->subpx == LV_FONT_SUBPX_NONE ? false : true;
 80046a8:	687b      	ldr	r3, [r7, #4]
 80046aa:	7a9b      	ldrb	r3, [r3, #10]
 80046ac:	f003 0303 	and.w	r3, r3, #3
 80046b0:	b2db      	uxtb	r3, r3
 80046b2:	2b00      	cmp	r3, #0
 80046b4:	bf14      	ite	ne
 80046b6:	2301      	movne	r3, #1
 80046b8:	2300      	moveq	r3, #0
 80046ba:	f887 3049 	strb.w	r3, [r7, #73]	; 0x49
    lv_coord_t col_start;
    lv_coord_t col_end;
    lv_coord_t row_start;
    lv_coord_t row_end;

    if(subpx == false) {
 80046be:	f897 3049 	ldrb.w	r3, [r7, #73]	; 0x49
 80046c2:	f083 0301 	eor.w	r3, r3, #1
 80046c6:	b2db      	uxtb	r3, r3
 80046c8:	2b00      	cmp	r3, #0
 80046ca:	d05e      	beq.n	800478a <lv_draw_letter+0x2ce>
        col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
 80046cc:	68bb      	ldr	r3, [r7, #8]
 80046ce:	f9b3 3000 	ldrsh.w	r3, [r3]
 80046d2:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 80046d6:	429a      	cmp	r2, r3
 80046d8:	da09      	bge.n	80046ee <lv_draw_letter+0x232>
 80046da:	68bb      	ldr	r3, [r7, #8]
 80046dc:	f9b3 3000 	ldrsh.w	r3, [r3]
 80046e0:	b29a      	uxth	r2, r3
 80046e2:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80046e6:	1ad3      	subs	r3, r2, r3
 80046e8:	b29b      	uxth	r3, r3
 80046ea:	b21b      	sxth	r3, r3
 80046ec:	e000      	b.n	80046f0 <lv_draw_letter+0x234>
 80046ee:	2300      	movs	r3, #0
 80046f0:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
        col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
 80046f4:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 80046f8:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 80046fc:	4413      	add	r3, r2
 80046fe:	68ba      	ldr	r2, [r7, #8]
 8004700:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
 8004704:	4293      	cmp	r3, r2
 8004706:	dc03      	bgt.n	8004710 <lv_draw_letter+0x254>
 8004708:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800470c:	b21b      	sxth	r3, r3
 800470e:	e00a      	b.n	8004726 <lv_draw_letter+0x26a>
 8004710:	68bb      	ldr	r3, [r7, #8]
 8004712:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8004716:	b29a      	uxth	r2, r3
 8004718:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 800471c:	1ad3      	subs	r3, r2, r3
 800471e:	b29b      	uxth	r3, r3
 8004720:	3301      	adds	r3, #1
 8004722:	b29b      	uxth	r3, r3
 8004724:	b21b      	sxth	r3, r3
 8004726:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
 800472a:	68bb      	ldr	r3, [r7, #8]
 800472c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8004730:	f9b7 205a 	ldrsh.w	r2, [r7, #90]	; 0x5a
 8004734:	429a      	cmp	r2, r3
 8004736:	da09      	bge.n	800474c <lv_draw_letter+0x290>
 8004738:	68bb      	ldr	r3, [r7, #8]
 800473a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800473e:	b29a      	uxth	r2, r3
 8004740:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 8004744:	1ad3      	subs	r3, r2, r3
 8004746:	b29b      	uxth	r3, r3
 8004748:	b21b      	sxth	r3, r3
 800474a:	e000      	b.n	800474e <lv_draw_letter+0x292>
 800474c:	2300      	movs	r3, #0
 800474e:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
 8004752:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8004756:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800475a:	4413      	add	r3, r2
 800475c:	68ba      	ldr	r2, [r7, #8]
 800475e:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 8004762:	4293      	cmp	r3, r2
 8004764:	dc03      	bgt.n	800476e <lv_draw_letter+0x2b2>
 8004766:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800476a:	b21b      	sxth	r3, r3
 800476c:	e00a      	b.n	8004784 <lv_draw_letter+0x2c8>
 800476e:	68bb      	ldr	r3, [r7, #8]
 8004770:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8004774:	b29a      	uxth	r2, r3
 8004776:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800477a:	1ad3      	subs	r3, r2, r3
 800477c:	b29b      	uxth	r3, r3
 800477e:	3301      	adds	r3, #1
 8004780:	b29b      	uxth	r3, r3
 8004782:	b21b      	sxth	r3, r3
 8004784:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
 8004788:	e06f      	b.n	800486a <lv_draw_letter+0x3ae>
    } else {
        col_start = pos_x >= mask_p->x1 ? 0 : (mask_p->x1 - pos_x) * 3;
 800478a:	68bb      	ldr	r3, [r7, #8]
 800478c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8004790:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 8004794:	429a      	cmp	r2, r3
 8004796:	da0d      	bge.n	80047b4 <lv_draw_letter+0x2f8>
 8004798:	68bb      	ldr	r3, [r7, #8]
 800479a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800479e:	461a      	mov	r2, r3
 80047a0:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 80047a4:	1ad3      	subs	r3, r2, r3
 80047a6:	b29b      	uxth	r3, r3
 80047a8:	461a      	mov	r2, r3
 80047aa:	0052      	lsls	r2, r2, #1
 80047ac:	4413      	add	r3, r2
 80047ae:	b29b      	uxth	r3, r3
 80047b0:	b21b      	sxth	r3, r3
 80047b2:	e000      	b.n	80047b6 <lv_draw_letter+0x2fa>
 80047b4:	2300      	movs	r3, #0
 80047b6:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
        col_end   = pos_x + g.box_w / 3 <= mask_p->x2 ? g.box_w : (mask_p->x2 - pos_x + 1) * 3;
 80047ba:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 80047be:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 80047c2:	4909      	ldr	r1, [pc, #36]	; (80047e8 <lv_draw_letter+0x32c>)
 80047c4:	fba1 1202 	umull	r1, r2, r1, r2
 80047c8:	0852      	lsrs	r2, r2, #1
 80047ca:	b2d2      	uxtb	r2, r2
 80047cc:	4413      	add	r3, r2
 80047ce:	68ba      	ldr	r2, [r7, #8]
 80047d0:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
 80047d4:	4293      	cmp	r3, r2
 80047d6:	dc09      	bgt.n	80047ec <lv_draw_letter+0x330>
 80047d8:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 80047dc:	b21b      	sxth	r3, r3
 80047de:	e013      	b.n	8004808 <lv_draw_letter+0x34c>
 80047e0:	0801380c 	.word	0x0801380c
 80047e4:	08013810 	.word	0x08013810
 80047e8:	aaaaaaab 	.word	0xaaaaaaab
 80047ec:	68bb      	ldr	r3, [r7, #8]
 80047ee:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80047f2:	461a      	mov	r2, r3
 80047f4:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 80047f8:	1ad3      	subs	r3, r2, r3
 80047fa:	3301      	adds	r3, #1
 80047fc:	b29b      	uxth	r3, r3
 80047fe:	461a      	mov	r2, r3
 8004800:	0052      	lsls	r2, r2, #1
 8004802:	4413      	add	r3, r2
 8004804:	b29b      	uxth	r3, r3
 8004806:	b21b      	sxth	r3, r3
 8004808:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
        row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
 800480c:	68bb      	ldr	r3, [r7, #8]
 800480e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8004812:	f9b7 205a 	ldrsh.w	r2, [r7, #90]	; 0x5a
 8004816:	429a      	cmp	r2, r3
 8004818:	da09      	bge.n	800482e <lv_draw_letter+0x372>
 800481a:	68bb      	ldr	r3, [r7, #8]
 800481c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8004820:	b29a      	uxth	r2, r3
 8004822:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 8004826:	1ad3      	subs	r3, r2, r3
 8004828:	b29b      	uxth	r3, r3
 800482a:	b21b      	sxth	r3, r3
 800482c:	e000      	b.n	8004830 <lv_draw_letter+0x374>
 800482e:	2300      	movs	r3, #0
 8004830:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
        row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
 8004834:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8004838:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800483c:	4413      	add	r3, r2
 800483e:	68ba      	ldr	r2, [r7, #8]
 8004840:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 8004844:	4293      	cmp	r3, r2
 8004846:	dc03      	bgt.n	8004850 <lv_draw_letter+0x394>
 8004848:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800484c:	b21b      	sxth	r3, r3
 800484e:	e00a      	b.n	8004866 <lv_draw_letter+0x3aa>
 8004850:	68bb      	ldr	r3, [r7, #8]
 8004852:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8004856:	b29a      	uxth	r2, r3
 8004858:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800485c:	1ad3      	subs	r3, r2, r3
 800485e:	b29b      	uxth	r3, r3
 8004860:	3301      	adds	r3, #1
 8004862:	b29b      	uxth	r3, r3
 8004864:	b21b      	sxth	r3, r3
 8004866:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    }

    /*Set a pointer on VDB to the first pixel of the letter*/
    vdb_buf_tmp += ((pos_y - vdb->area.y1) * vdb_width) + pos_x - vdb->area.x1;
 800486a:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 800486e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8004870:	f9b2 2012 	ldrsh.w	r2, [r2, #18]
 8004874:	1a9b      	subs	r3, r3, r2
 8004876:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 800487a:	fb02 f203 	mul.w	r2, r2, r3
 800487e:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8004882:	4413      	add	r3, r2
 8004884:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8004886:	f9b2 2010 	ldrsh.w	r2, [r2, #16]
 800488a:	1a9b      	subs	r3, r3, r2
 800488c:	005b      	lsls	r3, r3, #1
 800488e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8004890:	4413      	add	r3, r2
 8004892:	673b      	str	r3, [r7, #112]	; 0x70

    /*If the letter is partially out of mask the move there on VDB*/
    if(subpx) vdb_buf_tmp += (row_start * vdb_width) + col_start / 3;
 8004894:	f897 3049 	ldrb.w	r3, [r7, #73]	; 0x49
 8004898:	2b00      	cmp	r3, #0
 800489a:	d013      	beq.n	80048c4 <lv_draw_letter+0x408>
 800489c:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 80048a0:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 80048a4:	fb02 f203 	mul.w	r2, r2, r3
 80048a8:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 80048ac:	49b8      	ldr	r1, [pc, #736]	; (8004b90 <lv_draw_letter+0x6d4>)
 80048ae:	fb81 0103 	smull	r0, r1, r1, r3
 80048b2:	17db      	asrs	r3, r3, #31
 80048b4:	1acb      	subs	r3, r1, r3
 80048b6:	b21b      	sxth	r3, r3
 80048b8:	4413      	add	r3, r2
 80048ba:	005b      	lsls	r3, r3, #1
 80048bc:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80048be:	4413      	add	r3, r2
 80048c0:	673b      	str	r3, [r7, #112]	; 0x70
 80048c2:	e00c      	b.n	80048de <lv_draw_letter+0x422>
    else vdb_buf_tmp += (row_start * vdb_width) + col_start;
 80048c4:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 80048c8:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 80048cc:	fb02 f203 	mul.w	r2, r2, r3
 80048d0:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 80048d4:	4413      	add	r3, r2
 80048d6:	005b      	lsls	r3, r3, #1
 80048d8:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80048da:	4413      	add	r3, r2
 80048dc:	673b      	str	r3, [r7, #112]	; 0x70

    /*Move on the map too*/
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * g.bpp);
 80048de:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 80048e2:	f8b7 204a 	ldrh.w	r2, [r7, #74]	; 0x4a
 80048e6:	fb02 f203 	mul.w	r2, r2, r3
 80048ea:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 80048ee:	f897 102a 	ldrb.w	r1, [r7, #42]	; 0x2a
 80048f2:	fb01 f303 	mul.w	r3, r1, r3
 80048f6:	4413      	add	r3, r2
 80048f8:	647b      	str	r3, [r7, #68]	; 0x44
    map_p += bit_ofs >> 3;
 80048fa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80048fc:	08db      	lsrs	r3, r3, #3
 80048fe:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8004900:	4413      	add	r3, r2
 8004902:	677b      	str	r3, [r7, #116]	; 0x74

    uint8_t letter_px;
    lv_opa_t px_opa = 0;
 8004904:	2300      	movs	r3, #0
 8004906:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
    uint16_t col_bit;
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */
 800490a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800490c:	b29b      	uxth	r3, r3
 800490e:	f003 0307 	and.w	r3, r3, #7
 8004912:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60

    bool scr_transp = false;
 8004916:	2300      	movs	r3, #0
 8004918:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
    scr_transp = disp->driver.screen_transp;
#endif

    uint8_t font_rgb[3];
    uint8_t txt_rgb[3] = {LV_COLOR_GET_R(color), LV_COLOR_GET_G(color), LV_COLOR_GET_B(color)};
 800491c:	f897 3099 	ldrb.w	r3, [r7, #153]	; 0x99
 8004920:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8004924:	b2db      	uxtb	r3, r3
 8004926:	773b      	strb	r3, [r7, #28]
 8004928:	f8b7 3098 	ldrh.w	r3, [r7, #152]	; 0x98
 800492c:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8004930:	b2db      	uxtb	r3, r3
 8004932:	777b      	strb	r3, [r7, #29]
 8004934:	f897 3098 	ldrb.w	r3, [r7, #152]	; 0x98
 8004938:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800493c:	b2db      	uxtb	r3, r3
 800493e:	77bb      	strb	r3, [r7, #30]

    for(row = row_start; row < row_end; row++) {
 8004940:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8004944:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
 8004948:	e219      	b.n	8004d7e <lv_draw_letter+0x8c2>
        bitmask = bitmask_init >> col_bit;
 800494a:	f897 207b 	ldrb.w	r2, [r7, #123]	; 0x7b
 800494e:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8004952:	fa42 f303 	asr.w	r3, r2, r3
 8004956:	f887 307a 	strb.w	r3, [r7, #122]	; 0x7a
        uint8_t sub_px_cnt = 0;
 800495a:	2300      	movs	r3, #0
 800495c:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
        for(col = col_start; col < col_end; col++) {
 8004960:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 8004964:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
 8004968:	e1b6      	b.n	8004cd8 <lv_draw_letter+0x81c>
            letter_px = (*map_p & bitmask) >> (8 - col_bit - g.bpp);
 800496a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800496c:	781a      	ldrb	r2, [r3, #0]
 800496e:	f897 307a 	ldrb.w	r3, [r7, #122]	; 0x7a
 8004972:	4013      	ands	r3, r2
 8004974:	b2db      	uxtb	r3, r3
 8004976:	461a      	mov	r2, r3
 8004978:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800497c:	f1c3 0308 	rsb	r3, r3, #8
 8004980:	f897 102a 	ldrb.w	r1, [r7, #42]	; 0x2a
 8004984:	1a5b      	subs	r3, r3, r1
 8004986:	fa42 f303 	asr.w	r3, r2, r3
 800498a:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42

            /*subpx == 0*/
            if(subpx == false) {
 800498e:	f897 3049 	ldrb.w	r3, [r7, #73]	; 0x49
 8004992:	f083 0301 	eor.w	r3, r3, #1
 8004996:	b2db      	uxtb	r3, r3
 8004998:	2b00      	cmp	r3, #0
 800499a:	f000 8094 	beq.w	8004ac6 <lv_draw_letter+0x60a>
                if(letter_px != 0) {
 800499e:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 80049a2:	2b00      	cmp	r3, #0
 80049a4:	f000 808b 	beq.w	8004abe <lv_draw_letter+0x602>
                    if(opa == LV_OPA_COVER) {
 80049a8:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 80049ac:	2bff      	cmp	r3, #255	; 0xff
 80049ae:	d10e      	bne.n	80049ce <lv_draw_letter+0x512>
                        px_opa = g.bpp == 8 ? letter_px : bpp_opa_table[letter_px];
 80049b0:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 80049b4:	2b08      	cmp	r3, #8
 80049b6:	d005      	beq.n	80049c4 <lv_draw_letter+0x508>
 80049b8:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 80049bc:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80049be:	4413      	add	r3, r2
 80049c0:	781b      	ldrb	r3, [r3, #0]
 80049c2:	e001      	b.n	80049c8 <lv_draw_letter+0x50c>
 80049c4:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 80049c8:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
 80049cc:	e021      	b.n	8004a12 <lv_draw_letter+0x556>
                    } else {
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
 80049ce:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 80049d2:	2b08      	cmp	r3, #8
 80049d4:	d10c      	bne.n	80049f0 <lv_draw_letter+0x534>
 80049d6:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 80049da:	b29a      	uxth	r2, r3
 80049dc:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 80049e0:	b29b      	uxth	r3, r3
 80049e2:	fb12 f303 	smulbb	r3, r2, r3
 80049e6:	b29b      	uxth	r3, r3
 80049e8:	0a1b      	lsrs	r3, r3, #8
 80049ea:	b29b      	uxth	r3, r3
 80049ec:	b2db      	uxtb	r3, r3
 80049ee:	e00e      	b.n	8004a0e <lv_draw_letter+0x552>
                                : (uint16_t)((uint16_t)bpp_opa_table[letter_px] * opa) >> 8;
 80049f0:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 80049f4:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80049f6:	4413      	add	r3, r2
 80049f8:	781b      	ldrb	r3, [r3, #0]
 80049fa:	b29a      	uxth	r2, r3
 80049fc:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 8004a00:	b29b      	uxth	r3, r3
 8004a02:	fb12 f303 	smulbb	r3, r2, r3
 8004a06:	b29b      	uxth	r3, r3
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
 8004a08:	0a1b      	lsrs	r3, r3, #8
 8004a0a:	b29b      	uxth	r3, r3
 8004a0c:	b2db      	uxtb	r3, r3
 8004a0e:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
                    }

                    if(disp->driver.set_px_cb) {
 8004a12:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004a14:	695b      	ldr	r3, [r3, #20]
 8004a16:	2b00      	cmp	r3, #0
 8004a18:	d02c      	beq.n	8004a74 <lv_draw_letter+0x5b8>
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
 8004a1a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8004a1c:	695c      	ldr	r4, [r3, #20]
 8004a1e:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8004a20:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8004a22:	6899      	ldr	r1, [r3, #8]
                                (col + pos_x) - vdb->area.x1, (row + pos_y) - vdb->area.y1, color, px_opa);
 8004a24:	f8b7 206e 	ldrh.w	r2, [r7, #110]	; 0x6e
 8004a28:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8004a2c:	4413      	add	r3, r2
 8004a2e:	b29a      	uxth	r2, r3
 8004a30:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8004a32:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8004a36:	b29b      	uxth	r3, r3
 8004a38:	1ad3      	subs	r3, r2, r3
 8004a3a:	b29b      	uxth	r3, r3
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
 8004a3c:	b21e      	sxth	r6, r3
                                (col + pos_x) - vdb->area.x1, (row + pos_y) - vdb->area.y1, color, px_opa);
 8004a3e:	f8b7 206c 	ldrh.w	r2, [r7, #108]	; 0x6c
 8004a42:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 8004a46:	4413      	add	r3, r2
 8004a48:	b29a      	uxth	r2, r3
 8004a4a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8004a4c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8004a50:	b29b      	uxth	r3, r3
 8004a52:	1ad3      	subs	r3, r2, r3
 8004a54:	b29b      	uxth	r3, r3
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
 8004a56:	b21b      	sxth	r3, r3
 8004a58:	f9b7 504e 	ldrsh.w	r5, [r7, #78]	; 0x4e
 8004a5c:	f897 2063 	ldrb.w	r2, [r7, #99]	; 0x63
 8004a60:	9202      	str	r2, [sp, #8]
 8004a62:	f8b7 2098 	ldrh.w	r2, [r7, #152]	; 0x98
 8004a66:	f8ad 2004 	strh.w	r2, [sp, #4]
 8004a6a:	9300      	str	r3, [sp, #0]
 8004a6c:	4633      	mov	r3, r6
 8004a6e:	462a      	mov	r2, r5
 8004a70:	47a0      	blx	r4
 8004a72:	e024      	b.n	8004abe <lv_draw_letter+0x602>
                    } else if(vdb_buf_tmp->full != color.full) {
 8004a74:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004a76:	881a      	ldrh	r2, [r3, #0]
 8004a78:	f8b7 3098 	ldrh.w	r3, [r7, #152]	; 0x98
 8004a7c:	429a      	cmp	r2, r3
 8004a7e:	d01e      	beq.n	8004abe <lv_draw_letter+0x602>
                        if(px_opa > LV_OPA_MAX) {
 8004a80:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 8004a84:	2bfb      	cmp	r3, #251	; 0xfb
 8004a86:	d904      	bls.n	8004a92 <lv_draw_letter+0x5d6>
                            *vdb_buf_tmp = color;
 8004a88:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004a8a:	f8b7 2098 	ldrh.w	r2, [r7, #152]	; 0x98
 8004a8e:	801a      	strh	r2, [r3, #0]
 8004a90:	e015      	b.n	8004abe <lv_draw_letter+0x602>
                        } else if(px_opa > LV_OPA_MIN) {
 8004a92:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 8004a96:	2b10      	cmp	r3, #16
 8004a98:	d911      	bls.n	8004abe <lv_draw_letter+0x602>
                            if(scr_transp == false) {
 8004a9a:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8004a9e:	f083 0301 	eor.w	r3, r3, #1
 8004aa2:	b2db      	uxtb	r3, r3
 8004aa4:	2b00      	cmp	r3, #0
 8004aa6:	d00a      	beq.n	8004abe <lv_draw_letter+0x602>
                                *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
 8004aa8:	f897 2063 	ldrb.w	r2, [r7, #99]	; 0x63
 8004aac:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004aae:	8819      	ldrh	r1, [r3, #0]
 8004ab0:	f8b7 0098 	ldrh.w	r0, [r7, #152]	; 0x98
 8004ab4:	f7ff fa7c 	bl	8003fb0 <lv_color_mix>
 8004ab8:	4602      	mov	r2, r0
 8004aba:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004abc:	801a      	strh	r2, [r3, #0]
#endif
                            }
                        }
                    }
                }
                vdb_buf_tmp++;
 8004abe:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004ac0:	3302      	adds	r3, #2
 8004ac2:	673b      	str	r3, [r7, #112]	; 0x70
 8004ac4:	e0df      	b.n	8004c86 <lv_draw_letter+0x7ca>
            }
            /*Handle subpx drawing*/
            else {
                if(letter_px != 0) {
 8004ac6:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 8004aca:	2b00      	cmp	r3, #0
 8004acc:	d03e      	beq.n	8004b4c <lv_draw_letter+0x690>
                    if(opa == LV_OPA_COVER) {
 8004ace:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 8004ad2:	2bff      	cmp	r3, #255	; 0xff
 8004ad4:	d10e      	bne.n	8004af4 <lv_draw_letter+0x638>
                        px_opa = g.bpp == 8 ? letter_px : bpp_opa_table[letter_px];
 8004ad6:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 8004ada:	2b08      	cmp	r3, #8
 8004adc:	d005      	beq.n	8004aea <lv_draw_letter+0x62e>
 8004ade:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 8004ae2:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8004ae4:	4413      	add	r3, r2
 8004ae6:	781b      	ldrb	r3, [r3, #0]
 8004ae8:	e001      	b.n	8004aee <lv_draw_letter+0x632>
 8004aea:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 8004aee:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
 8004af2:	e021      	b.n	8004b38 <lv_draw_letter+0x67c>
                    } else {
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
 8004af4:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 8004af8:	2b08      	cmp	r3, #8
 8004afa:	d10c      	bne.n	8004b16 <lv_draw_letter+0x65a>
 8004afc:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 8004b00:	b29a      	uxth	r2, r3
 8004b02:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 8004b06:	b29b      	uxth	r3, r3
 8004b08:	fb12 f303 	smulbb	r3, r2, r3
 8004b0c:	b29b      	uxth	r3, r3
 8004b0e:	0a1b      	lsrs	r3, r3, #8
 8004b10:	b29b      	uxth	r3, r3
 8004b12:	b2db      	uxtb	r3, r3
 8004b14:	e00e      	b.n	8004b34 <lv_draw_letter+0x678>
                                : (uint16_t)((uint16_t)bpp_opa_table[letter_px] * opa) >> 8;
 8004b16:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 8004b1a:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8004b1c:	4413      	add	r3, r2
 8004b1e:	781b      	ldrb	r3, [r3, #0]
 8004b20:	b29a      	uxth	r2, r3
 8004b22:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 8004b26:	b29b      	uxth	r3, r3
 8004b28:	fb12 f303 	smulbb	r3, r2, r3
 8004b2c:	b29b      	uxth	r3, r3
                        px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
 8004b2e:	0a1b      	lsrs	r3, r3, #8
 8004b30:	b29b      	uxth	r3, r3
 8004b32:	b2db      	uxtb	r3, r3
 8004b34:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
                    }

                    font_rgb[sub_px_cnt] = px_opa;
 8004b38:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 8004b3c:	f107 0280 	add.w	r2, r7, #128	; 0x80
 8004b40:	4413      	add	r3, r2
 8004b42:	f897 2063 	ldrb.w	r2, [r7, #99]	; 0x63
 8004b46:	f803 2c60 	strb.w	r2, [r3, #-96]
 8004b4a:	e007      	b.n	8004b5c <lv_draw_letter+0x6a0>
                } else {
                    font_rgb[sub_px_cnt] = 0;
 8004b4c:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 8004b50:	f107 0280 	add.w	r2, r7, #128	; 0x80
 8004b54:	4413      	add	r3, r2
 8004b56:	2200      	movs	r2, #0
 8004b58:	f803 2c60 	strb.w	r2, [r3, #-96]
                }
                sub_px_cnt ++;
 8004b5c:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 8004b60:	3301      	adds	r3, #1
 8004b62:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f

                if(sub_px_cnt == 3) {
 8004b66:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 8004b6a:	2b03      	cmp	r3, #3
 8004b6c:	f040 808b 	bne.w	8004c86 <lv_draw_letter+0x7ca>
                    lv_color_t res_color;

                    if(font_rgb[0] == 0 && font_rgb[1] == 0 && font_rgb[2] == 0) {
 8004b70:	f897 3020 	ldrb.w	r3, [r7, #32]
 8004b74:	2b00      	cmp	r3, #0
 8004b76:	d10d      	bne.n	8004b94 <lv_draw_letter+0x6d8>
 8004b78:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8004b7c:	2b00      	cmp	r3, #0
 8004b7e:	d109      	bne.n	8004b94 <lv_draw_letter+0x6d8>
 8004b80:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8004b84:	2b00      	cmp	r3, #0
 8004b86:	d105      	bne.n	8004b94 <lv_draw_letter+0x6d8>
                        res_color = *vdb_buf_tmp;
 8004b88:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004b8a:	881b      	ldrh	r3, [r3, #0]
 8004b8c:	833b      	strh	r3, [r7, #24]
 8004b8e:	e06a      	b.n	8004c66 <lv_draw_letter+0x7aa>
 8004b90:	55555556 	.word	0x55555556
                    } else {

                        uint8_t bg_rgb[3] = {LV_COLOR_GET_R(*vdb_buf_tmp), LV_COLOR_GET_G(*vdb_buf_tmp), LV_COLOR_GET_B(*vdb_buf_tmp)};
 8004b94:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004b96:	785b      	ldrb	r3, [r3, #1]
 8004b98:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8004b9c:	b2db      	uxtb	r3, r3
 8004b9e:	753b      	strb	r3, [r7, #20]
 8004ba0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004ba2:	881b      	ldrh	r3, [r3, #0]
 8004ba4:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8004ba8:	b2db      	uxtb	r3, r3
 8004baa:	757b      	strb	r3, [r7, #21]
 8004bac:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004bae:	781b      	ldrb	r3, [r3, #0]
 8004bb0:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8004bb4:	b2db      	uxtb	r3, r3
 8004bb6:	75bb      	strb	r3, [r7, #22]

#if LV_FONT_SUBPX_BGR
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[2] * (255 - font_rgb[0]))) >> 8);
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[0] * (255 - font_rgb[2]))) >> 8);
#else
                        LV_COLOR_SET_R(res_color, (uint16_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8);
 8004bb8:	7f3b      	ldrb	r3, [r7, #28]
 8004bba:	b29a      	uxth	r2, r3
 8004bbc:	f897 3020 	ldrb.w	r3, [r7, #32]
 8004bc0:	b29b      	uxth	r3, r3
 8004bc2:	fb12 f303 	smulbb	r3, r2, r3
 8004bc6:	b29a      	uxth	r2, r3
 8004bc8:	7d3b      	ldrb	r3, [r7, #20]
 8004bca:	b299      	uxth	r1, r3
 8004bcc:	f897 3020 	ldrb.w	r3, [r7, #32]
 8004bd0:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8004bd4:	b29b      	uxth	r3, r3
 8004bd6:	fb11 f303 	smulbb	r3, r1, r3
 8004bda:	b29b      	uxth	r3, r3
 8004bdc:	4413      	add	r3, r2
 8004bde:	b29b      	uxth	r3, r3
 8004be0:	0a1b      	lsrs	r3, r3, #8
 8004be2:	b29b      	uxth	r3, r3
 8004be4:	f003 031f 	and.w	r3, r3, #31
 8004be8:	b2da      	uxtb	r2, r3
 8004bea:	7e7b      	ldrb	r3, [r7, #25]
 8004bec:	f362 03c7 	bfi	r3, r2, #3, #5
 8004bf0:	767b      	strb	r3, [r7, #25]
                        LV_COLOR_SET_B(res_color, (uint16_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8);
 8004bf2:	7fbb      	ldrb	r3, [r7, #30]
 8004bf4:	b29a      	uxth	r2, r3
 8004bf6:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8004bfa:	b29b      	uxth	r3, r3
 8004bfc:	fb12 f303 	smulbb	r3, r2, r3
 8004c00:	b29a      	uxth	r2, r3
 8004c02:	7dbb      	ldrb	r3, [r7, #22]
 8004c04:	b299      	uxth	r1, r3
 8004c06:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8004c0a:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8004c0e:	b29b      	uxth	r3, r3
 8004c10:	fb11 f303 	smulbb	r3, r1, r3
 8004c14:	b29b      	uxth	r3, r3
 8004c16:	4413      	add	r3, r2
 8004c18:	b29b      	uxth	r3, r3
 8004c1a:	0a1b      	lsrs	r3, r3, #8
 8004c1c:	b29b      	uxth	r3, r3
 8004c1e:	f003 031f 	and.w	r3, r3, #31
 8004c22:	b2da      	uxtb	r2, r3
 8004c24:	7e3b      	ldrb	r3, [r7, #24]
 8004c26:	f362 0304 	bfi	r3, r2, #0, #5
 8004c2a:	763b      	strb	r3, [r7, #24]
#endif
                        LV_COLOR_SET_G(res_color, (uint16_t)((uint16_t)txt_rgb[1] * font_rgb[1] + (bg_rgb[1] * (255 - font_rgb[1]))) >> 8);
 8004c2c:	7f7b      	ldrb	r3, [r7, #29]
 8004c2e:	b29a      	uxth	r2, r3
 8004c30:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8004c34:	b29b      	uxth	r3, r3
 8004c36:	fb12 f303 	smulbb	r3, r2, r3
 8004c3a:	b29a      	uxth	r2, r3
 8004c3c:	7d7b      	ldrb	r3, [r7, #21]
 8004c3e:	b299      	uxth	r1, r3
 8004c40:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8004c44:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8004c48:	b29b      	uxth	r3, r3
 8004c4a:	fb11 f303 	smulbb	r3, r1, r3
 8004c4e:	b29b      	uxth	r3, r3
 8004c50:	4413      	add	r3, r2
 8004c52:	b29b      	uxth	r3, r3
 8004c54:	0a1b      	lsrs	r3, r3, #8
 8004c56:	b29b      	uxth	r3, r3
 8004c58:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8004c5c:	b2da      	uxtb	r2, r3
 8004c5e:	8b3b      	ldrh	r3, [r7, #24]
 8004c60:	f362 134a 	bfi	r3, r2, #5, #6
 8004c64:	833b      	strh	r3, [r7, #24]
                    }
                    if(scr_transp == false) {
 8004c66:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8004c6a:	f083 0301 	eor.w	r3, r3, #1
 8004c6e:	b2db      	uxtb	r3, r3
 8004c70:	2b00      	cmp	r3, #0
 8004c72:	d002      	beq.n	8004c7a <lv_draw_letter+0x7be>
                        vdb_buf_tmp->full = res_color.full;
 8004c74:	8b3a      	ldrh	r2, [r7, #24]
 8004c76:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004c78:	801a      	strh	r2, [r3, #0]
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
                    } else {
                        *vdb_buf_tmp = color_mix_2_alpha(*vdb_buf_tmp, (*vdb_buf_tmp).ch.alpha, color, px_opa);
#endif
                    }
                    sub_px_cnt = 0;
 8004c7a:	2300      	movs	r3, #0
 8004c7c:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
                    vdb_buf_tmp++;
 8004c80:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004c82:	3302      	adds	r3, #2
 8004c84:	673b      	str	r3, [r7, #112]	; 0x70
                }
            }


            if(col_bit < 8 - g.bpp) {
 8004c86:	f8b7 2060 	ldrh.w	r2, [r7, #96]	; 0x60
 8004c8a:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 8004c8e:	f1c3 0308 	rsb	r3, r3, #8
 8004c92:	429a      	cmp	r2, r3
 8004c94:	da0f      	bge.n	8004cb6 <lv_draw_letter+0x7fa>
                col_bit += g.bpp;
 8004c96:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 8004c9a:	b29a      	uxth	r2, r3
 8004c9c:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8004ca0:	4413      	add	r3, r2
 8004ca2:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
                bitmask = bitmask >> g.bpp;
 8004ca6:	f897 307a 	ldrb.w	r3, [r7, #122]	; 0x7a
 8004caa:	f897 202a 	ldrb.w	r2, [r7, #42]	; 0x2a
 8004cae:	4113      	asrs	r3, r2
 8004cb0:	f887 307a 	strb.w	r3, [r7, #122]	; 0x7a
 8004cb4:	e009      	b.n	8004cca <lv_draw_letter+0x80e>
            } else {
                col_bit = 0;
 8004cb6:	2300      	movs	r3, #0
 8004cb8:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
                bitmask = bitmask_init;
 8004cbc:	f897 307b 	ldrb.w	r3, [r7, #123]	; 0x7b
 8004cc0:	f887 307a 	strb.w	r3, [r7, #122]	; 0x7a
                map_p++;
 8004cc4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004cc6:	3301      	adds	r3, #1
 8004cc8:	677b      	str	r3, [r7, #116]	; 0x74
        for(col = col_start; col < col_end; col++) {
 8004cca:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 8004cce:	b29b      	uxth	r3, r3
 8004cd0:	3301      	adds	r3, #1
 8004cd2:	b29b      	uxth	r3, r3
 8004cd4:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
 8004cd8:	f9b7 206e 	ldrsh.w	r2, [r7, #110]	; 0x6e
 8004cdc:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 8004ce0:	429a      	cmp	r2, r3
 8004ce2:	f6ff ae42 	blt.w	800496a <lv_draw_letter+0x4ae>
            }
        }

        col_bit += ((g.box_w - col_end) + col_start) * g.bpp;
 8004ce6:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8004cea:	461a      	mov	r2, r3
 8004cec:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 8004cf0:	1ad2      	subs	r2, r2, r3
 8004cf2:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8004cf6:	4413      	add	r3, r2
 8004cf8:	b29a      	uxth	r2, r3
 8004cfa:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 8004cfe:	b29b      	uxth	r3, r3
 8004d00:	fb12 f303 	smulbb	r3, r2, r3
 8004d04:	b29a      	uxth	r2, r3
 8004d06:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8004d0a:	4413      	add	r3, r2
 8004d0c:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60

        map_p += (col_bit >> 3);
 8004d10:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8004d14:	08db      	lsrs	r3, r3, #3
 8004d16:	b29b      	uxth	r3, r3
 8004d18:	461a      	mov	r2, r3
 8004d1a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004d1c:	4413      	add	r3, r2
 8004d1e:	677b      	str	r3, [r7, #116]	; 0x74
        col_bit = col_bit & 0x7;
 8004d20:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8004d24:	f003 0307 	and.w	r3, r3, #7
 8004d28:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60

        /*Next row in VDB*/
        if(subpx) vdb_buf_tmp += vdb_width - (col_end - col_start) / 3;
 8004d2c:	f897 3049 	ldrb.w	r3, [r7, #73]	; 0x49
 8004d30:	2b00      	cmp	r3, #0
 8004d32:	d011      	beq.n	8004d58 <lv_draw_letter+0x89c>
 8004d34:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 8004d38:	f9b7 1068 	ldrsh.w	r1, [r7, #104]	; 0x68
 8004d3c:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8004d40:	1acb      	subs	r3, r1, r3
 8004d42:	491a      	ldr	r1, [pc, #104]	; (8004dac <lv_draw_letter+0x8f0>)
 8004d44:	fb81 0103 	smull	r0, r1, r1, r3
 8004d48:	17db      	asrs	r3, r3, #31
 8004d4a:	1a5b      	subs	r3, r3, r1
 8004d4c:	4413      	add	r3, r2
 8004d4e:	005b      	lsls	r3, r3, #1
 8004d50:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8004d52:	4413      	add	r3, r2
 8004d54:	673b      	str	r3, [r7, #112]	; 0x70
 8004d56:	e00b      	b.n	8004d70 <lv_draw_letter+0x8b4>
        else vdb_buf_tmp += vdb_width - (col_end - col_start);
 8004d58:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 8004d5c:	f9b7 1068 	ldrsh.w	r1, [r7, #104]	; 0x68
 8004d60:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8004d64:	1acb      	subs	r3, r1, r3
 8004d66:	1ad3      	subs	r3, r2, r3
 8004d68:	005b      	lsls	r3, r3, #1
 8004d6a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8004d6c:	4413      	add	r3, r2
 8004d6e:	673b      	str	r3, [r7, #112]	; 0x70
    for(row = row_start; row < row_end; row++) {
 8004d70:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8004d74:	b29b      	uxth	r3, r3
 8004d76:	3301      	adds	r3, #1
 8004d78:	b29b      	uxth	r3, r3
 8004d7a:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
 8004d7e:	f9b7 206c 	ldrsh.w	r2, [r7, #108]	; 0x6c
 8004d82:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 8004d86:	429a      	cmp	r2, r3
 8004d88:	f6ff addf 	blt.w	800494a <lv_draw_letter+0x48e>
 8004d8c:	e00a      	b.n	8004da4 <lv_draw_letter+0x8e8>
    if(opa < LV_OPA_MIN) return;
 8004d8e:	bf00      	nop
 8004d90:	e008      	b.n	8004da4 <lv_draw_letter+0x8e8>
        return;
 8004d92:	bf00      	nop
 8004d94:	e006      	b.n	8004da4 <lv_draw_letter+0x8e8>
    if(g_ret == false) return;
 8004d96:	bf00      	nop
 8004d98:	e004      	b.n	8004da4 <lv_draw_letter+0x8e8>
        default: return; /*Invalid bpp. Can't render the letter*/
 8004d9a:	bf00      	nop
 8004d9c:	e002      	b.n	8004da4 <lv_draw_letter+0x8e8>
    if(map_p == NULL) return;
 8004d9e:	bf00      	nop
 8004da0:	e000      	b.n	8004da4 <lv_draw_letter+0x8e8>
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
 8004da2:	bf00      	nop
    }
}
 8004da4:	3784      	adds	r7, #132	; 0x84
 8004da6:	46bd      	mov	sp, r7
 8004da8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004daa:	bf00      	nop
 8004dac:	55555556 	.word	0x55555556

08004db0 <sw_color_fill>:
 * @param color fill color
 * @param opa opacity (0, LV_OPA_TRANSP: transparent ... 255, LV_OPA_COVER, fully cover)
 */
static void sw_color_fill(lv_color_t * mem, lv_coord_t mem_width, const lv_area_t * fill_area, lv_color_t color,
                          lv_opa_t opa)
{
 8004db0:	b590      	push	{r4, r7, lr}
 8004db2:	b08f      	sub	sp, #60	; 0x3c
 8004db4:	af04      	add	r7, sp, #16
 8004db6:	60f8      	str	r0, [r7, #12]
 8004db8:	607a      	str	r2, [r7, #4]
 8004dba:	813b      	strh	r3, [r7, #8]
 8004dbc:	460b      	mov	r3, r1
 8004dbe:	817b      	strh	r3, [r7, #10]
    /*Set all row in vdb to the given color*/
    lv_coord_t row;
    lv_coord_t col;

    lv_disp_t * disp = lv_refr_get_disp_refreshing();
 8004dc0:	f7fe f8c8 	bl	8002f54 <lv_refr_get_disp_refreshing>
 8004dc4:	6238      	str	r0, [r7, #32]
    if(disp->driver.set_px_cb) {
 8004dc6:	6a3b      	ldr	r3, [r7, #32]
 8004dc8:	695b      	ldr	r3, [r3, #20]
 8004dca:	2b00      	cmp	r3, #0
 8004dcc:	d035      	beq.n	8004e3a <sw_color_fill+0x8a>
        for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8004dce:	687b      	ldr	r3, [r7, #4]
 8004dd0:	881b      	ldrh	r3, [r3, #0]
 8004dd2:	84bb      	strh	r3, [r7, #36]	; 0x24
 8004dd4:	e029      	b.n	8004e2a <sw_color_fill+0x7a>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8004dd6:	687b      	ldr	r3, [r7, #4]
 8004dd8:	885b      	ldrh	r3, [r3, #2]
 8004dda:	84fb      	strh	r3, [r7, #38]	; 0x26
 8004ddc:	e018      	b.n	8004e10 <sw_color_fill+0x60>
                disp->driver.set_px_cb(&disp->driver, (uint8_t *)mem, mem_width, col, row, color, opa);
 8004dde:	6a3b      	ldr	r3, [r7, #32]
 8004de0:	695c      	ldr	r4, [r3, #20]
 8004de2:	6a38      	ldr	r0, [r7, #32]
 8004de4:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	; 0x24
 8004de8:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8004dec:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8004df0:	9302      	str	r3, [sp, #8]
 8004df2:	893b      	ldrh	r3, [r7, #8]
 8004df4:	f8ad 3004 	strh.w	r3, [sp, #4]
 8004df8:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8004dfc:	9300      	str	r3, [sp, #0]
 8004dfe:	460b      	mov	r3, r1
 8004e00:	68f9      	ldr	r1, [r7, #12]
 8004e02:	47a0      	blx	r4
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8004e04:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8004e08:	b29b      	uxth	r3, r3
 8004e0a:	3301      	adds	r3, #1
 8004e0c:	b29b      	uxth	r3, r3
 8004e0e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8004e10:	687b      	ldr	r3, [r7, #4]
 8004e12:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8004e16:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8004e1a:	429a      	cmp	r2, r3
 8004e1c:	dddf      	ble.n	8004dde <sw_color_fill+0x2e>
        for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8004e1e:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004e22:	b29b      	uxth	r3, r3
 8004e24:	3301      	adds	r3, #1
 8004e26:	b29b      	uxth	r3, r3
 8004e28:	84bb      	strh	r3, [r7, #36]	; 0x24
 8004e2a:	687b      	ldr	r3, [r7, #4]
 8004e2c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8004e30:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8004e34:	429a      	cmp	r2, r3
 8004e36:	ddce      	ble.n	8004dd6 <sw_color_fill+0x26>
                }
                mem += mem_width;
            }
        }
    }
}
 8004e38:	e0ce      	b.n	8004fd8 <sw_color_fill+0x228>
        mem += fill_area->y1 * mem_width; /*Go to the first row*/
 8004e3a:	687b      	ldr	r3, [r7, #4]
 8004e3c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8004e40:	461a      	mov	r2, r3
 8004e42:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8004e46:	fb03 f302 	mul.w	r3, r3, r2
 8004e4a:	005b      	lsls	r3, r3, #1
 8004e4c:	68fa      	ldr	r2, [r7, #12]
 8004e4e:	4413      	add	r3, r2
 8004e50:	60fb      	str	r3, [r7, #12]
        if(opa == LV_OPA_COVER) {
 8004e52:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8004e56:	2bff      	cmp	r3, #255	; 0xff
 8004e58:	d159      	bne.n	8004f0e <sw_color_fill+0x15e>
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8004e5a:	687b      	ldr	r3, [r7, #4]
 8004e5c:	881b      	ldrh	r3, [r3, #0]
 8004e5e:	84bb      	strh	r3, [r7, #36]	; 0x24
 8004e60:	e00c      	b.n	8004e7c <sw_color_fill+0xcc>
                mem[col] = color;
 8004e62:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004e66:	005b      	lsls	r3, r3, #1
 8004e68:	68fa      	ldr	r2, [r7, #12]
 8004e6a:	4413      	add	r3, r2
 8004e6c:	893a      	ldrh	r2, [r7, #8]
 8004e6e:	801a      	strh	r2, [r3, #0]
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8004e70:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004e74:	b29b      	uxth	r3, r3
 8004e76:	3301      	adds	r3, #1
 8004e78:	b29b      	uxth	r3, r3
 8004e7a:	84bb      	strh	r3, [r7, #36]	; 0x24
 8004e7c:	687b      	ldr	r3, [r7, #4]
 8004e7e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8004e82:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8004e86:	429a      	cmp	r2, r3
 8004e88:	ddeb      	ble.n	8004e62 <sw_color_fill+0xb2>
            lv_color_t * mem_first = &mem[fill_area->x1];
 8004e8a:	687b      	ldr	r3, [r7, #4]
 8004e8c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8004e90:	005b      	lsls	r3, r3, #1
 8004e92:	68fa      	ldr	r2, [r7, #12]
 8004e94:	4413      	add	r3, r2
 8004e96:	61bb      	str	r3, [r7, #24]
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
 8004e98:	687b      	ldr	r3, [r7, #4]
 8004e9a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8004e9e:	461a      	mov	r2, r3
 8004ea0:	687b      	ldr	r3, [r7, #4]
 8004ea2:	f9b3 3000 	ldrsh.w	r3, [r3]
 8004ea6:	1ad3      	subs	r3, r2, r3
 8004ea8:	3301      	adds	r3, #1
 8004eaa:	b29b      	uxth	r3, r3
 8004eac:	005b      	lsls	r3, r3, #1
 8004eae:	b29b      	uxth	r3, r3
 8004eb0:	82fb      	strh	r3, [r7, #22]
            mem += mem_width;
 8004eb2:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8004eb6:	005b      	lsls	r3, r3, #1
 8004eb8:	68fa      	ldr	r2, [r7, #12]
 8004eba:	4413      	add	r3, r2
 8004ebc:	60fb      	str	r3, [r7, #12]
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
 8004ebe:	687b      	ldr	r3, [r7, #4]
 8004ec0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8004ec4:	b29b      	uxth	r3, r3
 8004ec6:	3301      	adds	r3, #1
 8004ec8:	b29b      	uxth	r3, r3
 8004eca:	84fb      	strh	r3, [r7, #38]	; 0x26
 8004ecc:	e017      	b.n	8004efe <sw_color_fill+0x14e>
                memcpy(&mem[fill_area->x1], mem_first, copy_size);
 8004ece:	687b      	ldr	r3, [r7, #4]
 8004ed0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8004ed4:	005b      	lsls	r3, r3, #1
 8004ed6:	68fa      	ldr	r2, [r7, #12]
 8004ed8:	4413      	add	r3, r2
 8004eda:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8004ede:	69b9      	ldr	r1, [r7, #24]
 8004ee0:	4618      	mov	r0, r3
 8004ee2:	f00e fc31 	bl	8013748 <memcpy>
                mem += mem_width;
 8004ee6:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8004eea:	005b      	lsls	r3, r3, #1
 8004eec:	68fa      	ldr	r2, [r7, #12]
 8004eee:	4413      	add	r3, r2
 8004ef0:	60fb      	str	r3, [r7, #12]
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
 8004ef2:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8004ef6:	b29b      	uxth	r3, r3
 8004ef8:	3301      	adds	r3, #1
 8004efa:	b29b      	uxth	r3, r3
 8004efc:	84fb      	strh	r3, [r7, #38]	; 0x26
 8004efe:	687b      	ldr	r3, [r7, #4]
 8004f00:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8004f04:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8004f08:	429a      	cmp	r2, r3
 8004f0a:	dde0      	ble.n	8004ece <sw_color_fill+0x11e>
}
 8004f0c:	e064      	b.n	8004fd8 <sw_color_fill+0x228>
            bool scr_transp = false;
 8004f0e:	2300      	movs	r3, #0
 8004f10:	77fb      	strb	r3, [r7, #31]
            lv_color_t bg_tmp  = LV_COLOR_BLACK;
 8004f12:	7d3b      	ldrb	r3, [r7, #20]
 8004f14:	f36f 0304 	bfc	r3, #0, #5
 8004f18:	753b      	strb	r3, [r7, #20]
 8004f1a:	8abb      	ldrh	r3, [r7, #20]
 8004f1c:	f36f 134a 	bfc	r3, #5, #6
 8004f20:	82bb      	strh	r3, [r7, #20]
 8004f22:	7d7b      	ldrb	r3, [r7, #21]
 8004f24:	f36f 03c7 	bfc	r3, #3, #5
 8004f28:	757b      	strb	r3, [r7, #21]
            lv_color_t opa_tmp = lv_color_mix(color, bg_tmp, opa);
 8004f2a:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8004f2e:	461a      	mov	r2, r3
 8004f30:	8ab9      	ldrh	r1, [r7, #20]
 8004f32:	8938      	ldrh	r0, [r7, #8]
 8004f34:	f7ff f83c 	bl	8003fb0 <lv_color_mix>
 8004f38:	4603      	mov	r3, r0
 8004f3a:	823b      	strh	r3, [r7, #16]
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8004f3c:	687b      	ldr	r3, [r7, #4]
 8004f3e:	885b      	ldrh	r3, [r3, #2]
 8004f40:	84fb      	strh	r3, [r7, #38]	; 0x26
 8004f42:	e042      	b.n	8004fca <sw_color_fill+0x21a>
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8004f44:	687b      	ldr	r3, [r7, #4]
 8004f46:	881b      	ldrh	r3, [r3, #0]
 8004f48:	84bb      	strh	r3, [r7, #36]	; 0x24
 8004f4a:	e02b      	b.n	8004fa4 <sw_color_fill+0x1f4>
                    if(scr_transp == false) {
 8004f4c:	7ffb      	ldrb	r3, [r7, #31]
 8004f4e:	f083 0301 	eor.w	r3, r3, #1
 8004f52:	b2db      	uxtb	r3, r3
 8004f54:	2b00      	cmp	r3, #0
 8004f56:	d01f      	beq.n	8004f98 <sw_color_fill+0x1e8>
                        if(mem[col].full != bg_tmp.full) {
 8004f58:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004f5c:	005b      	lsls	r3, r3, #1
 8004f5e:	68fa      	ldr	r2, [r7, #12]
 8004f60:	4413      	add	r3, r2
 8004f62:	881a      	ldrh	r2, [r3, #0]
 8004f64:	8abb      	ldrh	r3, [r7, #20]
 8004f66:	429a      	cmp	r2, r3
 8004f68:	d00f      	beq.n	8004f8a <sw_color_fill+0x1da>
                            bg_tmp  = mem[col];
 8004f6a:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004f6e:	005b      	lsls	r3, r3, #1
 8004f70:	68fa      	ldr	r2, [r7, #12]
 8004f72:	4413      	add	r3, r2
 8004f74:	881b      	ldrh	r3, [r3, #0]
 8004f76:	82bb      	strh	r3, [r7, #20]
                            opa_tmp = lv_color_mix(color, bg_tmp, opa);
 8004f78:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8004f7c:	461a      	mov	r2, r3
 8004f7e:	8ab9      	ldrh	r1, [r7, #20]
 8004f80:	8938      	ldrh	r0, [r7, #8]
 8004f82:	f7ff f815 	bl	8003fb0 <lv_color_mix>
 8004f86:	4603      	mov	r3, r0
 8004f88:	823b      	strh	r3, [r7, #16]
                        mem[col] = opa_tmp;
 8004f8a:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004f8e:	005b      	lsls	r3, r3, #1
 8004f90:	68fa      	ldr	r2, [r7, #12]
 8004f92:	4413      	add	r3, r2
 8004f94:	8a3a      	ldrh	r2, [r7, #16]
 8004f96:	801a      	strh	r2, [r3, #0]
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8004f98:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004f9c:	b29b      	uxth	r3, r3
 8004f9e:	3301      	adds	r3, #1
 8004fa0:	b29b      	uxth	r3, r3
 8004fa2:	84bb      	strh	r3, [r7, #36]	; 0x24
 8004fa4:	687b      	ldr	r3, [r7, #4]
 8004fa6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8004faa:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8004fae:	429a      	cmp	r2, r3
 8004fb0:	ddcc      	ble.n	8004f4c <sw_color_fill+0x19c>
                mem += mem_width;
 8004fb2:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8004fb6:	005b      	lsls	r3, r3, #1
 8004fb8:	68fa      	ldr	r2, [r7, #12]
 8004fba:	4413      	add	r3, r2
 8004fbc:	60fb      	str	r3, [r7, #12]
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8004fbe:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8004fc2:	b29b      	uxth	r3, r3
 8004fc4:	3301      	adds	r3, #1
 8004fc6:	b29b      	uxth	r3, r3
 8004fc8:	84fb      	strh	r3, [r7, #38]	; 0x26
 8004fca:	687b      	ldr	r3, [r7, #4]
 8004fcc:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8004fd0:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8004fd4:	429a      	cmp	r2, r3
 8004fd6:	ddb5      	ble.n	8004f44 <sw_color_fill+0x194>
}
 8004fd8:	bf00      	nop
 8004fda:	372c      	adds	r7, #44	; 0x2c
 8004fdc:	46bd      	mov	sp, r7
 8004fde:	bd90      	pop	{r4, r7, pc}

08004fe0 <lv_img_color_format_get_px_size>:
 * Get the pixel size of a color format in bits
 * @param cf a color format (`LV_IMG_CF_...`)
 * @return the pixel size in bits
 */
uint8_t lv_img_color_format_get_px_size(lv_img_cf_t cf)
{
 8004fe0:	b480      	push	{r7}
 8004fe2:	b085      	sub	sp, #20
 8004fe4:	af00      	add	r7, sp, #0
 8004fe6:	4603      	mov	r3, r0
 8004fe8:	71fb      	strb	r3, [r7, #7]
    uint8_t px_size = 0;
 8004fea:	2300      	movs	r3, #0
 8004fec:	73fb      	strb	r3, [r7, #15]

    switch(cf) {
 8004fee:	79fb      	ldrb	r3, [r7, #7]
 8004ff0:	2b0e      	cmp	r3, #14
 8004ff2:	d836      	bhi.n	8005062 <lv_img_color_format_get_px_size+0x82>
 8004ff4:	a201      	add	r2, pc, #4	; (adr r2, 8004ffc <lv_img_color_format_get_px_size+0x1c>)
 8004ff6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004ffa:	bf00      	nop
 8004ffc:	08005039 	.word	0x08005039
 8005000:	08005039 	.word	0x08005039
 8005004:	08005063 	.word	0x08005063
 8005008:	08005063 	.word	0x08005063
 800500c:	0800503f 	.word	0x0800503f
 8005010:	08005045 	.word	0x08005045
 8005014:	0800503f 	.word	0x0800503f
 8005018:	0800504b 	.word	0x0800504b
 800501c:	08005051 	.word	0x08005051
 8005020:	08005057 	.word	0x08005057
 8005024:	0800505d 	.word	0x0800505d
 8005028:	0800504b 	.word	0x0800504b
 800502c:	08005051 	.word	0x08005051
 8005030:	08005057 	.word	0x08005057
 8005034:	0800505d 	.word	0x0800505d
        case LV_IMG_CF_UNKNOWN:
        case LV_IMG_CF_RAW: px_size = 0; break;
 8005038:	2300      	movs	r3, #0
 800503a:	73fb      	strb	r3, [r7, #15]
 800503c:	e014      	b.n	8005068 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_TRUE_COLOR:
        case LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED: px_size = LV_COLOR_SIZE; break;
 800503e:	2310      	movs	r3, #16
 8005040:	73fb      	strb	r3, [r7, #15]
 8005042:	e011      	b.n	8005068 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_TRUE_COLOR_ALPHA: px_size = LV_IMG_PX_SIZE_ALPHA_BYTE << 3; break;
 8005044:	2318      	movs	r3, #24
 8005046:	73fb      	strb	r3, [r7, #15]
 8005048:	e00e      	b.n	8005068 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_1BIT:
        case LV_IMG_CF_ALPHA_1BIT: px_size = 1; break;
 800504a:	2301      	movs	r3, #1
 800504c:	73fb      	strb	r3, [r7, #15]
 800504e:	e00b      	b.n	8005068 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_2BIT:
        case LV_IMG_CF_ALPHA_2BIT: px_size = 2; break;
 8005050:	2302      	movs	r3, #2
 8005052:	73fb      	strb	r3, [r7, #15]
 8005054:	e008      	b.n	8005068 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_4BIT:
        case LV_IMG_CF_ALPHA_4BIT: px_size = 4; break;
 8005056:	2304      	movs	r3, #4
 8005058:	73fb      	strb	r3, [r7, #15]
 800505a:	e005      	b.n	8005068 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_8BIT:
        case LV_IMG_CF_ALPHA_8BIT: px_size = 8; break;
 800505c:	2308      	movs	r3, #8
 800505e:	73fb      	strb	r3, [r7, #15]
 8005060:	e002      	b.n	8005068 <lv_img_color_format_get_px_size+0x88>
        default: px_size = 0; break;
 8005062:	2300      	movs	r3, #0
 8005064:	73fb      	strb	r3, [r7, #15]
 8005066:	bf00      	nop
    }

    return px_size;
 8005068:	7bfb      	ldrb	r3, [r7, #15]
}
 800506a:	4618      	mov	r0, r3
 800506c:	3714      	adds	r7, #20
 800506e:	46bd      	mov	sp, r7
 8005070:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005074:	4770      	bx	lr
 8005076:	bf00      	nop

08005078 <lv_img_src_get_type>:
 *  - a path to a file (e.g. "S:/folder/image.bin")
 *  - or a symbol (e.g. LV_SYMBOL_CLOSE)
 * @return type of the image source LV_IMG_SRC_VARIABLE/FILE/SYMBOL/UNKNOWN
 */
lv_img_src_t lv_img_src_get_type(const void * src)
{
 8005078:	b480      	push	{r7}
 800507a:	b085      	sub	sp, #20
 800507c:	af00      	add	r7, sp, #0
 800507e:	6078      	str	r0, [r7, #4]
    lv_img_src_t img_src_type = LV_IMG_SRC_UNKNOWN;
 8005080:	2303      	movs	r3, #3
 8005082:	73fb      	strb	r3, [r7, #15]

    if(src == NULL) return img_src_type;
 8005084:	687b      	ldr	r3, [r7, #4]
 8005086:	2b00      	cmp	r3, #0
 8005088:	d101      	bne.n	800508e <lv_img_src_get_type+0x16>
 800508a:	7bfb      	ldrb	r3, [r7, #15]
 800508c:	e018      	b.n	80050c0 <lv_img_src_get_type+0x48>
    const uint8_t * u8_p = src;
 800508e:	687b      	ldr	r3, [r7, #4]
 8005090:	60bb      	str	r3, [r7, #8]

    /*The first byte shows the type of the image source*/
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
 8005092:	68bb      	ldr	r3, [r7, #8]
 8005094:	781b      	ldrb	r3, [r3, #0]
 8005096:	2b1f      	cmp	r3, #31
 8005098:	d907      	bls.n	80050aa <lv_img_src_get_type+0x32>
 800509a:	68bb      	ldr	r3, [r7, #8]
 800509c:	781b      	ldrb	r3, [r3, #0]
 800509e:	b25b      	sxtb	r3, r3
 80050a0:	2b00      	cmp	r3, #0
 80050a2:	db02      	blt.n	80050aa <lv_img_src_get_type+0x32>
        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/
 80050a4:	2301      	movs	r3, #1
 80050a6:	73fb      	strb	r3, [r7, #15]
 80050a8:	e009      	b.n	80050be <lv_img_src_get_type+0x46>
    } else if(u8_p[0] >= 0x80) {
 80050aa:	68bb      	ldr	r3, [r7, #8]
 80050ac:	781b      	ldrb	r3, [r3, #0]
 80050ae:	b25b      	sxtb	r3, r3
 80050b0:	2b00      	cmp	r3, #0
 80050b2:	da02      	bge.n	80050ba <lv_img_src_get_type+0x42>
        img_src_type = LV_IMG_SRC_SYMBOL; /*Symbols begins after 0x7F*/
 80050b4:	2302      	movs	r3, #2
 80050b6:	73fb      	strb	r3, [r7, #15]
 80050b8:	e001      	b.n	80050be <lv_img_src_get_type+0x46>
    } else {
        img_src_type = LV_IMG_SRC_VARIABLE; /*`lv_img_dsc_t` is design to the first byte < 0x20*/
 80050ba:	2300      	movs	r3, #0
 80050bc:	73fb      	strb	r3, [r7, #15]

    if(LV_IMG_SRC_UNKNOWN == img_src_type) {
        LV_LOG_WARN("lv_img_src_get_type: unknown image type");
    }

    return img_src_type;
 80050be:	7bfb      	ldrb	r3, [r7, #15]
}
 80050c0:	4618      	mov	r0, r3
 80050c2:	3714      	adds	r7, #20
 80050c4:	46bd      	mov	sp, r7
 80050c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80050ca:	4770      	bx	lr

080050cc <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
 80050cc:	b480      	push	{r7}
 80050ce:	b083      	sub	sp, #12
 80050d0:	af00      	add	r7, sp, #0
 80050d2:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 80050d4:	687b      	ldr	r3, [r7, #4]
 80050d6:	7a1b      	ldrb	r3, [r3, #8]
}
 80050d8:	4618      	mov	r0, r3
 80050da:	370c      	adds	r7, #12
 80050dc:	46bd      	mov	sp, r7
 80050de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80050e2:	4770      	bx	lr

080050e4 <lv_color_make>:
#elif LV_COLOR_DEPTH == 32
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8, g8, r8, 0xff}}) /*Fix 0xff alpha*/
#endif

static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
 80050e4:	b490      	push	{r4, r7}
 80050e6:	b082      	sub	sp, #8
 80050e8:	af00      	add	r7, sp, #0
 80050ea:	4604      	mov	r4, r0
 80050ec:	4608      	mov	r0, r1
 80050ee:	4611      	mov	r1, r2
 80050f0:	4622      	mov	r2, r4
 80050f2:	71fa      	strb	r2, [r7, #7]
 80050f4:	4602      	mov	r2, r0
 80050f6:	71ba      	strb	r2, [r7, #6]
 80050f8:	460a      	mov	r2, r1
 80050fa:	717a      	strb	r2, [r7, #5]
    return LV_COLOR_MAKE(r, g, b);
 80050fc:	797a      	ldrb	r2, [r7, #5]
 80050fe:	08d2      	lsrs	r2, r2, #3
 8005100:	b2d2      	uxtb	r2, r2
 8005102:	f002 021f 	and.w	r2, r2, #31
 8005106:	b2d0      	uxtb	r0, r2
 8005108:	79ba      	ldrb	r2, [r7, #6]
 800510a:	0892      	lsrs	r2, r2, #2
 800510c:	b2d2      	uxtb	r2, r2
 800510e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8005112:	b2d1      	uxtb	r1, r2
 8005114:	79fa      	ldrb	r2, [r7, #7]
 8005116:	08d2      	lsrs	r2, r2, #3
 8005118:	b2d2      	uxtb	r2, r2
 800511a:	f002 021f 	and.w	r2, r2, #31
 800511e:	b2d2      	uxtb	r2, r2
 8005120:	f360 0304 	bfi	r3, r0, #0, #5
 8005124:	f361 134a 	bfi	r3, r1, #5, #6
 8005128:	f362 23cf 	bfi	r3, r2, #11, #5
}
 800512c:	4618      	mov	r0, r3
 800512e:	3708      	adds	r7, #8
 8005130:	46bd      	mov	sp, r7
 8005132:	bc90      	pop	{r4, r7}
 8005134:	4770      	bx	lr

08005136 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 8005136:	b480      	push	{r7}
 8005138:	b083      	sub	sp, #12
 800513a:	af00      	add	r7, sp, #0
 800513c:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 800513e:	687b      	ldr	r3, [r7, #4]
 8005140:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8005144:	b29a      	uxth	r2, r3
 8005146:	687b      	ldr	r3, [r7, #4]
 8005148:	f9b3 3000 	ldrsh.w	r3, [r3]
 800514c:	b29b      	uxth	r3, r3
 800514e:	1ad3      	subs	r3, r2, r3
 8005150:	b29b      	uxth	r3, r3
 8005152:	3301      	adds	r3, #1
 8005154:	b29b      	uxth	r3, r3
 8005156:	b21b      	sxth	r3, r3
}
 8005158:	4618      	mov	r0, r3
 800515a:	370c      	adds	r7, #12
 800515c:	46bd      	mov	sp, r7
 800515e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005162:	4770      	bx	lr

08005164 <lv_draw_label>:
 * @param sel make the text selected in the range by drawing a background there
 */
void lv_draw_label(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style, lv_opa_t opa_scale,
                   const char * txt, lv_txt_flag_t flag, lv_point_t * offset, lv_draw_label_txt_sel_t * sel,
                   lv_draw_label_hint_t * hint, lv_bidi_dir_t bidi_dir)
{
 8005164:	b590      	push	{r4, r7, lr}
 8005166:	b0b5      	sub	sp, #212	; 0xd4
 8005168:	af04      	add	r7, sp, #16
 800516a:	60f8      	str	r0, [r7, #12]
 800516c:	60b9      	str	r1, [r7, #8]
 800516e:	607a      	str	r2, [r7, #4]
 8005170:	70fb      	strb	r3, [r7, #3]
    const lv_font_t * font = style->text.font;
 8005172:	687b      	ldr	r3, [r7, #4]
 8005174:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005176:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    lv_coord_t w;

    /*No need to waste processor time if string is empty*/
    if (txt[0] == '\0')  return;
 800517a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800517e:	781b      	ldrb	r3, [r3, #0]
 8005180:	2b00      	cmp	r3, #0
 8005182:	f000 83dd 	beq.w	8005940 <lv_draw_label+0x7dc>

    if((flag & LV_TXT_FLAG_EXPAND) == 0) {
 8005186:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 800518a:	f003 0302 	and.w	r3, r3, #2
 800518e:	2b00      	cmp	r3, #0
 8005190:	d106      	bne.n	80051a0 <lv_draw_label+0x3c>
        /*Normally use the label's width as width*/
        w = lv_area_get_width(coords);
 8005192:	68f8      	ldr	r0, [r7, #12]
 8005194:	f7ff ffcf 	bl	8005136 <lv_area_get_width>
 8005198:	4603      	mov	r3, r0
 800519a:	f8a7 30be 	strh.w	r3, [r7, #190]	; 0xbe
 800519e:	e019      	b.n	80051d4 <lv_draw_label+0x70>
    } else {
        /*If EXAPND is enabled then not limit the text's width to the object's width*/
        lv_point_t p;
        lv_txt_get_size(&p, txt, style->text.font, style->text.letter_space, style->text.line_space, LV_COORD_MAX,
 80051a0:	687b      	ldr	r3, [r7, #4]
 80051a2:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80051a4:	687b      	ldr	r3, [r7, #4]
 80051a6:	f9b3 4028 	ldrsh.w	r4, [r3, #40]	; 0x28
 80051aa:	687b      	ldr	r3, [r7, #4]
 80051ac:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 80051b0:	f107 0028 	add.w	r0, r7, #40	; 0x28
 80051b4:	f897 20d4 	ldrb.w	r2, [r7, #212]	; 0xd4
 80051b8:	9202      	str	r2, [sp, #8]
 80051ba:	f647 4218 	movw	r2, #31768	; 0x7c18
 80051be:	9201      	str	r2, [sp, #4]
 80051c0:	9300      	str	r3, [sp, #0]
 80051c2:	4623      	mov	r3, r4
 80051c4:	460a      	mov	r2, r1
 80051c6:	f8d7 10d0 	ldr.w	r1, [r7, #208]	; 0xd0
 80051ca:	f008 f983 	bl	800d4d4 <lv_txt_get_size>
                flag);
        w = p.x;
 80051ce:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80051d0:	f8a7 30be 	strh.w	r3, [r7, #190]	; 0xbe
    }

    lv_coord_t line_height = lv_font_get_line_height(font) + style->text.line_space;
 80051d4:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 80051d8:	f7ff ff78 	bl	80050cc <lv_font_get_line_height>
 80051dc:	4603      	mov	r3, r0
 80051de:	b29a      	uxth	r2, r3
 80051e0:	687b      	ldr	r3, [r7, #4]
 80051e2:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 80051e6:	b29b      	uxth	r3, r3
 80051e8:	4413      	add	r3, r2
 80051ea:	b29b      	uxth	r3, r3
 80051ec:	f8a7 309a 	strh.w	r3, [r7, #154]	; 0x9a

    /*Init variables for the first line*/
    lv_coord_t line_width = 0;
 80051f0:	2300      	movs	r3, #0
 80051f2:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98
    lv_point_t pos;
    pos.x = coords->x1;
 80051f6:	68fb      	ldr	r3, [r7, #12]
 80051f8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80051fc:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
    pos.y = coords->y1;
 8005200:	68fb      	ldr	r3, [r7, #12]
 8005202:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005206:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

    lv_coord_t x_ofs = 0;
 800520a:	2300      	movs	r3, #0
 800520c:	f8a7 30bc 	strh.w	r3, [r7, #188]	; 0xbc
    lv_coord_t y_ofs = 0;
 8005210:	2300      	movs	r3, #0
 8005212:	f8a7 30ba 	strh.w	r3, [r7, #186]	; 0xba
    if(offset != NULL) {
 8005216:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800521a:	2b00      	cmp	r3, #0
 800521c:	d013      	beq.n	8005246 <lv_draw_label+0xe2>
        x_ofs = offset->x;
 800521e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8005222:	881b      	ldrh	r3, [r3, #0]
 8005224:	f8a7 30bc 	strh.w	r3, [r7, #188]	; 0xbc
        y_ofs = offset->y;
 8005228:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800522c:	885b      	ldrh	r3, [r3, #2]
 800522e:	f8a7 30ba 	strh.w	r3, [r7, #186]	; 0xba
        pos.y += y_ofs;
 8005232:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8005236:	b29a      	uxth	r2, r3
 8005238:	f8b7 30ba 	ldrh.w	r3, [r7, #186]	; 0xba
 800523c:	4413      	add	r3, r2
 800523e:	b29b      	uxth	r3, r3
 8005240:	b21b      	sxth	r3, r3
 8005242:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
    }

    uint32_t line_start     = 0;
 8005246:	2300      	movs	r3, #0
 8005248:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    int32_t last_line_start = -1;
 800524c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8005250:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

    /*Check the hint to use the cached info*/
    if(hint && y_ofs == 0 && coords->y1 < 0) {
 8005254:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8005258:	2b00      	cmp	r3, #0
 800525a:	d024      	beq.n	80052a6 <lv_draw_label+0x142>
 800525c:	f9b7 30ba 	ldrsh.w	r3, [r7, #186]	; 0xba
 8005260:	2b00      	cmp	r3, #0
 8005262:	d120      	bne.n	80052a6 <lv_draw_label+0x142>
 8005264:	68fb      	ldr	r3, [r7, #12]
 8005266:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800526a:	2b00      	cmp	r3, #0
 800526c:	da1b      	bge.n	80052a6 <lv_draw_label+0x142>
        /*If the label changed too much recalculate the hint.*/
        if(LV_MATH_ABS(hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {
 800526e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8005272:	689b      	ldr	r3, [r3, #8]
 8005274:	68fa      	ldr	r2, [r7, #12]
 8005276:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 800527a:	1a9b      	subs	r3, r3, r2
 800527c:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8005280:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 8005284:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 8005288:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
 800528c:	005b      	lsls	r3, r3, #1
 800528e:	429a      	cmp	r2, r3
 8005290:	dd04      	ble.n	800529c <lv_draw_label+0x138>
            hint->line_start = -1;
 8005292:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8005296:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800529a:	601a      	str	r2, [r3, #0]
        }
        last_line_start = hint->line_start;
 800529c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80052a0:	681b      	ldr	r3, [r3, #0]
 80052a2:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    }

    /*Use the hint if it's valid*/
    if(hint && last_line_start >= 0) {
 80052a6:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80052aa:	2b00      	cmp	r3, #0
 80052ac:	d013      	beq.n	80052d6 <lv_draw_label+0x172>
 80052ae:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80052b2:	2b00      	cmp	r3, #0
 80052b4:	db0f      	blt.n	80052d6 <lv_draw_label+0x172>
        line_start = last_line_start;
 80052b6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80052ba:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
        pos.y += hint->y;
 80052be:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 80052c2:	b29a      	uxth	r2, r3
 80052c4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80052c8:	685b      	ldr	r3, [r3, #4]
 80052ca:	b29b      	uxth	r3, r3
 80052cc:	4413      	add	r3, r2
 80052ce:	b29b      	uxth	r3, r3
 80052d0:	b21b      	sxth	r3, r3
 80052d2:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
    }


    uint32_t line_end = line_start + lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
 80052d6:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 80052da:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80052de:	18d0      	adds	r0, r2, r3
 80052e0:	687b      	ldr	r3, [r7, #4]
 80052e2:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 80052e6:	f9b7 10be 	ldrsh.w	r1, [r7, #190]	; 0xbe
 80052ea:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 80052ee:	9300      	str	r3, [sp, #0]
 80052f0:	460b      	mov	r3, r1
 80052f2:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
 80052f6:	f008 fabd 	bl	800d874 <lv_txt_get_next_line>
 80052fa:	4603      	mov	r3, r0
 80052fc:	461a      	mov	r2, r3
 80052fe:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8005302:	4413      	add	r3, r2
 8005304:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

    /*Go the first visible line*/
    while(pos.y + line_height < mask->y1) {
 8005308:	e053      	b.n	80053b2 <lv_draw_label+0x24e>
        /*Go to next line*/
        line_start = line_end;
 800530a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800530e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
 8005312:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8005316:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800531a:	18d0      	adds	r0, r2, r3
 800531c:	687b      	ldr	r3, [r7, #4]
 800531e:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8005322:	f9b7 10be 	ldrsh.w	r1, [r7, #190]	; 0xbe
 8005326:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 800532a:	9300      	str	r3, [sp, #0]
 800532c:	460b      	mov	r3, r1
 800532e:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
 8005332:	f008 fa9f 	bl	800d874 <lv_txt_get_next_line>
 8005336:	4603      	mov	r3, r0
 8005338:	461a      	mov	r2, r3
 800533a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800533e:	4413      	add	r3, r2
 8005340:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
        pos.y += line_height;
 8005344:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8005348:	b29a      	uxth	r2, r3
 800534a:	f8b7 309a 	ldrh.w	r3, [r7, #154]	; 0x9a
 800534e:	4413      	add	r3, r2
 8005350:	b29b      	uxth	r3, r3
 8005352:	b21b      	sxth	r3, r3
 8005354:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

        /*Save at the threshold coordinate*/
        if(hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && hint->line_start < 0) {
 8005358:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800535c:	2b00      	cmp	r3, #0
 800535e:	d01f      	beq.n	80053a0 <lv_draw_label+0x23c>
 8005360:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8005364:	f513 6f80 	cmn.w	r3, #1024	; 0x400
 8005368:	db1a      	blt.n	80053a0 <lv_draw_label+0x23c>
 800536a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800536e:	681b      	ldr	r3, [r3, #0]
 8005370:	2b00      	cmp	r3, #0
 8005372:	da15      	bge.n	80053a0 <lv_draw_label+0x23c>
            hint->line_start = line_start;
 8005374:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8005378:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800537c:	601a      	str	r2, [r3, #0]
            hint->y          = pos.y - coords->y1;
 800537e:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8005382:	461a      	mov	r2, r3
 8005384:	68fb      	ldr	r3, [r7, #12]
 8005386:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800538a:	1ad2      	subs	r2, r2, r3
 800538c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8005390:	605a      	str	r2, [r3, #4]
            hint->coord_y    = coords->y1;
 8005392:	68fb      	ldr	r3, [r7, #12]
 8005394:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005398:	461a      	mov	r2, r3
 800539a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800539e:	609a      	str	r2, [r3, #8]
        }

        if(txt[line_start] == '\0') return;
 80053a0:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 80053a4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80053a8:	4413      	add	r3, r2
 80053aa:	781b      	ldrb	r3, [r3, #0]
 80053ac:	2b00      	cmp	r3, #0
 80053ae:	f000 82c9 	beq.w	8005944 <lv_draw_label+0x7e0>
    while(pos.y + line_height < mask->y1) {
 80053b2:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 80053b6:	461a      	mov	r2, r3
 80053b8:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 80053bc:	4413      	add	r3, r2
 80053be:	68ba      	ldr	r2, [r7, #8]
 80053c0:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 80053c4:	4293      	cmp	r3, r2
 80053c6:	dba0      	blt.n	800530a <lv_draw_label+0x1a6>
    }

    /*Align to middle*/
    if(flag & LV_TXT_FLAG_CENTER) {
 80053c8:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 80053cc:	f003 0304 	and.w	r3, r3, #4
 80053d0:	2b00      	cmp	r3, #0
 80053d2:	d030      	beq.n	8005436 <lv_draw_label+0x2d2>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 80053d4:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 80053d8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80053dc:	18d0      	adds	r0, r2, r3
 80053de:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80053e2:	b29a      	uxth	r2, r3
 80053e4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80053e8:	b29b      	uxth	r3, r3
 80053ea:	1ad3      	subs	r3, r2, r3
 80053ec:	b299      	uxth	r1, r3
 80053ee:	687b      	ldr	r3, [r7, #4]
 80053f0:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 80053f4:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 80053f8:	9300      	str	r3, [sp, #0]
 80053fa:	4613      	mov	r3, r2
 80053fc:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8005400:	f008 faca 	bl	800d998 <lv_txt_get_width>
 8005404:	4603      	mov	r3, r0
 8005406:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98

        pos.x += (lv_area_get_width(coords) - line_width) / 2;
 800540a:	68f8      	ldr	r0, [r7, #12]
 800540c:	f7ff fe93 	bl	8005136 <lv_area_get_width>
 8005410:	4603      	mov	r3, r0
 8005412:	461a      	mov	r2, r3
 8005414:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
 8005418:	1ad3      	subs	r3, r2, r3
 800541a:	0fda      	lsrs	r2, r3, #31
 800541c:	4413      	add	r3, r2
 800541e:	105b      	asrs	r3, r3, #1
 8005420:	4619      	mov	r1, r3
 8005422:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8005426:	b29a      	uxth	r2, r3
 8005428:	b28b      	uxth	r3, r1
 800542a:	4413      	add	r3, r2
 800542c:	b29b      	uxth	r3, r3
 800542e:	b21b      	sxth	r3, r3
 8005430:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
 8005434:	e031      	b.n	800549a <lv_draw_label+0x336>

    }
    /*Align to the right*/
    else if(flag & LV_TXT_FLAG_RIGHT) {
 8005436:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 800543a:	f003 0308 	and.w	r3, r3, #8
 800543e:	2b00      	cmp	r3, #0
 8005440:	d02b      	beq.n	800549a <lv_draw_label+0x336>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 8005442:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8005446:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800544a:	18d0      	adds	r0, r2, r3
 800544c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8005450:	b29a      	uxth	r2, r3
 8005452:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8005456:	b29b      	uxth	r3, r3
 8005458:	1ad3      	subs	r3, r2, r3
 800545a:	b299      	uxth	r1, r3
 800545c:	687b      	ldr	r3, [r7, #4]
 800545e:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8005462:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 8005466:	9300      	str	r3, [sp, #0]
 8005468:	4613      	mov	r3, r2
 800546a:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 800546e:	f008 fa93 	bl	800d998 <lv_txt_get_width>
 8005472:	4603      	mov	r3, r0
 8005474:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98
        pos.x += lv_area_get_width(coords) - line_width;
 8005478:	68f8      	ldr	r0, [r7, #12]
 800547a:	f7ff fe5c 	bl	8005136 <lv_area_get_width>
 800547e:	4603      	mov	r3, r0
 8005480:	461a      	mov	r2, r3
 8005482:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
 8005486:	1ad3      	subs	r3, r2, r3
 8005488:	f9b7 2074 	ldrsh.w	r2, [r7, #116]	; 0x74
 800548c:	b292      	uxth	r2, r2
 800548e:	b29b      	uxth	r3, r3
 8005490:	4413      	add	r3, r2
 8005492:	b29b      	uxth	r3, r3
 8005494:	b21b      	sxth	r3, r3
 8005496:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
    }

    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->text.opa : (uint16_t)((uint16_t)style->text.opa * opa_scale) >> 8;
 800549a:	78fb      	ldrb	r3, [r7, #3]
 800549c:	2bff      	cmp	r3, #255	; 0xff
 800549e:	d103      	bne.n	80054a8 <lv_draw_label+0x344>
 80054a0:	687b      	ldr	r3, [r7, #4]
 80054a2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80054a6:	e00b      	b.n	80054c0 <lv_draw_label+0x35c>
 80054a8:	687b      	ldr	r3, [r7, #4]
 80054aa:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80054ae:	b29a      	uxth	r2, r3
 80054b0:	78fb      	ldrb	r3, [r7, #3]
 80054b2:	b29b      	uxth	r3, r3
 80054b4:	fb12 f303 	smulbb	r3, r2, r3
 80054b8:	b29b      	uxth	r3, r3
 80054ba:	0a1b      	lsrs	r3, r3, #8
 80054bc:	b29b      	uxth	r3, r3
 80054be:	b2db      	uxtb	r3, r3
 80054c0:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97

    uint16_t sel_start = 0xFFFF;
 80054c4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80054c8:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
    uint16_t sel_end = 0xFFFF;
 80054cc:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80054d0:	f8a7 30a8 	strh.w	r3, [r7, #168]	; 0xa8
    if(sel) {
 80054d4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80054d8:	2b00      	cmp	r3, #0
 80054da:	d01b      	beq.n	8005514 <lv_draw_label+0x3b0>
        sel_start = sel->start;
 80054dc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80054e0:	881b      	ldrh	r3, [r3, #0]
 80054e2:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
        sel_end = sel->end;
 80054e6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80054ea:	885b      	ldrh	r3, [r3, #2]
 80054ec:	f8a7 30a8 	strh.w	r3, [r7, #168]	; 0xa8
        if(sel_start > sel_end) {
 80054f0:	f8b7 20aa 	ldrh.w	r2, [r7, #170]	; 0xaa
 80054f4:	f8b7 30a8 	ldrh.w	r3, [r7, #168]	; 0xa8
 80054f8:	429a      	cmp	r2, r3
 80054fa:	d90b      	bls.n	8005514 <lv_draw_label+0x3b0>
            uint16_t tmp = sel_start;
 80054fc:	f8b7 30aa 	ldrh.w	r3, [r7, #170]	; 0xaa
 8005500:	f8a7 3094 	strh.w	r3, [r7, #148]	; 0x94
            sel_start = sel_end;
 8005504:	f8b7 30a8 	ldrh.w	r3, [r7, #168]	; 0xa8
 8005508:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
            sel_end = tmp;
 800550c:	f8b7 3094 	ldrh.w	r3, [r7, #148]	; 0x94
 8005510:	f8a7 30a8 	strh.w	r3, [r7, #168]	; 0xa8
        }
    }

    cmd_state_t cmd_state = CMD_STATE_WAIT;
 8005514:	2300      	movs	r3, #0
 8005516:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
    uint32_t i;
    uint16_t par_start = 0;
 800551a:	2300      	movs	r3, #0
 800551c:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
    lv_color_t recolor;
    lv_coord_t letter_w;
    lv_style_t sel_style;
    lv_style_copy(&sel_style, &lv_style_plain_color);
 8005520:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8005524:	49ab      	ldr	r1, [pc, #684]	; (80057d4 <lv_draw_label+0x670>)
 8005526:	4618      	mov	r0, r3
 8005528:	f7fe fc86 	bl	8003e38 <lv_style_copy>
    sel_style.body.main_color = sel_style.body.grad_color = style->text.sel_color;
 800552c:	687b      	ldr	r3, [r7, #4]
 800552e:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8005530:	863b      	strh	r3, [r7, #48]	; 0x30
 8005532:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8005534:	85fb      	strh	r3, [r7, #46]	; 0x2e

    /*Write out all lines*/
    while(txt[line_start] != '\0') {
 8005536:	e1f9      	b.n	800592c <lv_draw_label+0x7c8>
        if(offset != NULL) {
 8005538:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800553c:	2b00      	cmp	r3, #0
 800553e:	d009      	beq.n	8005554 <lv_draw_label+0x3f0>
            pos.x += x_ofs;
 8005540:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8005544:	b29a      	uxth	r2, r3
 8005546:	f8b7 30bc 	ldrh.w	r3, [r7, #188]	; 0xbc
 800554a:	4413      	add	r3, r2
 800554c:	b29b      	uxth	r3, r3
 800554e:	b21b      	sxth	r3, r3
 8005550:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
        }
        /*Write all letter of a line*/
        cmd_state = CMD_STATE_WAIT;
 8005554:	2300      	movs	r3, #0
 8005556:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
        i         = 0;
 800555a:	2300      	movs	r3, #0
 800555c:	673b      	str	r3, [r7, #112]	; 0x70
#if LV_USE_BIDI
        char *bidi_txt = lv_draw_get_buf(line_end - line_start + 1);
        lv_bidi_process_paragraph(txt + line_start, bidi_txt, line_end - line_start, bidi_dir, NULL, 0);
#else
        (void)bidi_dir;
        const char *bidi_txt = txt + line_start;
 800555e:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8005562:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8005566:	4413      	add	r3, r2
 8005568:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
#endif

        while(i < line_end - line_start) {
 800556c:	e139      	b.n	80057e2 <lv_draw_label+0x67e>
            uint16_t logical_char_pos = 0;
 800556e:	2300      	movs	r3, #0
 8005570:	f8a7 30a2 	strh.w	r3, [r7, #162]	; 0xa2
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
 8005574:	f8b7 30aa 	ldrh.w	r3, [r7, #170]	; 0xaa
 8005578:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800557c:	4293      	cmp	r3, r2
 800557e:	d012      	beq.n	80055a6 <lv_draw_label+0x442>
 8005580:	f8b7 30a8 	ldrh.w	r3, [r7, #168]	; 0xa8
 8005584:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8005588:	4293      	cmp	r3, r2
 800558a:	d00c      	beq.n	80055a6 <lv_draw_label+0x442>
#if LV_USE_BIDI
                logical_char_pos = lv_txt_encoded_get_char_id(txt, line_start);
                uint16_t t = lv_txt_encoded_get_char_id(bidi_txt, i);
                logical_char_pos += lv_bidi_get_logical_pos(bidi_txt, NULL, line_end - line_start, bidi_dir, t, NULL);
#else
                logical_char_pos = lv_txt_encoded_get_char_id(txt, line_start + i);
 800558c:	4b92      	ldr	r3, [pc, #584]	; (80057d8 <lv_draw_label+0x674>)
 800558e:	681b      	ldr	r3, [r3, #0]
 8005590:	6f39      	ldr	r1, [r7, #112]	; 0x70
 8005592:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8005596:	440a      	add	r2, r1
 8005598:	4611      	mov	r1, r2
 800559a:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 800559e:	4798      	blx	r3
 80055a0:	4603      	mov	r3, r0
 80055a2:	f8a7 30a2 	strh.w	r3, [r7, #162]	; 0xa2
#endif
            }

            letter      = lv_txt_encoded_next(bidi_txt, &i);
 80055a6:	4b8d      	ldr	r3, [pc, #564]	; (80057dc <lv_draw_label+0x678>)
 80055a8:	681b      	ldr	r3, [r3, #0]
 80055aa:	f107 0270 	add.w	r2, r7, #112	; 0x70
 80055ae:	4611      	mov	r1, r2
 80055b0:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 80055b4:	4798      	blx	r3
 80055b6:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
 80055ba:	4b88      	ldr	r3, [pc, #544]	; (80057dc <lv_draw_label+0x678>)
 80055bc:	681b      	ldr	r3, [r3, #0]
 80055be:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80055c0:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
 80055c4:	440a      	add	r2, r1
 80055c6:	2100      	movs	r1, #0
 80055c8:	4610      	mov	r0, r2
 80055ca:	4798      	blx	r3
 80055cc:	f8c7 0088 	str.w	r0, [r7, #136]	; 0x88


            /*Handle the re-color command*/
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 80055d0:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 80055d4:	f003 0301 	and.w	r3, r3, #1
 80055d8:	2b00      	cmp	r3, #0
 80055da:	d07f      	beq.n	80056dc <lv_draw_label+0x578>
                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {
 80055dc:	2323      	movs	r3, #35	; 0x23
 80055de:	461a      	mov	r2, r3
 80055e0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80055e4:	4293      	cmp	r3, r2
 80055e6:	d11a      	bne.n	800561e <lv_draw_label+0x4ba>
                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/
 80055e8:	f897 30a7 	ldrb.w	r3, [r7, #167]	; 0xa7
 80055ec:	2b00      	cmp	r3, #0
 80055ee:	d106      	bne.n	80055fe <lv_draw_label+0x49a>
                        par_start = i;
 80055f0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80055f2:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
                        cmd_state = CMD_STATE_PAR;
 80055f6:	2301      	movs	r3, #1
 80055f8:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
                        continue;
 80055fc:	e0f1      	b.n	80057e2 <lv_draw_label+0x67e>
                    } else if(cmd_state == CMD_STATE_PAR) { /*Other start char in parameter escaped cmd. char */
 80055fe:	f897 30a7 	ldrb.w	r3, [r7, #167]	; 0xa7
 8005602:	2b01      	cmp	r3, #1
 8005604:	d103      	bne.n	800560e <lv_draw_label+0x4aa>
                        cmd_state = CMD_STATE_WAIT;
 8005606:	2300      	movs	r3, #0
 8005608:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
 800560c:	e007      	b.n	800561e <lv_draw_label+0x4ba>
                    } else if(cmd_state == CMD_STATE_IN) { /*Command end */
 800560e:	f897 30a7 	ldrb.w	r3, [r7, #167]	; 0xa7
 8005612:	2b02      	cmp	r3, #2
 8005614:	d103      	bne.n	800561e <lv_draw_label+0x4ba>
                        cmd_state = CMD_STATE_WAIT;
 8005616:	2300      	movs	r3, #0
 8005618:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
                        continue;
 800561c:	e0e1      	b.n	80057e2 <lv_draw_label+0x67e>
                    }
                }

                /*Skip the color parameter and wait the space after it*/
                if(cmd_state == CMD_STATE_PAR) {
 800561e:	f897 30a7 	ldrb.w	r3, [r7, #167]	; 0xa7
 8005622:	2b01      	cmp	r3, #1
 8005624:	d15a      	bne.n	80056dc <lv_draw_label+0x578>
                    if(letter == ' ') {
 8005626:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800562a:	2b20      	cmp	r3, #32
 800562c:	f040 80d8 	bne.w	80057e0 <lv_draw_label+0x67c>
                        /*Get the parameter*/
                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {
 8005630:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8005632:	f8b7 30a4 	ldrh.w	r3, [r7, #164]	; 0xa4
 8005636:	1ad3      	subs	r3, r2, r3
 8005638:	2b07      	cmp	r3, #7
 800563a:	d147      	bne.n	80056cc <lv_draw_label+0x568>
                            char buf[LABEL_RECOLOR_PAR_LENGTH + 1];
                            memcpy(buf, &bidi_txt[par_start], LABEL_RECOLOR_PAR_LENGTH);
 800563c:	f8b7 30a4 	ldrh.w	r3, [r7, #164]	; 0xa4
 8005640:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8005644:	18d1      	adds	r1, r2, r3
 8005646:	f107 031c 	add.w	r3, r7, #28
 800564a:	2206      	movs	r2, #6
 800564c:	4618      	mov	r0, r3
 800564e:	f00e f87b 	bl	8013748 <memcpy>
                            buf[LABEL_RECOLOR_PAR_LENGTH] = '\0';
 8005652:	2300      	movs	r3, #0
 8005654:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
                            int r, g, b;
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
 8005658:	7f3b      	ldrb	r3, [r7, #28]
 800565a:	4618      	mov	r0, r3
 800565c:	f000 f978 	bl	8005950 <hex_char_to_num>
 8005660:	4603      	mov	r3, r0
 8005662:	011c      	lsls	r4, r3, #4
 8005664:	7f7b      	ldrb	r3, [r7, #29]
 8005666:	4618      	mov	r0, r3
 8005668:	f000 f972 	bl	8005950 <hex_char_to_num>
 800566c:	4603      	mov	r3, r0
 800566e:	4423      	add	r3, r4
 8005670:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
 8005674:	7fbb      	ldrb	r3, [r7, #30]
 8005676:	4618      	mov	r0, r3
 8005678:	f000 f96a 	bl	8005950 <hex_char_to_num>
 800567c:	4603      	mov	r3, r0
 800567e:	011c      	lsls	r4, r3, #4
 8005680:	7ffb      	ldrb	r3, [r7, #31]
 8005682:	4618      	mov	r0, r3
 8005684:	f000 f964 	bl	8005950 <hex_char_to_num>
 8005688:	4603      	mov	r3, r0
 800568a:	4423      	add	r3, r4
 800568c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);
 8005690:	f897 3020 	ldrb.w	r3, [r7, #32]
 8005694:	4618      	mov	r0, r3
 8005696:	f000 f95b 	bl	8005950 <hex_char_to_num>
 800569a:	4603      	mov	r3, r0
 800569c:	011c      	lsls	r4, r3, #4
 800569e:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80056a2:	4618      	mov	r0, r3
 80056a4:	f000 f954 	bl	8005950 <hex_char_to_num>
 80056a8:	4603      	mov	r3, r0
 80056aa:	4423      	add	r3, r4
 80056ac:	67fb      	str	r3, [r7, #124]	; 0x7c
                            recolor = lv_color_make(r, g, b);
 80056ae:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80056b2:	b2db      	uxtb	r3, r3
 80056b4:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 80056b8:	b2d1      	uxtb	r1, r2
 80056ba:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80056bc:	b2d2      	uxtb	r2, r2
 80056be:	4618      	mov	r0, r3
 80056c0:	f7ff fd10 	bl	80050e4 <lv_color_make>
 80056c4:	4603      	mov	r3, r0
 80056c6:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
 80056ca:	e003      	b.n	80056d4 <lv_draw_label+0x570>
                        } else {
                            recolor.full = style->text.color.full;
 80056cc:	687b      	ldr	r3, [r7, #4]
 80056ce:	8c1b      	ldrh	r3, [r3, #32]
 80056d0:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
                        }
                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/
 80056d4:	2302      	movs	r3, #2
 80056d6:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
                    }
                    continue;
 80056da:	e081      	b.n	80057e0 <lv_draw_label+0x67c>
                }
            }

            lv_color_t color = style->text.color;
 80056dc:	687b      	ldr	r3, [r7, #4]
 80056de:	8c1b      	ldrh	r3, [r3, #32]
 80056e0:	84bb      	strh	r3, [r7, #36]	; 0x24

            if(cmd_state == CMD_STATE_IN) color = recolor;
 80056e2:	f897 30a7 	ldrb.w	r3, [r7, #167]	; 0xa7
 80056e6:	2b02      	cmp	r3, #2
 80056e8:	d102      	bne.n	80056f0 <lv_draw_label+0x58c>
 80056ea:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 80056ee:	84bb      	strh	r3, [r7, #36]	; 0x24

            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
 80056f0:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 80056f4:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 80056f8:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 80056fc:	f005 fa6a 	bl	800abd4 <lv_font_get_glyph_width>
 8005700:	4603      	mov	r3, r0
 8005702:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a

            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
 8005706:	f8b7 30aa 	ldrh.w	r3, [r7, #170]	; 0xaa
 800570a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800570e:	4293      	cmp	r3, r2
 8005710:	d03c      	beq.n	800578c <lv_draw_label+0x628>
 8005712:	f8b7 30a8 	ldrh.w	r3, [r7, #168]	; 0xa8
 8005716:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800571a:	4293      	cmp	r3, r2
 800571c:	d036      	beq.n	800578c <lv_draw_label+0x628>
                if(logical_char_pos >= sel_start && logical_char_pos < sel_end) {
 800571e:	f8b7 20a2 	ldrh.w	r2, [r7, #162]	; 0xa2
 8005722:	f8b7 30aa 	ldrh.w	r3, [r7, #170]	; 0xaa
 8005726:	429a      	cmp	r2, r3
 8005728:	d330      	bcc.n	800578c <lv_draw_label+0x628>
 800572a:	f8b7 20a2 	ldrh.w	r2, [r7, #162]	; 0xa2
 800572e:	f8b7 30a8 	ldrh.w	r3, [r7, #168]	; 0xa8
 8005732:	429a      	cmp	r2, r3
 8005734:	d22a      	bcs.n	800578c <lv_draw_label+0x628>
                    lv_area_t sel_coords;
                    sel_coords.x1 = pos.x;
 8005736:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 800573a:	82bb      	strh	r3, [r7, #20]
                    sel_coords.y1 = pos.y;
 800573c:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8005740:	82fb      	strh	r3, [r7, #22]
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
 8005742:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8005746:	b29a      	uxth	r2, r3
 8005748:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 800574c:	4413      	add	r3, r2
 800574e:	b29a      	uxth	r2, r3
 8005750:	687b      	ldr	r3, [r7, #4]
 8005752:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8005756:	b29b      	uxth	r3, r3
 8005758:	4413      	add	r3, r2
 800575a:	b29b      	uxth	r3, r3
 800575c:	3b01      	subs	r3, #1
 800575e:	b29b      	uxth	r3, r3
 8005760:	b21b      	sxth	r3, r3
 8005762:	833b      	strh	r3, [r7, #24]
                    sel_coords.y2 = pos.y + line_height - 1;
 8005764:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8005768:	b29a      	uxth	r2, r3
 800576a:	f8b7 309a 	ldrh.w	r3, [r7, #154]	; 0x9a
 800576e:	4413      	add	r3, r2
 8005770:	b29b      	uxth	r3, r3
 8005772:	3b01      	subs	r3, #1
 8005774:	b29b      	uxth	r3, r3
 8005776:	b21b      	sxth	r3, r3
 8005778:	837b      	strh	r3, [r7, #26]
                    lv_draw_rect(&sel_coords, mask, &sel_style, opa);
 800577a:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 800577e:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 8005782:	f107 0014 	add.w	r0, r7, #20
 8005786:	68b9      	ldr	r1, [r7, #8]
 8005788:	f000 f9d5 	bl	8005b36 <lv_draw_rect>
                }
            }

            lv_draw_letter(&pos, mask, font, letter, color, opa);
 800578c:	f107 0074 	add.w	r0, r7, #116	; 0x74
 8005790:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 8005794:	9301      	str	r3, [sp, #4]
 8005796:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8005798:	f8ad 3000 	strh.w	r3, [sp]
 800579c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80057a0:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 80057a4:	68b9      	ldr	r1, [r7, #8]
 80057a6:	f7fe fe89 	bl	80044bc <lv_draw_letter>

            if(letter_w > 0) {
 80057aa:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 80057ae:	2b00      	cmp	r3, #0
 80057b0:	dd17      	ble.n	80057e2 <lv_draw_label+0x67e>
                pos.x += letter_w + style->text.letter_space;
 80057b2:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80057b6:	b29a      	uxth	r2, r3
 80057b8:	687b      	ldr	r3, [r7, #4]
 80057ba:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 80057be:	b299      	uxth	r1, r3
 80057c0:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 80057c4:	440b      	add	r3, r1
 80057c6:	b29b      	uxth	r3, r3
 80057c8:	4413      	add	r3, r2
 80057ca:	b29b      	uxth	r3, r3
 80057cc:	b21b      	sxth	r3, r3
 80057ce:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
 80057d2:	e006      	b.n	80057e2 <lv_draw_label+0x67e>
 80057d4:	20009900 	.word	0x20009900
 80057d8:	20000060 	.word	0x20000060
 80057dc:	20000054 	.word	0x20000054
                    continue;
 80057e0:	bf00      	nop
        while(i < line_end - line_start) {
 80057e2:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 80057e6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80057ea:	1ad2      	subs	r2, r2, r3
 80057ec:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80057ee:	429a      	cmp	r2, r3
 80057f0:	f63f aebd 	bhi.w	800556e <lv_draw_label+0x40a>
            }
        }
        /*Go to next line*/
        line_start = line_end;
 80057f4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80057f8:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
 80057fc:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8005800:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8005804:	18d0      	adds	r0, r2, r3
 8005806:	687b      	ldr	r3, [r7, #4]
 8005808:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 800580c:	f9b7 10be 	ldrsh.w	r1, [r7, #190]	; 0xbe
 8005810:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 8005814:	9300      	str	r3, [sp, #0]
 8005816:	460b      	mov	r3, r1
 8005818:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
 800581c:	f008 f82a 	bl	800d874 <lv_txt_get_next_line>
 8005820:	4603      	mov	r3, r0
 8005822:	461a      	mov	r2, r3
 8005824:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8005828:	4413      	add	r3, r2
 800582a:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

        pos.x = coords->x1;
 800582e:	68fb      	ldr	r3, [r7, #12]
 8005830:	f9b3 3000 	ldrsh.w	r3, [r3]
 8005834:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
        /*Align to middle*/
        if(flag & LV_TXT_FLAG_CENTER) {
 8005838:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 800583c:	f003 0304 	and.w	r3, r3, #4
 8005840:	2b00      	cmp	r3, #0
 8005842:	d030      	beq.n	80058a6 <lv_draw_label+0x742>
            line_width =
                    lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 8005844:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8005848:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800584c:	18d0      	adds	r0, r2, r3
 800584e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8005852:	b29a      	uxth	r2, r3
 8005854:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8005858:	b29b      	uxth	r3, r3
 800585a:	1ad3      	subs	r3, r2, r3
 800585c:	b299      	uxth	r1, r3
 800585e:	687b      	ldr	r3, [r7, #4]
 8005860:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
            line_width =
 8005864:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 8005868:	9300      	str	r3, [sp, #0]
 800586a:	4613      	mov	r3, r2
 800586c:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8005870:	f008 f892 	bl	800d998 <lv_txt_get_width>
 8005874:	4603      	mov	r3, r0
 8005876:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98

            pos.x += (lv_area_get_width(coords) - line_width) / 2;
 800587a:	68f8      	ldr	r0, [r7, #12]
 800587c:	f7ff fc5b 	bl	8005136 <lv_area_get_width>
 8005880:	4603      	mov	r3, r0
 8005882:	461a      	mov	r2, r3
 8005884:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
 8005888:	1ad3      	subs	r3, r2, r3
 800588a:	0fda      	lsrs	r2, r3, #31
 800588c:	4413      	add	r3, r2
 800588e:	105b      	asrs	r3, r3, #1
 8005890:	4619      	mov	r1, r3
 8005892:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8005896:	b29a      	uxth	r2, r3
 8005898:	b28b      	uxth	r3, r1
 800589a:	4413      	add	r3, r2
 800589c:	b29b      	uxth	r3, r3
 800589e:	b21b      	sxth	r3, r3
 80058a0:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
 80058a4:	e031      	b.n	800590a <lv_draw_label+0x7a6>

        }
        /*Align to the right*/
        else if(flag & LV_TXT_FLAG_RIGHT) {
 80058a6:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 80058aa:	f003 0308 	and.w	r3, r3, #8
 80058ae:	2b00      	cmp	r3, #0
 80058b0:	d02b      	beq.n	800590a <lv_draw_label+0x7a6>
            line_width =
                    lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 80058b2:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 80058b6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80058ba:	18d0      	adds	r0, r2, r3
 80058bc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80058c0:	b29a      	uxth	r2, r3
 80058c2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80058c6:	b29b      	uxth	r3, r3
 80058c8:	1ad3      	subs	r3, r2, r3
 80058ca:	b299      	uxth	r1, r3
 80058cc:	687b      	ldr	r3, [r7, #4]
 80058ce:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
            line_width =
 80058d2:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 80058d6:	9300      	str	r3, [sp, #0]
 80058d8:	4613      	mov	r3, r2
 80058da:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 80058de:	f008 f85b 	bl	800d998 <lv_txt_get_width>
 80058e2:	4603      	mov	r3, r0
 80058e4:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98
            pos.x += lv_area_get_width(coords) - line_width;
 80058e8:	68f8      	ldr	r0, [r7, #12]
 80058ea:	f7ff fc24 	bl	8005136 <lv_area_get_width>
 80058ee:	4603      	mov	r3, r0
 80058f0:	461a      	mov	r2, r3
 80058f2:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
 80058f6:	1ad3      	subs	r3, r2, r3
 80058f8:	f9b7 2074 	ldrsh.w	r2, [r7, #116]	; 0x74
 80058fc:	b292      	uxth	r2, r2
 80058fe:	b29b      	uxth	r3, r3
 8005900:	4413      	add	r3, r2
 8005902:	b29b      	uxth	r3, r3
 8005904:	b21b      	sxth	r3, r3
 8005906:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
        }

        /*Go the next line position*/
        pos.y += line_height;
 800590a:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 800590e:	b29a      	uxth	r2, r3
 8005910:	f8b7 309a 	ldrh.w	r3, [r7, #154]	; 0x9a
 8005914:	4413      	add	r3, r2
 8005916:	b29b      	uxth	r3, r3
 8005918:	b21b      	sxth	r3, r3
 800591a:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

        if(pos.y > mask->y2) return;
 800591e:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 8005922:	68bb      	ldr	r3, [r7, #8]
 8005924:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005928:	429a      	cmp	r2, r3
 800592a:	dc0d      	bgt.n	8005948 <lv_draw_label+0x7e4>
    while(txt[line_start] != '\0') {
 800592c:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8005930:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8005934:	4413      	add	r3, r2
 8005936:	781b      	ldrb	r3, [r3, #0]
 8005938:	2b00      	cmp	r3, #0
 800593a:	f47f adfd 	bne.w	8005538 <lv_draw_label+0x3d4>
 800593e:	e004      	b.n	800594a <lv_draw_label+0x7e6>
    if (txt[0] == '\0')  return;
 8005940:	bf00      	nop
 8005942:	e002      	b.n	800594a <lv_draw_label+0x7e6>
        if(txt[line_start] == '\0') return;
 8005944:	bf00      	nop
 8005946:	e000      	b.n	800594a <lv_draw_label+0x7e6>
        if(pos.y > mask->y2) return;
 8005948:	bf00      	nop
    }
}
 800594a:	37c4      	adds	r7, #196	; 0xc4
 800594c:	46bd      	mov	sp, r7
 800594e:	bd90      	pop	{r4, r7, pc}

08005950 <hex_char_to_num>:
 * Convert a hexadecimal characters to a number (0..15)
 * @param hex Pointer to a hexadecimal character (0..9, A..F)
 * @return the numerical value of `hex` or 0 on error
 */
static uint8_t hex_char_to_num(char hex)
{
 8005950:	b480      	push	{r7}
 8005952:	b085      	sub	sp, #20
 8005954:	af00      	add	r7, sp, #0
 8005956:	4603      	mov	r3, r0
 8005958:	71fb      	strb	r3, [r7, #7]
    uint8_t result = 0;
 800595a:	2300      	movs	r3, #0
 800595c:	73fb      	strb	r3, [r7, #15]

    if(hex >= '0' && hex <= '9') {
 800595e:	79fb      	ldrb	r3, [r7, #7]
 8005960:	2b2f      	cmp	r3, #47	; 0x2f
 8005962:	d906      	bls.n	8005972 <hex_char_to_num+0x22>
 8005964:	79fb      	ldrb	r3, [r7, #7]
 8005966:	2b39      	cmp	r3, #57	; 0x39
 8005968:	d803      	bhi.n	8005972 <hex_char_to_num+0x22>
        result = hex - '0';
 800596a:	79fb      	ldrb	r3, [r7, #7]
 800596c:	3b30      	subs	r3, #48	; 0x30
 800596e:	73fb      	strb	r3, [r7, #15]
 8005970:	e02d      	b.n	80059ce <hex_char_to_num+0x7e>
    } else {
        if(hex >= 'a') hex -= 'a' - 'A'; /*Convert to upper case*/
 8005972:	79fb      	ldrb	r3, [r7, #7]
 8005974:	2b60      	cmp	r3, #96	; 0x60
 8005976:	d902      	bls.n	800597e <hex_char_to_num+0x2e>
 8005978:	79fb      	ldrb	r3, [r7, #7]
 800597a:	3b20      	subs	r3, #32
 800597c:	71fb      	strb	r3, [r7, #7]

        switch(hex) {
 800597e:	79fb      	ldrb	r3, [r7, #7]
 8005980:	3b41      	subs	r3, #65	; 0x41
 8005982:	2b05      	cmp	r3, #5
 8005984:	d820      	bhi.n	80059c8 <hex_char_to_num+0x78>
 8005986:	a201      	add	r2, pc, #4	; (adr r2, 800598c <hex_char_to_num+0x3c>)
 8005988:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800598c:	080059a5 	.word	0x080059a5
 8005990:	080059ab 	.word	0x080059ab
 8005994:	080059b1 	.word	0x080059b1
 8005998:	080059b7 	.word	0x080059b7
 800599c:	080059bd 	.word	0x080059bd
 80059a0:	080059c3 	.word	0x080059c3
        case 'A': result = 10; break;
 80059a4:	230a      	movs	r3, #10
 80059a6:	73fb      	strb	r3, [r7, #15]
 80059a8:	e011      	b.n	80059ce <hex_char_to_num+0x7e>
        case 'B': result = 11; break;
 80059aa:	230b      	movs	r3, #11
 80059ac:	73fb      	strb	r3, [r7, #15]
 80059ae:	e00e      	b.n	80059ce <hex_char_to_num+0x7e>
        case 'C': result = 12; break;
 80059b0:	230c      	movs	r3, #12
 80059b2:	73fb      	strb	r3, [r7, #15]
 80059b4:	e00b      	b.n	80059ce <hex_char_to_num+0x7e>
        case 'D': result = 13; break;
 80059b6:	230d      	movs	r3, #13
 80059b8:	73fb      	strb	r3, [r7, #15]
 80059ba:	e008      	b.n	80059ce <hex_char_to_num+0x7e>
        case 'E': result = 14; break;
 80059bc:	230e      	movs	r3, #14
 80059be:	73fb      	strb	r3, [r7, #15]
 80059c0:	e005      	b.n	80059ce <hex_char_to_num+0x7e>
        case 'F': result = 15; break;
 80059c2:	230f      	movs	r3, #15
 80059c4:	73fb      	strb	r3, [r7, #15]
 80059c6:	e002      	b.n	80059ce <hex_char_to_num+0x7e>
        default: result = 0; break;
 80059c8:	2300      	movs	r3, #0
 80059ca:	73fb      	strb	r3, [r7, #15]
 80059cc:	bf00      	nop
        }
    }

    return result;
 80059ce:	7bfb      	ldrb	r3, [r7, #15]
}
 80059d0:	4618      	mov	r0, r3
 80059d2:	3714      	adds	r7, #20
 80059d4:	46bd      	mov	sp, r7
 80059d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80059da:	4770      	bx	lr

080059dc <lv_color_mix>:
{
 80059dc:	b480      	push	{r7}
 80059de:	b085      	sub	sp, #20
 80059e0:	af00      	add	r7, sp, #0
 80059e2:	80b8      	strh	r0, [r7, #4]
 80059e4:	8039      	strh	r1, [r7, #0]
 80059e6:	4613      	mov	r3, r2
 80059e8:	70fb      	strb	r3, [r7, #3]
    LV_COLOR_SET_R(ret, (uint16_t)((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) * (255 - mix)) >> 8);
 80059ea:	797b      	ldrb	r3, [r7, #5]
 80059ec:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80059f0:	b2db      	uxtb	r3, r3
 80059f2:	b29a      	uxth	r2, r3
 80059f4:	78fb      	ldrb	r3, [r7, #3]
 80059f6:	b29b      	uxth	r3, r3
 80059f8:	fb12 f303 	smulbb	r3, r2, r3
 80059fc:	b29a      	uxth	r2, r3
 80059fe:	787b      	ldrb	r3, [r7, #1]
 8005a00:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8005a04:	b2db      	uxtb	r3, r3
 8005a06:	b299      	uxth	r1, r3
 8005a08:	78fb      	ldrb	r3, [r7, #3]
 8005a0a:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8005a0e:	b29b      	uxth	r3, r3
 8005a10:	fb11 f303 	smulbb	r3, r1, r3
 8005a14:	b29b      	uxth	r3, r3
 8005a16:	4413      	add	r3, r2
 8005a18:	b29b      	uxth	r3, r3
 8005a1a:	0a1b      	lsrs	r3, r3, #8
 8005a1c:	b29b      	uxth	r3, r3
 8005a1e:	f003 031f 	and.w	r3, r3, #31
 8005a22:	b2da      	uxtb	r2, r3
 8005a24:	7b7b      	ldrb	r3, [r7, #13]
 8005a26:	f362 03c7 	bfi	r3, r2, #3, #5
 8005a2a:	737b      	strb	r3, [r7, #13]
    LV_COLOR_SET_G(ret, (uint16_t)((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) * (255 - mix)) >> 8);
 8005a2c:	88bb      	ldrh	r3, [r7, #4]
 8005a2e:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8005a32:	b2db      	uxtb	r3, r3
 8005a34:	b29a      	uxth	r2, r3
 8005a36:	78fb      	ldrb	r3, [r7, #3]
 8005a38:	b29b      	uxth	r3, r3
 8005a3a:	fb12 f303 	smulbb	r3, r2, r3
 8005a3e:	b29a      	uxth	r2, r3
 8005a40:	883b      	ldrh	r3, [r7, #0]
 8005a42:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8005a46:	b2db      	uxtb	r3, r3
 8005a48:	b299      	uxth	r1, r3
 8005a4a:	78fb      	ldrb	r3, [r7, #3]
 8005a4c:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8005a50:	b29b      	uxth	r3, r3
 8005a52:	fb11 f303 	smulbb	r3, r1, r3
 8005a56:	b29b      	uxth	r3, r3
 8005a58:	4413      	add	r3, r2
 8005a5a:	b29b      	uxth	r3, r3
 8005a5c:	0a1b      	lsrs	r3, r3, #8
 8005a5e:	b29b      	uxth	r3, r3
 8005a60:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8005a64:	b2da      	uxtb	r2, r3
 8005a66:	89bb      	ldrh	r3, [r7, #12]
 8005a68:	f362 134a 	bfi	r3, r2, #5, #6
 8005a6c:	81bb      	strh	r3, [r7, #12]
    LV_COLOR_SET_B(ret, (uint16_t)((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) * (255 - mix)) >> 8);
 8005a6e:	793b      	ldrb	r3, [r7, #4]
 8005a70:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8005a74:	b2db      	uxtb	r3, r3
 8005a76:	b29a      	uxth	r2, r3
 8005a78:	78fb      	ldrb	r3, [r7, #3]
 8005a7a:	b29b      	uxth	r3, r3
 8005a7c:	fb12 f303 	smulbb	r3, r2, r3
 8005a80:	b29a      	uxth	r2, r3
 8005a82:	783b      	ldrb	r3, [r7, #0]
 8005a84:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8005a88:	b2db      	uxtb	r3, r3
 8005a8a:	b299      	uxth	r1, r3
 8005a8c:	78fb      	ldrb	r3, [r7, #3]
 8005a8e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8005a92:	b29b      	uxth	r3, r3
 8005a94:	fb11 f303 	smulbb	r3, r1, r3
 8005a98:	b29b      	uxth	r3, r3
 8005a9a:	4413      	add	r3, r2
 8005a9c:	b29b      	uxth	r3, r3
 8005a9e:	0a1b      	lsrs	r3, r3, #8
 8005aa0:	b29b      	uxth	r3, r3
 8005aa2:	f003 031f 	and.w	r3, r3, #31
 8005aa6:	b2da      	uxtb	r2, r3
 8005aa8:	7b3b      	ldrb	r3, [r7, #12]
 8005aaa:	f362 0304 	bfi	r3, r2, #0, #5
 8005aae:	733b      	strb	r3, [r7, #12]
    return ret;
 8005ab0:	89bb      	ldrh	r3, [r7, #12]
}
 8005ab2:	4618      	mov	r0, r3
 8005ab4:	3714      	adds	r7, #20
 8005ab6:	46bd      	mov	sp, r7
 8005ab8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005abc:	4770      	bx	lr

08005abe <lv_area_copy>:
{
 8005abe:	b580      	push	{r7, lr}
 8005ac0:	b082      	sub	sp, #8
 8005ac2:	af00      	add	r7, sp, #0
 8005ac4:	6078      	str	r0, [r7, #4]
 8005ac6:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 8005ac8:	2208      	movs	r2, #8
 8005aca:	6839      	ldr	r1, [r7, #0]
 8005acc:	6878      	ldr	r0, [r7, #4]
 8005ace:	f00d fe3b 	bl	8013748 <memcpy>
}
 8005ad2:	bf00      	nop
 8005ad4:	3708      	adds	r7, #8
 8005ad6:	46bd      	mov	sp, r7
 8005ad8:	bd80      	pop	{r7, pc}

08005ada <lv_area_get_width>:
{
 8005ada:	b480      	push	{r7}
 8005adc:	b083      	sub	sp, #12
 8005ade:	af00      	add	r7, sp, #0
 8005ae0:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 8005ae2:	687b      	ldr	r3, [r7, #4]
 8005ae4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8005ae8:	b29a      	uxth	r2, r3
 8005aea:	687b      	ldr	r3, [r7, #4]
 8005aec:	f9b3 3000 	ldrsh.w	r3, [r3]
 8005af0:	b29b      	uxth	r3, r3
 8005af2:	1ad3      	subs	r3, r2, r3
 8005af4:	b29b      	uxth	r3, r3
 8005af6:	3301      	adds	r3, #1
 8005af8:	b29b      	uxth	r3, r3
 8005afa:	b21b      	sxth	r3, r3
}
 8005afc:	4618      	mov	r0, r3
 8005afe:	370c      	adds	r7, #12
 8005b00:	46bd      	mov	sp, r7
 8005b02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b06:	4770      	bx	lr

08005b08 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 8005b08:	b480      	push	{r7}
 8005b0a:	b083      	sub	sp, #12
 8005b0c:	af00      	add	r7, sp, #0
 8005b0e:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 8005b10:	687b      	ldr	r3, [r7, #4]
 8005b12:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005b16:	b29a      	uxth	r2, r3
 8005b18:	687b      	ldr	r3, [r7, #4]
 8005b1a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005b1e:	b29b      	uxth	r3, r3
 8005b20:	1ad3      	subs	r3, r2, r3
 8005b22:	b29b      	uxth	r3, r3
 8005b24:	3301      	adds	r3, #1
 8005b26:	b29b      	uxth	r3, r3
 8005b28:	b21b      	sxth	r3, r3
}
 8005b2a:	4618      	mov	r0, r3
 8005b2c:	370c      	adds	r7, #12
 8005b2e:	46bd      	mov	sp, r7
 8005b30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b34:	4770      	bx	lr

08005b36 <lv_draw_rect>:
 * @param mask the rectangle will be drawn only in this mask
 * @param style pointer to a style
 * @param opa_scale scale down all opacities by the factor
 */
void lv_draw_rect(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style, lv_opa_t opa_scale)
{
 8005b36:	b580      	push	{r7, lr}
 8005b38:	b084      	sub	sp, #16
 8005b3a:	af00      	add	r7, sp, #0
 8005b3c:	60f8      	str	r0, [r7, #12]
 8005b3e:	60b9      	str	r1, [r7, #8]
 8005b40:	607a      	str	r2, [r7, #4]
 8005b42:	70fb      	strb	r3, [r7, #3]
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
 8005b44:	68f8      	ldr	r0, [r7, #12]
 8005b46:	f7ff ffdf 	bl	8005b08 <lv_area_get_height>
 8005b4a:	4603      	mov	r3, r0
 8005b4c:	2b00      	cmp	r3, #0
 8005b4e:	dd4e      	ble.n	8005bee <lv_draw_rect+0xb8>
 8005b50:	68f8      	ldr	r0, [r7, #12]
 8005b52:	f7ff ffc2 	bl	8005ada <lv_area_get_width>
 8005b56:	4603      	mov	r3, r0
 8005b58:	2b00      	cmp	r3, #0
 8005b5a:	dd48      	ble.n	8005bee <lv_draw_rect+0xb8>

#if LV_USE_SHADOW
    if(style->body.shadow.width != 0) {
 8005b5c:	687b      	ldr	r3, [r7, #4]
 8005b5e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8005b62:	2b00      	cmp	r3, #0
 8005b64:	d005      	beq.n	8005b72 <lv_draw_rect+0x3c>
        lv_draw_shadow(coords, mask, style, opa_scale);
 8005b66:	78fb      	ldrb	r3, [r7, #3]
 8005b68:	687a      	ldr	r2, [r7, #4]
 8005b6a:	68b9      	ldr	r1, [r7, #8]
 8005b6c:	68f8      	ldr	r0, [r7, #12]
 8005b6e:	f002 ff63 	bl	8008a38 <lv_draw_shadow>
    }
#endif

    /* If the object is out of the mask there is nothing to draw.
     * Draw shadow before it because the shadow is out of `coords`*/
    if(lv_area_is_on(coords, mask) == false) return;
 8005b72:	68b9      	ldr	r1, [r7, #8]
 8005b74:	68f8      	ldr	r0, [r7, #12]
 8005b76:	f006 fb32 	bl	800c1de <lv_area_is_on>
 8005b7a:	4603      	mov	r3, r0
 8005b7c:	f083 0301 	eor.w	r3, r3, #1
 8005b80:	b2db      	uxtb	r3, r3
 8005b82:	2b00      	cmp	r3, #0
 8005b84:	d135      	bne.n	8005bf2 <lv_draw_rect+0xbc>

    if(style->body.opa > LV_OPA_MIN) {
 8005b86:	687b      	ldr	r3, [r7, #4]
 8005b88:	7a1b      	ldrb	r3, [r3, #8]
 8005b8a:	2b10      	cmp	r3, #16
 8005b8c:	d910      	bls.n	8005bb0 <lv_draw_rect+0x7a>
        lv_draw_rect_main_mid(coords, mask, style, opa_scale);
 8005b8e:	78fb      	ldrb	r3, [r7, #3]
 8005b90:	687a      	ldr	r2, [r7, #4]
 8005b92:	68b9      	ldr	r1, [r7, #8]
 8005b94:	68f8      	ldr	r0, [r7, #12]
 8005b96:	f000 f830 	bl	8005bfa <lv_draw_rect_main_mid>

        if(style->body.radius != 0) {
 8005b9a:	687b      	ldr	r3, [r7, #4]
 8005b9c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005ba0:	2b00      	cmp	r3, #0
 8005ba2:	d005      	beq.n	8005bb0 <lv_draw_rect+0x7a>
            lv_draw_rect_main_corner(coords, mask, style, opa_scale);
 8005ba4:	78fb      	ldrb	r3, [r7, #3]
 8005ba6:	687a      	ldr	r2, [r7, #4]
 8005ba8:	68b9      	ldr	r1, [r7, #8]
 8005baa:	68f8      	ldr	r0, [r7, #12]
 8005bac:	f000 f927 	bl	8005dfe <lv_draw_rect_main_corner>
        }
    }

    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE &&
 8005bb0:	687b      	ldr	r3, [r7, #4]
 8005bb2:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8005bb6:	2b00      	cmp	r3, #0
 8005bb8:	d01c      	beq.n	8005bf4 <lv_draw_rect+0xbe>
 8005bba:	687b      	ldr	r3, [r7, #4]
 8005bbc:	7b9b      	ldrb	r3, [r3, #14]
 8005bbe:	2b00      	cmp	r3, #0
 8005bc0:	d018      	beq.n	8005bf4 <lv_draw_rect+0xbe>
       style->body.border.opa >= LV_OPA_MIN) {
 8005bc2:	687b      	ldr	r3, [r7, #4]
 8005bc4:	7bdb      	ldrb	r3, [r3, #15]
    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE &&
 8005bc6:	2b0f      	cmp	r3, #15
 8005bc8:	d914      	bls.n	8005bf4 <lv_draw_rect+0xbe>
        lv_draw_rect_border_straight(coords, mask, style, opa_scale);
 8005bca:	78fb      	ldrb	r3, [r7, #3]
 8005bcc:	687a      	ldr	r2, [r7, #4]
 8005bce:	68b9      	ldr	r1, [r7, #8]
 8005bd0:	68f8      	ldr	r0, [r7, #12]
 8005bd2:	f001 f93d 	bl	8006e50 <lv_draw_rect_border_straight>

        if(style->body.radius != 0) {
 8005bd6:	687b      	ldr	r3, [r7, #4]
 8005bd8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005bdc:	2b00      	cmp	r3, #0
 8005bde:	d009      	beq.n	8005bf4 <lv_draw_rect+0xbe>
            lv_draw_rect_border_corner(coords, mask, style, opa_scale);
 8005be0:	78fb      	ldrb	r3, [r7, #3]
 8005be2:	687a      	ldr	r2, [r7, #4]
 8005be4:	68b9      	ldr	r1, [r7, #8]
 8005be6:	68f8      	ldr	r0, [r7, #12]
 8005be8:	f001 fcdf 	bl	80075aa <lv_draw_rect_border_corner>
 8005bec:	e002      	b.n	8005bf4 <lv_draw_rect+0xbe>
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
 8005bee:	bf00      	nop
 8005bf0:	e000      	b.n	8005bf4 <lv_draw_rect+0xbe>
    if(lv_area_is_on(coords, mask) == false) return;
 8005bf2:	bf00      	nop
        }
    }
}
 8005bf4:	3710      	adds	r7, #16
 8005bf6:	46bd      	mov	sp, r7
 8005bf8:	bd80      	pop	{r7, pc}

08005bfa <lv_draw_rect_main_mid>:
 * @param rects_p pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_main_mid(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                  lv_opa_t opa_scale)
{
 8005bfa:	b580      	push	{r7, lr}
 8005bfc:	b08e      	sub	sp, #56	; 0x38
 8005bfe:	af00      	add	r7, sp, #0
 8005c00:	60f8      	str	r0, [r7, #12]
 8005c02:	60b9      	str	r1, [r7, #8]
 8005c04:	607a      	str	r2, [r7, #4]
 8005c06:	70fb      	strb	r3, [r7, #3]
    uint16_t radius = style->body.radius;
 8005c08:	687b      	ldr	r3, [r7, #4]
 8005c0a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005c0e:	863b      	strh	r3, [r7, #48]	; 0x30
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8005c10:	f7fd f9a0 	bl	8002f54 <lv_refr_get_disp_refreshing>
 8005c14:	4603      	mov	r3, r0
 8005c16:	4618      	mov	r0, r3
 8005c18:	f005 ff1d 	bl	800ba56 <lv_disp_get_antialiasing>
 8005c1c:	4603      	mov	r3, r0
 8005c1e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    lv_color_t mcolor = style->body.main_color;
 8005c22:	687b      	ldr	r3, [r7, #4]
 8005c24:	885b      	ldrh	r3, [r3, #2]
 8005c26:	84bb      	strh	r3, [r7, #36]	; 0x24
    lv_color_t gcolor = style->body.grad_color;
 8005c28:	687b      	ldr	r3, [r7, #4]
 8005c2a:	889b      	ldrh	r3, [r3, #4]
 8005c2c:	843b      	strh	r3, [r7, #32]
    uint8_t mix;
    lv_coord_t height = lv_area_get_height(coords);
 8005c2e:	68f8      	ldr	r0, [r7, #12]
 8005c30:	f7ff ff6a 	bl	8005b08 <lv_area_get_height>
 8005c34:	4603      	mov	r3, r0
 8005c36:	85bb      	strh	r3, [r7, #44]	; 0x2c
    lv_coord_t width  = lv_area_get_width(coords);
 8005c38:	68f8      	ldr	r0, [r7, #12]
 8005c3a:	f7ff ff4e 	bl	8005ada <lv_area_get_width>
 8005c3e:	4603      	mov	r3, r0
 8005c40:	857b      	strh	r3, [r7, #42]	; 0x2a
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 8005c42:	78fb      	ldrb	r3, [r7, #3]
 8005c44:	2bff      	cmp	r3, #255	; 0xff
 8005c46:	d102      	bne.n	8005c4e <lv_draw_rect_main_mid+0x54>
 8005c48:	687b      	ldr	r3, [r7, #4]
 8005c4a:	7a1b      	ldrb	r3, [r3, #8]
 8005c4c:	e00a      	b.n	8005c64 <lv_draw_rect_main_mid+0x6a>
 8005c4e:	687b      	ldr	r3, [r7, #4]
 8005c50:	7a1b      	ldrb	r3, [r3, #8]
 8005c52:	b29a      	uxth	r2, r3
 8005c54:	78fb      	ldrb	r3, [r7, #3]
 8005c56:	b29b      	uxth	r3, r3
 8005c58:	fb12 f303 	smulbb	r3, r2, r3
 8005c5c:	b29b      	uxth	r3, r3
 8005c5e:	0a1b      	lsrs	r3, r3, #8
 8005c60:	b29b      	uxth	r3, r3
 8005c62:	b2db      	uxtb	r3, r3
 8005c64:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8005c68:	f9b7 202c 	ldrsh.w	r2, [r7, #44]	; 0x2c
 8005c6c:	f9b7 102a 	ldrsh.w	r1, [r7, #42]	; 0x2a
 8005c70:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8005c72:	4618      	mov	r0, r3
 8005c74:	f003 fdd8 	bl	8009828 <lv_draw_cont_radius_corr>
 8005c78:	4603      	mov	r3, r0
 8005c7a:	863b      	strh	r3, [r7, #48]	; 0x30

    /*If the radius is too big then there is no body*/
    if(radius > height / 2) return;
 8005c7c:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 8005c7e:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 8005c82:	0fd9      	lsrs	r1, r3, #31
 8005c84:	440b      	add	r3, r1
 8005c86:	105b      	asrs	r3, r3, #1
 8005c88:	b21b      	sxth	r3, r3
 8005c8a:	429a      	cmp	r2, r3
 8005c8c:	f300 80b3 	bgt.w	8005df6 <lv_draw_rect_main_mid+0x1fc>

    lv_area_t work_area;
    work_area.x1 = coords->x1;
 8005c90:	68fb      	ldr	r3, [r7, #12]
 8005c92:	f9b3 3000 	ldrsh.w	r3, [r3]
 8005c96:	833b      	strh	r3, [r7, #24]
    work_area.x2 = coords->x2;
 8005c98:	68fb      	ldr	r3, [r7, #12]
 8005c9a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8005c9e:	83bb      	strh	r3, [r7, #28]

    if(mcolor.full == gcolor.full) {
 8005ca0:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8005ca2:	8c3b      	ldrh	r3, [r7, #32]
 8005ca4:	429a      	cmp	r2, r3
 8005ca6:	d140      	bne.n	8005d2a <lv_draw_rect_main_mid+0x130>
        work_area.y1 = coords->y1 + radius;
 8005ca8:	68fb      	ldr	r3, [r7, #12]
 8005caa:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005cae:	b29a      	uxth	r2, r3
 8005cb0:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8005cb2:	4413      	add	r3, r2
 8005cb4:	b29b      	uxth	r3, r3
 8005cb6:	b21b      	sxth	r3, r3
 8005cb8:	837b      	strh	r3, [r7, #26]
        work_area.y2 = coords->y2 - radius;
 8005cba:	68fb      	ldr	r3, [r7, #12]
 8005cbc:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005cc0:	b29a      	uxth	r2, r3
 8005cc2:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8005cc4:	1ad3      	subs	r3, r2, r3
 8005cc6:	b29b      	uxth	r3, r3
 8005cc8:	b21b      	sxth	r3, r3
 8005cca:	83fb      	strh	r3, [r7, #30]

        if(style->body.radius != 0) {
 8005ccc:	687b      	ldr	r3, [r7, #4]
 8005cce:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005cd2:	2b00      	cmp	r3, #0
 8005cd4:	d020      	beq.n	8005d18 <lv_draw_rect_main_mid+0x11e>

            if(aa) {
 8005cd6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8005cda:	2b00      	cmp	r3, #0
 8005cdc:	d00e      	beq.n	8005cfc <lv_draw_rect_main_mid+0x102>
                work_area.y1 += 2;
 8005cde:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8005ce2:	b29b      	uxth	r3, r3
 8005ce4:	3302      	adds	r3, #2
 8005ce6:	b29b      	uxth	r3, r3
 8005ce8:	b21b      	sxth	r3, r3
 8005cea:	837b      	strh	r3, [r7, #26]
                work_area.y2 -= 2;
 8005cec:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8005cf0:	b29b      	uxth	r3, r3
 8005cf2:	3b02      	subs	r3, #2
 8005cf4:	b29b      	uxth	r3, r3
 8005cf6:	b21b      	sxth	r3, r3
 8005cf8:	83fb      	strh	r3, [r7, #30]
 8005cfa:	e00d      	b.n	8005d18 <lv_draw_rect_main_mid+0x11e>
            } else {
                work_area.y1 += 1;
 8005cfc:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8005d00:	b29b      	uxth	r3, r3
 8005d02:	3301      	adds	r3, #1
 8005d04:	b29b      	uxth	r3, r3
 8005d06:	b21b      	sxth	r3, r3
 8005d08:	837b      	strh	r3, [r7, #26]
                work_area.y2 -= 1;
 8005d0a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8005d0e:	b29b      	uxth	r3, r3
 8005d10:	3b01      	subs	r3, #1
 8005d12:	b29b      	uxth	r3, r3
 8005d14:	b21b      	sxth	r3, r3
 8005d16:	83fb      	strh	r3, [r7, #30]
            }
        }

        lv_draw_fill(&work_area, mask, mcolor, opa);
 8005d18:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8005d1c:	f107 0018 	add.w	r0, r7, #24
 8005d20:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8005d22:	68b9      	ldr	r1, [r7, #8]
 8005d24:	f7fe fa7c 	bl	8004220 <lv_draw_fill>
 8005d28:	e066      	b.n	8005df8 <lv_draw_rect_main_mid+0x1fe>
    } else {
        lv_coord_t row;
        lv_coord_t row_start = coords->y1 + radius;
 8005d2a:	68fb      	ldr	r3, [r7, #12]
 8005d2c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005d30:	b29a      	uxth	r2, r3
 8005d32:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8005d34:	4413      	add	r3, r2
 8005d36:	b29b      	uxth	r3, r3
 8005d38:	86bb      	strh	r3, [r7, #52]	; 0x34
        lv_coord_t row_end   = coords->y2 - radius;
 8005d3a:	68fb      	ldr	r3, [r7, #12]
 8005d3c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005d40:	b29a      	uxth	r2, r3
 8005d42:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8005d44:	1ad3      	subs	r3, r2, r3
 8005d46:	b29b      	uxth	r3, r3
 8005d48:	867b      	strh	r3, [r7, #50]	; 0x32
        lv_color_t act_color;

        if(style->body.radius != 0) {
 8005d4a:	687b      	ldr	r3, [r7, #4]
 8005d4c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005d50:	2b00      	cmp	r3, #0
 8005d52:	d014      	beq.n	8005d7e <lv_draw_rect_main_mid+0x184>
            if(aa) {
 8005d54:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8005d58:	2b00      	cmp	r3, #0
 8005d5a:	d008      	beq.n	8005d6e <lv_draw_rect_main_mid+0x174>
                row_start += 2;
 8005d5c:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8005d5e:	3302      	adds	r3, #2
 8005d60:	b29b      	uxth	r3, r3
 8005d62:	86bb      	strh	r3, [r7, #52]	; 0x34
                row_end -= 2;
 8005d64:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8005d66:	3b02      	subs	r3, #2
 8005d68:	b29b      	uxth	r3, r3
 8005d6a:	867b      	strh	r3, [r7, #50]	; 0x32
 8005d6c:	e007      	b.n	8005d7e <lv_draw_rect_main_mid+0x184>
            } else {
                row_start += 1;
 8005d6e:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8005d70:	3301      	adds	r3, #1
 8005d72:	b29b      	uxth	r3, r3
 8005d74:	86bb      	strh	r3, [r7, #52]	; 0x34
                row_end -= 1;
 8005d76:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8005d78:	3b01      	subs	r3, #1
 8005d7a:	b29b      	uxth	r3, r3
 8005d7c:	867b      	strh	r3, [r7, #50]	; 0x32
            }
        }
        if(row_start < 0) row_start = 0;
 8005d7e:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8005d82:	2b00      	cmp	r3, #0
 8005d84:	da01      	bge.n	8005d8a <lv_draw_rect_main_mid+0x190>
 8005d86:	2300      	movs	r3, #0
 8005d88:	86bb      	strh	r3, [r7, #52]	; 0x34

        for(row = row_start; row <= row_end; row++) {
 8005d8a:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8005d8c:	86fb      	strh	r3, [r7, #54]	; 0x36
 8005d8e:	e02b      	b.n	8005de8 <lv_draw_rect_main_mid+0x1ee>
            work_area.y1 = row;
 8005d90:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8005d92:	837b      	strh	r3, [r7, #26]
            work_area.y2 = row;
 8005d94:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8005d96:	83fb      	strh	r3, [r7, #30]
            mix          = (uint32_t)((uint32_t)(coords->y2 - work_area.y1) * 255) / height;
 8005d98:	68fb      	ldr	r3, [r7, #12]
 8005d9a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005d9e:	461a      	mov	r2, r3
 8005da0:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8005da4:	1ad3      	subs	r3, r2, r3
 8005da6:	461a      	mov	r2, r3
 8005da8:	4613      	mov	r3, r2
 8005daa:	021b      	lsls	r3, r3, #8
 8005dac:	1a9a      	subs	r2, r3, r2
 8005dae:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 8005db2:	fbb2 f3f3 	udiv	r3, r2, r3
 8005db6:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
            act_color    = lv_color_mix(mcolor, gcolor, mix);
 8005dba:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8005dbe:	461a      	mov	r2, r3
 8005dc0:	8c39      	ldrh	r1, [r7, #32]
 8005dc2:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
 8005dc4:	f7ff fe0a 	bl	80059dc <lv_color_mix>
 8005dc8:	4603      	mov	r3, r0
 8005dca:	82bb      	strh	r3, [r7, #20]

            lv_draw_fill(&work_area, mask, act_color, opa);
 8005dcc:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8005dd0:	f107 0018 	add.w	r0, r7, #24
 8005dd4:	8aba      	ldrh	r2, [r7, #20]
 8005dd6:	68b9      	ldr	r1, [r7, #8]
 8005dd8:	f7fe fa22 	bl	8004220 <lv_draw_fill>
        for(row = row_start; row <= row_end; row++) {
 8005ddc:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8005de0:	b29b      	uxth	r3, r3
 8005de2:	3301      	adds	r3, #1
 8005de4:	b29b      	uxth	r3, r3
 8005de6:	86fb      	strh	r3, [r7, #54]	; 0x36
 8005de8:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 8005dec:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8005df0:	429a      	cmp	r2, r3
 8005df2:	ddcd      	ble.n	8005d90 <lv_draw_rect_main_mid+0x196>
 8005df4:	e000      	b.n	8005df8 <lv_draw_rect_main_mid+0x1fe>
    if(radius > height / 2) return;
 8005df6:	bf00      	nop
        }
    }
}
 8005df8:	3738      	adds	r7, #56	; 0x38
 8005dfa:	46bd      	mov	sp, r7
 8005dfc:	bd80      	pop	{r7, pc}

08005dfe <lv_draw_rect_main_corner>:
 * @param rects_p pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_main_corner(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                     lv_opa_t opa_scale)
{
 8005dfe:	b5b0      	push	{r4, r5, r7, lr}
 8005e00:	b0a4      	sub	sp, #144	; 0x90
 8005e02:	af02      	add	r7, sp, #8
 8005e04:	60f8      	str	r0, [r7, #12]
 8005e06:	60b9      	str	r1, [r7, #8]
 8005e08:	607a      	str	r2, [r7, #4]
 8005e0a:	70fb      	strb	r3, [r7, #3]
    uint16_t radius = style->body.radius;
 8005e0c:	687b      	ldr	r3, [r7, #4]
 8005e0e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005e12:	f8a7 3078 	strh.w	r3, [r7, #120]	; 0x78
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8005e16:	f7fd f89d 	bl	8002f54 <lv_refr_get_disp_refreshing>
 8005e1a:	4603      	mov	r3, r0
 8005e1c:	4618      	mov	r0, r3
 8005e1e:	f005 fe1a 	bl	800ba56 <lv_disp_get_antialiasing>
 8005e22:	4603      	mov	r3, r0
 8005e24:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77

    lv_color_t mcolor = style->body.main_color;
 8005e28:	687b      	ldr	r3, [r7, #4]
 8005e2a:	885b      	ldrh	r3, [r3, #2]
 8005e2c:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    lv_color_t gcolor = style->body.grad_color;
 8005e30:	687b      	ldr	r3, [r7, #4]
 8005e32:	889b      	ldrh	r3, [r3, #4]
 8005e34:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    lv_color_t act_color;
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 8005e38:	78fb      	ldrb	r3, [r7, #3]
 8005e3a:	2bff      	cmp	r3, #255	; 0xff
 8005e3c:	d102      	bne.n	8005e44 <lv_draw_rect_main_corner+0x46>
 8005e3e:	687b      	ldr	r3, [r7, #4]
 8005e40:	7a1b      	ldrb	r3, [r3, #8]
 8005e42:	e00a      	b.n	8005e5a <lv_draw_rect_main_corner+0x5c>
 8005e44:	687b      	ldr	r3, [r7, #4]
 8005e46:	7a1b      	ldrb	r3, [r3, #8]
 8005e48:	b29a      	uxth	r2, r3
 8005e4a:	78fb      	ldrb	r3, [r7, #3]
 8005e4c:	b29b      	uxth	r3, r3
 8005e4e:	fb12 f303 	smulbb	r3, r2, r3
 8005e52:	b29b      	uxth	r3, r3
 8005e54:	0a1b      	lsrs	r3, r3, #8
 8005e56:	b29b      	uxth	r3, r3
 8005e58:	b2db      	uxtb	r3, r3
 8005e5a:	f887 3076 	strb.w	r3, [r7, #118]	; 0x76
    uint8_t mix;
    lv_coord_t height = lv_area_get_height(coords);
 8005e5e:	68f8      	ldr	r0, [r7, #12]
 8005e60:	f7ff fe52 	bl	8005b08 <lv_area_get_height>
 8005e64:	4603      	mov	r3, r0
 8005e66:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
    lv_coord_t width  = lv_area_get_width(coords);
 8005e6a:	68f8      	ldr	r0, [r7, #12]
 8005e6c:	f7ff fe35 	bl	8005ada <lv_area_get_width>
 8005e70:	4603      	mov	r3, r0
 8005e72:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8005e76:	f9b7 2074 	ldrsh.w	r2, [r7, #116]	; 0x74
 8005e7a:	f9b7 1072 	ldrsh.w	r1, [r7, #114]	; 0x72
 8005e7e:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8005e82:	4618      	mov	r0, r3
 8005e84:	f003 fcd0 	bl	8009828 <lv_draw_cont_radius_corr>
 8005e88:	4603      	mov	r3, r0
 8005e8a:	f8a7 3078 	strh.w	r3, [r7, #120]	; 0x78
    lv_point_t lt_origo; /*Left  Top    origo*/
    lv_point_t lb_origo; /*Left  Bottom origo*/
    lv_point_t rt_origo; /*Right Top    origo*/
    lv_point_t rb_origo; /*Left  Bottom origo*/

    lt_origo.x = coords->x1 + radius + aa;
 8005e8e:	68fb      	ldr	r3, [r7, #12]
 8005e90:	f9b3 3000 	ldrsh.w	r3, [r3]
 8005e94:	b29a      	uxth	r2, r3
 8005e96:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8005e9a:	4413      	add	r3, r2
 8005e9c:	b29a      	uxth	r2, r3
 8005e9e:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8005ea2:	b29b      	uxth	r3, r3
 8005ea4:	4413      	add	r3, r2
 8005ea6:	b29b      	uxth	r3, r3
 8005ea8:	b21b      	sxth	r3, r3
 8005eaa:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
    lt_origo.y = coords->y1 + radius + aa;
 8005eae:	68fb      	ldr	r3, [r7, #12]
 8005eb0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005eb4:	b29a      	uxth	r2, r3
 8005eb6:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8005eba:	4413      	add	r3, r2
 8005ebc:	b29a      	uxth	r2, r3
 8005ebe:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8005ec2:	b29b      	uxth	r3, r3
 8005ec4:	4413      	add	r3, r2
 8005ec6:	b29b      	uxth	r3, r3
 8005ec8:	b21b      	sxth	r3, r3
 8005eca:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a

    lb_origo.x = coords->x1 + radius + aa;
 8005ece:	68fb      	ldr	r3, [r7, #12]
 8005ed0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8005ed4:	b29a      	uxth	r2, r3
 8005ed6:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8005eda:	4413      	add	r3, r2
 8005edc:	b29a      	uxth	r2, r3
 8005ede:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8005ee2:	b29b      	uxth	r3, r3
 8005ee4:	4413      	add	r3, r2
 8005ee6:	b29b      	uxth	r3, r3
 8005ee8:	b21b      	sxth	r3, r3
 8005eea:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    lb_origo.y = coords->y2 - radius - aa;
 8005eee:	68fb      	ldr	r3, [r7, #12]
 8005ef0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005ef4:	b29a      	uxth	r2, r3
 8005ef6:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8005efa:	1ad3      	subs	r3, r2, r3
 8005efc:	b29a      	uxth	r2, r3
 8005efe:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8005f02:	b29b      	uxth	r3, r3
 8005f04:	1ad3      	subs	r3, r2, r3
 8005f06:	b29b      	uxth	r3, r3
 8005f08:	b21b      	sxth	r3, r3
 8005f0a:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56

    rt_origo.x = coords->x2 - radius - aa;
 8005f0e:	68fb      	ldr	r3, [r7, #12]
 8005f10:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8005f14:	b29a      	uxth	r2, r3
 8005f16:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8005f1a:	1ad3      	subs	r3, r2, r3
 8005f1c:	b29a      	uxth	r2, r3
 8005f1e:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8005f22:	b29b      	uxth	r3, r3
 8005f24:	1ad3      	subs	r3, r2, r3
 8005f26:	b29b      	uxth	r3, r3
 8005f28:	b21b      	sxth	r3, r3
 8005f2a:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
    rt_origo.y = coords->y1 + radius + aa;
 8005f2e:	68fb      	ldr	r3, [r7, #12]
 8005f30:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005f34:	b29a      	uxth	r2, r3
 8005f36:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8005f3a:	4413      	add	r3, r2
 8005f3c:	b29a      	uxth	r2, r3
 8005f3e:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8005f42:	b29b      	uxth	r3, r3
 8005f44:	4413      	add	r3, r2
 8005f46:	b29b      	uxth	r3, r3
 8005f48:	b21b      	sxth	r3, r3
 8005f4a:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    rb_origo.x = coords->x2 - radius - aa;
 8005f4e:	68fb      	ldr	r3, [r7, #12]
 8005f50:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8005f54:	b29a      	uxth	r2, r3
 8005f56:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8005f5a:	1ad3      	subs	r3, r2, r3
 8005f5c:	b29a      	uxth	r2, r3
 8005f5e:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8005f62:	b29b      	uxth	r3, r3
 8005f64:	1ad3      	subs	r3, r2, r3
 8005f66:	b29b      	uxth	r3, r3
 8005f68:	b21b      	sxth	r3, r3
 8005f6a:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
    rb_origo.y = coords->y2 - radius - aa;
 8005f6e:	68fb      	ldr	r3, [r7, #12]
 8005f70:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8005f74:	b29a      	uxth	r2, r3
 8005f76:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8005f7a:	1ad3      	subs	r3, r2, r3
 8005f7c:	b29a      	uxth	r2, r3
 8005f7e:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8005f82:	b29b      	uxth	r3, r3
 8005f84:	1ad3      	subs	r3, r2, r3
 8005f86:	b29b      	uxth	r3, r3
 8005f88:	b21b      	sxth	r3, r3
 8005f8a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    lv_area_t mid_bot_area;
    lv_area_t edge_bot_area;

    lv_point_t cir;
    lv_coord_t cir_tmp;
    lv_circ_init(&cir, &cir_tmp, radius);
 8005f8e:	f9b7 2078 	ldrsh.w	r2, [r7, #120]	; 0x78
 8005f92:	f107 0126 	add.w	r1, r7, #38	; 0x26
 8005f96:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8005f9a:	4618      	mov	r0, r3
 8005f9c:	f006 f97d 	bl	800c29a <lv_circ_init>

    /*Init the areas*/
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8005fa0:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8005fa4:	b29a      	uxth	r2, r3
 8005fa6:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8005faa:	b29b      	uxth	r3, r3
 8005fac:	1ad3      	subs	r3, r2, r3
 8005fae:	b29b      	uxth	r3, r3
 8005fb0:	b219      	sxth	r1, r3
 8005fb2:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8005fb6:	b29a      	uxth	r2, r3
 8005fb8:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8005fbc:	b29b      	uxth	r3, r3
 8005fbe:	4413      	add	r3, r2
 8005fc0:	b29b      	uxth	r3, r3
 8005fc2:	b21c      	sxth	r4, r3
                rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 8005fc4:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8005fc8:	b29a      	uxth	r2, r3
 8005fca:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8005fce:	b29b      	uxth	r3, r3
 8005fd0:	4413      	add	r3, r2
 8005fd2:	b29b      	uxth	r3, r3
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8005fd4:	b21d      	sxth	r5, r3
                rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 8005fd6:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8005fda:	b29a      	uxth	r2, r3
 8005fdc:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8005fe0:	b29b      	uxth	r3, r3
 8005fe2:	4413      	add	r3, r2
 8005fe4:	b29b      	uxth	r3, r3
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8005fe6:	b21b      	sxth	r3, r3
 8005fe8:	f107 0034 	add.w	r0, r7, #52	; 0x34
 8005fec:	9300      	str	r3, [sp, #0]
 8005fee:	462b      	mov	r3, r5
 8005ff0:	4622      	mov	r2, r4
 8005ff2:	f006 f827 	bl	800c044 <lv_area_set>

    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8005ff6:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8005ffa:	b29a      	uxth	r2, r3
 8005ffc:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8006000:	b29b      	uxth	r3, r3
 8006002:	1ad3      	subs	r3, r2, r3
 8006004:	b29b      	uxth	r3, r3
 8006006:	b219      	sxth	r1, r3
 8006008:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 800600c:	b29a      	uxth	r2, r3
 800600e:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8006012:	b29b      	uxth	r3, r3
 8006014:	4413      	add	r3, r2
 8006016:	b29b      	uxth	r3, r3
 8006018:	b21c      	sxth	r4, r3
                rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 800601a:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 800601e:	b29a      	uxth	r2, r3
 8006020:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8006024:	b29b      	uxth	r3, r3
 8006026:	4413      	add	r3, r2
 8006028:	b29b      	uxth	r3, r3
    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 800602a:	b21d      	sxth	r5, r3
                rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 800602c:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8006030:	b29a      	uxth	r2, r3
 8006032:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8006036:	b29b      	uxth	r3, r3
 8006038:	4413      	add	r3, r2
 800603a:	b29b      	uxth	r3, r3
    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 800603c:	b21b      	sxth	r3, r3
 800603e:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8006042:	9300      	str	r3, [sp, #0]
 8006044:	462b      	mov	r3, r5
 8006046:	4622      	mov	r2, r4
 8006048:	f005 fffc 	bl	800c044 <lv_area_set>

    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 800604c:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8006050:	b29a      	uxth	r2, r3
 8006052:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8006056:	b29b      	uxth	r3, r3
 8006058:	1ad3      	subs	r3, r2, r3
 800605a:	b29b      	uxth	r3, r3
 800605c:	b219      	sxth	r1, r3
 800605e:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8006062:	b29a      	uxth	r2, r3
 8006064:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8006068:	b29b      	uxth	r3, r3
 800606a:	1ad3      	subs	r3, r2, r3
 800606c:	b29b      	uxth	r3, r3
 800606e:	b21c      	sxth	r4, r3
                rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 8006070:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8006074:	b29a      	uxth	r2, r3
 8006076:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 800607a:	b29b      	uxth	r3, r3
 800607c:	4413      	add	r3, r2
 800607e:	b29b      	uxth	r3, r3
    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8006080:	b21d      	sxth	r5, r3
                rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 8006082:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8006086:	b29a      	uxth	r2, r3
 8006088:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 800608c:	b29b      	uxth	r3, r3
 800608e:	1ad3      	subs	r3, r2, r3
 8006090:	b29b      	uxth	r3, r3
    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8006092:	b21b      	sxth	r3, r3
 8006094:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 8006098:	9300      	str	r3, [sp, #0]
 800609a:	462b      	mov	r3, r5
 800609c:	4622      	mov	r2, r4
 800609e:	f005 ffd1 	bl	800c044 <lv_area_set>

    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 80060a2:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 80060a6:	b29a      	uxth	r2, r3
 80060a8:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80060ac:	b29b      	uxth	r3, r3
 80060ae:	1ad3      	subs	r3, r2, r3
 80060b0:	b29b      	uxth	r3, r3
 80060b2:	b219      	sxth	r1, r3
 80060b4:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 80060b8:	b29a      	uxth	r2, r3
 80060ba:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80060be:	b29b      	uxth	r3, r3
 80060c0:	1ad3      	subs	r3, r2, r3
 80060c2:	b29b      	uxth	r3, r3
 80060c4:	b21c      	sxth	r4, r3
                rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 80060c6:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 80060ca:	b29a      	uxth	r2, r3
 80060cc:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80060d0:	b29b      	uxth	r3, r3
 80060d2:	4413      	add	r3, r2
 80060d4:	b29b      	uxth	r3, r3
    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 80060d6:	b21d      	sxth	r5, r3
                rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 80060d8:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80060dc:	b29a      	uxth	r2, r3
 80060de:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80060e2:	b29b      	uxth	r3, r3
 80060e4:	1ad3      	subs	r3, r2, r3
 80060e6:	b29b      	uxth	r3, r3
    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 80060e8:	b21b      	sxth	r3, r3
 80060ea:	f107 0044 	add.w	r0, r7, #68	; 0x44
 80060ee:	9300      	str	r3, [sp, #0]
 80060f0:	462b      	mov	r3, r5
 80060f2:	4622      	mov	r2, r4
 80060f4:	f005 ffa6 	bl	800c044 <lv_area_set>
#if LV_ANTIALIAS
    /*Store some internal states for anti-aliasing*/
    lv_coord_t out_y_seg_start = 0;
 80060f8:	2300      	movs	r3, #0
 80060fa:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
    lv_coord_t out_y_seg_end   = 0;
 80060fe:	2300      	movs	r3, #0
 8006100:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
    lv_coord_t out_x_last      = radius;
 8006104:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8006108:	f8a7 3084 	strh.w	r3, [r7, #132]	; 0x84
    lv_color_t aa_color_hor_top;
    lv_color_t aa_color_hor_bottom;
    lv_color_t aa_color_ver;
#endif

    while(lv_circ_cont(&cir)) {
 800610c:	e367      	b.n	80067de <lv_draw_rect_main_corner+0x9e0>
#if LV_ANTIALIAS
        if(aa) {
 800610e:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8006112:	2b00      	cmp	r3, #0
 8006114:	f000 8197 	beq.w	8006446 <lv_draw_rect_main_corner+0x648>
            /*New step in y on the outter circle*/
            if(out_x_last != cir.x) {
 8006118:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 800611c:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 8006120:	429a      	cmp	r2, r3
 8006122:	f000 8190 	beq.w	8006446 <lv_draw_rect_main_corner+0x648>
                out_y_seg_end       = cir.y;
 8006126:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8006128:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
                lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 800612c:	f8b7 2070 	ldrh.w	r2, [r7, #112]	; 0x70
 8006130:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8006134:	1ad3      	subs	r3, r2, r3
 8006136:	b29b      	uxth	r3, r3
 8006138:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
                lv_point_t aa_p;

                aa_p.x = out_x_last;
 800613c:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 8006140:	833b      	strh	r3, [r7, #24]
                aa_p.y = out_y_seg_start;
 8006142:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8006146:	837b      	strh	r3, [r7, #26]

                mix                 = (uint32_t)((uint32_t)(radius - out_x_last) * 255) / height;
 8006148:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 800614c:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 8006150:	1ad3      	subs	r3, r2, r3
 8006152:	461a      	mov	r2, r3
 8006154:	4613      	mov	r3, r2
 8006156:	021b      	lsls	r3, r3, #8
 8006158:	1a9a      	subs	r2, r3, r2
 800615a:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 800615e:	fbb2 f3f3 	udiv	r3, r2, r3
 8006162:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                aa_color_hor_top    = lv_color_mix(gcolor, mcolor, mix);
 8006166:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800616a:	461a      	mov	r2, r3
 800616c:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8006170:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8006174:	f7ff fc32 	bl	80059dc <lv_color_mix>
 8006178:	4603      	mov	r3, r0
 800617a:	84bb      	strh	r3, [r7, #36]	; 0x24
                aa_color_hor_bottom = lv_color_mix(mcolor, gcolor, mix);
 800617c:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8006180:	461a      	mov	r2, r3
 8006182:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8006186:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 800618a:	f7ff fc27 	bl	80059dc <lv_color_mix>
 800618e:	4603      	mov	r3, r0
 8006190:	843b      	strh	r3, [r7, #32]

                lv_coord_t i;
                for(i = 0; i < seg_size; i++) {
 8006192:	2300      	movs	r3, #0
 8006194:	f8a7 3082 	strh.w	r3, [r7, #130]	; 0x82
 8006198:	e147      	b.n	800642a <lv_draw_rect_main_corner+0x62c>
                    lv_opa_t aa_opa;
                    if(seg_size > CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD) { /*Use non-linear opa mapping
 800619a:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 800619e:	2b01      	cmp	r3, #1
 80061a0:	dd0c      	ble.n	80061bc <lv_draw_rect_main_corner+0x3be>
                                                                           on the first segment*/
                        aa_opa = antialias_get_opa_circ(seg_size, i, opa);
 80061a2:	f897 2076 	ldrb.w	r2, [r7, #118]	; 0x76
 80061a6:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 80061aa:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 80061ae:	4618      	mov	r0, r3
 80061b0:	f003 fb7c 	bl	80098ac <antialias_get_opa_circ>
 80061b4:	4603      	mov	r3, r0
 80061b6:	f887 3081 	strb.w	r3, [r7, #129]	; 0x81
 80061ba:	e00f      	b.n	80061dc <lv_draw_rect_main_corner+0x3de>
                    } else {
                        aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 80061bc:	f897 2076 	ldrb.w	r2, [r7, #118]	; 0x76
 80061c0:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 80061c4:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 80061c8:	4618      	mov	r0, r3
 80061ca:	f7fd feb7 	bl	8003f3c <lv_draw_aa_get_opa>
 80061ce:	4603      	mov	r3, r0
 80061d0:	461a      	mov	r2, r3
 80061d2:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80061d6:	1a9b      	subs	r3, r3, r2
 80061d8:	f887 3081 	strb.w	r3, [r7, #129]	; 0x81
                    }

                    lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 80061dc:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 80061e0:	b29a      	uxth	r2, r3
 80061e2:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80061e6:	b29b      	uxth	r3, r3
 80061e8:	4413      	add	r3, r2
 80061ea:	b29a      	uxth	r2, r3
 80061ec:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 80061f0:	4413      	add	r3, r2
 80061f2:	b29b      	uxth	r3, r3
 80061f4:	b218      	sxth	r0, r3
 80061f6:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 80061fa:	b29a      	uxth	r2, r3
 80061fc:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8006200:	b29b      	uxth	r3, r3
 8006202:	4413      	add	r3, r2
 8006204:	b29b      	uxth	r3, r3
 8006206:	3301      	adds	r3, #1
 8006208:	b29b      	uxth	r3, r3
 800620a:	b219      	sxth	r1, r3
 800620c:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 8006210:	9300      	str	r3, [sp, #0]
 8006212:	8c3b      	ldrh	r3, [r7, #32]
 8006214:	68ba      	ldr	r2, [r7, #8]
 8006216:	f7fd ff6a 	bl	80040ee <lv_draw_px>
                               aa_color_hor_bottom, aa_opa);
                    lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 800621a:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 800621e:	b29a      	uxth	r2, r3
 8006220:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8006224:	b29b      	uxth	r3, r3
 8006226:	1ad3      	subs	r3, r2, r3
 8006228:	b29a      	uxth	r2, r3
 800622a:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 800622e:	1ad3      	subs	r3, r2, r3
 8006230:	b29b      	uxth	r3, r3
 8006232:	b218      	sxth	r0, r3
 8006234:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8006238:	b29a      	uxth	r2, r3
 800623a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800623e:	b29b      	uxth	r3, r3
 8006240:	4413      	add	r3, r2
 8006242:	b29b      	uxth	r3, r3
 8006244:	3301      	adds	r3, #1
 8006246:	b29b      	uxth	r3, r3
 8006248:	b219      	sxth	r1, r3
 800624a:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 800624e:	9300      	str	r3, [sp, #0]
 8006250:	8c3b      	ldrh	r3, [r7, #32]
 8006252:	68ba      	ldr	r2, [r7, #8]
 8006254:	f7fd ff4b 	bl	80040ee <lv_draw_px>
                               aa_color_hor_bottom, aa_opa);
                    lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 8006258:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 800625c:	b29a      	uxth	r2, r3
 800625e:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8006262:	b29b      	uxth	r3, r3
 8006264:	1ad3      	subs	r3, r2, r3
 8006266:	b29a      	uxth	r2, r3
 8006268:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 800626c:	1ad3      	subs	r3, r2, r3
 800626e:	b29b      	uxth	r3, r3
 8006270:	b218      	sxth	r0, r3
 8006272:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8006276:	b29a      	uxth	r2, r3
 8006278:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800627c:	b29b      	uxth	r3, r3
 800627e:	1ad3      	subs	r3, r2, r3
 8006280:	b29b      	uxth	r3, r3
 8006282:	3b01      	subs	r3, #1
 8006284:	b29b      	uxth	r3, r3
 8006286:	b219      	sxth	r1, r3
 8006288:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 800628c:	9300      	str	r3, [sp, #0]
 800628e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006290:	68ba      	ldr	r2, [r7, #8]
 8006292:	f7fd ff2c 	bl	80040ee <lv_draw_px>
                               aa_color_hor_top, aa_opa);
                    lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 8006296:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 800629a:	b29a      	uxth	r2, r3
 800629c:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80062a0:	b29b      	uxth	r3, r3
 80062a2:	4413      	add	r3, r2
 80062a4:	b29a      	uxth	r2, r3
 80062a6:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 80062aa:	4413      	add	r3, r2
 80062ac:	b29b      	uxth	r3, r3
 80062ae:	b218      	sxth	r0, r3
 80062b0:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80062b4:	b29a      	uxth	r2, r3
 80062b6:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80062ba:	b29b      	uxth	r3, r3
 80062bc:	1ad3      	subs	r3, r2, r3
 80062be:	b29b      	uxth	r3, r3
 80062c0:	3b01      	subs	r3, #1
 80062c2:	b29b      	uxth	r3, r3
 80062c4:	b219      	sxth	r1, r3
 80062c6:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 80062ca:	9300      	str	r3, [sp, #0]
 80062cc:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80062ce:	68ba      	ldr	r2, [r7, #8]
 80062d0:	f7fd ff0d 	bl	80040ee <lv_draw_px>
                               aa_color_hor_top, aa_opa);

                    mix          = (uint32_t)((uint32_t)(radius - out_y_seg_start + i) * 255) / height;
 80062d4:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 80062d8:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 80062dc:	1ad2      	subs	r2, r2, r3
 80062de:	f9b7 3082 	ldrsh.w	r3, [r7, #130]	; 0x82
 80062e2:	4413      	add	r3, r2
 80062e4:	461a      	mov	r2, r3
 80062e6:	4613      	mov	r3, r2
 80062e8:	021b      	lsls	r3, r3, #8
 80062ea:	1a9a      	subs	r2, r3, r2
 80062ec:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80062f0:	fbb2 f3f3 	udiv	r3, r2, r3
 80062f4:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                    aa_color_ver = lv_color_mix(mcolor, gcolor, mix);
 80062f8:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80062fc:	461a      	mov	r2, r3
 80062fe:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8006302:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8006306:	f7ff fb69 	bl	80059dc <lv_color_mix>
 800630a:	4603      	mov	r3, r0
 800630c:	83bb      	strh	r3, [r7, #28]
                    lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 800630e:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8006312:	b29a      	uxth	r2, r3
 8006314:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8006318:	b29b      	uxth	r3, r3
 800631a:	4413      	add	r3, r2
 800631c:	b29b      	uxth	r3, r3
 800631e:	3301      	adds	r3, #1
 8006320:	b29b      	uxth	r3, r3
 8006322:	b218      	sxth	r0, r3
 8006324:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8006328:	b29a      	uxth	r2, r3
 800632a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800632e:	b29b      	uxth	r3, r3
 8006330:	4413      	add	r3, r2
 8006332:	b29a      	uxth	r2, r3
 8006334:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8006338:	4413      	add	r3, r2
 800633a:	b29b      	uxth	r3, r3
 800633c:	b219      	sxth	r1, r3
 800633e:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 8006342:	9300      	str	r3, [sp, #0]
 8006344:	8bbb      	ldrh	r3, [r7, #28]
 8006346:	68ba      	ldr	r2, [r7, #8]
 8006348:	f7fd fed1 	bl	80040ee <lv_draw_px>
                               aa_color_ver, aa_opa);
                    lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 800634c:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8006350:	b29a      	uxth	r2, r3
 8006352:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8006356:	b29b      	uxth	r3, r3
 8006358:	1ad3      	subs	r3, r2, r3
 800635a:	b29b      	uxth	r3, r3
 800635c:	3b01      	subs	r3, #1
 800635e:	b29b      	uxth	r3, r3
 8006360:	b218      	sxth	r0, r3
 8006362:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8006366:	b29a      	uxth	r2, r3
 8006368:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800636c:	b29b      	uxth	r3, r3
 800636e:	4413      	add	r3, r2
 8006370:	b29a      	uxth	r2, r3
 8006372:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8006376:	4413      	add	r3, r2
 8006378:	b29b      	uxth	r3, r3
 800637a:	b219      	sxth	r1, r3
 800637c:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 8006380:	9300      	str	r3, [sp, #0]
 8006382:	8bbb      	ldrh	r3, [r7, #28]
 8006384:	68ba      	ldr	r2, [r7, #8]
 8006386:	f7fd feb2 	bl	80040ee <lv_draw_px>
                               aa_color_ver, aa_opa);

                    aa_color_ver = lv_color_mix(gcolor, mcolor, mix);
 800638a:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800638e:	461a      	mov	r2, r3
 8006390:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8006394:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8006398:	f7ff fb20 	bl	80059dc <lv_color_mix>
 800639c:	4603      	mov	r3, r0
 800639e:	83bb      	strh	r3, [r7, #28]
                    lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 80063a0:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 80063a4:	b29a      	uxth	r2, r3
 80063a6:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80063aa:	b29b      	uxth	r3, r3
 80063ac:	1ad3      	subs	r3, r2, r3
 80063ae:	b29b      	uxth	r3, r3
 80063b0:	3b01      	subs	r3, #1
 80063b2:	b29b      	uxth	r3, r3
 80063b4:	b218      	sxth	r0, r3
 80063b6:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 80063ba:	b29a      	uxth	r2, r3
 80063bc:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80063c0:	b29b      	uxth	r3, r3
 80063c2:	1ad3      	subs	r3, r2, r3
 80063c4:	b29a      	uxth	r2, r3
 80063c6:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 80063ca:	1ad3      	subs	r3, r2, r3
 80063cc:	b29b      	uxth	r3, r3
 80063ce:	b219      	sxth	r1, r3
 80063d0:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 80063d4:	9300      	str	r3, [sp, #0]
 80063d6:	8bbb      	ldrh	r3, [r7, #28]
 80063d8:	68ba      	ldr	r2, [r7, #8]
 80063da:	f7fd fe88 	bl	80040ee <lv_draw_px>
                               aa_color_ver, aa_opa);
                    lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 80063de:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 80063e2:	b29a      	uxth	r2, r3
 80063e4:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80063e8:	b29b      	uxth	r3, r3
 80063ea:	4413      	add	r3, r2
 80063ec:	b29b      	uxth	r3, r3
 80063ee:	3301      	adds	r3, #1
 80063f0:	b29b      	uxth	r3, r3
 80063f2:	b218      	sxth	r0, r3
 80063f4:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80063f8:	b29a      	uxth	r2, r3
 80063fa:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80063fe:	b29b      	uxth	r3, r3
 8006400:	1ad3      	subs	r3, r2, r3
 8006402:	b29a      	uxth	r2, r3
 8006404:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8006408:	1ad3      	subs	r3, r2, r3
 800640a:	b29b      	uxth	r3, r3
 800640c:	b219      	sxth	r1, r3
 800640e:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 8006412:	9300      	str	r3, [sp, #0]
 8006414:	8bbb      	ldrh	r3, [r7, #28]
 8006416:	68ba      	ldr	r2, [r7, #8]
 8006418:	f7fd fe69 	bl	80040ee <lv_draw_px>
                for(i = 0; i < seg_size; i++) {
 800641c:	f9b7 3082 	ldrsh.w	r3, [r7, #130]	; 0x82
 8006420:	b29b      	uxth	r3, r3
 8006422:	3301      	adds	r3, #1
 8006424:	b29b      	uxth	r3, r3
 8006426:	f8a7 3082 	strh.w	r3, [r7, #130]	; 0x82
 800642a:	f9b7 2082 	ldrsh.w	r2, [r7, #130]	; 0x82
 800642e:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 8006432:	429a      	cmp	r2, r3
 8006434:	f6ff aeb1 	blt.w	800619a <lv_draw_rect_main_corner+0x39c>
                               aa_color_ver, aa_opa);
                }

                out_x_last      = cir.x;
 8006438:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800643a:	f8a7 3084 	strh.w	r3, [r7, #132]	; 0x84
                out_y_seg_start = out_y_seg_end;
 800643e:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 8006442:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
            }
        }
#endif
        uint8_t edge_top_refr = 0;
 8006446:	2300      	movs	r3, #0
 8006448:	f887 3080 	strb.w	r3, [r7, #128]	; 0x80
        uint8_t mid_top_refr  = 0;
 800644c:	2300      	movs	r3, #0
 800644e:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
        uint8_t mid_bot_refr  = 0;
 8006452:	2300      	movs	r3, #0
 8006454:	f887 307e 	strb.w	r3, [r7, #126]	; 0x7e
        uint8_t edge_bot_refr = 0;
 8006458:	2300      	movs	r3, #0
 800645a:	f887 307d 	strb.w	r3, [r7, #125]	; 0x7d

        /* If a new row coming draw the previous
         * The y coordinate can remain the same so wait for a new*/
        if(mid_bot_area.y1 != LV_CIRC_OCT4_Y(cir) + lb_origo.y) mid_bot_refr = 1;
 800645e:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8006462:	461a      	mov	r2, r3
 8006464:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8006468:	4619      	mov	r1, r3
 800646a:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 800646e:	440b      	add	r3, r1
 8006470:	429a      	cmp	r2, r3
 8006472:	d002      	beq.n	800647a <lv_draw_rect_main_corner+0x67c>
 8006474:	2301      	movs	r3, #1
 8006476:	f887 307e 	strb.w	r3, [r7, #126]	; 0x7e

        if(edge_bot_area.y1 != LV_CIRC_OCT2_Y(cir) + lb_origo.y) edge_bot_refr = 1;
 800647a:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 800647e:	461a      	mov	r2, r3
 8006480:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8006484:	4619      	mov	r1, r3
 8006486:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 800648a:	440b      	add	r3, r1
 800648c:	429a      	cmp	r2, r3
 800648e:	d002      	beq.n	8006496 <lv_draw_rect_main_corner+0x698>
 8006490:	2301      	movs	r3, #1
 8006492:	f887 307d 	strb.w	r3, [r7, #125]	; 0x7d

        if(mid_top_area.y1 != LV_CIRC_OCT8_Y(cir) + lt_origo.y) mid_top_refr = 1;
 8006496:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 800649a:	461a      	mov	r2, r3
 800649c:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 80064a0:	4619      	mov	r1, r3
 80064a2:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80064a6:	1acb      	subs	r3, r1, r3
 80064a8:	429a      	cmp	r2, r3
 80064aa:	d002      	beq.n	80064b2 <lv_draw_rect_main_corner+0x6b4>
 80064ac:	2301      	movs	r3, #1
 80064ae:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f

        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
 80064b2:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 80064b6:	461a      	mov	r2, r3
 80064b8:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 80064bc:	4619      	mov	r1, r3
 80064be:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80064c2:	1acb      	subs	r3, r1, r3
 80064c4:	429a      	cmp	r2, r3
 80064c6:	d002      	beq.n	80064ce <lv_draw_rect_main_corner+0x6d0>
 80064c8:	2301      	movs	r3, #1
 80064ca:	f887 3080 	strb.w	r3, [r7, #128]	; 0x80

        /*Draw the areas which are not disabled*/
        if(edge_top_refr != 0) {
 80064ce:	f897 3080 	ldrb.w	r3, [r7, #128]	; 0x80
 80064d2:	2b00      	cmp	r3, #0
 80064d4:	d030      	beq.n	8006538 <lv_draw_rect_main_corner+0x73a>
            if(mcolor.full == gcolor.full)
 80064d6:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 80064da:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 80064de:	429a      	cmp	r2, r3
 80064e0:	d104      	bne.n	80064ec <lv_draw_rect_main_corner+0x6ee>
                act_color = mcolor;
 80064e2:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 80064e6:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 80064ea:	e01c      	b.n	8006526 <lv_draw_rect_main_corner+0x728>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
 80064ec:	68fb      	ldr	r3, [r7, #12]
 80064ee:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80064f2:	461a      	mov	r2, r3
 80064f4:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 80064f8:	1ad3      	subs	r3, r2, r3
 80064fa:	461a      	mov	r2, r3
 80064fc:	4613      	mov	r3, r2
 80064fe:	021b      	lsls	r3, r3, #8
 8006500:	1a9a      	subs	r2, r3, r2
 8006502:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8006506:	fbb2 f3f3 	udiv	r3, r2, r3
 800650a:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 800650e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8006512:	461a      	mov	r2, r3
 8006514:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8006518:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 800651c:	f7ff fa5e 	bl	80059dc <lv_color_mix>
 8006520:	4603      	mov	r3, r0
 8006522:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&edge_top_area, mask, act_color, opa);
 8006526:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 800652a:	f107 0044 	add.w	r0, r7, #68	; 0x44
 800652e:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8006532:	68b9      	ldr	r1, [r7, #8]
 8006534:	f7fd fe74 	bl	8004220 <lv_draw_fill>
        }

        if(mid_top_refr != 0) {
 8006538:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
 800653c:	2b00      	cmp	r3, #0
 800653e:	d030      	beq.n	80065a2 <lv_draw_rect_main_corner+0x7a4>
            if(mcolor.full == gcolor.full)
 8006540:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8006544:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8006548:	429a      	cmp	r2, r3
 800654a:	d104      	bne.n	8006556 <lv_draw_rect_main_corner+0x758>
                act_color = mcolor;
 800654c:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8006550:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8006554:	e01c      	b.n	8006590 <lv_draw_rect_main_corner+0x792>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
 8006556:	68fb      	ldr	r3, [r7, #12]
 8006558:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800655c:	461a      	mov	r2, r3
 800655e:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8006562:	1ad3      	subs	r3, r2, r3
 8006564:	461a      	mov	r2, r3
 8006566:	4613      	mov	r3, r2
 8006568:	021b      	lsls	r3, r3, #8
 800656a:	1a9a      	subs	r2, r3, r2
 800656c:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8006570:	fbb2 f3f3 	udiv	r3, r2, r3
 8006574:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 8006578:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800657c:	461a      	mov	r2, r3
 800657e:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8006582:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8006586:	f7ff fa29 	bl	80059dc <lv_color_mix>
 800658a:	4603      	mov	r3, r0
 800658c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&mid_top_area, mask, act_color, opa);
 8006590:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8006594:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 8006598:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 800659c:	68b9      	ldr	r1, [r7, #8]
 800659e:	f7fd fe3f 	bl	8004220 <lv_draw_fill>
        }

        if(mid_bot_refr != 0) {
 80065a2:	f897 307e 	ldrb.w	r3, [r7, #126]	; 0x7e
 80065a6:	2b00      	cmp	r3, #0
 80065a8:	d030      	beq.n	800660c <lv_draw_rect_main_corner+0x80e>
            if(mcolor.full == gcolor.full)
 80065aa:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 80065ae:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 80065b2:	429a      	cmp	r2, r3
 80065b4:	d104      	bne.n	80065c0 <lv_draw_rect_main_corner+0x7c2>
                act_color = mcolor;
 80065b6:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 80065ba:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 80065be:	e01c      	b.n	80065fa <lv_draw_rect_main_corner+0x7fc>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
 80065c0:	68fb      	ldr	r3, [r7, #12]
 80065c2:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80065c6:	461a      	mov	r2, r3
 80065c8:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80065cc:	1ad3      	subs	r3, r2, r3
 80065ce:	461a      	mov	r2, r3
 80065d0:	4613      	mov	r3, r2
 80065d2:	021b      	lsls	r3, r3, #8
 80065d4:	1a9a      	subs	r2, r3, r2
 80065d6:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80065da:	fbb2 f3f3 	udiv	r3, r2, r3
 80065de:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 80065e2:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80065e6:	461a      	mov	r2, r3
 80065e8:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80065ec:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80065f0:	f7ff f9f4 	bl	80059dc <lv_color_mix>
 80065f4:	4603      	mov	r3, r0
 80065f6:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&mid_bot_area, mask, act_color, opa);
 80065fa:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80065fe:	f107 0034 	add.w	r0, r7, #52	; 0x34
 8006602:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8006606:	68b9      	ldr	r1, [r7, #8]
 8006608:	f7fd fe0a 	bl	8004220 <lv_draw_fill>
        }

        if(edge_bot_refr != 0) {
 800660c:	f897 307d 	ldrb.w	r3, [r7, #125]	; 0x7d
 8006610:	2b00      	cmp	r3, #0
 8006612:	d030      	beq.n	8006676 <lv_draw_rect_main_corner+0x878>

            if(mcolor.full == gcolor.full)
 8006614:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8006618:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800661c:	429a      	cmp	r2, r3
 800661e:	d104      	bne.n	800662a <lv_draw_rect_main_corner+0x82c>
                act_color = mcolor;
 8006620:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8006624:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8006628:	e01c      	b.n	8006664 <lv_draw_rect_main_corner+0x866>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
 800662a:	68fb      	ldr	r3, [r7, #12]
 800662c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8006630:	461a      	mov	r2, r3
 8006632:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 8006636:	1ad3      	subs	r3, r2, r3
 8006638:	461a      	mov	r2, r3
 800663a:	4613      	mov	r3, r2
 800663c:	021b      	lsls	r3, r3, #8
 800663e:	1a9a      	subs	r2, r3, r2
 8006640:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8006644:	fbb2 f3f3 	udiv	r3, r2, r3
 8006648:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 800664c:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8006650:	461a      	mov	r2, r3
 8006652:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8006656:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 800665a:	f7ff f9bf 	bl	80059dc <lv_color_mix>
 800665e:	4603      	mov	r3, r0
 8006660:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&edge_bot_area, mask, act_color, opa);
 8006664:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8006668:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 800666c:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8006670:	68b9      	ldr	r1, [r7, #8]
 8006672:	f7fd fdd5 	bl	8004220 <lv_draw_fill>
        }

        /*Save the current coordinates*/
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8006676:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 800667a:	b29a      	uxth	r2, r3
 800667c:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8006680:	b29b      	uxth	r3, r3
 8006682:	1ad3      	subs	r3, r2, r3
 8006684:	b29b      	uxth	r3, r3
 8006686:	b219      	sxth	r1, r3
 8006688:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 800668c:	b29a      	uxth	r2, r3
 800668e:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8006692:	b29b      	uxth	r3, r3
 8006694:	4413      	add	r3, r2
 8006696:	b29b      	uxth	r3, r3
 8006698:	b21c      	sxth	r4, r3
                    rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 800669a:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 800669e:	b29a      	uxth	r2, r3
 80066a0:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80066a4:	b29b      	uxth	r3, r3
 80066a6:	4413      	add	r3, r2
 80066a8:	b29b      	uxth	r3, r3
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 80066aa:	b21d      	sxth	r5, r3
                    rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 80066ac:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 80066b0:	b29a      	uxth	r2, r3
 80066b2:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80066b6:	b29b      	uxth	r3, r3
 80066b8:	4413      	add	r3, r2
 80066ba:	b29b      	uxth	r3, r3
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 80066bc:	b21b      	sxth	r3, r3
 80066be:	f107 0034 	add.w	r0, r7, #52	; 0x34
 80066c2:	9300      	str	r3, [sp, #0]
 80066c4:	462b      	mov	r3, r5
 80066c6:	4622      	mov	r2, r4
 80066c8:	f005 fcbc 	bl	800c044 <lv_area_set>

        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 80066cc:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 80066d0:	b29a      	uxth	r2, r3
 80066d2:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80066d6:	b29b      	uxth	r3, r3
 80066d8:	1ad3      	subs	r3, r2, r3
 80066da:	b29b      	uxth	r3, r3
 80066dc:	b219      	sxth	r1, r3
 80066de:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 80066e2:	b29a      	uxth	r2, r3
 80066e4:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80066e8:	b29b      	uxth	r3, r3
 80066ea:	4413      	add	r3, r2
 80066ec:	b29b      	uxth	r3, r3
 80066ee:	b21c      	sxth	r4, r3
                    rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 80066f0:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 80066f4:	b29a      	uxth	r2, r3
 80066f6:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80066fa:	b29b      	uxth	r3, r3
 80066fc:	4413      	add	r3, r2
 80066fe:	b29b      	uxth	r3, r3
        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8006700:	b21d      	sxth	r5, r3
                    rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 8006702:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8006706:	b29a      	uxth	r2, r3
 8006708:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 800670c:	b29b      	uxth	r3, r3
 800670e:	4413      	add	r3, r2
 8006710:	b29b      	uxth	r3, r3
        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8006712:	b21b      	sxth	r3, r3
 8006714:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8006718:	9300      	str	r3, [sp, #0]
 800671a:	462b      	mov	r3, r5
 800671c:	4622      	mov	r2, r4
 800671e:	f005 fc91 	bl	800c044 <lv_area_set>

        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8006722:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8006726:	b29a      	uxth	r2, r3
 8006728:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 800672c:	b29b      	uxth	r3, r3
 800672e:	1ad3      	subs	r3, r2, r3
 8006730:	b29b      	uxth	r3, r3
 8006732:	b219      	sxth	r1, r3
 8006734:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8006738:	b29a      	uxth	r2, r3
 800673a:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 800673e:	b29b      	uxth	r3, r3
 8006740:	1ad3      	subs	r3, r2, r3
 8006742:	b29b      	uxth	r3, r3
 8006744:	b21c      	sxth	r4, r3
                    rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 8006746:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 800674a:	b29a      	uxth	r2, r3
 800674c:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8006750:	b29b      	uxth	r3, r3
 8006752:	4413      	add	r3, r2
 8006754:	b29b      	uxth	r3, r3
        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8006756:	b21d      	sxth	r5, r3
                    rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 8006758:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 800675c:	b29a      	uxth	r2, r3
 800675e:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8006762:	b29b      	uxth	r3, r3
 8006764:	1ad3      	subs	r3, r2, r3
 8006766:	b29b      	uxth	r3, r3
        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8006768:	b21b      	sxth	r3, r3
 800676a:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 800676e:	9300      	str	r3, [sp, #0]
 8006770:	462b      	mov	r3, r5
 8006772:	4622      	mov	r2, r4
 8006774:	f005 fc66 	bl	800c044 <lv_area_set>

        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 8006778:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 800677c:	b29a      	uxth	r2, r3
 800677e:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8006782:	b29b      	uxth	r3, r3
 8006784:	1ad3      	subs	r3, r2, r3
 8006786:	b29b      	uxth	r3, r3
 8006788:	b219      	sxth	r1, r3
 800678a:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 800678e:	b29a      	uxth	r2, r3
 8006790:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8006794:	b29b      	uxth	r3, r3
 8006796:	1ad3      	subs	r3, r2, r3
 8006798:	b29b      	uxth	r3, r3
 800679a:	b21c      	sxth	r4, r3
                    rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 800679c:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 80067a0:	b29a      	uxth	r2, r3
 80067a2:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80067a6:	b29b      	uxth	r3, r3
 80067a8:	4413      	add	r3, r2
 80067aa:	b29b      	uxth	r3, r3
        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 80067ac:	b21d      	sxth	r5, r3
                    rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 80067ae:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80067b2:	b29a      	uxth	r2, r3
 80067b4:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80067b8:	b29b      	uxth	r3, r3
 80067ba:	1ad3      	subs	r3, r2, r3
 80067bc:	b29b      	uxth	r3, r3
        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 80067be:	b21b      	sxth	r3, r3
 80067c0:	f107 0044 	add.w	r0, r7, #68	; 0x44
 80067c4:	9300      	str	r3, [sp, #0]
 80067c6:	462b      	mov	r3, r5
 80067c8:	4622      	mov	r2, r4
 80067ca:	f005 fc3b 	bl	800c044 <lv_area_set>

        lv_circ_next(&cir, &cir_tmp);
 80067ce:	f107 0226 	add.w	r2, r7, #38	; 0x26
 80067d2:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80067d6:	4611      	mov	r1, r2
 80067d8:	4618      	mov	r0, r3
 80067da:	f005 fd8d 	bl	800c2f8 <lv_circ_next>
    while(lv_circ_cont(&cir)) {
 80067de:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80067e2:	4618      	mov	r0, r3
 80067e4:	f005 fd73 	bl	800c2ce <lv_circ_cont>
 80067e8:	4603      	mov	r3, r0
 80067ea:	2b00      	cmp	r3, #0
 80067ec:	f47f ac8f 	bne.w	800610e <lv_draw_rect_main_corner+0x310>
    }

    if(mcolor.full == gcolor.full)
 80067f0:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 80067f4:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 80067f8:	429a      	cmp	r2, r3
 80067fa:	d104      	bne.n	8006806 <lv_draw_rect_main_corner+0xa08>
        act_color = mcolor;
 80067fc:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8006800:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8006804:	e01c      	b.n	8006840 <lv_draw_rect_main_corner+0xa42>
    else {
        mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
 8006806:	68fb      	ldr	r3, [r7, #12]
 8006808:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800680c:	461a      	mov	r2, r3
 800680e:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8006812:	1ad3      	subs	r3, r2, r3
 8006814:	461a      	mov	r2, r3
 8006816:	4613      	mov	r3, r2
 8006818:	021b      	lsls	r3, r3, #8
 800681a:	1a9a      	subs	r2, r3, r2
 800681c:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8006820:	fbb2 f3f3 	udiv	r3, r2, r3
 8006824:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
        act_color = lv_color_mix(mcolor, gcolor, mix);
 8006828:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800682c:	461a      	mov	r2, r3
 800682e:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8006832:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8006836:	f7ff f8d1 	bl	80059dc <lv_color_mix>
 800683a:	4603      	mov	r3, r0
 800683c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    }
    lv_draw_fill(&edge_top_area, mask, act_color, opa);
 8006840:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8006844:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8006848:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 800684c:	68b9      	ldr	r1, [r7, #8]
 800684e:	f7fd fce7 	bl	8004220 <lv_draw_fill>

    if(edge_top_area.y1 != mid_top_area.y1) {
 8006852:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 8006856:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 800685a:	429a      	cmp	r2, r3
 800685c:	d030      	beq.n	80068c0 <lv_draw_rect_main_corner+0xac2>

        if(mcolor.full == gcolor.full)
 800685e:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8006862:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8006866:	429a      	cmp	r2, r3
 8006868:	d104      	bne.n	8006874 <lv_draw_rect_main_corner+0xa76>
            act_color = mcolor;
 800686a:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 800686e:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8006872:	e01c      	b.n	80068ae <lv_draw_rect_main_corner+0xab0>
        else {
            mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
 8006874:	68fb      	ldr	r3, [r7, #12]
 8006876:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800687a:	461a      	mov	r2, r3
 800687c:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8006880:	1ad3      	subs	r3, r2, r3
 8006882:	461a      	mov	r2, r3
 8006884:	4613      	mov	r3, r2
 8006886:	021b      	lsls	r3, r3, #8
 8006888:	1a9a      	subs	r2, r3, r2
 800688a:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 800688e:	fbb2 f3f3 	udiv	r3, r2, r3
 8006892:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            act_color = lv_color_mix(mcolor, gcolor, mix);
 8006896:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800689a:	461a      	mov	r2, r3
 800689c:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80068a0:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80068a4:	f7ff f89a 	bl	80059dc <lv_color_mix>
 80068a8:	4603      	mov	r3, r0
 80068aa:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
        }
        lv_draw_fill(&mid_top_area, mask, act_color, opa);
 80068ae:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80068b2:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 80068b6:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 80068ba:	68b9      	ldr	r1, [r7, #8]
 80068bc:	f7fd fcb0 	bl	8004220 <lv_draw_fill>
    }

    if(mcolor.full == gcolor.full)
 80068c0:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 80068c4:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 80068c8:	429a      	cmp	r2, r3
 80068ca:	d104      	bne.n	80068d6 <lv_draw_rect_main_corner+0xad8>
        act_color = mcolor;
 80068cc:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 80068d0:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 80068d4:	e01c      	b.n	8006910 <lv_draw_rect_main_corner+0xb12>
    else {
        mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
 80068d6:	68fb      	ldr	r3, [r7, #12]
 80068d8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80068dc:	461a      	mov	r2, r3
 80068de:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80068e2:	1ad3      	subs	r3, r2, r3
 80068e4:	461a      	mov	r2, r3
 80068e6:	4613      	mov	r3, r2
 80068e8:	021b      	lsls	r3, r3, #8
 80068ea:	1a9a      	subs	r2, r3, r2
 80068ec:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80068f0:	fbb2 f3f3 	udiv	r3, r2, r3
 80068f4:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
        act_color = lv_color_mix(mcolor, gcolor, mix);
 80068f8:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80068fc:	461a      	mov	r2, r3
 80068fe:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8006902:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8006906:	f7ff f869 	bl	80059dc <lv_color_mix>
 800690a:	4603      	mov	r3, r0
 800690c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    }
    lv_draw_fill(&mid_bot_area, mask, act_color, opa);
 8006910:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8006914:	f107 0034 	add.w	r0, r7, #52	; 0x34
 8006918:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 800691c:	68b9      	ldr	r1, [r7, #8]
 800691e:	f7fd fc7f 	bl	8004220 <lv_draw_fill>

    if(edge_bot_area.y1 != mid_bot_area.y1) {
 8006922:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 8006926:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 800692a:	429a      	cmp	r2, r3
 800692c:	d030      	beq.n	8006990 <lv_draw_rect_main_corner+0xb92>

        if(mcolor.full == gcolor.full)
 800692e:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8006932:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8006936:	429a      	cmp	r2, r3
 8006938:	d104      	bne.n	8006944 <lv_draw_rect_main_corner+0xb46>
            act_color = mcolor;
 800693a:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 800693e:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8006942:	e01c      	b.n	800697e <lv_draw_rect_main_corner+0xb80>
        else {
            mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
 8006944:	68fb      	ldr	r3, [r7, #12]
 8006946:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800694a:	461a      	mov	r2, r3
 800694c:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 8006950:	1ad3      	subs	r3, r2, r3
 8006952:	461a      	mov	r2, r3
 8006954:	4613      	mov	r3, r2
 8006956:	021b      	lsls	r3, r3, #8
 8006958:	1a9a      	subs	r2, r3, r2
 800695a:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 800695e:	fbb2 f3f3 	udiv	r3, r2, r3
 8006962:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            act_color = lv_color_mix(mcolor, gcolor, mix);
 8006966:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800696a:	461a      	mov	r2, r3
 800696c:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8006970:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8006974:	f7ff f832 	bl	80059dc <lv_color_mix>
 8006978:	4603      	mov	r3, r0
 800697a:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
        }
        lv_draw_fill(&edge_bot_area, mask, act_color, opa);
 800697e:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8006982:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8006986:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 800698a:	68b9      	ldr	r1, [r7, #8]
 800698c:	f7fd fc48 	bl	8004220 <lv_draw_fill>
    }

#if LV_ANTIALIAS
    if(aa) {
 8006990:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8006994:	2b00      	cmp	r3, #0
 8006996:	f000 8257 	beq.w	8006e48 <lv_draw_rect_main_corner+0x104a>
        /*The first and the last line is not drawn*/
        edge_top_area.x1 = coords->x1 + radius + 2;
 800699a:	68fb      	ldr	r3, [r7, #12]
 800699c:	f9b3 3000 	ldrsh.w	r3, [r3]
 80069a0:	b29a      	uxth	r2, r3
 80069a2:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 80069a6:	4413      	add	r3, r2
 80069a8:	b29b      	uxth	r3, r3
 80069aa:	3302      	adds	r3, #2
 80069ac:	b29b      	uxth	r3, r3
 80069ae:	b21b      	sxth	r3, r3
 80069b0:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
        edge_top_area.x2 = coords->x2 - radius - 2;
 80069b4:	68fb      	ldr	r3, [r7, #12]
 80069b6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80069ba:	b29a      	uxth	r2, r3
 80069bc:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 80069c0:	1ad3      	subs	r3, r2, r3
 80069c2:	b29b      	uxth	r3, r3
 80069c4:	3b02      	subs	r3, #2
 80069c6:	b29b      	uxth	r3, r3
 80069c8:	b21b      	sxth	r3, r3
 80069ca:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
        edge_top_area.y1 = coords->y1;
 80069ce:	68fb      	ldr	r3, [r7, #12]
 80069d0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80069d4:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
        edge_top_area.y2 = coords->y1;
 80069d8:	68fb      	ldr	r3, [r7, #12]
 80069da:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80069de:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
        lv_draw_fill(&edge_top_area, mask, style->body.main_color, opa);
 80069e2:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80069e6:	687a      	ldr	r2, [r7, #4]
 80069e8:	f107 0044 	add.w	r0, r7, #68	; 0x44
 80069ec:	8852      	ldrh	r2, [r2, #2]
 80069ee:	68b9      	ldr	r1, [r7, #8]
 80069f0:	f7fd fc16 	bl	8004220 <lv_draw_fill>

        edge_top_area.y1 = coords->y2;
 80069f4:	68fb      	ldr	r3, [r7, #12]
 80069f6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80069fa:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
        edge_top_area.y2 = coords->y2;
 80069fe:	68fb      	ldr	r3, [r7, #12]
 8006a00:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8006a04:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
        lv_draw_fill(&edge_top_area, mask, style->body.grad_color, opa);
 8006a08:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8006a0c:	687a      	ldr	r2, [r7, #4]
 8006a0e:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8006a12:	8892      	ldrh	r2, [r2, #4]
 8006a14:	68b9      	ldr	r1, [r7, #8]
 8006a16:	f7fd fc03 	bl	8004220 <lv_draw_fill>

        /*Last parts of the anti-alias*/
        out_y_seg_end       = cir.y;
 8006a1a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8006a1c:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
        lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 8006a20:	f8b7 2070 	ldrh.w	r2, [r7, #112]	; 0x70
 8006a24:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8006a28:	1ad3      	subs	r3, r2, r3
 8006a2a:	b29b      	uxth	r3, r3
 8006a2c:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
        lv_point_t aa_p;

        aa_p.x = out_x_last;
 8006a30:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 8006a34:	82bb      	strh	r3, [r7, #20]
        aa_p.y = out_y_seg_start;
 8006a36:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8006a3a:	82fb      	strh	r3, [r7, #22]

        mix                 = (uint32_t)((uint32_t)(radius - out_x_last) * 255) / height;
 8006a3c:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 8006a40:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 8006a44:	1ad3      	subs	r3, r2, r3
 8006a46:	461a      	mov	r2, r3
 8006a48:	4613      	mov	r3, r2
 8006a4a:	021b      	lsls	r3, r3, #8
 8006a4c:	1a9a      	subs	r2, r3, r2
 8006a4e:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8006a52:	fbb2 f3f3 	udiv	r3, r2, r3
 8006a56:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
        aa_color_hor_bottom = lv_color_mix(gcolor, mcolor, mix);
 8006a5a:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8006a5e:	461a      	mov	r2, r3
 8006a60:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8006a64:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8006a68:	f7fe ffb8 	bl	80059dc <lv_color_mix>
 8006a6c:	4603      	mov	r3, r0
 8006a6e:	843b      	strh	r3, [r7, #32]
        aa_color_hor_top    = lv_color_mix(mcolor, gcolor, mix);
 8006a70:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8006a74:	461a      	mov	r2, r3
 8006a76:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8006a7a:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8006a7e:	f7fe ffad 	bl	80059dc <lv_color_mix>
 8006a82:	4603      	mov	r3, r0
 8006a84:	84bb      	strh	r3, [r7, #36]	; 0x24

        lv_coord_t i;
        for(i = 0; i < seg_size; i++) {
 8006a86:	2300      	movs	r3, #0
 8006a88:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a
 8006a8c:	e136      	b.n	8006cfc <lv_draw_rect_main_corner+0xefe>
            lv_opa_t aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 8006a8e:	f897 2076 	ldrb.w	r2, [r7, #118]	; 0x76
 8006a92:	f9b7 107a 	ldrsh.w	r1, [r7, #122]	; 0x7a
 8006a96:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8006a9a:	4618      	mov	r0, r3
 8006a9c:	f7fd fa4e 	bl	8003f3c <lv_draw_aa_get_opa>
 8006aa0:	4603      	mov	r3, r0
 8006aa2:	461a      	mov	r2, r3
 8006aa4:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8006aa8:	1a9b      	subs	r3, r3, r2
 8006aaa:	f887 306a 	strb.w	r3, [r7, #106]	; 0x6a
            lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 8006aae:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8006ab2:	b29a      	uxth	r2, r3
 8006ab4:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006ab8:	b29b      	uxth	r3, r3
 8006aba:	4413      	add	r3, r2
 8006abc:	b29a      	uxth	r2, r3
 8006abe:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8006ac2:	4413      	add	r3, r2
 8006ac4:	b29b      	uxth	r3, r3
 8006ac6:	b218      	sxth	r0, r3
 8006ac8:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8006acc:	b29a      	uxth	r2, r3
 8006ace:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006ad2:	b29b      	uxth	r3, r3
 8006ad4:	4413      	add	r3, r2
 8006ad6:	b29b      	uxth	r3, r3
 8006ad8:	3301      	adds	r3, #1
 8006ada:	b29b      	uxth	r3, r3
 8006adc:	b219      	sxth	r1, r3
 8006ade:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8006ae2:	9300      	str	r3, [sp, #0]
 8006ae4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006ae6:	68ba      	ldr	r2, [r7, #8]
 8006ae8:	f7fd fb01 	bl	80040ee <lv_draw_px>
                       aa_color_hor_top, aa_opa);
            lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 8006aec:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8006af0:	b29a      	uxth	r2, r3
 8006af2:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006af6:	b29b      	uxth	r3, r3
 8006af8:	1ad3      	subs	r3, r2, r3
 8006afa:	b29a      	uxth	r2, r3
 8006afc:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8006b00:	1ad3      	subs	r3, r2, r3
 8006b02:	b29b      	uxth	r3, r3
 8006b04:	b218      	sxth	r0, r3
 8006b06:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8006b0a:	b29a      	uxth	r2, r3
 8006b0c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006b10:	b29b      	uxth	r3, r3
 8006b12:	4413      	add	r3, r2
 8006b14:	b29b      	uxth	r3, r3
 8006b16:	3301      	adds	r3, #1
 8006b18:	b29b      	uxth	r3, r3
 8006b1a:	b219      	sxth	r1, r3
 8006b1c:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8006b20:	9300      	str	r3, [sp, #0]
 8006b22:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006b24:	68ba      	ldr	r2, [r7, #8]
 8006b26:	f7fd fae2 	bl	80040ee <lv_draw_px>
                       aa_color_hor_top, aa_opa);
            lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 8006b2a:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8006b2e:	b29a      	uxth	r2, r3
 8006b30:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006b34:	b29b      	uxth	r3, r3
 8006b36:	1ad3      	subs	r3, r2, r3
 8006b38:	b29a      	uxth	r2, r3
 8006b3a:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8006b3e:	1ad3      	subs	r3, r2, r3
 8006b40:	b29b      	uxth	r3, r3
 8006b42:	b218      	sxth	r0, r3
 8006b44:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8006b48:	b29a      	uxth	r2, r3
 8006b4a:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006b4e:	b29b      	uxth	r3, r3
 8006b50:	1ad3      	subs	r3, r2, r3
 8006b52:	b29b      	uxth	r3, r3
 8006b54:	3b01      	subs	r3, #1
 8006b56:	b29b      	uxth	r3, r3
 8006b58:	b219      	sxth	r1, r3
 8006b5a:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8006b5e:	9300      	str	r3, [sp, #0]
 8006b60:	8c3b      	ldrh	r3, [r7, #32]
 8006b62:	68ba      	ldr	r2, [r7, #8]
 8006b64:	f7fd fac3 	bl	80040ee <lv_draw_px>
                       aa_color_hor_bottom, aa_opa);
            lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 8006b68:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8006b6c:	b29a      	uxth	r2, r3
 8006b6e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006b72:	b29b      	uxth	r3, r3
 8006b74:	4413      	add	r3, r2
 8006b76:	b29a      	uxth	r2, r3
 8006b78:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8006b7c:	4413      	add	r3, r2
 8006b7e:	b29b      	uxth	r3, r3
 8006b80:	b218      	sxth	r0, r3
 8006b82:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8006b86:	b29a      	uxth	r2, r3
 8006b88:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006b8c:	b29b      	uxth	r3, r3
 8006b8e:	1ad3      	subs	r3, r2, r3
 8006b90:	b29b      	uxth	r3, r3
 8006b92:	3b01      	subs	r3, #1
 8006b94:	b29b      	uxth	r3, r3
 8006b96:	b219      	sxth	r1, r3
 8006b98:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8006b9c:	9300      	str	r3, [sp, #0]
 8006b9e:	8c3b      	ldrh	r3, [r7, #32]
 8006ba0:	68ba      	ldr	r2, [r7, #8]
 8006ba2:	f7fd faa4 	bl	80040ee <lv_draw_px>
                       aa_color_hor_bottom, aa_opa);

            mix          = (uint32_t)((uint32_t)(radius - out_y_seg_start + i) * 255) / height;
 8006ba6:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 8006baa:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 8006bae:	1ad2      	subs	r2, r2, r3
 8006bb0:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 8006bb4:	4413      	add	r3, r2
 8006bb6:	461a      	mov	r2, r3
 8006bb8:	4613      	mov	r3, r2
 8006bba:	021b      	lsls	r3, r3, #8
 8006bbc:	1a9a      	subs	r2, r3, r2
 8006bbe:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8006bc2:	fbb2 f3f3 	udiv	r3, r2, r3
 8006bc6:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            aa_color_ver = lv_color_mix(mcolor, gcolor, mix);
 8006bca:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8006bce:	461a      	mov	r2, r3
 8006bd0:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8006bd4:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8006bd8:	f7fe ff00 	bl	80059dc <lv_color_mix>
 8006bdc:	4603      	mov	r3, r0
 8006bde:	83bb      	strh	r3, [r7, #28]
            lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask, aa_color_ver,
 8006be0:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8006be4:	b29a      	uxth	r2, r3
 8006be6:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006bea:	b29b      	uxth	r3, r3
 8006bec:	4413      	add	r3, r2
 8006bee:	b29b      	uxth	r3, r3
 8006bf0:	3301      	adds	r3, #1
 8006bf2:	b29b      	uxth	r3, r3
 8006bf4:	b218      	sxth	r0, r3
 8006bf6:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8006bfa:	b29a      	uxth	r2, r3
 8006bfc:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006c00:	b29b      	uxth	r3, r3
 8006c02:	4413      	add	r3, r2
 8006c04:	b29a      	uxth	r2, r3
 8006c06:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8006c0a:	4413      	add	r3, r2
 8006c0c:	b29b      	uxth	r3, r3
 8006c0e:	b219      	sxth	r1, r3
 8006c10:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8006c14:	9300      	str	r3, [sp, #0]
 8006c16:	8bbb      	ldrh	r3, [r7, #28]
 8006c18:	68ba      	ldr	r2, [r7, #8]
 8006c1a:	f7fd fa68 	bl	80040ee <lv_draw_px>
                       aa_opa);
            lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask, aa_color_ver,
 8006c1e:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8006c22:	b29a      	uxth	r2, r3
 8006c24:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006c28:	b29b      	uxth	r3, r3
 8006c2a:	1ad3      	subs	r3, r2, r3
 8006c2c:	b29b      	uxth	r3, r3
 8006c2e:	3b01      	subs	r3, #1
 8006c30:	b29b      	uxth	r3, r3
 8006c32:	b218      	sxth	r0, r3
 8006c34:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8006c38:	b29a      	uxth	r2, r3
 8006c3a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006c3e:	b29b      	uxth	r3, r3
 8006c40:	4413      	add	r3, r2
 8006c42:	b29a      	uxth	r2, r3
 8006c44:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8006c48:	4413      	add	r3, r2
 8006c4a:	b29b      	uxth	r3, r3
 8006c4c:	b219      	sxth	r1, r3
 8006c4e:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8006c52:	9300      	str	r3, [sp, #0]
 8006c54:	8bbb      	ldrh	r3, [r7, #28]
 8006c56:	68ba      	ldr	r2, [r7, #8]
 8006c58:	f7fd fa49 	bl	80040ee <lv_draw_px>
                       aa_opa);

            aa_color_ver = lv_color_mix(gcolor, mcolor, mix);
 8006c5c:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8006c60:	461a      	mov	r2, r3
 8006c62:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8006c66:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8006c6a:	f7fe feb7 	bl	80059dc <lv_color_mix>
 8006c6e:	4603      	mov	r3, r0
 8006c70:	83bb      	strh	r3, [r7, #28]
            lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask, aa_color_ver,
 8006c72:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8006c76:	b29a      	uxth	r2, r3
 8006c78:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006c7c:	b29b      	uxth	r3, r3
 8006c7e:	1ad3      	subs	r3, r2, r3
 8006c80:	b29b      	uxth	r3, r3
 8006c82:	3b01      	subs	r3, #1
 8006c84:	b29b      	uxth	r3, r3
 8006c86:	b218      	sxth	r0, r3
 8006c88:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8006c8c:	b29a      	uxth	r2, r3
 8006c8e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006c92:	b29b      	uxth	r3, r3
 8006c94:	1ad3      	subs	r3, r2, r3
 8006c96:	b29a      	uxth	r2, r3
 8006c98:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8006c9c:	1ad3      	subs	r3, r2, r3
 8006c9e:	b29b      	uxth	r3, r3
 8006ca0:	b219      	sxth	r1, r3
 8006ca2:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8006ca6:	9300      	str	r3, [sp, #0]
 8006ca8:	8bbb      	ldrh	r3, [r7, #28]
 8006caa:	68ba      	ldr	r2, [r7, #8]
 8006cac:	f7fd fa1f 	bl	80040ee <lv_draw_px>
                       aa_opa);
            lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask, aa_color_ver,
 8006cb0:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8006cb4:	b29a      	uxth	r2, r3
 8006cb6:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006cba:	b29b      	uxth	r3, r3
 8006cbc:	4413      	add	r3, r2
 8006cbe:	b29b      	uxth	r3, r3
 8006cc0:	3301      	adds	r3, #1
 8006cc2:	b29b      	uxth	r3, r3
 8006cc4:	b218      	sxth	r0, r3
 8006cc6:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8006cca:	b29a      	uxth	r2, r3
 8006ccc:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006cd0:	b29b      	uxth	r3, r3
 8006cd2:	1ad3      	subs	r3, r2, r3
 8006cd4:	b29a      	uxth	r2, r3
 8006cd6:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8006cda:	1ad3      	subs	r3, r2, r3
 8006cdc:	b29b      	uxth	r3, r3
 8006cde:	b219      	sxth	r1, r3
 8006ce0:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8006ce4:	9300      	str	r3, [sp, #0]
 8006ce6:	8bbb      	ldrh	r3, [r7, #28]
 8006ce8:	68ba      	ldr	r2, [r7, #8]
 8006cea:	f7fd fa00 	bl	80040ee <lv_draw_px>
        for(i = 0; i < seg_size; i++) {
 8006cee:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 8006cf2:	b29b      	uxth	r3, r3
 8006cf4:	3301      	adds	r3, #1
 8006cf6:	b29b      	uxth	r3, r3
 8006cf8:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a
 8006cfc:	f9b7 207a 	ldrsh.w	r2, [r7, #122]	; 0x7a
 8006d00:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8006d04:	429a      	cmp	r2, r3
 8006d06:	f6ff aec2 	blt.w	8006a8e <lv_draw_rect_main_corner+0xc90>
                       aa_opa);
        }

        /*In some cases the last pixel is not drawn*/
        if(LV_MATH_ABS(aa_p.x - aa_p.y) == seg_size) {
 8006d0a:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006d0e:	461a      	mov	r2, r3
 8006d10:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006d14:	1ad3      	subs	r3, r2, r3
 8006d16:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8006d1a:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 8006d1e:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8006d22:	429a      	cmp	r2, r3
 8006d24:	f040 8090 	bne.w	8006e48 <lv_draw_rect_main_corner+0x104a>
            aa_p.x = out_x_last;
 8006d28:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 8006d2c:	82bb      	strh	r3, [r7, #20]
            aa_p.y = out_x_last;
 8006d2e:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 8006d32:	82fb      	strh	r3, [r7, #22]

            mix                 = (uint32_t)((uint32_t)(out_x_last)*255) / height;
 8006d34:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 8006d38:	4613      	mov	r3, r2
 8006d3a:	021b      	lsls	r3, r3, #8
 8006d3c:	1a9a      	subs	r2, r3, r2
 8006d3e:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8006d42:	fbb2 f3f3 	udiv	r3, r2, r3
 8006d46:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            aa_color_hor_top    = lv_color_mix(gcolor, mcolor, mix);
 8006d4a:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8006d4e:	461a      	mov	r2, r3
 8006d50:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8006d54:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8006d58:	f7fe fe40 	bl	80059dc <lv_color_mix>
 8006d5c:	4603      	mov	r3, r0
 8006d5e:	84bb      	strh	r3, [r7, #36]	; 0x24
            aa_color_hor_bottom = lv_color_mix(mcolor, gcolor, mix);
 8006d60:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8006d64:	461a      	mov	r2, r3
 8006d66:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8006d6a:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8006d6e:	f7fe fe35 	bl	80059dc <lv_color_mix>
 8006d72:	4603      	mov	r3, r0
 8006d74:	843b      	strh	r3, [r7, #32]

            lv_opa_t aa_opa = opa >> 1;
 8006d76:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8006d7a:	085b      	lsrs	r3, r3, #1
 8006d7c:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
            lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p), rb_origo.y + LV_CIRC_OCT2_Y(aa_p), mask, aa_color_hor_bottom,
 8006d80:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8006d84:	b29a      	uxth	r2, r3
 8006d86:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006d8a:	b29b      	uxth	r3, r3
 8006d8c:	4413      	add	r3, r2
 8006d8e:	b29b      	uxth	r3, r3
 8006d90:	b218      	sxth	r0, r3
 8006d92:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8006d96:	b29a      	uxth	r2, r3
 8006d98:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006d9c:	b29b      	uxth	r3, r3
 8006d9e:	4413      	add	r3, r2
 8006da0:	b29b      	uxth	r3, r3
 8006da2:	b219      	sxth	r1, r3
 8006da4:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8006da8:	9300      	str	r3, [sp, #0]
 8006daa:	8c3b      	ldrh	r3, [r7, #32]
 8006dac:	68ba      	ldr	r2, [r7, #8]
 8006dae:	f7fd f99e 	bl	80040ee <lv_draw_px>
                       aa_opa);
            lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p), lb_origo.y + LV_CIRC_OCT4_Y(aa_p), mask, aa_color_hor_bottom,
 8006db2:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8006db6:	b29a      	uxth	r2, r3
 8006db8:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006dbc:	b29b      	uxth	r3, r3
 8006dbe:	1ad3      	subs	r3, r2, r3
 8006dc0:	b29b      	uxth	r3, r3
 8006dc2:	b218      	sxth	r0, r3
 8006dc4:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8006dc8:	b29a      	uxth	r2, r3
 8006dca:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006dce:	b29b      	uxth	r3, r3
 8006dd0:	4413      	add	r3, r2
 8006dd2:	b29b      	uxth	r3, r3
 8006dd4:	b219      	sxth	r1, r3
 8006dd6:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8006dda:	9300      	str	r3, [sp, #0]
 8006ddc:	8c3b      	ldrh	r3, [r7, #32]
 8006dde:	68ba      	ldr	r2, [r7, #8]
 8006de0:	f7fd f985 	bl	80040ee <lv_draw_px>
                       aa_opa);
            lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p), lt_origo.y + LV_CIRC_OCT6_Y(aa_p), mask, aa_color_hor_top,
 8006de4:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8006de8:	b29a      	uxth	r2, r3
 8006dea:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006dee:	b29b      	uxth	r3, r3
 8006df0:	1ad3      	subs	r3, r2, r3
 8006df2:	b29b      	uxth	r3, r3
 8006df4:	b218      	sxth	r0, r3
 8006df6:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8006dfa:	b29a      	uxth	r2, r3
 8006dfc:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006e00:	b29b      	uxth	r3, r3
 8006e02:	1ad3      	subs	r3, r2, r3
 8006e04:	b29b      	uxth	r3, r3
 8006e06:	b219      	sxth	r1, r3
 8006e08:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8006e0c:	9300      	str	r3, [sp, #0]
 8006e0e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006e10:	68ba      	ldr	r2, [r7, #8]
 8006e12:	f7fd f96c 	bl	80040ee <lv_draw_px>
                       aa_opa);
            lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p), rt_origo.y + LV_CIRC_OCT8_Y(aa_p), mask, aa_color_hor_top,
 8006e16:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8006e1a:	b29a      	uxth	r2, r3
 8006e1c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8006e20:	b29b      	uxth	r3, r3
 8006e22:	4413      	add	r3, r2
 8006e24:	b29b      	uxth	r3, r3
 8006e26:	b218      	sxth	r0, r3
 8006e28:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8006e2c:	b29a      	uxth	r2, r3
 8006e2e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8006e32:	b29b      	uxth	r3, r3
 8006e34:	1ad3      	subs	r3, r2, r3
 8006e36:	b29b      	uxth	r3, r3
 8006e38:	b219      	sxth	r1, r3
 8006e3a:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8006e3e:	9300      	str	r3, [sp, #0]
 8006e40:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006e42:	68ba      	ldr	r2, [r7, #8]
 8006e44:	f7fd f953 	bl	80040ee <lv_draw_px>
                       aa_opa);
        }
    }
#endif
}
 8006e48:	bf00      	nop
 8006e4a:	3788      	adds	r7, #136	; 0x88
 8006e4c:	46bd      	mov	sp, r7
 8006e4e:	bdb0      	pop	{r4, r5, r7, pc}

08006e50 <lv_draw_rect_border_straight>:
 * @param rstyle pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_border_straight(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                         lv_opa_t opa_scale)
{
 8006e50:	b580      	push	{r7, lr}
 8006e52:	b08c      	sub	sp, #48	; 0x30
 8006e54:	af00      	add	r7, sp, #0
 8006e56:	60f8      	str	r0, [r7, #12]
 8006e58:	60b9      	str	r1, [r7, #8]
 8006e5a:	607a      	str	r2, [r7, #4]
 8006e5c:	70fb      	strb	r3, [r7, #3]
    uint16_t radius = style->body.radius;
 8006e5e:	687b      	ldr	r3, [r7, #4]
 8006e60:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8006e64:	857b      	strh	r3, [r7, #42]	; 0x2a
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8006e66:	f7fc f875 	bl	8002f54 <lv_refr_get_disp_refreshing>
 8006e6a:	4603      	mov	r3, r0
 8006e6c:	4618      	mov	r0, r3
 8006e6e:	f004 fdf2 	bl	800ba56 <lv_disp_get_antialiasing>
 8006e72:	4603      	mov	r3, r0
 8006e74:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29

    lv_coord_t width  = lv_area_get_width(coords);
 8006e78:	68f8      	ldr	r0, [r7, #12]
 8006e7a:	f7fe fe2e 	bl	8005ada <lv_area_get_width>
 8006e7e:	4603      	mov	r3, r0
 8006e80:	84fb      	strh	r3, [r7, #38]	; 0x26
    lv_coord_t height = lv_area_get_height(coords);
 8006e82:	68f8      	ldr	r0, [r7, #12]
 8006e84:	f7fe fe40 	bl	8005b08 <lv_area_get_height>
 8006e88:	4603      	mov	r3, r0
 8006e8a:	84bb      	strh	r3, [r7, #36]	; 0x24
    lv_coord_t bwidth = style->body.border.width;
 8006e8c:	687b      	ldr	r3, [r7, #4]
 8006e8e:	899b      	ldrh	r3, [r3, #12]
 8006e90:	847b      	strh	r3, [r7, #34]	; 0x22
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
 8006e92:	78fb      	ldrb	r3, [r7, #3]
 8006e94:	2bff      	cmp	r3, #255	; 0xff
 8006e96:	d102      	bne.n	8006e9e <lv_draw_rect_border_straight+0x4e>
 8006e98:	687b      	ldr	r3, [r7, #4]
 8006e9a:	7bdb      	ldrb	r3, [r3, #15]
 8006e9c:	e00a      	b.n	8006eb4 <lv_draw_rect_border_straight+0x64>
                                             : (uint16_t)((uint16_t)style->body.border.opa * opa_scale) >> 8;
 8006e9e:	687b      	ldr	r3, [r7, #4]
 8006ea0:	7bdb      	ldrb	r3, [r3, #15]
 8006ea2:	b29a      	uxth	r2, r3
 8006ea4:	78fb      	ldrb	r3, [r7, #3]
 8006ea6:	b29b      	uxth	r3, r3
 8006ea8:	fb12 f303 	smulbb	r3, r2, r3
 8006eac:	b29b      	uxth	r3, r3
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
 8006eae:	0a1b      	lsrs	r3, r3, #8
 8006eb0:	b29b      	uxth	r3, r3
 8006eb2:	b2db      	uxtb	r3, r3
 8006eb4:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
    lv_border_part_t part = style->body.border.part;
 8006eb8:	687b      	ldr	r3, [r7, #4]
 8006eba:	7b9b      	ldrb	r3, [r3, #14]
 8006ebc:	f887 3020 	strb.w	r3, [r7, #32]
    lv_color_t color      = style->body.border.color;
 8006ec0:	687b      	ldr	r3, [r7, #4]
 8006ec2:	895b      	ldrh	r3, [r3, #10]
 8006ec4:	83bb      	strh	r3, [r7, #28]
    lv_area_t work_area;
    lv_coord_t length_corr = 0;
 8006ec6:	2300      	movs	r3, #0
 8006ec8:	85fb      	strh	r3, [r7, #46]	; 0x2e
    lv_coord_t corner_size = 0;
 8006eca:	2300      	movs	r3, #0
 8006ecc:	85bb      	strh	r3, [r7, #44]	; 0x2c

    /*the 0 px border width drawn as 1 px, so decrement the b_width*/
    bwidth--;
 8006ece:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8006ed2:	b29b      	uxth	r3, r3
 8006ed4:	3b01      	subs	r3, #1
 8006ed6:	b29b      	uxth	r3, r3
 8006ed8:	847b      	strh	r3, [r7, #34]	; 0x22

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8006eda:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8006ede:	f9b7 1026 	ldrsh.w	r1, [r7, #38]	; 0x26
 8006ee2:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8006ee4:	4618      	mov	r0, r3
 8006ee6:	f002 fc9f 	bl	8009828 <lv_draw_cont_radius_corr>
 8006eea:	4603      	mov	r3, r0
 8006eec:	857b      	strh	r3, [r7, #42]	; 0x2a

    if(radius < bwidth) {
 8006eee:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 8006ef0:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8006ef4:	429a      	cmp	r2, r3
 8006ef6:	da0c      	bge.n	8006f12 <lv_draw_rect_border_straight+0xc2>
        length_corr = bwidth - radius - aa;
 8006ef8:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8006efa:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8006efc:	1ad3      	subs	r3, r2, r3
 8006efe:	b29a      	uxth	r2, r3
 8006f00:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8006f04:	b29b      	uxth	r3, r3
 8006f06:	1ad3      	subs	r3, r2, r3
 8006f08:	b29b      	uxth	r3, r3
 8006f0a:	85fb      	strh	r3, [r7, #46]	; 0x2e
        corner_size = bwidth;
 8006f0c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8006f0e:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8006f10:	e006      	b.n	8006f20 <lv_draw_rect_border_straight+0xd0>
    } else {
        corner_size = radius + aa;
 8006f12:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8006f16:	b29a      	uxth	r2, r3
 8006f18:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8006f1a:	4413      	add	r3, r2
 8006f1c:	b29b      	uxth	r3, r3
 8006f1e:	85bb      	strh	r3, [r7, #44]	; 0x2c
    }

    /*If radius == 0 is a special case*/
    if(style->body.radius == 0) {
 8006f20:	687b      	ldr	r3, [r7, #4]
 8006f22:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8006f26:	2b00      	cmp	r3, #0
 8006f28:	f040 80ca 	bne.w	80070c0 <lv_draw_rect_border_straight+0x270>
        /*Left top corner*/
        if(part & LV_BORDER_TOP) {
 8006f2c:	f897 3020 	ldrb.w	r3, [r7, #32]
 8006f30:	f003 0302 	and.w	r3, r3, #2
 8006f34:	2b00      	cmp	r3, #0
 8006f36:	d01c      	beq.n	8006f72 <lv_draw_rect_border_straight+0x122>
            work_area.x1 = coords->x1;
 8006f38:	68fb      	ldr	r3, [r7, #12]
 8006f3a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8006f3e:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8006f40:	68fb      	ldr	r3, [r7, #12]
 8006f42:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8006f46:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1;
 8006f48:	68fb      	ldr	r3, [r7, #12]
 8006f4a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8006f4e:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + bwidth;
 8006f50:	68fb      	ldr	r3, [r7, #12]
 8006f52:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8006f56:	b29a      	uxth	r2, r3
 8006f58:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8006f5a:	4413      	add	r3, r2
 8006f5c:	b29b      	uxth	r3, r3
 8006f5e:	b21b      	sxth	r3, r3
 8006f60:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8006f62:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8006f66:	f107 0014 	add.w	r0, r7, #20
 8006f6a:	8bba      	ldrh	r2, [r7, #28]
 8006f6c:	68b9      	ldr	r1, [r7, #8]
 8006f6e:	f7fd f957 	bl	8004220 <lv_draw_fill>
        }

        /*Right top corner*/
        if(part & LV_BORDER_RIGHT) {
 8006f72:	f897 3020 	ldrb.w	r3, [r7, #32]
 8006f76:	f003 0308 	and.w	r3, r3, #8
 8006f7a:	2b00      	cmp	r3, #0
 8006f7c:	d03a      	beq.n	8006ff4 <lv_draw_rect_border_straight+0x1a4>
            work_area.x1 = coords->x2 - bwidth;
 8006f7e:	68fb      	ldr	r3, [r7, #12]
 8006f80:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8006f84:	b29a      	uxth	r2, r3
 8006f86:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8006f88:	1ad3      	subs	r3, r2, r3
 8006f8a:	b29b      	uxth	r3, r3
 8006f8c:	b21b      	sxth	r3, r3
 8006f8e:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8006f90:	68fb      	ldr	r3, [r7, #12]
 8006f92:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8006f96:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
 8006f98:	68fb      	ldr	r3, [r7, #12]
 8006f9a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8006f9e:	b29a      	uxth	r2, r3
 8006fa0:	f897 3020 	ldrb.w	r3, [r7, #32]
 8006fa4:	f003 0302 	and.w	r3, r3, #2
 8006fa8:	2b00      	cmp	r3, #0
 8006faa:	d003      	beq.n	8006fb4 <lv_draw_rect_border_straight+0x164>
 8006fac:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8006fae:	3301      	adds	r3, #1
 8006fb0:	b29b      	uxth	r3, r3
 8006fb2:	e000      	b.n	8006fb6 <lv_draw_rect_border_straight+0x166>
 8006fb4:	2300      	movs	r3, #0
 8006fb6:	4413      	add	r3, r2
 8006fb8:	b29b      	uxth	r3, r3
 8006fba:	b21b      	sxth	r3, r3
 8006fbc:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
 8006fbe:	68fb      	ldr	r3, [r7, #12]
 8006fc0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8006fc4:	b29a      	uxth	r2, r3
 8006fc6:	f897 3020 	ldrb.w	r3, [r7, #32]
 8006fca:	f003 0301 	and.w	r3, r3, #1
 8006fce:	2b00      	cmp	r3, #0
 8006fd0:	d003      	beq.n	8006fda <lv_draw_rect_border_straight+0x18a>
 8006fd2:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8006fd4:	3301      	adds	r3, #1
 8006fd6:	b29b      	uxth	r3, r3
 8006fd8:	e000      	b.n	8006fdc <lv_draw_rect_border_straight+0x18c>
 8006fda:	2300      	movs	r3, #0
 8006fdc:	1ad3      	subs	r3, r2, r3
 8006fde:	b29b      	uxth	r3, r3
 8006fe0:	b21b      	sxth	r3, r3
 8006fe2:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8006fe4:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8006fe8:	f107 0014 	add.w	r0, r7, #20
 8006fec:	8bba      	ldrh	r2, [r7, #28]
 8006fee:	68b9      	ldr	r1, [r7, #8]
 8006ff0:	f7fd f916 	bl	8004220 <lv_draw_fill>
        }

        /*Left bottom corner*/
        if(part & LV_BORDER_LEFT) {
 8006ff4:	f897 3020 	ldrb.w	r3, [r7, #32]
 8006ff8:	f003 0304 	and.w	r3, r3, #4
 8006ffc:	2b00      	cmp	r3, #0
 8006ffe:	d03a      	beq.n	8007076 <lv_draw_rect_border_straight+0x226>
            work_area.x1 = coords->x1;
 8007000:	68fb      	ldr	r3, [r7, #12]
 8007002:	f9b3 3000 	ldrsh.w	r3, [r3]
 8007006:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + bwidth;
 8007008:	68fb      	ldr	r3, [r7, #12]
 800700a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800700e:	b29a      	uxth	r2, r3
 8007010:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8007012:	4413      	add	r3, r2
 8007014:	b29b      	uxth	r3, r3
 8007016:	b21b      	sxth	r3, r3
 8007018:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
 800701a:	68fb      	ldr	r3, [r7, #12]
 800701c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8007020:	b29a      	uxth	r2, r3
 8007022:	f897 3020 	ldrb.w	r3, [r7, #32]
 8007026:	f003 0302 	and.w	r3, r3, #2
 800702a:	2b00      	cmp	r3, #0
 800702c:	d003      	beq.n	8007036 <lv_draw_rect_border_straight+0x1e6>
 800702e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8007030:	3301      	adds	r3, #1
 8007032:	b29b      	uxth	r3, r3
 8007034:	e000      	b.n	8007038 <lv_draw_rect_border_straight+0x1e8>
 8007036:	2300      	movs	r3, #0
 8007038:	4413      	add	r3, r2
 800703a:	b29b      	uxth	r3, r3
 800703c:	b21b      	sxth	r3, r3
 800703e:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
 8007040:	68fb      	ldr	r3, [r7, #12]
 8007042:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8007046:	b29a      	uxth	r2, r3
 8007048:	f897 3020 	ldrb.w	r3, [r7, #32]
 800704c:	f003 0301 	and.w	r3, r3, #1
 8007050:	2b00      	cmp	r3, #0
 8007052:	d003      	beq.n	800705c <lv_draw_rect_border_straight+0x20c>
 8007054:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8007056:	3301      	adds	r3, #1
 8007058:	b29b      	uxth	r3, r3
 800705a:	e000      	b.n	800705e <lv_draw_rect_border_straight+0x20e>
 800705c:	2300      	movs	r3, #0
 800705e:	1ad3      	subs	r3, r2, r3
 8007060:	b29b      	uxth	r3, r3
 8007062:	b21b      	sxth	r3, r3
 8007064:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8007066:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 800706a:	f107 0014 	add.w	r0, r7, #20
 800706e:	8bba      	ldrh	r2, [r7, #28]
 8007070:	68b9      	ldr	r1, [r7, #8]
 8007072:	f7fd f8d5 	bl	8004220 <lv_draw_fill>
        }

        /*Right bottom corner*/
        if(part & LV_BORDER_BOTTOM) {
 8007076:	f897 3020 	ldrb.w	r3, [r7, #32]
 800707a:	f003 0301 	and.w	r3, r3, #1
 800707e:	2b00      	cmp	r3, #0
 8007080:	f000 828f 	beq.w	80075a2 <lv_draw_rect_border_straight+0x752>
            work_area.x1 = coords->x1;
 8007084:	68fb      	ldr	r3, [r7, #12]
 8007086:	f9b3 3000 	ldrsh.w	r3, [r3]
 800708a:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 800708c:	68fb      	ldr	r3, [r7, #12]
 800708e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8007092:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - bwidth;
 8007094:	68fb      	ldr	r3, [r7, #12]
 8007096:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800709a:	b29a      	uxth	r2, r3
 800709c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800709e:	1ad3      	subs	r3, r2, r3
 80070a0:	b29b      	uxth	r3, r3
 80070a2:	b21b      	sxth	r3, r3
 80070a4:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2;
 80070a6:	68fb      	ldr	r3, [r7, #12]
 80070a8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80070ac:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 80070ae:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80070b2:	f107 0014 	add.w	r0, r7, #20
 80070b6:	8bba      	ldrh	r2, [r7, #28]
 80070b8:	68b9      	ldr	r1, [r7, #8]
 80070ba:	f7fd f8b1 	bl	8004220 <lv_draw_fill>
 80070be:	e271      	b.n	80075a4 <lv_draw_rect_border_straight+0x754>
        }
        return;
    }

    /* Modify the corner_size if corner is drawn */
    corner_size++;
 80070c0:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 80070c4:	b29b      	uxth	r3, r3
 80070c6:	3301      	adds	r3, #1
 80070c8:	b29b      	uxth	r3, r3
 80070ca:	85bb      	strh	r3, [r7, #44]	; 0x2c

    /*Depending one which part's are drawn modify the area lengths */
    if(part & LV_BORDER_TOP)
 80070cc:	f897 3020 	ldrb.w	r3, [r7, #32]
 80070d0:	f003 0302 	and.w	r3, r3, #2
 80070d4:	2b00      	cmp	r3, #0
 80070d6:	d009      	beq.n	80070ec <lv_draw_rect_border_straight+0x29c>
        work_area.y1 = coords->y1 + corner_size;
 80070d8:	68fb      	ldr	r3, [r7, #12]
 80070da:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80070de:	b29a      	uxth	r2, r3
 80070e0:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80070e2:	4413      	add	r3, r2
 80070e4:	b29b      	uxth	r3, r3
 80070e6:	b21b      	sxth	r3, r3
 80070e8:	82fb      	strh	r3, [r7, #22]
 80070ea:	e008      	b.n	80070fe <lv_draw_rect_border_straight+0x2ae>
    else
        work_area.y1 = coords->y1 + radius;
 80070ec:	68fb      	ldr	r3, [r7, #12]
 80070ee:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80070f2:	b29a      	uxth	r2, r3
 80070f4:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80070f6:	4413      	add	r3, r2
 80070f8:	b29b      	uxth	r3, r3
 80070fa:	b21b      	sxth	r3, r3
 80070fc:	82fb      	strh	r3, [r7, #22]

    if(part & LV_BORDER_BOTTOM)
 80070fe:	f897 3020 	ldrb.w	r3, [r7, #32]
 8007102:	f003 0301 	and.w	r3, r3, #1
 8007106:	2b00      	cmp	r3, #0
 8007108:	d009      	beq.n	800711e <lv_draw_rect_border_straight+0x2ce>
        work_area.y2 = coords->y2 - corner_size;
 800710a:	68fb      	ldr	r3, [r7, #12]
 800710c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8007110:	b29a      	uxth	r2, r3
 8007112:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8007114:	1ad3      	subs	r3, r2, r3
 8007116:	b29b      	uxth	r3, r3
 8007118:	b21b      	sxth	r3, r3
 800711a:	837b      	strh	r3, [r7, #26]
 800711c:	e008      	b.n	8007130 <lv_draw_rect_border_straight+0x2e0>
    else
        work_area.y2 = coords->y2 - radius;
 800711e:	68fb      	ldr	r3, [r7, #12]
 8007120:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8007124:	b29a      	uxth	r2, r3
 8007126:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8007128:	1ad3      	subs	r3, r2, r3
 800712a:	b29b      	uxth	r3, r3
 800712c:	b21b      	sxth	r3, r3
 800712e:	837b      	strh	r3, [r7, #26]

    /*Left border*/
    if(part & LV_BORDER_LEFT) {
 8007130:	f897 3020 	ldrb.w	r3, [r7, #32]
 8007134:	f003 0304 	and.w	r3, r3, #4
 8007138:	2b00      	cmp	r3, #0
 800713a:	d013      	beq.n	8007164 <lv_draw_rect_border_straight+0x314>
        work_area.x1 = coords->x1;
 800713c:	68fb      	ldr	r3, [r7, #12]
 800713e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8007142:	82bb      	strh	r3, [r7, #20]
        work_area.x2 = work_area.x1 + bwidth;
 8007144:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8007148:	b29a      	uxth	r2, r3
 800714a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800714c:	4413      	add	r3, r2
 800714e:	b29b      	uxth	r3, r3
 8007150:	b21b      	sxth	r3, r3
 8007152:	833b      	strh	r3, [r7, #24]
        lv_draw_fill(&work_area, mask, color, opa);
 8007154:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8007158:	f107 0014 	add.w	r0, r7, #20
 800715c:	8bba      	ldrh	r2, [r7, #28]
 800715e:	68b9      	ldr	r1, [r7, #8]
 8007160:	f7fd f85e 	bl	8004220 <lv_draw_fill>
    }

    /*Right border*/
    if(part & LV_BORDER_RIGHT) {
 8007164:	f897 3020 	ldrb.w	r3, [r7, #32]
 8007168:	f003 0308 	and.w	r3, r3, #8
 800716c:	2b00      	cmp	r3, #0
 800716e:	d013      	beq.n	8007198 <lv_draw_rect_border_straight+0x348>
        work_area.x2 = coords->x2;
 8007170:	68fb      	ldr	r3, [r7, #12]
 8007172:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8007176:	833b      	strh	r3, [r7, #24]
        work_area.x1 = work_area.x2 - bwidth;
 8007178:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800717c:	b29a      	uxth	r2, r3
 800717e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8007180:	1ad3      	subs	r3, r2, r3
 8007182:	b29b      	uxth	r3, r3
 8007184:	b21b      	sxth	r3, r3
 8007186:	82bb      	strh	r3, [r7, #20]
        lv_draw_fill(&work_area, mask, color, opa);
 8007188:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 800718c:	f107 0014 	add.w	r0, r7, #20
 8007190:	8bba      	ldrh	r2, [r7, #28]
 8007192:	68b9      	ldr	r1, [r7, #8]
 8007194:	f7fd f844 	bl	8004220 <lv_draw_fill>
    }

    work_area.x1 = coords->x1 + corner_size - length_corr;
 8007198:	68fb      	ldr	r3, [r7, #12]
 800719a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800719e:	b29a      	uxth	r2, r3
 80071a0:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80071a2:	4413      	add	r3, r2
 80071a4:	b29a      	uxth	r2, r3
 80071a6:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80071a8:	1ad3      	subs	r3, r2, r3
 80071aa:	b29b      	uxth	r3, r3
 80071ac:	b21b      	sxth	r3, r3
 80071ae:	82bb      	strh	r3, [r7, #20]
    work_area.x2 = coords->x2 - corner_size + length_corr;
 80071b0:	68fb      	ldr	r3, [r7, #12]
 80071b2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80071b6:	b29a      	uxth	r2, r3
 80071b8:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80071ba:	1ad3      	subs	r3, r2, r3
 80071bc:	b29a      	uxth	r2, r3
 80071be:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80071c0:	4413      	add	r3, r2
 80071c2:	b29b      	uxth	r3, r3
 80071c4:	b21b      	sxth	r3, r3
 80071c6:	833b      	strh	r3, [r7, #24]

    /*Upper border*/
    if(part & LV_BORDER_TOP) {
 80071c8:	f897 3020 	ldrb.w	r3, [r7, #32]
 80071cc:	f003 0302 	and.w	r3, r3, #2
 80071d0:	2b00      	cmp	r3, #0
 80071d2:	d014      	beq.n	80071fe <lv_draw_rect_border_straight+0x3ae>
        work_area.y1 = coords->y1;
 80071d4:	68fb      	ldr	r3, [r7, #12]
 80071d6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80071da:	82fb      	strh	r3, [r7, #22]
        work_area.y2 = coords->y1 + bwidth;
 80071dc:	68fb      	ldr	r3, [r7, #12]
 80071de:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80071e2:	b29a      	uxth	r2, r3
 80071e4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80071e6:	4413      	add	r3, r2
 80071e8:	b29b      	uxth	r3, r3
 80071ea:	b21b      	sxth	r3, r3
 80071ec:	837b      	strh	r3, [r7, #26]
        lv_draw_fill(&work_area, mask, color, opa);
 80071ee:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80071f2:	f107 0014 	add.w	r0, r7, #20
 80071f6:	8bba      	ldrh	r2, [r7, #28]
 80071f8:	68b9      	ldr	r1, [r7, #8]
 80071fa:	f7fd f811 	bl	8004220 <lv_draw_fill>
    }

    /*Lower border*/
    if(part & LV_BORDER_BOTTOM) {
 80071fe:	f897 3020 	ldrb.w	r3, [r7, #32]
 8007202:	f003 0301 	and.w	r3, r3, #1
 8007206:	2b00      	cmp	r3, #0
 8007208:	d013      	beq.n	8007232 <lv_draw_rect_border_straight+0x3e2>
        work_area.y2 = coords->y2;
 800720a:	68fb      	ldr	r3, [r7, #12]
 800720c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8007210:	837b      	strh	r3, [r7, #26]
        work_area.y1 = work_area.y2 - bwidth;
 8007212:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8007216:	b29a      	uxth	r2, r3
 8007218:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800721a:	1ad3      	subs	r3, r2, r3
 800721c:	b29b      	uxth	r3, r3
 800721e:	b21b      	sxth	r3, r3
 8007220:	82fb      	strh	r3, [r7, #22]
        lv_draw_fill(&work_area, mask, color, opa);
 8007222:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8007226:	f107 0014 	add.w	r0, r7, #20
 800722a:	8bba      	ldrh	r2, [r7, #28]
 800722c:	68b9      	ldr	r1, [r7, #8]
 800722e:	f7fc fff7 	bl	8004220 <lv_draw_fill>
    }

    /*Draw the a remaining rectangles if the radius is smaller then bwidth */
    if(length_corr != 0) {
 8007232:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 8007236:	2b00      	cmp	r3, #0
 8007238:	f000 80fc 	beq.w	8007434 <lv_draw_rect_border_straight+0x5e4>
        /*Left top correction*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 800723c:	f897 3020 	ldrb.w	r3, [r7, #32]
 8007240:	f003 0302 	and.w	r3, r3, #2
 8007244:	2b00      	cmp	r3, #0
 8007246:	d038      	beq.n	80072ba <lv_draw_rect_border_straight+0x46a>
 8007248:	f897 3020 	ldrb.w	r3, [r7, #32]
 800724c:	f003 0304 	and.w	r3, r3, #4
 8007250:	2b00      	cmp	r3, #0
 8007252:	d032      	beq.n	80072ba <lv_draw_rect_border_straight+0x46a>
            work_area.x1 = coords->x1;
 8007254:	68fb      	ldr	r3, [r7, #12]
 8007256:	f9b3 3000 	ldrsh.w	r3, [r3]
 800725a:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + radius + aa;
 800725c:	68fb      	ldr	r3, [r7, #12]
 800725e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8007262:	b29a      	uxth	r2, r3
 8007264:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8007266:	4413      	add	r3, r2
 8007268:	b29a      	uxth	r2, r3
 800726a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 800726e:	b29b      	uxth	r3, r3
 8007270:	4413      	add	r3, r2
 8007272:	b29b      	uxth	r3, r3
 8007274:	b21b      	sxth	r3, r3
 8007276:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + radius + 1 + aa;
 8007278:	68fb      	ldr	r3, [r7, #12]
 800727a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800727e:	b29a      	uxth	r2, r3
 8007280:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8007282:	4413      	add	r3, r2
 8007284:	b29a      	uxth	r2, r3
 8007286:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 800728a:	b29b      	uxth	r3, r3
 800728c:	4413      	add	r3, r2
 800728e:	b29b      	uxth	r3, r3
 8007290:	3301      	adds	r3, #1
 8007292:	b29b      	uxth	r3, r3
 8007294:	b21b      	sxth	r3, r3
 8007296:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + bwidth;
 8007298:	68fb      	ldr	r3, [r7, #12]
 800729a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800729e:	b29a      	uxth	r2, r3
 80072a0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80072a2:	4413      	add	r3, r2
 80072a4:	b29b      	uxth	r3, r3
 80072a6:	b21b      	sxth	r3, r3
 80072a8:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 80072aa:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80072ae:	f107 0014 	add.w	r0, r7, #20
 80072b2:	8bba      	ldrh	r2, [r7, #28]
 80072b4:	68b9      	ldr	r1, [r7, #8]
 80072b6:	f7fc ffb3 	bl	8004220 <lv_draw_fill>
        }

        /*Right top correction*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 80072ba:	f897 3020 	ldrb.w	r3, [r7, #32]
 80072be:	f003 0302 	and.w	r3, r3, #2
 80072c2:	2b00      	cmp	r3, #0
 80072c4:	d038      	beq.n	8007338 <lv_draw_rect_border_straight+0x4e8>
 80072c6:	f897 3020 	ldrb.w	r3, [r7, #32]
 80072ca:	f003 0308 	and.w	r3, r3, #8
 80072ce:	2b00      	cmp	r3, #0
 80072d0:	d032      	beq.n	8007338 <lv_draw_rect_border_straight+0x4e8>
            work_area.x1 = coords->x2 - radius - aa;
 80072d2:	68fb      	ldr	r3, [r7, #12]
 80072d4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80072d8:	b29a      	uxth	r2, r3
 80072da:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80072dc:	1ad3      	subs	r3, r2, r3
 80072de:	b29a      	uxth	r2, r3
 80072e0:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80072e4:	b29b      	uxth	r3, r3
 80072e6:	1ad3      	subs	r3, r2, r3
 80072e8:	b29b      	uxth	r3, r3
 80072ea:	b21b      	sxth	r3, r3
 80072ec:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 80072ee:	68fb      	ldr	r3, [r7, #12]
 80072f0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80072f4:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + radius + 1 + aa;
 80072f6:	68fb      	ldr	r3, [r7, #12]
 80072f8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80072fc:	b29a      	uxth	r2, r3
 80072fe:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8007300:	4413      	add	r3, r2
 8007302:	b29a      	uxth	r2, r3
 8007304:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8007308:	b29b      	uxth	r3, r3
 800730a:	4413      	add	r3, r2
 800730c:	b29b      	uxth	r3, r3
 800730e:	3301      	adds	r3, #1
 8007310:	b29b      	uxth	r3, r3
 8007312:	b21b      	sxth	r3, r3
 8007314:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + bwidth;
 8007316:	68fb      	ldr	r3, [r7, #12]
 8007318:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800731c:	b29a      	uxth	r2, r3
 800731e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8007320:	4413      	add	r3, r2
 8007322:	b29b      	uxth	r3, r3
 8007324:	b21b      	sxth	r3, r3
 8007326:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8007328:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 800732c:	f107 0014 	add.w	r0, r7, #20
 8007330:	8bba      	ldrh	r2, [r7, #28]
 8007332:	68b9      	ldr	r1, [r7, #8]
 8007334:	f7fc ff74 	bl	8004220 <lv_draw_fill>
        }

        /*Left bottom correction*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8007338:	f897 3020 	ldrb.w	r3, [r7, #32]
 800733c:	f003 0301 	and.w	r3, r3, #1
 8007340:	2b00      	cmp	r3, #0
 8007342:	d038      	beq.n	80073b6 <lv_draw_rect_border_straight+0x566>
 8007344:	f897 3020 	ldrb.w	r3, [r7, #32]
 8007348:	f003 0304 	and.w	r3, r3, #4
 800734c:	2b00      	cmp	r3, #0
 800734e:	d032      	beq.n	80073b6 <lv_draw_rect_border_straight+0x566>
            work_area.x1 = coords->x1;
 8007350:	68fb      	ldr	r3, [r7, #12]
 8007352:	f9b3 3000 	ldrsh.w	r3, [r3]
 8007356:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + radius + aa;
 8007358:	68fb      	ldr	r3, [r7, #12]
 800735a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800735e:	b29a      	uxth	r2, r3
 8007360:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8007362:	4413      	add	r3, r2
 8007364:	b29a      	uxth	r2, r3
 8007366:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 800736a:	b29b      	uxth	r3, r3
 800736c:	4413      	add	r3, r2
 800736e:	b29b      	uxth	r3, r3
 8007370:	b21b      	sxth	r3, r3
 8007372:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - bwidth;
 8007374:	68fb      	ldr	r3, [r7, #12]
 8007376:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800737a:	b29a      	uxth	r2, r3
 800737c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800737e:	1ad3      	subs	r3, r2, r3
 8007380:	b29b      	uxth	r3, r3
 8007382:	b21b      	sxth	r3, r3
 8007384:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - radius - 1 - aa;
 8007386:	68fb      	ldr	r3, [r7, #12]
 8007388:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800738c:	b29a      	uxth	r2, r3
 800738e:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8007390:	1ad3      	subs	r3, r2, r3
 8007392:	b29a      	uxth	r2, r3
 8007394:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8007398:	b29b      	uxth	r3, r3
 800739a:	1ad3      	subs	r3, r2, r3
 800739c:	b29b      	uxth	r3, r3
 800739e:	3b01      	subs	r3, #1
 80073a0:	b29b      	uxth	r3, r3
 80073a2:	b21b      	sxth	r3, r3
 80073a4:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 80073a6:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80073aa:	f107 0014 	add.w	r0, r7, #20
 80073ae:	8bba      	ldrh	r2, [r7, #28]
 80073b0:	68b9      	ldr	r1, [r7, #8]
 80073b2:	f7fc ff35 	bl	8004220 <lv_draw_fill>
        }

        /*Right bottom correction*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 80073b6:	f897 3020 	ldrb.w	r3, [r7, #32]
 80073ba:	f003 0301 	and.w	r3, r3, #1
 80073be:	2b00      	cmp	r3, #0
 80073c0:	d038      	beq.n	8007434 <lv_draw_rect_border_straight+0x5e4>
 80073c2:	f897 3020 	ldrb.w	r3, [r7, #32]
 80073c6:	f003 0308 	and.w	r3, r3, #8
 80073ca:	2b00      	cmp	r3, #0
 80073cc:	d032      	beq.n	8007434 <lv_draw_rect_border_straight+0x5e4>
            work_area.x1 = coords->x2 - radius - aa;
 80073ce:	68fb      	ldr	r3, [r7, #12]
 80073d0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80073d4:	b29a      	uxth	r2, r3
 80073d6:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80073d8:	1ad3      	subs	r3, r2, r3
 80073da:	b29a      	uxth	r2, r3
 80073dc:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80073e0:	b29b      	uxth	r3, r3
 80073e2:	1ad3      	subs	r3, r2, r3
 80073e4:	b29b      	uxth	r3, r3
 80073e6:	b21b      	sxth	r3, r3
 80073e8:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 80073ea:	68fb      	ldr	r3, [r7, #12]
 80073ec:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80073f0:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - bwidth;
 80073f2:	68fb      	ldr	r3, [r7, #12]
 80073f4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80073f8:	b29a      	uxth	r2, r3
 80073fa:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80073fc:	1ad3      	subs	r3, r2, r3
 80073fe:	b29b      	uxth	r3, r3
 8007400:	b21b      	sxth	r3, r3
 8007402:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - radius - 1 - aa;
 8007404:	68fb      	ldr	r3, [r7, #12]
 8007406:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800740a:	b29a      	uxth	r2, r3
 800740c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800740e:	1ad3      	subs	r3, r2, r3
 8007410:	b29a      	uxth	r2, r3
 8007412:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8007416:	b29b      	uxth	r3, r3
 8007418:	1ad3      	subs	r3, r2, r3
 800741a:	b29b      	uxth	r3, r3
 800741c:	3b01      	subs	r3, #1
 800741e:	b29b      	uxth	r3, r3
 8007420:	b21b      	sxth	r3, r3
 8007422:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8007424:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8007428:	f107 0014 	add.w	r0, r7, #20
 800742c:	8bba      	ldrh	r2, [r7, #28]
 800742e:	68b9      	ldr	r1, [r7, #8]
 8007430:	f7fc fef6 	bl	8004220 <lv_draw_fill>
        }
    }

    /*If radius == 0 one px on the corners are not drawn by main drawer*/
    if(style->body.radius == 0) {
 8007434:	687b      	ldr	r3, [r7, #4]
 8007436:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800743a:	2b00      	cmp	r3, #0
 800743c:	f040 80b2 	bne.w	80075a4 <lv_draw_rect_border_straight+0x754>
        /*Left top corner*/
        if(part & (LV_BORDER_TOP | LV_BORDER_LEFT)) {
 8007440:	f897 3020 	ldrb.w	r3, [r7, #32]
 8007444:	f003 0306 	and.w	r3, r3, #6
 8007448:	2b00      	cmp	r3, #0
 800744a:	d025      	beq.n	8007498 <lv_draw_rect_border_straight+0x648>
            work_area.x1 = coords->x1;
 800744c:	68fb      	ldr	r3, [r7, #12]
 800744e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8007452:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + aa;
 8007454:	68fb      	ldr	r3, [r7, #12]
 8007456:	f9b3 3000 	ldrsh.w	r3, [r3]
 800745a:	b29a      	uxth	r2, r3
 800745c:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8007460:	b29b      	uxth	r3, r3
 8007462:	4413      	add	r3, r2
 8007464:	b29b      	uxth	r3, r3
 8007466:	b21b      	sxth	r3, r3
 8007468:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1;
 800746a:	68fb      	ldr	r3, [r7, #12]
 800746c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8007470:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + aa;
 8007472:	68fb      	ldr	r3, [r7, #12]
 8007474:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8007478:	b29a      	uxth	r2, r3
 800747a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 800747e:	b29b      	uxth	r3, r3
 8007480:	4413      	add	r3, r2
 8007482:	b29b      	uxth	r3, r3
 8007484:	b21b      	sxth	r3, r3
 8007486:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8007488:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 800748c:	f107 0014 	add.w	r0, r7, #20
 8007490:	8bba      	ldrh	r2, [r7, #28]
 8007492:	68b9      	ldr	r1, [r7, #8]
 8007494:	f7fc fec4 	bl	8004220 <lv_draw_fill>
        }

        /*Right top corner*/
        if(part & (LV_BORDER_TOP | LV_BORDER_RIGHT)) {
 8007498:	f897 3020 	ldrb.w	r3, [r7, #32]
 800749c:	f003 030a 	and.w	r3, r3, #10
 80074a0:	2b00      	cmp	r3, #0
 80074a2:	d025      	beq.n	80074f0 <lv_draw_rect_border_straight+0x6a0>
            work_area.x1 = coords->x2 - aa;
 80074a4:	68fb      	ldr	r3, [r7, #12]
 80074a6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80074aa:	b29a      	uxth	r2, r3
 80074ac:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80074b0:	b29b      	uxth	r3, r3
 80074b2:	1ad3      	subs	r3, r2, r3
 80074b4:	b29b      	uxth	r3, r3
 80074b6:	b21b      	sxth	r3, r3
 80074b8:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 80074ba:	68fb      	ldr	r3, [r7, #12]
 80074bc:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80074c0:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1;
 80074c2:	68fb      	ldr	r3, [r7, #12]
 80074c4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80074c8:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + aa;
 80074ca:	68fb      	ldr	r3, [r7, #12]
 80074cc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80074d0:	b29a      	uxth	r2, r3
 80074d2:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80074d6:	b29b      	uxth	r3, r3
 80074d8:	4413      	add	r3, r2
 80074da:	b29b      	uxth	r3, r3
 80074dc:	b21b      	sxth	r3, r3
 80074de:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 80074e0:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80074e4:	f107 0014 	add.w	r0, r7, #20
 80074e8:	8bba      	ldrh	r2, [r7, #28]
 80074ea:	68b9      	ldr	r1, [r7, #8]
 80074ec:	f7fc fe98 	bl	8004220 <lv_draw_fill>
        }

        /*Left bottom corner*/
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_LEFT)) {
 80074f0:	f897 3020 	ldrb.w	r3, [r7, #32]
 80074f4:	f003 0305 	and.w	r3, r3, #5
 80074f8:	2b00      	cmp	r3, #0
 80074fa:	d025      	beq.n	8007548 <lv_draw_rect_border_straight+0x6f8>
            work_area.x1 = coords->x1;
 80074fc:	68fb      	ldr	r3, [r7, #12]
 80074fe:	f9b3 3000 	ldrsh.w	r3, [r3]
 8007502:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + aa;
 8007504:	68fb      	ldr	r3, [r7, #12]
 8007506:	f9b3 3000 	ldrsh.w	r3, [r3]
 800750a:	b29a      	uxth	r2, r3
 800750c:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8007510:	b29b      	uxth	r3, r3
 8007512:	4413      	add	r3, r2
 8007514:	b29b      	uxth	r3, r3
 8007516:	b21b      	sxth	r3, r3
 8007518:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - aa;
 800751a:	68fb      	ldr	r3, [r7, #12]
 800751c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8007520:	b29a      	uxth	r2, r3
 8007522:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8007526:	b29b      	uxth	r3, r3
 8007528:	1ad3      	subs	r3, r2, r3
 800752a:	b29b      	uxth	r3, r3
 800752c:	b21b      	sxth	r3, r3
 800752e:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2;
 8007530:	68fb      	ldr	r3, [r7, #12]
 8007532:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8007536:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8007538:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 800753c:	f107 0014 	add.w	r0, r7, #20
 8007540:	8bba      	ldrh	r2, [r7, #28]
 8007542:	68b9      	ldr	r1, [r7, #8]
 8007544:	f7fc fe6c 	bl	8004220 <lv_draw_fill>
        }

        /*Right bottom corner*/
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_RIGHT)) {
 8007548:	f897 3020 	ldrb.w	r3, [r7, #32]
 800754c:	f003 0309 	and.w	r3, r3, #9
 8007550:	2b00      	cmp	r3, #0
 8007552:	d027      	beq.n	80075a4 <lv_draw_rect_border_straight+0x754>
            work_area.x1 = coords->x2 - aa;
 8007554:	68fb      	ldr	r3, [r7, #12]
 8007556:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800755a:	b29a      	uxth	r2, r3
 800755c:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8007560:	b29b      	uxth	r3, r3
 8007562:	1ad3      	subs	r3, r2, r3
 8007564:	b29b      	uxth	r3, r3
 8007566:	b21b      	sxth	r3, r3
 8007568:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 800756a:	68fb      	ldr	r3, [r7, #12]
 800756c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8007570:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - aa;
 8007572:	68fb      	ldr	r3, [r7, #12]
 8007574:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8007578:	b29a      	uxth	r2, r3
 800757a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 800757e:	b29b      	uxth	r3, r3
 8007580:	1ad3      	subs	r3, r2, r3
 8007582:	b29b      	uxth	r3, r3
 8007584:	b21b      	sxth	r3, r3
 8007586:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2;
 8007588:	68fb      	ldr	r3, [r7, #12]
 800758a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800758e:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8007590:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8007594:	f107 0014 	add.w	r0, r7, #20
 8007598:	8bba      	ldrh	r2, [r7, #28]
 800759a:	68b9      	ldr	r1, [r7, #8]
 800759c:	f7fc fe40 	bl	8004220 <lv_draw_fill>
 80075a0:	e000      	b.n	80075a4 <lv_draw_rect_border_straight+0x754>
        return;
 80075a2:	bf00      	nop
        }
    }
}
 80075a4:	3730      	adds	r7, #48	; 0x30
 80075a6:	46bd      	mov	sp, r7
 80075a8:	bd80      	pop	{r7, pc}

080075aa <lv_draw_rect_border_corner>:
 * @param style pointer to a style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_border_corner(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                       lv_opa_t opa_scale)
{
 80075aa:	b580      	push	{r7, lr}
 80075ac:	b0a0      	sub	sp, #128	; 0x80
 80075ae:	af02      	add	r7, sp, #8
 80075b0:	60f8      	str	r0, [r7, #12]
 80075b2:	60b9      	str	r1, [r7, #8]
 80075b4:	607a      	str	r2, [r7, #4]
 80075b6:	70fb      	strb	r3, [r7, #3]
    uint16_t radius       = style->body.radius;
 80075b8:	687b      	ldr	r3, [r7, #4]
 80075ba:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80075be:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    bool aa               = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 80075c2:	f7fb fcc7 	bl	8002f54 <lv_refr_get_disp_refreshing>
 80075c6:	4603      	mov	r3, r0
 80075c8:	4618      	mov	r0, r3
 80075ca:	f004 fa44 	bl	800ba56 <lv_disp_get_antialiasing>
 80075ce:	4603      	mov	r3, r0
 80075d0:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
    lv_coord_t bwidth     = style->body.border.width;
 80075d4:	687b      	ldr	r3, [r7, #4]
 80075d6:	899b      	ldrh	r3, [r3, #12]
 80075d8:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
    lv_color_t color      = style->body.border.color;
 80075dc:	687b      	ldr	r3, [r7, #4]
 80075de:	895b      	ldrh	r3, [r3, #10]
 80075e0:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
    lv_border_part_t part = style->body.border.part;
 80075e4:	687b      	ldr	r3, [r7, #4]
 80075e6:	7b9b      	ldrb	r3, [r3, #14]
 80075e8:	f887 305a 	strb.w	r3, [r7, #90]	; 0x5a
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
 80075ec:	78fb      	ldrb	r3, [r7, #3]
 80075ee:	2bff      	cmp	r3, #255	; 0xff
 80075f0:	d102      	bne.n	80075f8 <lv_draw_rect_border_corner+0x4e>
 80075f2:	687b      	ldr	r3, [r7, #4]
 80075f4:	7bdb      	ldrb	r3, [r3, #15]
 80075f6:	e00a      	b.n	800760e <lv_draw_rect_border_corner+0x64>
                                             : (uint16_t)((uint16_t)style->body.border.opa * opa_scale) >> 8;
 80075f8:	687b      	ldr	r3, [r7, #4]
 80075fa:	7bdb      	ldrb	r3, [r3, #15]
 80075fc:	b29a      	uxth	r2, r3
 80075fe:	78fb      	ldrb	r3, [r7, #3]
 8007600:	b29b      	uxth	r3, r3
 8007602:	fb12 f303 	smulbb	r3, r2, r3
 8007606:	b29b      	uxth	r3, r3
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
 8007608:	0a1b      	lsrs	r3, r3, #8
 800760a:	b29b      	uxth	r3, r3
 800760c:	b2db      	uxtb	r3, r3
 800760e:	f887 3059 	strb.w	r3, [r7, #89]	; 0x59
    /*0 px border width drawn as 1 px, so decrement the bwidth*/
    bwidth--;
 8007612:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8007616:	b29b      	uxth	r3, r3
 8007618:	3b01      	subs	r3, #1
 800761a:	b29b      	uxth	r3, r3
 800761c:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

#if LV_ANTIALIAS
    if(aa) bwidth--; /*Because of anti-aliasing the border seems one pixel ticker*/
 8007620:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8007624:	2b00      	cmp	r3, #0
 8007626:	d006      	beq.n	8007636 <lv_draw_rect_border_corner+0x8c>
 8007628:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 800762c:	b29b      	uxth	r3, r3
 800762e:	3b01      	subs	r3, #1
 8007630:	b29b      	uxth	r3, r3
 8007632:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
#endif

    lv_coord_t width  = lv_area_get_width(coords);
 8007636:	68f8      	ldr	r0, [r7, #12]
 8007638:	f7fe fa4f 	bl	8005ada <lv_area_get_width>
 800763c:	4603      	mov	r3, r0
 800763e:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
    lv_coord_t height = lv_area_get_height(coords);
 8007642:	68f8      	ldr	r0, [r7, #12]
 8007644:	f7fe fa60 	bl	8005b08 <lv_area_get_height>
 8007648:	4603      	mov	r3, r0
 800764a:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54

    radius = lv_draw_cont_radius_corr(radius, width, height);
 800764e:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 8007652:	f9b7 1056 	ldrsh.w	r1, [r7, #86]	; 0x56
 8007656:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 800765a:	4618      	mov	r0, r3
 800765c:	f002 f8e4 	bl	8009828 <lv_draw_cont_radius_corr>
 8007660:	4603      	mov	r3, r0
 8007662:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    lv_point_t lt_origo; /*Left  Top    origo*/
    lv_point_t lb_origo; /*Left  Bottom origo*/
    lv_point_t rt_origo; /*Right Top    origo*/
    lv_point_t rb_origo; /*Left  Bottom origo*/

    lt_origo.x = coords->x1 + radius + aa;
 8007666:	68fb      	ldr	r3, [r7, #12]
 8007668:	f9b3 3000 	ldrsh.w	r3, [r3]
 800766c:	b29a      	uxth	r2, r3
 800766e:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8007672:	4413      	add	r3, r2
 8007674:	b29a      	uxth	r2, r3
 8007676:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 800767a:	b29b      	uxth	r3, r3
 800767c:	4413      	add	r3, r2
 800767e:	b29b      	uxth	r3, r3
 8007680:	b21b      	sxth	r3, r3
 8007682:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
    lt_origo.y = coords->y1 + radius + aa;
 8007686:	68fb      	ldr	r3, [r7, #12]
 8007688:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800768c:	b29a      	uxth	r2, r3
 800768e:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8007692:	4413      	add	r3, r2
 8007694:	b29a      	uxth	r2, r3
 8007696:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 800769a:	b29b      	uxth	r3, r3
 800769c:	4413      	add	r3, r2
 800769e:	b29b      	uxth	r3, r3
 80076a0:	b21b      	sxth	r3, r3
 80076a2:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42

    lb_origo.x = coords->x1 + radius + aa;
 80076a6:	68fb      	ldr	r3, [r7, #12]
 80076a8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80076ac:	b29a      	uxth	r2, r3
 80076ae:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80076b2:	4413      	add	r3, r2
 80076b4:	b29a      	uxth	r2, r3
 80076b6:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 80076ba:	b29b      	uxth	r3, r3
 80076bc:	4413      	add	r3, r2
 80076be:	b29b      	uxth	r3, r3
 80076c0:	b21b      	sxth	r3, r3
 80076c2:	87bb      	strh	r3, [r7, #60]	; 0x3c
    lb_origo.y = coords->y2 - radius - aa;
 80076c4:	68fb      	ldr	r3, [r7, #12]
 80076c6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80076ca:	b29a      	uxth	r2, r3
 80076cc:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80076d0:	1ad3      	subs	r3, r2, r3
 80076d2:	b29a      	uxth	r2, r3
 80076d4:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 80076d8:	b29b      	uxth	r3, r3
 80076da:	1ad3      	subs	r3, r2, r3
 80076dc:	b29b      	uxth	r3, r3
 80076de:	b21b      	sxth	r3, r3
 80076e0:	87fb      	strh	r3, [r7, #62]	; 0x3e

    rt_origo.x = coords->x2 - radius - aa;
 80076e2:	68fb      	ldr	r3, [r7, #12]
 80076e4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80076e8:	b29a      	uxth	r2, r3
 80076ea:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80076ee:	1ad3      	subs	r3, r2, r3
 80076f0:	b29a      	uxth	r2, r3
 80076f2:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 80076f6:	b29b      	uxth	r3, r3
 80076f8:	1ad3      	subs	r3, r2, r3
 80076fa:	b29b      	uxth	r3, r3
 80076fc:	b21b      	sxth	r3, r3
 80076fe:	873b      	strh	r3, [r7, #56]	; 0x38
    rt_origo.y = coords->y1 + radius + aa;
 8007700:	68fb      	ldr	r3, [r7, #12]
 8007702:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8007706:	b29a      	uxth	r2, r3
 8007708:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 800770c:	4413      	add	r3, r2
 800770e:	b29a      	uxth	r2, r3
 8007710:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8007714:	b29b      	uxth	r3, r3
 8007716:	4413      	add	r3, r2
 8007718:	b29b      	uxth	r3, r3
 800771a:	b21b      	sxth	r3, r3
 800771c:	877b      	strh	r3, [r7, #58]	; 0x3a

    rb_origo.x = coords->x2 - radius - aa;
 800771e:	68fb      	ldr	r3, [r7, #12]
 8007720:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8007724:	b29a      	uxth	r2, r3
 8007726:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 800772a:	1ad3      	subs	r3, r2, r3
 800772c:	b29a      	uxth	r2, r3
 800772e:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8007732:	b29b      	uxth	r3, r3
 8007734:	1ad3      	subs	r3, r2, r3
 8007736:	b29b      	uxth	r3, r3
 8007738:	b21b      	sxth	r3, r3
 800773a:	86bb      	strh	r3, [r7, #52]	; 0x34
    rb_origo.y = coords->y2 - radius - aa;
 800773c:	68fb      	ldr	r3, [r7, #12]
 800773e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8007742:	b29a      	uxth	r2, r3
 8007744:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8007748:	1ad3      	subs	r3, r2, r3
 800774a:	b29a      	uxth	r2, r3
 800774c:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8007750:	b29b      	uxth	r3, r3
 8007752:	1ad3      	subs	r3, r2, r3
 8007754:	b29b      	uxth	r3, r3
 8007756:	b21b      	sxth	r3, r3
 8007758:	86fb      	strh	r3, [r7, #54]	; 0x36

    lv_point_t cir_out;
    lv_coord_t tmp_out;
    lv_circ_init(&cir_out, &tmp_out, radius);
 800775a:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 800775e:	f107 012e 	add.w	r1, r7, #46	; 0x2e
 8007762:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8007766:	4618      	mov	r0, r3
 8007768:	f004 fd97 	bl	800c29a <lv_circ_init>

    lv_point_t cir_in;
    lv_coord_t tmp_in;
    lv_coord_t radius_in = radius - bwidth;
 800776c:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8007770:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8007774:	1ad3      	subs	r3, r2, r3
 8007776:	b29b      	uxth	r3, r3
 8007778:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74

    if(radius_in < 0) {
 800777c:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8007780:	2b00      	cmp	r3, #0
 8007782:	da02      	bge.n	800778a <lv_draw_rect_border_corner+0x1e0>
        radius_in = 0;
 8007784:	2300      	movs	r3, #0
 8007786:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
    }

    lv_circ_init(&cir_in, &tmp_in, radius_in);
 800778a:	f9b7 2074 	ldrsh.w	r2, [r7, #116]	; 0x74
 800778e:	f107 0126 	add.w	r1, r7, #38	; 0x26
 8007792:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8007796:	4618      	mov	r0, r3
 8007798:	f004 fd7f 	bl	800c29a <lv_circ_init>
    lv_coord_t act_w1;
    lv_coord_t act_w2;

#if LV_ANTIALIAS
    /*Store some internal states for anti-aliasing*/
    lv_coord_t out_y_seg_start = 0;
 800779c:	2300      	movs	r3, #0
 800779e:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
    lv_coord_t out_y_seg_end   = 0;
 80077a2:	2300      	movs	r3, #0
 80077a4:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
    lv_coord_t out_x_last      = radius;
 80077a8:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80077ac:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c

    lv_coord_t in_y_seg_start = 0;
 80077b0:	2300      	movs	r3, #0
 80077b2:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
    lv_coord_t in_y_seg_end   = 0;
 80077b6:	2300      	movs	r3, #0
 80077b8:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
    lv_coord_t in_x_last      = radius - bwidth;
 80077bc:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 80077c0:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 80077c4:	1ad3      	subs	r3, r2, r3
 80077c6:	b29b      	uxth	r3, r3
 80077c8:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
#endif

    while(cir_out.y <= cir_out.x) {
 80077cc:	f000 bd74 	b.w	80082b8 <lv_draw_rect_border_corner+0xd0e>

        /*Calculate the actual width to avoid overwriting pixels*/
        if(cir_in.y < cir_in.x) {
 80077d0:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 80077d4:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80077d8:	429a      	cmp	r2, r3
 80077da:	da0e      	bge.n	80077fa <lv_draw_rect_border_corner+0x250>
            act_w1 = cir_out.x - cir_in.x;
 80077dc:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 80077e0:	b29a      	uxth	r2, r3
 80077e2:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80077e6:	b29b      	uxth	r3, r3
 80077e8:	1ad3      	subs	r3, r2, r3
 80077ea:	b29b      	uxth	r3, r3
 80077ec:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
            act_w2 = act_w1;
 80077f0:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 80077f4:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
 80077f8:	e00f      	b.n	800781a <lv_draw_rect_border_corner+0x270>
        } else {
            act_w1 = cir_out.x - cir_out.y;
 80077fa:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 80077fe:	b29a      	uxth	r2, r3
 8007800:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8007804:	b29b      	uxth	r3, r3
 8007806:	1ad3      	subs	r3, r2, r3
 8007808:	b29b      	uxth	r3, r3
 800780a:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
            act_w2 = act_w1 - 1;
 800780e:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 8007812:	3b01      	subs	r3, #1
 8007814:	b29b      	uxth	r3, r3
 8007816:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
        }

#if LV_ANTIALIAS
        if(aa) {
 800781a:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 800781e:	2b00      	cmp	r3, #0
 8007820:	f000 8340 	beq.w	8007ea4 <lv_draw_rect_border_corner+0x8fa>
            /*New step in y on the outter circle*/
            if(out_x_last != cir_out.x) {
 8007824:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8007828:	f9b7 206c 	ldrsh.w	r2, [r7, #108]	; 0x6c
 800782c:	429a      	cmp	r2, r3
 800782e:	f000 817b 	beq.w	8007b28 <lv_draw_rect_border_corner+0x57e>
                out_y_seg_end       = cir_out.y;
 8007832:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8007834:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 8007838:	f8b7 2052 	ldrh.w	r2, [r7, #82]	; 0x52
 800783c:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 8007840:	1ad3      	subs	r3, r2, r3
 8007842:	b29b      	uxth	r3, r3
 8007844:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
                lv_point_t aa_p;

                aa_p.x = out_x_last;
 8007848:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 800784c:	833b      	strh	r3, [r7, #24]
                aa_p.y = out_y_seg_start;
 800784e:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 8007852:	837b      	strh	r3, [r7, #26]

                lv_coord_t i;
                for(i = 0; i < seg_size; i++) {
 8007854:	2300      	movs	r3, #0
 8007856:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800785a:	e157      	b.n	8007b0c <lv_draw_rect_border_corner+0x562>
                    lv_opa_t aa_opa;

                    if(seg_size > CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD) { /*Use non-linear opa mapping
 800785c:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 8007860:	2b01      	cmp	r3, #1
 8007862:	dd0c      	ble.n	800787e <lv_draw_rect_border_corner+0x2d4>
                                                                           on the first segment*/
                        aa_opa = antialias_get_opa_circ(seg_size, i, opa);
 8007864:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 8007868:	f9b7 1066 	ldrsh.w	r1, [r7, #102]	; 0x66
 800786c:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 8007870:	4618      	mov	r0, r3
 8007872:	f002 f81b 	bl	80098ac <antialias_get_opa_circ>
 8007876:	4603      	mov	r3, r0
 8007878:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
 800787c:	e00f      	b.n	800789e <lv_draw_rect_border_corner+0x2f4>
                    } else {
                        aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 800787e:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 8007882:	f9b7 1066 	ldrsh.w	r1, [r7, #102]	; 0x66
 8007886:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 800788a:	4618      	mov	r0, r3
 800788c:	f7fc fb56 	bl	8003f3c <lv_draw_aa_get_opa>
 8007890:	4603      	mov	r3, r0
 8007892:	461a      	mov	r2, r3
 8007894:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8007898:	1a9b      	subs	r3, r3, r2
 800789a:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 800789e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80078a2:	f003 0301 	and.w	r3, r3, #1
 80078a6:	2b00      	cmp	r3, #0
 80078a8:	d045      	beq.n	8007936 <lv_draw_rect_border_corner+0x38c>
 80078aa:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80078ae:	f003 0308 	and.w	r3, r3, #8
 80078b2:	2b00      	cmp	r3, #0
 80078b4:	d03f      	beq.n	8007936 <lv_draw_rect_border_corner+0x38c>
                        lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 80078b6:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 80078ba:	b29a      	uxth	r2, r3
 80078bc:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80078c0:	b29b      	uxth	r3, r3
 80078c2:	4413      	add	r3, r2
 80078c4:	b29b      	uxth	r3, r3
 80078c6:	3301      	adds	r3, #1
 80078c8:	b29b      	uxth	r3, r3
 80078ca:	b218      	sxth	r0, r3
 80078cc:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80078d0:	b29a      	uxth	r2, r3
 80078d2:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80078d6:	b29b      	uxth	r3, r3
 80078d8:	4413      	add	r3, r2
 80078da:	b29a      	uxth	r2, r3
 80078dc:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80078e0:	4413      	add	r3, r2
 80078e2:	b29b      	uxth	r3, r3
 80078e4:	b219      	sxth	r1, r3
 80078e6:	687b      	ldr	r3, [r7, #4]
 80078e8:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 80078ec:	9200      	str	r2, [sp, #0]
 80078ee:	895b      	ldrh	r3, [r3, #10]
 80078f0:	68ba      	ldr	r2, [r7, #8]
 80078f2:	f7fc fbfc 	bl	80040ee <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 80078f6:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 80078fa:	b29a      	uxth	r2, r3
 80078fc:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8007900:	b29b      	uxth	r3, r3
 8007902:	4413      	add	r3, r2
 8007904:	b29a      	uxth	r2, r3
 8007906:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800790a:	4413      	add	r3, r2
 800790c:	b29b      	uxth	r3, r3
 800790e:	b218      	sxth	r0, r3
 8007910:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8007914:	b29a      	uxth	r2, r3
 8007916:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800791a:	b29b      	uxth	r3, r3
 800791c:	4413      	add	r3, r2
 800791e:	b29b      	uxth	r3, r3
 8007920:	3301      	adds	r3, #1
 8007922:	b29b      	uxth	r3, r3
 8007924:	b219      	sxth	r1, r3
 8007926:	687b      	ldr	r3, [r7, #4]
 8007928:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 800792c:	9200      	str	r2, [sp, #0]
 800792e:	895b      	ldrh	r3, [r3, #10]
 8007930:	68ba      	ldr	r2, [r7, #8]
 8007932:	f7fc fbdc 	bl	80040ee <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8007936:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 800793a:	f003 0301 	and.w	r3, r3, #1
 800793e:	2b00      	cmp	r3, #0
 8007940:	d045      	beq.n	80079ce <lv_draw_rect_border_corner+0x424>
 8007942:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007946:	f003 0304 	and.w	r3, r3, #4
 800794a:	2b00      	cmp	r3, #0
 800794c:	d03f      	beq.n	80079ce <lv_draw_rect_border_corner+0x424>
                        lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 800794e:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8007952:	b29a      	uxth	r2, r3
 8007954:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8007958:	b29b      	uxth	r3, r3
 800795a:	1ad3      	subs	r3, r2, r3
 800795c:	b29a      	uxth	r2, r3
 800795e:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8007962:	1ad3      	subs	r3, r2, r3
 8007964:	b29b      	uxth	r3, r3
 8007966:	b218      	sxth	r0, r3
 8007968:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 800796c:	b29a      	uxth	r2, r3
 800796e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8007972:	b29b      	uxth	r3, r3
 8007974:	4413      	add	r3, r2
 8007976:	b29b      	uxth	r3, r3
 8007978:	3301      	adds	r3, #1
 800797a:	b29b      	uxth	r3, r3
 800797c:	b219      	sxth	r1, r3
 800797e:	687b      	ldr	r3, [r7, #4]
 8007980:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8007984:	9200      	str	r2, [sp, #0]
 8007986:	895b      	ldrh	r3, [r3, #10]
 8007988:	68ba      	ldr	r2, [r7, #8]
 800798a:	f7fc fbb0 	bl	80040ee <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 800798e:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8007992:	b29a      	uxth	r2, r3
 8007994:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8007998:	b29b      	uxth	r3, r3
 800799a:	1ad3      	subs	r3, r2, r3
 800799c:	b29b      	uxth	r3, r3
 800799e:	3b01      	subs	r3, #1
 80079a0:	b29b      	uxth	r3, r3
 80079a2:	b218      	sxth	r0, r3
 80079a4:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80079a8:	b29a      	uxth	r2, r3
 80079aa:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80079ae:	b29b      	uxth	r3, r3
 80079b0:	4413      	add	r3, r2
 80079b2:	b29a      	uxth	r2, r3
 80079b4:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80079b8:	4413      	add	r3, r2
 80079ba:	b29b      	uxth	r3, r3
 80079bc:	b219      	sxth	r1, r3
 80079be:	687b      	ldr	r3, [r7, #4]
 80079c0:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 80079c4:	9200      	str	r2, [sp, #0]
 80079c6:	895b      	ldrh	r3, [r3, #10]
 80079c8:	68ba      	ldr	r2, [r7, #8]
 80079ca:	f7fc fb90 	bl	80040ee <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 80079ce:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80079d2:	f003 0302 	and.w	r3, r3, #2
 80079d6:	2b00      	cmp	r3, #0
 80079d8:	d045      	beq.n	8007a66 <lv_draw_rect_border_corner+0x4bc>
 80079da:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80079de:	f003 0304 	and.w	r3, r3, #4
 80079e2:	2b00      	cmp	r3, #0
 80079e4:	d03f      	beq.n	8007a66 <lv_draw_rect_border_corner+0x4bc>
                        lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 80079e6:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 80079ea:	b29a      	uxth	r2, r3
 80079ec:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80079f0:	b29b      	uxth	r3, r3
 80079f2:	1ad3      	subs	r3, r2, r3
 80079f4:	b29b      	uxth	r3, r3
 80079f6:	3b01      	subs	r3, #1
 80079f8:	b29b      	uxth	r3, r3
 80079fa:	b218      	sxth	r0, r3
 80079fc:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8007a00:	b29a      	uxth	r2, r3
 8007a02:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8007a06:	b29b      	uxth	r3, r3
 8007a08:	1ad3      	subs	r3, r2, r3
 8007a0a:	b29a      	uxth	r2, r3
 8007a0c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8007a10:	1ad3      	subs	r3, r2, r3
 8007a12:	b29b      	uxth	r3, r3
 8007a14:	b219      	sxth	r1, r3
 8007a16:	687b      	ldr	r3, [r7, #4]
 8007a18:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8007a1c:	9200      	str	r2, [sp, #0]
 8007a1e:	895b      	ldrh	r3, [r3, #10]
 8007a20:	68ba      	ldr	r2, [r7, #8]
 8007a22:	f7fc fb64 	bl	80040ee <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 8007a26:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8007a2a:	b29a      	uxth	r2, r3
 8007a2c:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8007a30:	b29b      	uxth	r3, r3
 8007a32:	1ad3      	subs	r3, r2, r3
 8007a34:	b29a      	uxth	r2, r3
 8007a36:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8007a3a:	1ad3      	subs	r3, r2, r3
 8007a3c:	b29b      	uxth	r3, r3
 8007a3e:	b218      	sxth	r0, r3
 8007a40:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8007a44:	b29a      	uxth	r2, r3
 8007a46:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8007a4a:	b29b      	uxth	r3, r3
 8007a4c:	1ad3      	subs	r3, r2, r3
 8007a4e:	b29b      	uxth	r3, r3
 8007a50:	3b01      	subs	r3, #1
 8007a52:	b29b      	uxth	r3, r3
 8007a54:	b219      	sxth	r1, r3
 8007a56:	687b      	ldr	r3, [r7, #4]
 8007a58:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8007a5c:	9200      	str	r2, [sp, #0]
 8007a5e:	895b      	ldrh	r3, [r3, #10]
 8007a60:	68ba      	ldr	r2, [r7, #8]
 8007a62:	f7fc fb44 	bl	80040ee <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8007a66:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007a6a:	f003 0302 	and.w	r3, r3, #2
 8007a6e:	2b00      	cmp	r3, #0
 8007a70:	d045      	beq.n	8007afe <lv_draw_rect_border_corner+0x554>
 8007a72:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007a76:	f003 0308 	and.w	r3, r3, #8
 8007a7a:	2b00      	cmp	r3, #0
 8007a7c:	d03f      	beq.n	8007afe <lv_draw_rect_border_corner+0x554>
                        lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 8007a7e:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8007a82:	b29a      	uxth	r2, r3
 8007a84:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8007a88:	b29b      	uxth	r3, r3
 8007a8a:	4413      	add	r3, r2
 8007a8c:	b29a      	uxth	r2, r3
 8007a8e:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8007a92:	4413      	add	r3, r2
 8007a94:	b29b      	uxth	r3, r3
 8007a96:	b218      	sxth	r0, r3
 8007a98:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8007a9c:	b29a      	uxth	r2, r3
 8007a9e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8007aa2:	b29b      	uxth	r3, r3
 8007aa4:	1ad3      	subs	r3, r2, r3
 8007aa6:	b29b      	uxth	r3, r3
 8007aa8:	3b01      	subs	r3, #1
 8007aaa:	b29b      	uxth	r3, r3
 8007aac:	b219      	sxth	r1, r3
 8007aae:	687b      	ldr	r3, [r7, #4]
 8007ab0:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8007ab4:	9200      	str	r2, [sp, #0]
 8007ab6:	895b      	ldrh	r3, [r3, #10]
 8007ab8:	68ba      	ldr	r2, [r7, #8]
 8007aba:	f7fc fb18 	bl	80040ee <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 8007abe:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8007ac2:	b29a      	uxth	r2, r3
 8007ac4:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8007ac8:	b29b      	uxth	r3, r3
 8007aca:	4413      	add	r3, r2
 8007acc:	b29b      	uxth	r3, r3
 8007ace:	3301      	adds	r3, #1
 8007ad0:	b29b      	uxth	r3, r3
 8007ad2:	b218      	sxth	r0, r3
 8007ad4:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8007ad8:	b29a      	uxth	r2, r3
 8007ada:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8007ade:	b29b      	uxth	r3, r3
 8007ae0:	1ad3      	subs	r3, r2, r3
 8007ae2:	b29a      	uxth	r2, r3
 8007ae4:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8007ae8:	1ad3      	subs	r3, r2, r3
 8007aea:	b29b      	uxth	r3, r3
 8007aec:	b219      	sxth	r1, r3
 8007aee:	687b      	ldr	r3, [r7, #4]
 8007af0:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8007af4:	9200      	str	r2, [sp, #0]
 8007af6:	895b      	ldrh	r3, [r3, #10]
 8007af8:	68ba      	ldr	r2, [r7, #8]
 8007afa:	f7fc faf8 	bl	80040ee <lv_draw_px>
                for(i = 0; i < seg_size; i++) {
 8007afe:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 8007b02:	b29b      	uxth	r3, r3
 8007b04:	3301      	adds	r3, #1
 8007b06:	b29b      	uxth	r3, r3
 8007b08:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8007b0c:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 8007b10:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 8007b14:	429a      	cmp	r2, r3
 8007b16:	f6ff aea1 	blt.w	800785c <lv_draw_rect_border_corner+0x2b2>
                                   style->body.border.color, aa_opa);
                    }
                }

                out_x_last      = cir_out.x;
 8007b1a:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8007b1c:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
                out_y_seg_start = out_y_seg_end;
 8007b20:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 8007b24:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
            }

            /*New step in y on the inner circle*/
            if(in_x_last != cir_in.x) {
 8007b28:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8007b2c:	f9b7 2068 	ldrsh.w	r2, [r7, #104]	; 0x68
 8007b30:	429a      	cmp	r2, r3
 8007b32:	f000 81b7 	beq.w	8007ea4 <lv_draw_rect_border_corner+0x8fa>
                in_y_seg_end        = cir_out.y;
 8007b36:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8007b38:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                lv_coord_t seg_size = in_y_seg_end - in_y_seg_start;
 8007b3c:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 8007b40:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 8007b44:	1ad3      	subs	r3, r2, r3
 8007b46:	b29b      	uxth	r3, r3
 8007b48:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
                lv_point_t aa_p;

                aa_p.x = in_x_last;
 8007b4c:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 8007b50:	82bb      	strh	r3, [r7, #20]
                aa_p.y = in_y_seg_start;
 8007b52:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 8007b56:	82fb      	strh	r3, [r7, #22]

                lv_coord_t i;
                for(i = 0; i < seg_size; i++) {
 8007b58:	2300      	movs	r3, #0
 8007b5a:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
 8007b5e:	e193      	b.n	8007e88 <lv_draw_rect_border_corner+0x8de>
                    lv_opa_t aa_opa;

                    if(seg_size > CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD) { /*Use non-linear opa mapping
 8007b60:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8007b64:	2b01      	cmp	r3, #1
 8007b66:	dd10      	ble.n	8007b8a <lv_draw_rect_border_corner+0x5e0>
                                                                           on the first segment*/
                        aa_opa = opa - antialias_get_opa_circ(seg_size, i, opa);
 8007b68:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 8007b6c:	f9b7 1062 	ldrsh.w	r1, [r7, #98]	; 0x62
 8007b70:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8007b74:	4618      	mov	r0, r3
 8007b76:	f001 fe99 	bl	80098ac <antialias_get_opa_circ>
 8007b7a:	4603      	mov	r3, r0
 8007b7c:	461a      	mov	r2, r3
 8007b7e:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8007b82:	1a9b      	subs	r3, r3, r2
 8007b84:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
 8007b88:	e00b      	b.n	8007ba2 <lv_draw_rect_border_corner+0x5f8>
                    } else {
                        aa_opa = lv_draw_aa_get_opa(seg_size, i, opa);
 8007b8a:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 8007b8e:	f9b7 1062 	ldrsh.w	r1, [r7, #98]	; 0x62
 8007b92:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8007b96:	4618      	mov	r0, r3
 8007b98:	f7fc f9d0 	bl	8003f3c <lv_draw_aa_get_opa>
 8007b9c:	4603      	mov	r3, r0
 8007b9e:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8007ba2:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007ba6:	f003 0301 	and.w	r3, r3, #1
 8007baa:	2b00      	cmp	r3, #0
 8007bac:	d025      	beq.n	8007bfa <lv_draw_rect_border_corner+0x650>
 8007bae:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007bb2:	f003 0308 	and.w	r3, r3, #8
 8007bb6:	2b00      	cmp	r3, #0
 8007bb8:	d01f      	beq.n	8007bfa <lv_draw_rect_border_corner+0x650>
                        lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) - 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 8007bba:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8007bbe:	b29a      	uxth	r2, r3
 8007bc0:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8007bc4:	b29b      	uxth	r3, r3
 8007bc6:	4413      	add	r3, r2
 8007bc8:	b29b      	uxth	r3, r3
 8007bca:	3b01      	subs	r3, #1
 8007bcc:	b29b      	uxth	r3, r3
 8007bce:	b218      	sxth	r0, r3
 8007bd0:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8007bd4:	b29a      	uxth	r2, r3
 8007bd6:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8007bda:	b29b      	uxth	r3, r3
 8007bdc:	4413      	add	r3, r2
 8007bde:	b29a      	uxth	r2, r3
 8007be0:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8007be4:	4413      	add	r3, r2
 8007be6:	b29b      	uxth	r3, r3
 8007be8:	b219      	sxth	r1, r3
 8007bea:	687b      	ldr	r3, [r7, #4]
 8007bec:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8007bf0:	9200      	str	r2, [sp, #0]
 8007bf2:	895b      	ldrh	r3, [r3, #10]
 8007bf4:	68ba      	ldr	r2, [r7, #8]
 8007bf6:	f7fc fa7a 	bl	80040ee <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8007bfa:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007bfe:	f003 0301 	and.w	r3, r3, #1
 8007c02:	2b00      	cmp	r3, #0
 8007c04:	d025      	beq.n	8007c52 <lv_draw_rect_border_corner+0x6a8>
 8007c06:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007c0a:	f003 0304 	and.w	r3, r3, #4
 8007c0e:	2b00      	cmp	r3, #0
 8007c10:	d01f      	beq.n	8007c52 <lv_draw_rect_border_corner+0x6a8>
                        lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) - 1, mask,
 8007c12:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8007c16:	b29a      	uxth	r2, r3
 8007c18:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8007c1c:	b29b      	uxth	r3, r3
 8007c1e:	1ad3      	subs	r3, r2, r3
 8007c20:	b29a      	uxth	r2, r3
 8007c22:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8007c26:	1ad3      	subs	r3, r2, r3
 8007c28:	b29b      	uxth	r3, r3
 8007c2a:	b218      	sxth	r0, r3
 8007c2c:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8007c30:	b29a      	uxth	r2, r3
 8007c32:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8007c36:	b29b      	uxth	r3, r3
 8007c38:	4413      	add	r3, r2
 8007c3a:	b29b      	uxth	r3, r3
 8007c3c:	3b01      	subs	r3, #1
 8007c3e:	b29b      	uxth	r3, r3
 8007c40:	b219      	sxth	r1, r3
 8007c42:	687b      	ldr	r3, [r7, #4]
 8007c44:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8007c48:	9200      	str	r2, [sp, #0]
 8007c4a:	895b      	ldrh	r3, [r3, #10]
 8007c4c:	68ba      	ldr	r2, [r7, #8]
 8007c4e:	f7fc fa4e 	bl	80040ee <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8007c52:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007c56:	f003 0302 	and.w	r3, r3, #2
 8007c5a:	2b00      	cmp	r3, #0
 8007c5c:	d025      	beq.n	8007caa <lv_draw_rect_border_corner+0x700>
 8007c5e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007c62:	f003 0304 	and.w	r3, r3, #4
 8007c66:	2b00      	cmp	r3, #0
 8007c68:	d01f      	beq.n	8007caa <lv_draw_rect_border_corner+0x700>
                        lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) + 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 8007c6a:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8007c6e:	b29a      	uxth	r2, r3
 8007c70:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8007c74:	b29b      	uxth	r3, r3
 8007c76:	1ad3      	subs	r3, r2, r3
 8007c78:	b29b      	uxth	r3, r3
 8007c7a:	3301      	adds	r3, #1
 8007c7c:	b29b      	uxth	r3, r3
 8007c7e:	b218      	sxth	r0, r3
 8007c80:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8007c84:	b29a      	uxth	r2, r3
 8007c86:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8007c8a:	b29b      	uxth	r3, r3
 8007c8c:	1ad3      	subs	r3, r2, r3
 8007c8e:	b29a      	uxth	r2, r3
 8007c90:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8007c94:	1ad3      	subs	r3, r2, r3
 8007c96:	b29b      	uxth	r3, r3
 8007c98:	b219      	sxth	r1, r3
 8007c9a:	687b      	ldr	r3, [r7, #4]
 8007c9c:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8007ca0:	9200      	str	r2, [sp, #0]
 8007ca2:	895b      	ldrh	r3, [r3, #10]
 8007ca4:	68ba      	ldr	r2, [r7, #8]
 8007ca6:	f7fc fa22 	bl	80040ee <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8007caa:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007cae:	f003 0302 	and.w	r3, r3, #2
 8007cb2:	2b00      	cmp	r3, #0
 8007cb4:	d025      	beq.n	8007d02 <lv_draw_rect_border_corner+0x758>
 8007cb6:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007cba:	f003 0308 	and.w	r3, r3, #8
 8007cbe:	2b00      	cmp	r3, #0
 8007cc0:	d01f      	beq.n	8007d02 <lv_draw_rect_border_corner+0x758>
                        lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) + 1, mask,
 8007cc2:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8007cc6:	b29a      	uxth	r2, r3
 8007cc8:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8007ccc:	b29b      	uxth	r3, r3
 8007cce:	4413      	add	r3, r2
 8007cd0:	b29a      	uxth	r2, r3
 8007cd2:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8007cd6:	4413      	add	r3, r2
 8007cd8:	b29b      	uxth	r3, r3
 8007cda:	b218      	sxth	r0, r3
 8007cdc:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8007ce0:	b29a      	uxth	r2, r3
 8007ce2:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8007ce6:	b29b      	uxth	r3, r3
 8007ce8:	1ad3      	subs	r3, r2, r3
 8007cea:	b29b      	uxth	r3, r3
 8007cec:	3301      	adds	r3, #1
 8007cee:	b29b      	uxth	r3, r3
 8007cf0:	b219      	sxth	r1, r3
 8007cf2:	687b      	ldr	r3, [r7, #4]
 8007cf4:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8007cf8:	9200      	str	r2, [sp, #0]
 8007cfa:	895b      	ldrh	r3, [r3, #10]
 8007cfc:	68ba      	ldr	r2, [r7, #8]
 8007cfe:	f7fc f9f6 	bl	80040ee <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    /*Be sure the pixels on the middle are not drawn twice*/
                    if(LV_CIRC_OCT1_X(aa_p) - 1 != LV_CIRC_OCT2_X(aa_p) + i) {
 8007d02:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8007d06:	1e5a      	subs	r2, r3, #1
 8007d08:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8007d0c:	4619      	mov	r1, r3
 8007d0e:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8007d12:	440b      	add	r3, r1
 8007d14:	429a      	cmp	r2, r3
 8007d16:	f000 80b0 	beq.w	8007e7a <lv_draw_rect_border_corner+0x8d0>
                        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8007d1a:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007d1e:	f003 0301 	and.w	r3, r3, #1
 8007d22:	2b00      	cmp	r3, #0
 8007d24:	d025      	beq.n	8007d72 <lv_draw_rect_border_corner+0x7c8>
 8007d26:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007d2a:	f003 0308 	and.w	r3, r3, #8
 8007d2e:	2b00      	cmp	r3, #0
 8007d30:	d01f      	beq.n	8007d72 <lv_draw_rect_border_corner+0x7c8>
                            lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) - 1,
 8007d32:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8007d36:	b29a      	uxth	r2, r3
 8007d38:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8007d3c:	b29b      	uxth	r3, r3
 8007d3e:	4413      	add	r3, r2
 8007d40:	b29a      	uxth	r2, r3
 8007d42:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8007d46:	4413      	add	r3, r2
 8007d48:	b29b      	uxth	r3, r3
 8007d4a:	b218      	sxth	r0, r3
 8007d4c:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8007d50:	b29a      	uxth	r2, r3
 8007d52:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8007d56:	b29b      	uxth	r3, r3
 8007d58:	4413      	add	r3, r2
 8007d5a:	b29b      	uxth	r3, r3
 8007d5c:	3b01      	subs	r3, #1
 8007d5e:	b29b      	uxth	r3, r3
 8007d60:	b219      	sxth	r1, r3
 8007d62:	687b      	ldr	r3, [r7, #4]
 8007d64:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8007d68:	9200      	str	r2, [sp, #0]
 8007d6a:	895b      	ldrh	r3, [r3, #10]
 8007d6c:	68ba      	ldr	r2, [r7, #8]
 8007d6e:	f7fc f9be 	bl	80040ee <lv_draw_px>
                                       mask, style->body.border.color, aa_opa);
                        }

                        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8007d72:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007d76:	f003 0301 	and.w	r3, r3, #1
 8007d7a:	2b00      	cmp	r3, #0
 8007d7c:	d025      	beq.n	8007dca <lv_draw_rect_border_corner+0x820>
 8007d7e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007d82:	f003 0304 	and.w	r3, r3, #4
 8007d86:	2b00      	cmp	r3, #0
 8007d88:	d01f      	beq.n	8007dca <lv_draw_rect_border_corner+0x820>
                            lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) + 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i,
 8007d8a:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8007d8e:	b29a      	uxth	r2, r3
 8007d90:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8007d94:	b29b      	uxth	r3, r3
 8007d96:	1ad3      	subs	r3, r2, r3
 8007d98:	b29b      	uxth	r3, r3
 8007d9a:	3301      	adds	r3, #1
 8007d9c:	b29b      	uxth	r3, r3
 8007d9e:	b218      	sxth	r0, r3
 8007da0:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8007da4:	b29a      	uxth	r2, r3
 8007da6:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8007daa:	b29b      	uxth	r3, r3
 8007dac:	4413      	add	r3, r2
 8007dae:	b29a      	uxth	r2, r3
 8007db0:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8007db4:	4413      	add	r3, r2
 8007db6:	b29b      	uxth	r3, r3
 8007db8:	b219      	sxth	r1, r3
 8007dba:	687b      	ldr	r3, [r7, #4]
 8007dbc:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8007dc0:	9200      	str	r2, [sp, #0]
 8007dc2:	895b      	ldrh	r3, [r3, #10]
 8007dc4:	68ba      	ldr	r2, [r7, #8]
 8007dc6:	f7fc f992 	bl	80040ee <lv_draw_px>
                                       mask, style->body.border.color, aa_opa);
                        }

                        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8007dca:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007dce:	f003 0302 	and.w	r3, r3, #2
 8007dd2:	2b00      	cmp	r3, #0
 8007dd4:	d025      	beq.n	8007e22 <lv_draw_rect_border_corner+0x878>
 8007dd6:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007dda:	f003 0304 	and.w	r3, r3, #4
 8007dde:	2b00      	cmp	r3, #0
 8007de0:	d01f      	beq.n	8007e22 <lv_draw_rect_border_corner+0x878>
                            lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) + 1,
 8007de2:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8007de6:	b29a      	uxth	r2, r3
 8007de8:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8007dec:	b29b      	uxth	r3, r3
 8007dee:	1ad3      	subs	r3, r2, r3
 8007df0:	b29a      	uxth	r2, r3
 8007df2:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8007df6:	1ad3      	subs	r3, r2, r3
 8007df8:	b29b      	uxth	r3, r3
 8007dfa:	b218      	sxth	r0, r3
 8007dfc:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8007e00:	b29a      	uxth	r2, r3
 8007e02:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8007e06:	b29b      	uxth	r3, r3
 8007e08:	1ad3      	subs	r3, r2, r3
 8007e0a:	b29b      	uxth	r3, r3
 8007e0c:	3301      	adds	r3, #1
 8007e0e:	b29b      	uxth	r3, r3
 8007e10:	b219      	sxth	r1, r3
 8007e12:	687b      	ldr	r3, [r7, #4]
 8007e14:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8007e18:	9200      	str	r2, [sp, #0]
 8007e1a:	895b      	ldrh	r3, [r3, #10]
 8007e1c:	68ba      	ldr	r2, [r7, #8]
 8007e1e:	f7fc f966 	bl	80040ee <lv_draw_px>
                                       mask, style->body.border.color, aa_opa);
                        }

                        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8007e22:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007e26:	f003 0302 	and.w	r3, r3, #2
 8007e2a:	2b00      	cmp	r3, #0
 8007e2c:	d025      	beq.n	8007e7a <lv_draw_rect_border_corner+0x8d0>
 8007e2e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007e32:	f003 0308 	and.w	r3, r3, #8
 8007e36:	2b00      	cmp	r3, #0
 8007e38:	d01f      	beq.n	8007e7a <lv_draw_rect_border_corner+0x8d0>
                            lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) - 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i,
 8007e3a:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8007e3e:	b29a      	uxth	r2, r3
 8007e40:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8007e44:	b29b      	uxth	r3, r3
 8007e46:	4413      	add	r3, r2
 8007e48:	b29b      	uxth	r3, r3
 8007e4a:	3b01      	subs	r3, #1
 8007e4c:	b29b      	uxth	r3, r3
 8007e4e:	b218      	sxth	r0, r3
 8007e50:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8007e54:	b29a      	uxth	r2, r3
 8007e56:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8007e5a:	b29b      	uxth	r3, r3
 8007e5c:	1ad3      	subs	r3, r2, r3
 8007e5e:	b29a      	uxth	r2, r3
 8007e60:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8007e64:	1ad3      	subs	r3, r2, r3
 8007e66:	b29b      	uxth	r3, r3
 8007e68:	b219      	sxth	r1, r3
 8007e6a:	687b      	ldr	r3, [r7, #4]
 8007e6c:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8007e70:	9200      	str	r2, [sp, #0]
 8007e72:	895b      	ldrh	r3, [r3, #10]
 8007e74:	68ba      	ldr	r2, [r7, #8]
 8007e76:	f7fc f93a 	bl	80040ee <lv_draw_px>
                for(i = 0; i < seg_size; i++) {
 8007e7a:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8007e7e:	b29b      	uxth	r3, r3
 8007e80:	3301      	adds	r3, #1
 8007e82:	b29b      	uxth	r3, r3
 8007e84:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
 8007e88:	f9b7 2062 	ldrsh.w	r2, [r7, #98]	; 0x62
 8007e8c:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8007e90:	429a      	cmp	r2, r3
 8007e92:	f6ff ae65 	blt.w	8007b60 <lv_draw_rect_border_corner+0x5b6>
                                       mask, style->body.border.color, aa_opa);
                        }
                    }
                }

                in_x_last      = cir_in.x;
 8007e96:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8007e98:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
                in_y_seg_start = in_y_seg_end;
 8007e9c:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 8007ea0:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
            }
        }
#endif

        /*Draw the octets to the right bottom corner*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8007ea4:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007ea8:	f003 0301 	and.w	r3, r3, #1
 8007eac:	2b00      	cmp	r3, #0
 8007eae:	d06f      	beq.n	8007f90 <lv_draw_rect_border_corner+0x9e6>
 8007eb0:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007eb4:	f003 0308 	and.w	r3, r3, #8
 8007eb8:	2b00      	cmp	r3, #0
 8007eba:	d069      	beq.n	8007f90 <lv_draw_rect_border_corner+0x9e6>
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
 8007ebc:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8007ec0:	b29a      	uxth	r2, r3
 8007ec2:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8007ec6:	b29b      	uxth	r3, r3
 8007ec8:	4413      	add	r3, r2
 8007eca:	b29a      	uxth	r2, r3
 8007ecc:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 8007ed0:	1ad3      	subs	r3, r2, r3
 8007ed2:	b29b      	uxth	r3, r3
 8007ed4:	b21b      	sxth	r3, r3
 8007ed6:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT1_X(cir_out);
 8007ed8:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8007edc:	b29a      	uxth	r2, r3
 8007ede:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8007ee2:	b29b      	uxth	r3, r3
 8007ee4:	4413      	add	r3, r2
 8007ee6:	b29b      	uxth	r3, r3
 8007ee8:	b21b      	sxth	r3, r3
 8007eea:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
 8007eec:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8007ef0:	b29a      	uxth	r2, r3
 8007ef2:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8007ef6:	b29b      	uxth	r3, r3
 8007ef8:	4413      	add	r3, r2
 8007efa:	b29b      	uxth	r3, r3
 8007efc:	b21b      	sxth	r3, r3
 8007efe:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
 8007f00:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8007f04:	b29a      	uxth	r2, r3
 8007f06:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8007f0a:	b29b      	uxth	r3, r3
 8007f0c:	4413      	add	r3, r2
 8007f0e:	b29b      	uxth	r3, r3
 8007f10:	b21b      	sxth	r3, r3
 8007f12:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8007f14:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8007f18:	f107 001c 	add.w	r0, r7, #28
 8007f1c:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8007f20:	68b9      	ldr	r1, [r7, #8]
 8007f22:	f7fc f97d 	bl	8004220 <lv_draw_fill>

            circ_area.x1 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
 8007f26:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8007f2a:	b29a      	uxth	r2, r3
 8007f2c:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8007f30:	b29b      	uxth	r3, r3
 8007f32:	4413      	add	r3, r2
 8007f34:	b29b      	uxth	r3, r3
 8007f36:	b21b      	sxth	r3, r3
 8007f38:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
 8007f3a:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8007f3e:	b29a      	uxth	r2, r3
 8007f40:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8007f44:	b29b      	uxth	r3, r3
 8007f46:	4413      	add	r3, r2
 8007f48:	b29b      	uxth	r3, r3
 8007f4a:	b21b      	sxth	r3, r3
 8007f4c:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out) - act_w1;
 8007f4e:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8007f52:	b29a      	uxth	r2, r3
 8007f54:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8007f58:	b29b      	uxth	r3, r3
 8007f5a:	4413      	add	r3, r2
 8007f5c:	b29a      	uxth	r2, r3
 8007f5e:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 8007f62:	1ad3      	subs	r3, r2, r3
 8007f64:	b29b      	uxth	r3, r3
 8007f66:	b21b      	sxth	r3, r3
 8007f68:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out);
 8007f6a:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8007f6e:	b29a      	uxth	r2, r3
 8007f70:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8007f74:	b29b      	uxth	r3, r3
 8007f76:	4413      	add	r3, r2
 8007f78:	b29b      	uxth	r3, r3
 8007f7a:	b21b      	sxth	r3, r3
 8007f7c:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8007f7e:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8007f82:	f107 001c 	add.w	r0, r7, #28
 8007f86:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8007f8a:	68b9      	ldr	r1, [r7, #8]
 8007f8c:	f7fc f948 	bl	8004220 <lv_draw_fill>
        }

        /*Draw the octets to the left bottom corner*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8007f90:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007f94:	f003 0301 	and.w	r3, r3, #1
 8007f98:	2b00      	cmp	r3, #0
 8007f9a:	d06f      	beq.n	800807c <lv_draw_rect_border_corner+0xad2>
 8007f9c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007fa0:	f003 0304 	and.w	r3, r3, #4
 8007fa4:	2b00      	cmp	r3, #0
 8007fa6:	d069      	beq.n	800807c <lv_draw_rect_border_corner+0xad2>
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
 8007fa8:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8007fac:	b29a      	uxth	r2, r3
 8007fae:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8007fb2:	b29b      	uxth	r3, r3
 8007fb4:	1ad3      	subs	r3, r2, r3
 8007fb6:	b29b      	uxth	r3, r3
 8007fb8:	b21b      	sxth	r3, r3
 8007fba:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
 8007fbc:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8007fc0:	b29a      	uxth	r2, r3
 8007fc2:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8007fc6:	b29b      	uxth	r3, r3
 8007fc8:	1ad3      	subs	r3, r2, r3
 8007fca:	b29b      	uxth	r3, r3
 8007fcc:	b21b      	sxth	r3, r3
 8007fce:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out) - act_w2;
 8007fd0:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8007fd4:	b29a      	uxth	r2, r3
 8007fd6:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8007fda:	b29b      	uxth	r3, r3
 8007fdc:	4413      	add	r3, r2
 8007fde:	b29a      	uxth	r2, r3
 8007fe0:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 8007fe4:	1ad3      	subs	r3, r2, r3
 8007fe6:	b29b      	uxth	r3, r3
 8007fe8:	b21b      	sxth	r3, r3
 8007fea:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out);
 8007fec:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8007ff0:	b29a      	uxth	r2, r3
 8007ff2:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8007ff6:	b29b      	uxth	r3, r3
 8007ff8:	4413      	add	r3, r2
 8007ffa:	b29b      	uxth	r3, r3
 8007ffc:	b21b      	sxth	r3, r3
 8007ffe:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8008000:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8008004:	f107 001c 	add.w	r0, r7, #28
 8008008:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 800800c:	68b9      	ldr	r1, [r7, #8]
 800800e:	f7fc f907 	bl	8004220 <lv_draw_fill>

            circ_area.x1 = lb_origo.x + LV_CIRC_OCT4_X(cir_out);
 8008012:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8008016:	b29a      	uxth	r2, r3
 8008018:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 800801c:	b29b      	uxth	r3, r3
 800801e:	1ad3      	subs	r3, r2, r3
 8008020:	b29b      	uxth	r3, r3
 8008022:	b21b      	sxth	r3, r3
 8008024:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT4_X(cir_out) + act_w1;
 8008026:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 800802a:	b29a      	uxth	r2, r3
 800802c:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8008030:	b29b      	uxth	r3, r3
 8008032:	1ad3      	subs	r3, r2, r3
 8008034:	b29a      	uxth	r2, r3
 8008036:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 800803a:	4413      	add	r3, r2
 800803c:	b29b      	uxth	r3, r3
 800803e:	b21b      	sxth	r3, r3
 8008040:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
 8008042:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8008046:	b29a      	uxth	r2, r3
 8008048:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 800804c:	b29b      	uxth	r3, r3
 800804e:	4413      	add	r3, r2
 8008050:	b29b      	uxth	r3, r3
 8008052:	b21b      	sxth	r3, r3
 8008054:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
 8008056:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 800805a:	b29a      	uxth	r2, r3
 800805c:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8008060:	b29b      	uxth	r3, r3
 8008062:	4413      	add	r3, r2
 8008064:	b29b      	uxth	r3, r3
 8008066:	b21b      	sxth	r3, r3
 8008068:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 800806a:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 800806e:	f107 001c 	add.w	r0, r7, #28
 8008072:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8008076:	68b9      	ldr	r1, [r7, #8]
 8008078:	f7fc f8d2 	bl	8004220 <lv_draw_fill>
        }

        /*Draw the octets to the left top corner*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 800807c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008080:	f003 0302 	and.w	r3, r3, #2
 8008084:	2b00      	cmp	r3, #0
 8008086:	d07d      	beq.n	8008184 <lv_draw_rect_border_corner+0xbda>
 8008088:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 800808c:	f003 0304 	and.w	r3, r3, #4
 8008090:	2b00      	cmp	r3, #0
 8008092:	d077      	beq.n	8008184 <lv_draw_rect_border_corner+0xbda>
            if(lb_origo.y + LV_CIRC_OCT4_Y(cir_out) > lt_origo.y + LV_CIRC_OCT5_Y(cir_out)) {
 8008094:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8008098:	461a      	mov	r2, r3
 800809a:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 800809e:	441a      	add	r2, r3
 80080a0:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 80080a4:	4619      	mov	r1, r3
 80080a6:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 80080aa:	1acb      	subs	r3, r1, r3
 80080ac:	429a      	cmp	r2, r3
 80080ae:	dd34      	ble.n	800811a <lv_draw_rect_border_corner+0xb70>
                /*Don't draw if the lines are common in the middle*/
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
 80080b0:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 80080b4:	b29a      	uxth	r2, r3
 80080b6:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 80080ba:	b29b      	uxth	r3, r3
 80080bc:	1ad3      	subs	r3, r2, r3
 80080be:	b29b      	uxth	r3, r3
 80080c0:	b21b      	sxth	r3, r3
 80080c2:	83bb      	strh	r3, [r7, #28]
                circ_area.x2 = lt_origo.x + LV_CIRC_OCT5_X(cir_out) + act_w2;
 80080c4:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 80080c8:	b29a      	uxth	r2, r3
 80080ca:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 80080ce:	b29b      	uxth	r3, r3
 80080d0:	1ad3      	subs	r3, r2, r3
 80080d2:	b29a      	uxth	r2, r3
 80080d4:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 80080d8:	4413      	add	r3, r2
 80080da:	b29b      	uxth	r3, r3
 80080dc:	b21b      	sxth	r3, r3
 80080de:	843b      	strh	r3, [r7, #32]
                circ_area.y1 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
 80080e0:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 80080e4:	b29a      	uxth	r2, r3
 80080e6:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 80080ea:	b29b      	uxth	r3, r3
 80080ec:	1ad3      	subs	r3, r2, r3
 80080ee:	b29b      	uxth	r3, r3
 80080f0:	b21b      	sxth	r3, r3
 80080f2:	83fb      	strh	r3, [r7, #30]
                circ_area.y2 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
 80080f4:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 80080f8:	b29a      	uxth	r2, r3
 80080fa:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 80080fe:	b29b      	uxth	r3, r3
 8008100:	1ad3      	subs	r3, r2, r3
 8008102:	b29b      	uxth	r3, r3
 8008104:	b21b      	sxth	r3, r3
 8008106:	847b      	strh	r3, [r7, #34]	; 0x22
                lv_draw_fill(&circ_area, mask, color, opa);
 8008108:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 800810c:	f107 001c 	add.w	r0, r7, #28
 8008110:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8008114:	68b9      	ldr	r1, [r7, #8]
 8008116:	f7fc f883 	bl	8004220 <lv_draw_fill>
            }

            circ_area.x1 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
 800811a:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 800811e:	b29a      	uxth	r2, r3
 8008120:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8008124:	b29b      	uxth	r3, r3
 8008126:	1ad3      	subs	r3, r2, r3
 8008128:	b29b      	uxth	r3, r3
 800812a:	b21b      	sxth	r3, r3
 800812c:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
 800812e:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8008132:	b29a      	uxth	r2, r3
 8008134:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8008138:	b29b      	uxth	r3, r3
 800813a:	1ad3      	subs	r3, r2, r3
 800813c:	b29b      	uxth	r3, r3
 800813e:	b21b      	sxth	r3, r3
 8008140:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out);
 8008142:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8008146:	b29a      	uxth	r2, r3
 8008148:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 800814c:	b29b      	uxth	r3, r3
 800814e:	1ad3      	subs	r3, r2, r3
 8008150:	b29b      	uxth	r3, r3
 8008152:	b21b      	sxth	r3, r3
 8008154:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out) + act_w1;
 8008156:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 800815a:	b29a      	uxth	r2, r3
 800815c:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8008160:	b29b      	uxth	r3, r3
 8008162:	1ad3      	subs	r3, r2, r3
 8008164:	b29a      	uxth	r2, r3
 8008166:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 800816a:	4413      	add	r3, r2
 800816c:	b29b      	uxth	r3, r3
 800816e:	b21b      	sxth	r3, r3
 8008170:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8008172:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8008176:	f107 001c 	add.w	r0, r7, #28
 800817a:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 800817e:	68b9      	ldr	r1, [r7, #8]
 8008180:	f7fc f84e 	bl	8004220 <lv_draw_fill>
        }

        /*Draw the octets to the right top corner*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8008184:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008188:	f003 0302 	and.w	r3, r3, #2
 800818c:	2b00      	cmp	r3, #0
 800818e:	d07d      	beq.n	800828c <lv_draw_rect_border_corner+0xce2>
 8008190:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008194:	f003 0308 	and.w	r3, r3, #8
 8008198:	2b00      	cmp	r3, #0
 800819a:	d077      	beq.n	800828c <lv_draw_rect_border_corner+0xce2>
            circ_area.x1 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
 800819c:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80081a0:	b29a      	uxth	r2, r3
 80081a2:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 80081a6:	b29b      	uxth	r3, r3
 80081a8:	4413      	add	r3, r2
 80081aa:	b29b      	uxth	r3, r3
 80081ac:	b21b      	sxth	r3, r3
 80081ae:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
 80081b0:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80081b4:	b29a      	uxth	r2, r3
 80081b6:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 80081ba:	b29b      	uxth	r3, r3
 80081bc:	4413      	add	r3, r2
 80081be:	b29b      	uxth	r3, r3
 80081c0:	b21b      	sxth	r3, r3
 80081c2:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out);
 80081c4:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 80081c8:	b29a      	uxth	r2, r3
 80081ca:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 80081ce:	b29b      	uxth	r3, r3
 80081d0:	1ad3      	subs	r3, r2, r3
 80081d2:	b29b      	uxth	r3, r3
 80081d4:	b21b      	sxth	r3, r3
 80081d6:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out) + act_w2;
 80081d8:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 80081dc:	b29a      	uxth	r2, r3
 80081de:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 80081e2:	b29b      	uxth	r3, r3
 80081e4:	1ad3      	subs	r3, r2, r3
 80081e6:	b29a      	uxth	r2, r3
 80081e8:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 80081ec:	4413      	add	r3, r2
 80081ee:	b29b      	uxth	r3, r3
 80081f0:	b21b      	sxth	r3, r3
 80081f2:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 80081f4:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 80081f8:	f107 001c 	add.w	r0, r7, #28
 80081fc:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8008200:	68b9      	ldr	r1, [r7, #8]
 8008202:	f7fc f80d 	bl	8004220 <lv_draw_fill>

            /*Don't draw if the lines are common in the middle*/
            if(rb_origo.y + LV_CIRC_OCT1_Y(cir_out) > rt_origo.y + LV_CIRC_OCT8_Y(cir_out)) {
 8008206:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 800820a:	461a      	mov	r2, r3
 800820c:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8008210:	441a      	add	r2, r3
 8008212:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8008216:	4619      	mov	r1, r3
 8008218:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 800821c:	1acb      	subs	r3, r1, r3
 800821e:	429a      	cmp	r2, r3
 8008220:	dd34      	ble.n	800828c <lv_draw_rect_border_corner+0xce2>
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
 8008222:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8008226:	b29a      	uxth	r2, r3
 8008228:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 800822c:	b29b      	uxth	r3, r3
 800822e:	4413      	add	r3, r2
 8008230:	b29a      	uxth	r2, r3
 8008232:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 8008236:	1ad3      	subs	r3, r2, r3
 8008238:	b29b      	uxth	r3, r3
 800823a:	b21b      	sxth	r3, r3
 800823c:	83bb      	strh	r3, [r7, #28]
                circ_area.x2 = rt_origo.x + LV_CIRC_OCT8_X(cir_out);
 800823e:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8008242:	b29a      	uxth	r2, r3
 8008244:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8008248:	b29b      	uxth	r3, r3
 800824a:	4413      	add	r3, r2
 800824c:	b29b      	uxth	r3, r3
 800824e:	b21b      	sxth	r3, r3
 8008250:	843b      	strh	r3, [r7, #32]
                circ_area.y1 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
 8008252:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8008256:	b29a      	uxth	r2, r3
 8008258:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 800825c:	b29b      	uxth	r3, r3
 800825e:	1ad3      	subs	r3, r2, r3
 8008260:	b29b      	uxth	r3, r3
 8008262:	b21b      	sxth	r3, r3
 8008264:	83fb      	strh	r3, [r7, #30]
                circ_area.y2 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
 8008266:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 800826a:	b29a      	uxth	r2, r3
 800826c:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8008270:	b29b      	uxth	r3, r3
 8008272:	1ad3      	subs	r3, r2, r3
 8008274:	b29b      	uxth	r3, r3
 8008276:	b21b      	sxth	r3, r3
 8008278:	847b      	strh	r3, [r7, #34]	; 0x22
                lv_draw_fill(&circ_area, mask, color, opa);
 800827a:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 800827e:	f107 001c 	add.w	r0, r7, #28
 8008282:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8008286:	68b9      	ldr	r1, [r7, #8]
 8008288:	f7fb ffca 	bl	8004220 <lv_draw_fill>
            }
        }
        lv_circ_next(&cir_out, &tmp_out);
 800828c:	f107 022e 	add.w	r2, r7, #46	; 0x2e
 8008290:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8008294:	4611      	mov	r1, r2
 8008296:	4618      	mov	r0, r3
 8008298:	f004 f82e 	bl	800c2f8 <lv_circ_next>

        /*The internal circle will be ready faster
         * so check it! */
        if(cir_in.y < cir_in.x) {
 800829c:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 80082a0:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80082a4:	429a      	cmp	r2, r3
 80082a6:	da07      	bge.n	80082b8 <lv_draw_rect_border_corner+0xd0e>
            lv_circ_next(&cir_in, &tmp_in);
 80082a8:	f107 0226 	add.w	r2, r7, #38	; 0x26
 80082ac:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80082b0:	4611      	mov	r1, r2
 80082b2:	4618      	mov	r0, r3
 80082b4:	f004 f820 	bl	800c2f8 <lv_circ_next>
    while(cir_out.y <= cir_out.x) {
 80082b8:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 80082bc:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 80082c0:	429a      	cmp	r2, r3
 80082c2:	f77f aa85 	ble.w	80077d0 <lv_draw_rect_border_corner+0x226>
        }
    }

#if LV_ANTIALIAS
    if(aa) {
 80082c6:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 80082ca:	2b00      	cmp	r3, #0
 80082cc:	f000 83b0 	beq.w	8008a30 <lv_draw_rect_border_corner+0x1486>
        /*Last parts of the outer anti-alias*/
        out_y_seg_end       = cir_out.y;
 80082d0:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 80082d2:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
        lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 80082d6:	f8b7 2052 	ldrh.w	r2, [r7, #82]	; 0x52
 80082da:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 80082de:	1ad3      	subs	r3, r2, r3
 80082e0:	b29b      	uxth	r3, r3
 80082e2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
        lv_point_t aa_p;

        aa_p.x = out_x_last;
 80082e6:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 80082ea:	823b      	strh	r3, [r7, #16]
        aa_p.y = out_y_seg_start;
 80082ec:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 80082f0:	827b      	strh	r3, [r7, #18]

        lv_coord_t i;
        for(i = 0; i < seg_size; i++) {
 80082f2:	2300      	movs	r3, #0
 80082f4:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 80082f8:	e146      	b.n	8008588 <lv_draw_rect_border_corner+0xfde>
            lv_opa_t aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 80082fa:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 80082fe:	f9b7 105e 	ldrsh.w	r1, [r7, #94]	; 0x5e
 8008302:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8008306:	4618      	mov	r0, r3
 8008308:	f7fb fe18 	bl	8003f3c <lv_draw_aa_get_opa>
 800830c:	4603      	mov	r3, r0
 800830e:	461a      	mov	r2, r3
 8008310:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8008314:	1a9b      	subs	r3, r3, r2
 8008316:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 800831a:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 800831e:	f003 0301 	and.w	r3, r3, #1
 8008322:	2b00      	cmp	r3, #0
 8008324:	d045      	beq.n	80083b2 <lv_draw_rect_border_corner+0xe08>
 8008326:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 800832a:	f003 0308 	and.w	r3, r3, #8
 800832e:	2b00      	cmp	r3, #0
 8008330:	d03f      	beq.n	80083b2 <lv_draw_rect_border_corner+0xe08>
                lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 8008332:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8008336:	b29a      	uxth	r2, r3
 8008338:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800833c:	b29b      	uxth	r3, r3
 800833e:	4413      	add	r3, r2
 8008340:	b29b      	uxth	r3, r3
 8008342:	3301      	adds	r3, #1
 8008344:	b29b      	uxth	r3, r3
 8008346:	b218      	sxth	r0, r3
 8008348:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 800834c:	b29a      	uxth	r2, r3
 800834e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008352:	b29b      	uxth	r3, r3
 8008354:	4413      	add	r3, r2
 8008356:	b29a      	uxth	r2, r3
 8008358:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 800835c:	4413      	add	r3, r2
 800835e:	b29b      	uxth	r3, r3
 8008360:	b219      	sxth	r1, r3
 8008362:	687b      	ldr	r3, [r7, #4]
 8008364:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 8008368:	9200      	str	r2, [sp, #0]
 800836a:	895b      	ldrh	r3, [r3, #10]
 800836c:	68ba      	ldr	r2, [r7, #8]
 800836e:	f7fb febe 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 8008372:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8008376:	b29a      	uxth	r2, r3
 8008378:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800837c:	b29b      	uxth	r3, r3
 800837e:	4413      	add	r3, r2
 8008380:	b29a      	uxth	r2, r3
 8008382:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8008386:	4413      	add	r3, r2
 8008388:	b29b      	uxth	r3, r3
 800838a:	b218      	sxth	r0, r3
 800838c:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8008390:	b29a      	uxth	r2, r3
 8008392:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8008396:	b29b      	uxth	r3, r3
 8008398:	4413      	add	r3, r2
 800839a:	b29b      	uxth	r3, r3
 800839c:	3301      	adds	r3, #1
 800839e:	b29b      	uxth	r3, r3
 80083a0:	b219      	sxth	r1, r3
 80083a2:	687b      	ldr	r3, [r7, #4]
 80083a4:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 80083a8:	9200      	str	r2, [sp, #0]
 80083aa:	895b      	ldrh	r3, [r3, #10]
 80083ac:	68ba      	ldr	r2, [r7, #8]
 80083ae:	f7fb fe9e 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 80083b2:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80083b6:	f003 0301 	and.w	r3, r3, #1
 80083ba:	2b00      	cmp	r3, #0
 80083bc:	d045      	beq.n	800844a <lv_draw_rect_border_corner+0xea0>
 80083be:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80083c2:	f003 0304 	and.w	r3, r3, #4
 80083c6:	2b00      	cmp	r3, #0
 80083c8:	d03f      	beq.n	800844a <lv_draw_rect_border_corner+0xea0>
                lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 80083ca:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 80083ce:	b29a      	uxth	r2, r3
 80083d0:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80083d4:	b29b      	uxth	r3, r3
 80083d6:	1ad3      	subs	r3, r2, r3
 80083d8:	b29a      	uxth	r2, r3
 80083da:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80083de:	1ad3      	subs	r3, r2, r3
 80083e0:	b29b      	uxth	r3, r3
 80083e2:	b218      	sxth	r0, r3
 80083e4:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80083e8:	b29a      	uxth	r2, r3
 80083ea:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80083ee:	b29b      	uxth	r3, r3
 80083f0:	4413      	add	r3, r2
 80083f2:	b29b      	uxth	r3, r3
 80083f4:	3301      	adds	r3, #1
 80083f6:	b29b      	uxth	r3, r3
 80083f8:	b219      	sxth	r1, r3
 80083fa:	687b      	ldr	r3, [r7, #4]
 80083fc:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 8008400:	9200      	str	r2, [sp, #0]
 8008402:	895b      	ldrh	r3, [r3, #10]
 8008404:	68ba      	ldr	r2, [r7, #8]
 8008406:	f7fb fe72 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 800840a:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 800840e:	b29a      	uxth	r2, r3
 8008410:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8008414:	b29b      	uxth	r3, r3
 8008416:	1ad3      	subs	r3, r2, r3
 8008418:	b29b      	uxth	r3, r3
 800841a:	3b01      	subs	r3, #1
 800841c:	b29b      	uxth	r3, r3
 800841e:	b218      	sxth	r0, r3
 8008420:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8008424:	b29a      	uxth	r2, r3
 8008426:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800842a:	b29b      	uxth	r3, r3
 800842c:	4413      	add	r3, r2
 800842e:	b29a      	uxth	r2, r3
 8008430:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8008434:	4413      	add	r3, r2
 8008436:	b29b      	uxth	r3, r3
 8008438:	b219      	sxth	r1, r3
 800843a:	687b      	ldr	r3, [r7, #4]
 800843c:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 8008440:	9200      	str	r2, [sp, #0]
 8008442:	895b      	ldrh	r3, [r3, #10]
 8008444:	68ba      	ldr	r2, [r7, #8]
 8008446:	f7fb fe52 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 800844a:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 800844e:	f003 0302 	and.w	r3, r3, #2
 8008452:	2b00      	cmp	r3, #0
 8008454:	d045      	beq.n	80084e2 <lv_draw_rect_border_corner+0xf38>
 8008456:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 800845a:	f003 0304 	and.w	r3, r3, #4
 800845e:	2b00      	cmp	r3, #0
 8008460:	d03f      	beq.n	80084e2 <lv_draw_rect_border_corner+0xf38>
                lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 8008462:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8008466:	b29a      	uxth	r2, r3
 8008468:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800846c:	b29b      	uxth	r3, r3
 800846e:	1ad3      	subs	r3, r2, r3
 8008470:	b29b      	uxth	r3, r3
 8008472:	3b01      	subs	r3, #1
 8008474:	b29b      	uxth	r3, r3
 8008476:	b218      	sxth	r0, r3
 8008478:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 800847c:	b29a      	uxth	r2, r3
 800847e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008482:	b29b      	uxth	r3, r3
 8008484:	1ad3      	subs	r3, r2, r3
 8008486:	b29a      	uxth	r2, r3
 8008488:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 800848c:	1ad3      	subs	r3, r2, r3
 800848e:	b29b      	uxth	r3, r3
 8008490:	b219      	sxth	r1, r3
 8008492:	687b      	ldr	r3, [r7, #4]
 8008494:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 8008498:	9200      	str	r2, [sp, #0]
 800849a:	895b      	ldrh	r3, [r3, #10]
 800849c:	68ba      	ldr	r2, [r7, #8]
 800849e:	f7fb fe26 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 80084a2:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 80084a6:	b29a      	uxth	r2, r3
 80084a8:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80084ac:	b29b      	uxth	r3, r3
 80084ae:	1ad3      	subs	r3, r2, r3
 80084b0:	b29a      	uxth	r2, r3
 80084b2:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80084b6:	1ad3      	subs	r3, r2, r3
 80084b8:	b29b      	uxth	r3, r3
 80084ba:	b218      	sxth	r0, r3
 80084bc:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 80084c0:	b29a      	uxth	r2, r3
 80084c2:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80084c6:	b29b      	uxth	r3, r3
 80084c8:	1ad3      	subs	r3, r2, r3
 80084ca:	b29b      	uxth	r3, r3
 80084cc:	3b01      	subs	r3, #1
 80084ce:	b29b      	uxth	r3, r3
 80084d0:	b219      	sxth	r1, r3
 80084d2:	687b      	ldr	r3, [r7, #4]
 80084d4:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 80084d8:	9200      	str	r2, [sp, #0]
 80084da:	895b      	ldrh	r3, [r3, #10]
 80084dc:	68ba      	ldr	r2, [r7, #8]
 80084de:	f7fb fe06 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 80084e2:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80084e6:	f003 0302 	and.w	r3, r3, #2
 80084ea:	2b00      	cmp	r3, #0
 80084ec:	d045      	beq.n	800857a <lv_draw_rect_border_corner+0xfd0>
 80084ee:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80084f2:	f003 0308 	and.w	r3, r3, #8
 80084f6:	2b00      	cmp	r3, #0
 80084f8:	d03f      	beq.n	800857a <lv_draw_rect_border_corner+0xfd0>
                lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 80084fa:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80084fe:	b29a      	uxth	r2, r3
 8008500:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008504:	b29b      	uxth	r3, r3
 8008506:	4413      	add	r3, r2
 8008508:	b29a      	uxth	r2, r3
 800850a:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 800850e:	4413      	add	r3, r2
 8008510:	b29b      	uxth	r3, r3
 8008512:	b218      	sxth	r0, r3
 8008514:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8008518:	b29a      	uxth	r2, r3
 800851a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800851e:	b29b      	uxth	r3, r3
 8008520:	1ad3      	subs	r3, r2, r3
 8008522:	b29b      	uxth	r3, r3
 8008524:	3b01      	subs	r3, #1
 8008526:	b29b      	uxth	r3, r3
 8008528:	b219      	sxth	r1, r3
 800852a:	687b      	ldr	r3, [r7, #4]
 800852c:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 8008530:	9200      	str	r2, [sp, #0]
 8008532:	895b      	ldrh	r3, [r3, #10]
 8008534:	68ba      	ldr	r2, [r7, #8]
 8008536:	f7fb fdda 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 800853a:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 800853e:	b29a      	uxth	r2, r3
 8008540:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8008544:	b29b      	uxth	r3, r3
 8008546:	4413      	add	r3, r2
 8008548:	b29b      	uxth	r3, r3
 800854a:	3301      	adds	r3, #1
 800854c:	b29b      	uxth	r3, r3
 800854e:	b218      	sxth	r0, r3
 8008550:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8008554:	b29a      	uxth	r2, r3
 8008556:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800855a:	b29b      	uxth	r3, r3
 800855c:	1ad3      	subs	r3, r2, r3
 800855e:	b29a      	uxth	r2, r3
 8008560:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8008564:	1ad3      	subs	r3, r2, r3
 8008566:	b29b      	uxth	r3, r3
 8008568:	b219      	sxth	r1, r3
 800856a:	687b      	ldr	r3, [r7, #4]
 800856c:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 8008570:	9200      	str	r2, [sp, #0]
 8008572:	895b      	ldrh	r3, [r3, #10]
 8008574:	68ba      	ldr	r2, [r7, #8]
 8008576:	f7fb fdba 	bl	80040ee <lv_draw_px>
        for(i = 0; i < seg_size; i++) {
 800857a:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 800857e:	b29b      	uxth	r3, r3
 8008580:	3301      	adds	r3, #1
 8008582:	b29b      	uxth	r3, r3
 8008584:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 8008588:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 800858c:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8008590:	429a      	cmp	r2, r3
 8008592:	f6ff aeb2 	blt.w	80082fa <lv_draw_rect_border_corner+0xd50>
                           style->body.border.color, aa_opa);
            }
        }

        /*In some cases the last pixel in the outer middle is not drawn*/
        if(LV_MATH_ABS(aa_p.x - aa_p.y) == seg_size) {
 8008596:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800859a:	461a      	mov	r2, r3
 800859c:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80085a0:	1ad3      	subs	r3, r2, r3
 80085a2:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80085a6:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 80085aa:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 80085ae:	429a      	cmp	r2, r3
 80085b0:	f040 80a3 	bne.w	80086fa <lv_draw_rect_border_corner+0x1150>
            aa_p.x = out_x_last;
 80085b4:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 80085b8:	823b      	strh	r3, [r7, #16]
            aa_p.y = out_x_last;
 80085ba:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 80085be:	827b      	strh	r3, [r7, #18]

            lv_opa_t aa_opa = opa >> 1;
 80085c0:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 80085c4:	085b      	lsrs	r3, r3, #1
 80085c6:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 80085ca:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80085ce:	f003 0301 	and.w	r3, r3, #1
 80085d2:	2b00      	cmp	r3, #0
 80085d4:	d01f      	beq.n	8008616 <lv_draw_rect_border_corner+0x106c>
 80085d6:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80085da:	f003 0308 	and.w	r3, r3, #8
 80085de:	2b00      	cmp	r3, #0
 80085e0:	d019      	beq.n	8008616 <lv_draw_rect_border_corner+0x106c>
                lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p), rb_origo.y + LV_CIRC_OCT2_Y(aa_p), mask,
 80085e2:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 80085e6:	b29a      	uxth	r2, r3
 80085e8:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80085ec:	b29b      	uxth	r3, r3
 80085ee:	4413      	add	r3, r2
 80085f0:	b29b      	uxth	r3, r3
 80085f2:	b218      	sxth	r0, r3
 80085f4:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80085f8:	b29a      	uxth	r2, r3
 80085fa:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80085fe:	b29b      	uxth	r3, r3
 8008600:	4413      	add	r3, r2
 8008602:	b29b      	uxth	r3, r3
 8008604:	b219      	sxth	r1, r3
 8008606:	687b      	ldr	r3, [r7, #4]
 8008608:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 800860c:	9200      	str	r2, [sp, #0]
 800860e:	895b      	ldrh	r3, [r3, #10]
 8008610:	68ba      	ldr	r2, [r7, #8]
 8008612:	f7fb fd6c 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8008616:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 800861a:	f003 0301 	and.w	r3, r3, #1
 800861e:	2b00      	cmp	r3, #0
 8008620:	d01f      	beq.n	8008662 <lv_draw_rect_border_corner+0x10b8>
 8008622:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008626:	f003 0304 	and.w	r3, r3, #4
 800862a:	2b00      	cmp	r3, #0
 800862c:	d019      	beq.n	8008662 <lv_draw_rect_border_corner+0x10b8>
                lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p), lb_origo.y + LV_CIRC_OCT4_Y(aa_p), mask,
 800862e:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8008632:	b29a      	uxth	r2, r3
 8008634:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8008638:	b29b      	uxth	r3, r3
 800863a:	1ad3      	subs	r3, r2, r3
 800863c:	b29b      	uxth	r3, r3
 800863e:	b218      	sxth	r0, r3
 8008640:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8008644:	b29a      	uxth	r2, r3
 8008646:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800864a:	b29b      	uxth	r3, r3
 800864c:	4413      	add	r3, r2
 800864e:	b29b      	uxth	r3, r3
 8008650:	b219      	sxth	r1, r3
 8008652:	687b      	ldr	r3, [r7, #4]
 8008654:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 8008658:	9200      	str	r2, [sp, #0]
 800865a:	895b      	ldrh	r3, [r3, #10]
 800865c:	68ba      	ldr	r2, [r7, #8]
 800865e:	f7fb fd46 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8008662:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008666:	f003 0302 	and.w	r3, r3, #2
 800866a:	2b00      	cmp	r3, #0
 800866c:	d01f      	beq.n	80086ae <lv_draw_rect_border_corner+0x1104>
 800866e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008672:	f003 0304 	and.w	r3, r3, #4
 8008676:	2b00      	cmp	r3, #0
 8008678:	d019      	beq.n	80086ae <lv_draw_rect_border_corner+0x1104>
                lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p), lt_origo.y + LV_CIRC_OCT6_Y(aa_p), mask,
 800867a:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 800867e:	b29a      	uxth	r2, r3
 8008680:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008684:	b29b      	uxth	r3, r3
 8008686:	1ad3      	subs	r3, r2, r3
 8008688:	b29b      	uxth	r3, r3
 800868a:	b218      	sxth	r0, r3
 800868c:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8008690:	b29a      	uxth	r2, r3
 8008692:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8008696:	b29b      	uxth	r3, r3
 8008698:	1ad3      	subs	r3, r2, r3
 800869a:	b29b      	uxth	r3, r3
 800869c:	b219      	sxth	r1, r3
 800869e:	687b      	ldr	r3, [r7, #4]
 80086a0:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 80086a4:	9200      	str	r2, [sp, #0]
 80086a6:	895b      	ldrh	r3, [r3, #10]
 80086a8:	68ba      	ldr	r2, [r7, #8]
 80086aa:	f7fb fd20 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 80086ae:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80086b2:	f003 0302 	and.w	r3, r3, #2
 80086b6:	2b00      	cmp	r3, #0
 80086b8:	d01f      	beq.n	80086fa <lv_draw_rect_border_corner+0x1150>
 80086ba:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80086be:	f003 0308 	and.w	r3, r3, #8
 80086c2:	2b00      	cmp	r3, #0
 80086c4:	d019      	beq.n	80086fa <lv_draw_rect_border_corner+0x1150>
                lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p), rt_origo.y + LV_CIRC_OCT8_Y(aa_p), mask,
 80086c6:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80086ca:	b29a      	uxth	r2, r3
 80086cc:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80086d0:	b29b      	uxth	r3, r3
 80086d2:	4413      	add	r3, r2
 80086d4:	b29b      	uxth	r3, r3
 80086d6:	b218      	sxth	r0, r3
 80086d8:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 80086dc:	b29a      	uxth	r2, r3
 80086de:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80086e2:	b29b      	uxth	r3, r3
 80086e4:	1ad3      	subs	r3, r2, r3
 80086e6:	b29b      	uxth	r3, r3
 80086e8:	b219      	sxth	r1, r3
 80086ea:	687b      	ldr	r3, [r7, #4]
 80086ec:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 80086f0:	9200      	str	r2, [sp, #0]
 80086f2:	895b      	ldrh	r3, [r3, #10]
 80086f4:	68ba      	ldr	r2, [r7, #8]
 80086f6:	f7fb fcfa 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
            }
        }

        /*Last parts of the inner anti-alias*/
        in_y_seg_end = cir_in.y;
 80086fa:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80086fc:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
        aa_p.x       = in_x_last;
 8008700:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 8008704:	823b      	strh	r3, [r7, #16]
        aa_p.y       = in_y_seg_start;
 8008706:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 800870a:	827b      	strh	r3, [r7, #18]
        seg_size     = in_y_seg_end - in_y_seg_start;
 800870c:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 8008710:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 8008714:	1ad3      	subs	r3, r2, r3
 8008716:	b29b      	uxth	r3, r3
 8008718:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

        for(i = 0; i < seg_size; i++) {
 800871c:	2300      	movs	r3, #0
 800871e:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 8008722:	e17e      	b.n	8008a22 <lv_draw_rect_border_corner+0x1478>
            lv_opa_t aa_opa = lv_draw_aa_get_opa(seg_size, i, opa);
 8008724:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 8008728:	f9b7 105e 	ldrsh.w	r1, [r7, #94]	; 0x5e
 800872c:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8008730:	4618      	mov	r0, r3
 8008732:	f7fb fc03 	bl	8003f3c <lv_draw_aa_get_opa>
 8008736:	4603      	mov	r3, r0
 8008738:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 800873c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008740:	f003 0301 	and.w	r3, r3, #1
 8008744:	2b00      	cmp	r3, #0
 8008746:	d025      	beq.n	8008794 <lv_draw_rect_border_corner+0x11ea>
 8008748:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 800874c:	f003 0308 	and.w	r3, r3, #8
 8008750:	2b00      	cmp	r3, #0
 8008752:	d01f      	beq.n	8008794 <lv_draw_rect_border_corner+0x11ea>
                lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) - 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 8008754:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8008758:	b29a      	uxth	r2, r3
 800875a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800875e:	b29b      	uxth	r3, r3
 8008760:	4413      	add	r3, r2
 8008762:	b29b      	uxth	r3, r3
 8008764:	3b01      	subs	r3, #1
 8008766:	b29b      	uxth	r3, r3
 8008768:	b218      	sxth	r0, r3
 800876a:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 800876e:	b29a      	uxth	r2, r3
 8008770:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008774:	b29b      	uxth	r3, r3
 8008776:	4413      	add	r3, r2
 8008778:	b29a      	uxth	r2, r3
 800877a:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 800877e:	4413      	add	r3, r2
 8008780:	b29b      	uxth	r3, r3
 8008782:	b219      	sxth	r1, r3
 8008784:	687b      	ldr	r3, [r7, #4]
 8008786:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 800878a:	9200      	str	r2, [sp, #0]
 800878c:	895b      	ldrh	r3, [r3, #10]
 800878e:	68ba      	ldr	r2, [r7, #8]
 8008790:	f7fb fcad 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8008794:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008798:	f003 0301 	and.w	r3, r3, #1
 800879c:	2b00      	cmp	r3, #0
 800879e:	d025      	beq.n	80087ec <lv_draw_rect_border_corner+0x1242>
 80087a0:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80087a4:	f003 0304 	and.w	r3, r3, #4
 80087a8:	2b00      	cmp	r3, #0
 80087aa:	d01f      	beq.n	80087ec <lv_draw_rect_border_corner+0x1242>
                lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) - 1, mask,
 80087ac:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 80087b0:	b29a      	uxth	r2, r3
 80087b2:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80087b6:	b29b      	uxth	r3, r3
 80087b8:	1ad3      	subs	r3, r2, r3
 80087ba:	b29a      	uxth	r2, r3
 80087bc:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80087c0:	1ad3      	subs	r3, r2, r3
 80087c2:	b29b      	uxth	r3, r3
 80087c4:	b218      	sxth	r0, r3
 80087c6:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80087ca:	b29a      	uxth	r2, r3
 80087cc:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80087d0:	b29b      	uxth	r3, r3
 80087d2:	4413      	add	r3, r2
 80087d4:	b29b      	uxth	r3, r3
 80087d6:	3b01      	subs	r3, #1
 80087d8:	b29b      	uxth	r3, r3
 80087da:	b219      	sxth	r1, r3
 80087dc:	687b      	ldr	r3, [r7, #4]
 80087de:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 80087e2:	9200      	str	r2, [sp, #0]
 80087e4:	895b      	ldrh	r3, [r3, #10]
 80087e6:	68ba      	ldr	r2, [r7, #8]
 80087e8:	f7fb fc81 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 80087ec:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80087f0:	f003 0302 	and.w	r3, r3, #2
 80087f4:	2b00      	cmp	r3, #0
 80087f6:	d025      	beq.n	8008844 <lv_draw_rect_border_corner+0x129a>
 80087f8:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80087fc:	f003 0304 	and.w	r3, r3, #4
 8008800:	2b00      	cmp	r3, #0
 8008802:	d01f      	beq.n	8008844 <lv_draw_rect_border_corner+0x129a>
                lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) + 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 8008804:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8008808:	b29a      	uxth	r2, r3
 800880a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800880e:	b29b      	uxth	r3, r3
 8008810:	1ad3      	subs	r3, r2, r3
 8008812:	b29b      	uxth	r3, r3
 8008814:	3301      	adds	r3, #1
 8008816:	b29b      	uxth	r3, r3
 8008818:	b218      	sxth	r0, r3
 800881a:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 800881e:	b29a      	uxth	r2, r3
 8008820:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008824:	b29b      	uxth	r3, r3
 8008826:	1ad3      	subs	r3, r2, r3
 8008828:	b29a      	uxth	r2, r3
 800882a:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 800882e:	1ad3      	subs	r3, r2, r3
 8008830:	b29b      	uxth	r3, r3
 8008832:	b219      	sxth	r1, r3
 8008834:	687b      	ldr	r3, [r7, #4]
 8008836:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 800883a:	9200      	str	r2, [sp, #0]
 800883c:	895b      	ldrh	r3, [r3, #10]
 800883e:	68ba      	ldr	r2, [r7, #8]
 8008840:	f7fb fc55 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8008844:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008848:	f003 0302 	and.w	r3, r3, #2
 800884c:	2b00      	cmp	r3, #0
 800884e:	d025      	beq.n	800889c <lv_draw_rect_border_corner+0x12f2>
 8008850:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008854:	f003 0308 	and.w	r3, r3, #8
 8008858:	2b00      	cmp	r3, #0
 800885a:	d01f      	beq.n	800889c <lv_draw_rect_border_corner+0x12f2>
                lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) + 1, mask,
 800885c:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8008860:	b29a      	uxth	r2, r3
 8008862:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008866:	b29b      	uxth	r3, r3
 8008868:	4413      	add	r3, r2
 800886a:	b29a      	uxth	r2, r3
 800886c:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8008870:	4413      	add	r3, r2
 8008872:	b29b      	uxth	r3, r3
 8008874:	b218      	sxth	r0, r3
 8008876:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 800887a:	b29a      	uxth	r2, r3
 800887c:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8008880:	b29b      	uxth	r3, r3
 8008882:	1ad3      	subs	r3, r2, r3
 8008884:	b29b      	uxth	r3, r3
 8008886:	3301      	adds	r3, #1
 8008888:	b29b      	uxth	r3, r3
 800888a:	b219      	sxth	r1, r3
 800888c:	687b      	ldr	r3, [r7, #4]
 800888e:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 8008892:	9200      	str	r2, [sp, #0]
 8008894:	895b      	ldrh	r3, [r3, #10]
 8008896:	68ba      	ldr	r2, [r7, #8]
 8008898:	f7fb fc29 	bl	80040ee <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if(LV_CIRC_OCT1_X(aa_p) - 1 != LV_CIRC_OCT2_X(aa_p) + i) {
 800889c:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80088a0:	1e5a      	subs	r2, r3, #1
 80088a2:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80088a6:	4619      	mov	r1, r3
 80088a8:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80088ac:	440b      	add	r3, r1
 80088ae:	429a      	cmp	r2, r3
 80088b0:	f000 80b0 	beq.w	8008a14 <lv_draw_rect_border_corner+0x146a>
                if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 80088b4:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80088b8:	f003 0301 	and.w	r3, r3, #1
 80088bc:	2b00      	cmp	r3, #0
 80088be:	d025      	beq.n	800890c <lv_draw_rect_border_corner+0x1362>
 80088c0:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80088c4:	f003 0308 	and.w	r3, r3, #8
 80088c8:	2b00      	cmp	r3, #0
 80088ca:	d01f      	beq.n	800890c <lv_draw_rect_border_corner+0x1362>
                    lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) - 1, mask,
 80088cc:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 80088d0:	b29a      	uxth	r2, r3
 80088d2:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80088d6:	b29b      	uxth	r3, r3
 80088d8:	4413      	add	r3, r2
 80088da:	b29a      	uxth	r2, r3
 80088dc:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80088e0:	4413      	add	r3, r2
 80088e2:	b29b      	uxth	r3, r3
 80088e4:	b218      	sxth	r0, r3
 80088e6:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80088ea:	b29a      	uxth	r2, r3
 80088ec:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80088f0:	b29b      	uxth	r3, r3
 80088f2:	4413      	add	r3, r2
 80088f4:	b29b      	uxth	r3, r3
 80088f6:	3b01      	subs	r3, #1
 80088f8:	b29b      	uxth	r3, r3
 80088fa:	b219      	sxth	r1, r3
 80088fc:	687b      	ldr	r3, [r7, #4]
 80088fe:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 8008902:	9200      	str	r2, [sp, #0]
 8008904:	895b      	ldrh	r3, [r3, #10]
 8008906:	68ba      	ldr	r2, [r7, #8]
 8008908:	f7fb fbf1 	bl	80040ee <lv_draw_px>
                               style->body.border.color, aa_opa);
                }

                if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 800890c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008910:	f003 0301 	and.w	r3, r3, #1
 8008914:	2b00      	cmp	r3, #0
 8008916:	d025      	beq.n	8008964 <lv_draw_rect_border_corner+0x13ba>
 8008918:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 800891c:	f003 0304 	and.w	r3, r3, #4
 8008920:	2b00      	cmp	r3, #0
 8008922:	d01f      	beq.n	8008964 <lv_draw_rect_border_corner+0x13ba>
                    lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) + 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 8008924:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8008928:	b29a      	uxth	r2, r3
 800892a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800892e:	b29b      	uxth	r3, r3
 8008930:	1ad3      	subs	r3, r2, r3
 8008932:	b29b      	uxth	r3, r3
 8008934:	3301      	adds	r3, #1
 8008936:	b29b      	uxth	r3, r3
 8008938:	b218      	sxth	r0, r3
 800893a:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 800893e:	b29a      	uxth	r2, r3
 8008940:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008944:	b29b      	uxth	r3, r3
 8008946:	4413      	add	r3, r2
 8008948:	b29a      	uxth	r2, r3
 800894a:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 800894e:	4413      	add	r3, r2
 8008950:	b29b      	uxth	r3, r3
 8008952:	b219      	sxth	r1, r3
 8008954:	687b      	ldr	r3, [r7, #4]
 8008956:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 800895a:	9200      	str	r2, [sp, #0]
 800895c:	895b      	ldrh	r3, [r3, #10]
 800895e:	68ba      	ldr	r2, [r7, #8]
 8008960:	f7fb fbc5 	bl	80040ee <lv_draw_px>
                               style->body.border.color, aa_opa);
                }

                if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8008964:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008968:	f003 0302 	and.w	r3, r3, #2
 800896c:	2b00      	cmp	r3, #0
 800896e:	d025      	beq.n	80089bc <lv_draw_rect_border_corner+0x1412>
 8008970:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8008974:	f003 0304 	and.w	r3, r3, #4
 8008978:	2b00      	cmp	r3, #0
 800897a:	d01f      	beq.n	80089bc <lv_draw_rect_border_corner+0x1412>
                    lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) + 1, mask,
 800897c:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8008980:	b29a      	uxth	r2, r3
 8008982:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008986:	b29b      	uxth	r3, r3
 8008988:	1ad3      	subs	r3, r2, r3
 800898a:	b29a      	uxth	r2, r3
 800898c:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8008990:	1ad3      	subs	r3, r2, r3
 8008992:	b29b      	uxth	r3, r3
 8008994:	b218      	sxth	r0, r3
 8008996:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 800899a:	b29a      	uxth	r2, r3
 800899c:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80089a0:	b29b      	uxth	r3, r3
 80089a2:	1ad3      	subs	r3, r2, r3
 80089a4:	b29b      	uxth	r3, r3
 80089a6:	3301      	adds	r3, #1
 80089a8:	b29b      	uxth	r3, r3
 80089aa:	b219      	sxth	r1, r3
 80089ac:	687b      	ldr	r3, [r7, #4]
 80089ae:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 80089b2:	9200      	str	r2, [sp, #0]
 80089b4:	895b      	ldrh	r3, [r3, #10]
 80089b6:	68ba      	ldr	r2, [r7, #8]
 80089b8:	f7fb fb99 	bl	80040ee <lv_draw_px>
                               style->body.border.color, aa_opa);
                }

                if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 80089bc:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80089c0:	f003 0302 	and.w	r3, r3, #2
 80089c4:	2b00      	cmp	r3, #0
 80089c6:	d025      	beq.n	8008a14 <lv_draw_rect_border_corner+0x146a>
 80089c8:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80089cc:	f003 0308 	and.w	r3, r3, #8
 80089d0:	2b00      	cmp	r3, #0
 80089d2:	d01f      	beq.n	8008a14 <lv_draw_rect_border_corner+0x146a>
                    lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) - 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 80089d4:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80089d8:	b29a      	uxth	r2, r3
 80089da:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80089de:	b29b      	uxth	r3, r3
 80089e0:	4413      	add	r3, r2
 80089e2:	b29b      	uxth	r3, r3
 80089e4:	3b01      	subs	r3, #1
 80089e6:	b29b      	uxth	r3, r3
 80089e8:	b218      	sxth	r0, r3
 80089ea:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 80089ee:	b29a      	uxth	r2, r3
 80089f0:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80089f4:	b29b      	uxth	r3, r3
 80089f6:	1ad3      	subs	r3, r2, r3
 80089f8:	b29a      	uxth	r2, r3
 80089fa:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80089fe:	1ad3      	subs	r3, r2, r3
 8008a00:	b29b      	uxth	r3, r3
 8008a02:	b219      	sxth	r1, r3
 8008a04:	687b      	ldr	r3, [r7, #4]
 8008a06:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 8008a0a:	9200      	str	r2, [sp, #0]
 8008a0c:	895b      	ldrh	r3, [r3, #10]
 8008a0e:	68ba      	ldr	r2, [r7, #8]
 8008a10:	f7fb fb6d 	bl	80040ee <lv_draw_px>
        for(i = 0; i < seg_size; i++) {
 8008a14:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8008a18:	b29b      	uxth	r3, r3
 8008a1a:	3301      	adds	r3, #1
 8008a1c:	b29b      	uxth	r3, r3
 8008a1e:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 8008a22:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 8008a26:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8008a2a:	429a      	cmp	r2, r3
 8008a2c:	f6ff ae7a 	blt.w	8008724 <lv_draw_rect_border_corner+0x117a>
                }
            }
        }
    }
#endif
}
 8008a30:	bf00      	nop
 8008a32:	3778      	adds	r7, #120	; 0x78
 8008a34:	46bd      	mov	sp, r7
 8008a36:	bd80      	pop	{r7, pc}

08008a38 <lv_draw_shadow>:
 * @param mask pointer to a mask area (from the design functions)
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_shadow(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                           lv_opa_t opa_scale)
{
 8008a38:	b580      	push	{r7, lr}
 8008a3a:	b088      	sub	sp, #32
 8008a3c:	af00      	add	r7, sp, #0
 8008a3e:	60f8      	str	r0, [r7, #12]
 8008a40:	60b9      	str	r1, [r7, #8]
 8008a42:	607a      	str	r2, [r7, #4]
 8008a44:	70fb      	strb	r3, [r7, #3]
    /* If mask is in the middle of cords do not draw shadow*/
    lv_coord_t radius = style->body.radius;
 8008a46:	687b      	ldr	r3, [r7, #4]
 8008a48:	88db      	ldrh	r3, [r3, #6]
 8008a4a:	83fb      	strh	r3, [r7, #30]
    lv_coord_t width  = lv_area_get_width(coords);
 8008a4c:	68f8      	ldr	r0, [r7, #12]
 8008a4e:	f7fd f844 	bl	8005ada <lv_area_get_width>
 8008a52:	4603      	mov	r3, r0
 8008a54:	83bb      	strh	r3, [r7, #28]
    lv_coord_t height = lv_area_get_height(coords);
 8008a56:	68f8      	ldr	r0, [r7, #12]
 8008a58:	f7fd f856 	bl	8005b08 <lv_area_get_height>
 8008a5c:	4603      	mov	r3, r0
 8008a5e:	837b      	strh	r3, [r7, #26]
    radius            = lv_draw_cont_radius_corr(radius, width, height);
 8008a60:	8bfb      	ldrh	r3, [r7, #30]
 8008a62:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 8008a66:	f9b7 101c 	ldrsh.w	r1, [r7, #28]
 8008a6a:	4618      	mov	r0, r3
 8008a6c:	f000 fedc 	bl	8009828 <lv_draw_cont_radius_corr>
 8008a70:	4603      	mov	r3, r0
 8008a72:	83fb      	strh	r3, [r7, #30]
    lv_area_t area_tmp;

    /*Check horizontally without radius*/
    lv_area_copy(&area_tmp, coords);
 8008a74:	f107 0310 	add.w	r3, r7, #16
 8008a78:	68f9      	ldr	r1, [r7, #12]
 8008a7a:	4618      	mov	r0, r3
 8008a7c:	f7fd f81f 	bl	8005abe <lv_area_copy>
    area_tmp.x1 += radius;
 8008a80:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8008a84:	b29a      	uxth	r2, r3
 8008a86:	8bfb      	ldrh	r3, [r7, #30]
 8008a88:	4413      	add	r3, r2
 8008a8a:	b29b      	uxth	r3, r3
 8008a8c:	b21b      	sxth	r3, r3
 8008a8e:	823b      	strh	r3, [r7, #16]
    area_tmp.x2 -= radius;
 8008a90:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8008a94:	b29a      	uxth	r2, r3
 8008a96:	8bfb      	ldrh	r3, [r7, #30]
 8008a98:	1ad3      	subs	r3, r2, r3
 8008a9a:	b29b      	uxth	r3, r3
 8008a9c:	b21b      	sxth	r3, r3
 8008a9e:	82bb      	strh	r3, [r7, #20]
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 8008aa0:	f107 0310 	add.w	r3, r7, #16
 8008aa4:	4619      	mov	r1, r3
 8008aa6:	68b8      	ldr	r0, [r7, #8]
 8008aa8:	f003 fbc7 	bl	800c23a <lv_area_is_in>
 8008aac:	4603      	mov	r3, r0
 8008aae:	2b00      	cmp	r3, #0
 8008ab0:	d134      	bne.n	8008b1c <lv_draw_shadow+0xe4>

    /*Check vertically without radius*/
    lv_area_copy(&area_tmp, coords);
 8008ab2:	f107 0310 	add.w	r3, r7, #16
 8008ab6:	68f9      	ldr	r1, [r7, #12]
 8008ab8:	4618      	mov	r0, r3
 8008aba:	f7fd f800 	bl	8005abe <lv_area_copy>
    area_tmp.y1 += radius;
 8008abe:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008ac2:	b29a      	uxth	r2, r3
 8008ac4:	8bfb      	ldrh	r3, [r7, #30]
 8008ac6:	4413      	add	r3, r2
 8008ac8:	b29b      	uxth	r3, r3
 8008aca:	b21b      	sxth	r3, r3
 8008acc:	827b      	strh	r3, [r7, #18]
    area_tmp.y2 -= radius;
 8008ace:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8008ad2:	b29a      	uxth	r2, r3
 8008ad4:	8bfb      	ldrh	r3, [r7, #30]
 8008ad6:	1ad3      	subs	r3, r2, r3
 8008ad8:	b29b      	uxth	r3, r3
 8008ada:	b21b      	sxth	r3, r3
 8008adc:	82fb      	strh	r3, [r7, #22]
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 8008ade:	f107 0310 	add.w	r3, r7, #16
 8008ae2:	4619      	mov	r1, r3
 8008ae4:	68b8      	ldr	r0, [r7, #8]
 8008ae6:	f003 fba8 	bl	800c23a <lv_area_is_in>
 8008aea:	4603      	mov	r3, r0
 8008aec:	2b00      	cmp	r3, #0
 8008aee:	d117      	bne.n	8008b20 <lv_draw_shadow+0xe8>

    if(style->body.shadow.type == LV_SHADOW_FULL) {
 8008af0:	687b      	ldr	r3, [r7, #4]
 8008af2:	7d1b      	ldrb	r3, [r3, #20]
 8008af4:	2b01      	cmp	r3, #1
 8008af6:	d106      	bne.n	8008b06 <lv_draw_shadow+0xce>
        lv_draw_shadow_full(coords, mask, style, opa_scale);
 8008af8:	78fb      	ldrb	r3, [r7, #3]
 8008afa:	687a      	ldr	r2, [r7, #4]
 8008afc:	68b9      	ldr	r1, [r7, #8]
 8008afe:	68f8      	ldr	r0, [r7, #12]
 8008b00:	f000 f812 	bl	8008b28 <lv_draw_shadow_full>
 8008b04:	e00d      	b.n	8008b22 <lv_draw_shadow+0xea>
    } else if(style->body.shadow.type == LV_SHADOW_BOTTOM) {
 8008b06:	687b      	ldr	r3, [r7, #4]
 8008b08:	7d1b      	ldrb	r3, [r3, #20]
 8008b0a:	2b00      	cmp	r3, #0
 8008b0c:	d109      	bne.n	8008b22 <lv_draw_shadow+0xea>
        lv_draw_shadow_bottom(coords, mask, style, opa_scale);
 8008b0e:	78fb      	ldrb	r3, [r7, #3]
 8008b10:	687a      	ldr	r2, [r7, #4]
 8008b12:	68b9      	ldr	r1, [r7, #8]
 8008b14:	68f8      	ldr	r0, [r7, #12]
 8008b16:	f000 fb2e 	bl	8009176 <lv_draw_shadow_bottom>
 8008b1a:	e002      	b.n	8008b22 <lv_draw_shadow+0xea>
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 8008b1c:	bf00      	nop
 8008b1e:	e000      	b.n	8008b22 <lv_draw_shadow+0xea>
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 8008b20:	bf00      	nop
    }
}
 8008b22:	3720      	adds	r7, #32
 8008b24:	46bd      	mov	sp, r7
 8008b26:	bd80      	pop	{r7, pc}

08008b28 <lv_draw_shadow_full>:

static void lv_draw_shadow_full(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                lv_opa_t opa_scale)
{
 8008b28:	b580      	push	{r7, lr}
 8008b2a:	b0a0      	sub	sp, #128	; 0x80
 8008b2c:	af02      	add	r7, sp, #8
 8008b2e:	60f8      	str	r0, [r7, #12]
 8008b30:	60b9      	str	r1, [r7, #8]
 8008b32:	607a      	str	r2, [r7, #4]
 8008b34:	70fb      	strb	r3, [r7, #3]
     * radius means smaller average shadow opacity. The solution should be to start `line` from `-
     * swidth` and handle if the straight part is short (or zero) and the value is taken from the
     * other corner. `col` also should start from `- swidth`
     */

    bool aa = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8008b36:	f7fa fa0d 	bl	8002f54 <lv_refr_get_disp_refreshing>
 8008b3a:	4603      	mov	r3, r0
 8008b3c:	4618      	mov	r0, r3
 8008b3e:	f002 ff8a 	bl	800ba56 <lv_disp_get_antialiasing>
 8008b42:	4603      	mov	r3, r0
 8008b44:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67

    lv_coord_t radius = style->body.radius;
 8008b48:	687b      	ldr	r3, [r7, #4]
 8008b4a:	88db      	ldrh	r3, [r3, #6]
 8008b4c:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    lv_coord_t swidth = style->body.shadow.width;
 8008b50:	687b      	ldr	r3, [r7, #4]
 8008b52:	8a5b      	ldrh	r3, [r3, #18]
 8008b54:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

    lv_coord_t width  = lv_area_get_width(coords);
 8008b58:	68f8      	ldr	r0, [r7, #12]
 8008b5a:	f7fc ffbe 	bl	8005ada <lv_area_get_width>
 8008b5e:	4603      	mov	r3, r0
 8008b60:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    lv_coord_t height = lv_area_get_height(coords);
 8008b64:	68f8      	ldr	r0, [r7, #12]
 8008b66:	f7fc ffcf 	bl	8005b08 <lv_area_get_height>
 8008b6a:	4603      	mov	r3, r0
 8008b6c:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8008b70:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8008b74:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 8008b78:	f9b7 1060 	ldrsh.w	r1, [r7, #96]	; 0x60
 8008b7c:	4618      	mov	r0, r3
 8008b7e:	f000 fe53 	bl	8009828 <lv_draw_cont_radius_corr>
 8008b82:	4603      	mov	r3, r0
 8008b84:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64

    radius += aa;
 8008b88:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8008b8c:	b29a      	uxth	r2, r3
 8008b8e:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8008b92:	4413      	add	r3, r2
 8008b94:	b29b      	uxth	r3, r3
 8008b96:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64

    /*Allocate a draw buffer the buffer required to draw the shadow*/
    int16_t filter_width = 2 * swidth + 1;
 8008b9a:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8008b9e:	005b      	lsls	r3, r3, #1
 8008ba0:	b29b      	uxth	r3, r3
 8008ba2:	3301      	adds	r3, #1
 8008ba4:	b29b      	uxth	r3, r3
 8008ba6:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    uint32_t curve_x_size = ((radius + swidth + 1) + 3) & ~0x3; /*Round to 4*/
 8008baa:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 8008bae:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8008bb2:	4413      	add	r3, r2
 8008bb4:	3304      	adds	r3, #4
 8008bb6:	f023 0303 	bic.w	r3, r3, #3
 8008bba:	65bb      	str	r3, [r7, #88]	; 0x58
    curve_x_size *= sizeof(lv_coord_t);
 8008bbc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8008bbe:	005b      	lsls	r3, r3, #1
 8008bc0:	65bb      	str	r3, [r7, #88]	; 0x58
    uint32_t line_1d_blur_size = (filter_width + 3) & ~0x3;     /*Round to 4*/
 8008bc2:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8008bc6:	3303      	adds	r3, #3
 8008bc8:	f023 0303 	bic.w	r3, r3, #3
 8008bcc:	657b      	str	r3, [r7, #84]	; 0x54
    line_1d_blur_size *= sizeof(uint32_t);
 8008bce:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8008bd0:	009b      	lsls	r3, r3, #2
 8008bd2:	657b      	str	r3, [r7, #84]	; 0x54
    uint32_t line_2d_blur_size = ((radius + swidth + 1) + 3) & ~0x3;     /*Round to 4*/
 8008bd4:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 8008bd8:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8008bdc:	4413      	add	r3, r2
 8008bde:	3304      	adds	r3, #4
 8008be0:	f023 0303 	bic.w	r3, r3, #3
 8008be4:	653b      	str	r3, [r7, #80]	; 0x50
    line_2d_blur_size *= sizeof(lv_opa_t);

    uint8_t * draw_buf = lv_draw_get_buf(curve_x_size + line_1d_blur_size + line_2d_blur_size);
 8008be6:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8008be8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8008bea:	441a      	add	r2, r3
 8008bec:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008bee:	4413      	add	r3, r2
 8008bf0:	4618      	mov	r0, r3
 8008bf2:	f7fb f92f 	bl	8003e54 <lv_draw_get_buf>
 8008bf6:	64f8      	str	r0, [r7, #76]	; 0x4c

    /*Divide the draw buffer*/
    lv_coord_t  * curve_x = (lv_coord_t *)&draw_buf[0]; /*Stores the 'x' coordinates of a quarter circle.*/
 8008bf8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008bfa:	64bb      	str	r3, [r7, #72]	; 0x48
    uint32_t * line_1d_blur = (uint32_t *)&draw_buf[curve_x_size];
 8008bfc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008bfe:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8008c00:	4413      	add	r3, r2
 8008c02:	647b      	str	r3, [r7, #68]	; 0x44
    lv_opa_t * line_2d_blur = (lv_opa_t *)&draw_buf[curve_x_size + line_1d_blur_size];
 8008c04:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8008c06:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8008c08:	4413      	add	r3, r2
 8008c0a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008c0c:	4413      	add	r3, r2
 8008c0e:	643b      	str	r3, [r7, #64]	; 0x40

    memset(curve_x, 0, curve_x_size);
 8008c10:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8008c12:	2100      	movs	r1, #0
 8008c14:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8008c16:	f00a fda2 	bl	801375e <memset>
    lv_point_t circ;
    lv_coord_t circ_tmp;
    lv_circ_init(&circ, &circ_tmp, radius);
 8008c1a:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 8008c1e:	f107 0136 	add.w	r1, r7, #54	; 0x36
 8008c22:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8008c26:	4618      	mov	r0, r3
 8008c28:	f003 fb37 	bl	800c29a <lv_circ_init>
    while(lv_circ_cont(&circ)) {
 8008c2c:	e017      	b.n	8008c5e <lv_draw_shadow_full+0x136>
        curve_x[LV_CIRC_OCT1_Y(circ)] = LV_CIRC_OCT1_X(circ);
 8008c2e:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8008c32:	005b      	lsls	r3, r3, #1
 8008c34:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8008c36:	4413      	add	r3, r2
 8008c38:	f9b7 2038 	ldrsh.w	r2, [r7, #56]	; 0x38
 8008c3c:	801a      	strh	r2, [r3, #0]
        curve_x[LV_CIRC_OCT2_Y(circ)] = LV_CIRC_OCT2_X(circ);
 8008c3e:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8008c42:	005b      	lsls	r3, r3, #1
 8008c44:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8008c46:	4413      	add	r3, r2
 8008c48:	f9b7 203a 	ldrsh.w	r2, [r7, #58]	; 0x3a
 8008c4c:	801a      	strh	r2, [r3, #0]
        lv_circ_next(&circ, &circ_tmp);
 8008c4e:	f107 0236 	add.w	r2, r7, #54	; 0x36
 8008c52:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8008c56:	4611      	mov	r1, r2
 8008c58:	4618      	mov	r0, r3
 8008c5a:	f003 fb4d 	bl	800c2f8 <lv_circ_next>
    while(lv_circ_cont(&circ)) {
 8008c5e:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8008c62:	4618      	mov	r0, r3
 8008c64:	f003 fb33 	bl	800c2ce <lv_circ_cont>
 8008c68:	4603      	mov	r3, r0
 8008c6a:	2b00      	cmp	r3, #0
 8008c6c:	d1df      	bne.n	8008c2e <lv_draw_shadow_full+0x106>
    }
    int16_t line;
    /*1D Blur horizontally*/
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 8008c6e:	78fb      	ldrb	r3, [r7, #3]
 8008c70:	2bff      	cmp	r3, #255	; 0xff
 8008c72:	d102      	bne.n	8008c7a <lv_draw_shadow_full+0x152>
 8008c74:	687b      	ldr	r3, [r7, #4]
 8008c76:	7a1b      	ldrb	r3, [r3, #8]
 8008c78:	e00a      	b.n	8008c90 <lv_draw_shadow_full+0x168>
 8008c7a:	687b      	ldr	r3, [r7, #4]
 8008c7c:	7a1b      	ldrb	r3, [r3, #8]
 8008c7e:	b29a      	uxth	r2, r3
 8008c80:	78fb      	ldrb	r3, [r7, #3]
 8008c82:	b29b      	uxth	r3, r3
 8008c84:	fb12 f303 	smulbb	r3, r2, r3
 8008c88:	b29b      	uxth	r3, r3
 8008c8a:	0a1b      	lsrs	r3, r3, #8
 8008c8c:	b29b      	uxth	r3, r3
 8008c8e:	b2db      	uxtb	r3, r3
 8008c90:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    for(line = 0; line < filter_width; line++) {
 8008c94:	2300      	movs	r3, #0
 8008c96:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 8008c9a:	e021      	b.n	8008ce0 <lv_draw_shadow_full+0x1b8>
        line_1d_blur[line] = (uint32_t)((uint32_t)(filter_width - line) * (opa * 2) << SHADOW_OPA_EXTRA_PRECISION) /
 8008c9c:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 8008ca0:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8008ca4:	1ad3      	subs	r3, r2, r3
 8008ca6:	461a      	mov	r2, r3
 8008ca8:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8008cac:	fb03 f302 	mul.w	r3, r3, r2
 8008cb0:	005b      	lsls	r3, r3, #1
 8008cb2:	021a      	lsls	r2, r3, #8
                             (filter_width * filter_width);
 8008cb4:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8008cb8:	f9b7 105c 	ldrsh.w	r1, [r7, #92]	; 0x5c
 8008cbc:	fb01 f303 	mul.w	r3, r1, r3
 8008cc0:	4618      	mov	r0, r3
        line_1d_blur[line] = (uint32_t)((uint32_t)(filter_width - line) * (opa * 2) << SHADOW_OPA_EXTRA_PRECISION) /
 8008cc2:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8008cc6:	009b      	lsls	r3, r3, #2
 8008cc8:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8008cca:	440b      	add	r3, r1
 8008ccc:	fbb2 f2f0 	udiv	r2, r2, r0
 8008cd0:	601a      	str	r2, [r3, #0]
    for(line = 0; line < filter_width; line++) {
 8008cd2:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8008cd6:	b29b      	uxth	r3, r3
 8008cd8:	3301      	adds	r3, #1
 8008cda:	b29b      	uxth	r3, r3
 8008cdc:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 8008ce0:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 8008ce4:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8008ce8:	429a      	cmp	r2, r3
 8008cea:	dbd7      	blt.n	8008c9c <lv_draw_shadow_full+0x174>
    lv_point_t point_lb;
    lv_point_t ofs_rb;
    lv_point_t ofs_rt;
    lv_point_t ofs_lb;
    lv_point_t ofs_lt;
    ofs_rb.x = coords->x2 - radius - aa;
 8008cec:	68fb      	ldr	r3, [r7, #12]
 8008cee:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8008cf2:	b29a      	uxth	r2, r3
 8008cf4:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8008cf8:	1ad3      	subs	r3, r2, r3
 8008cfa:	b29a      	uxth	r2, r3
 8008cfc:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8008d00:	b29b      	uxth	r3, r3
 8008d02:	1ad3      	subs	r3, r2, r3
 8008d04:	b29b      	uxth	r3, r3
 8008d06:	b21b      	sxth	r3, r3
 8008d08:	843b      	strh	r3, [r7, #32]
    ofs_rb.y = coords->y2 - radius - aa;
 8008d0a:	68fb      	ldr	r3, [r7, #12]
 8008d0c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8008d10:	b29a      	uxth	r2, r3
 8008d12:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8008d16:	1ad3      	subs	r3, r2, r3
 8008d18:	b29a      	uxth	r2, r3
 8008d1a:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8008d1e:	b29b      	uxth	r3, r3
 8008d20:	1ad3      	subs	r3, r2, r3
 8008d22:	b29b      	uxth	r3, r3
 8008d24:	b21b      	sxth	r3, r3
 8008d26:	847b      	strh	r3, [r7, #34]	; 0x22

    ofs_rt.x = coords->x2 - radius - aa;
 8008d28:	68fb      	ldr	r3, [r7, #12]
 8008d2a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8008d2e:	b29a      	uxth	r2, r3
 8008d30:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8008d34:	1ad3      	subs	r3, r2, r3
 8008d36:	b29a      	uxth	r2, r3
 8008d38:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8008d3c:	b29b      	uxth	r3, r3
 8008d3e:	1ad3      	subs	r3, r2, r3
 8008d40:	b29b      	uxth	r3, r3
 8008d42:	b21b      	sxth	r3, r3
 8008d44:	83bb      	strh	r3, [r7, #28]
    ofs_rt.y = coords->y1 + radius + aa;
 8008d46:	68fb      	ldr	r3, [r7, #12]
 8008d48:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8008d4c:	b29a      	uxth	r2, r3
 8008d4e:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8008d52:	4413      	add	r3, r2
 8008d54:	b29a      	uxth	r2, r3
 8008d56:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8008d5a:	b29b      	uxth	r3, r3
 8008d5c:	4413      	add	r3, r2
 8008d5e:	b29b      	uxth	r3, r3
 8008d60:	b21b      	sxth	r3, r3
 8008d62:	83fb      	strh	r3, [r7, #30]

    ofs_lb.x = coords->x1 + radius + aa;
 8008d64:	68fb      	ldr	r3, [r7, #12]
 8008d66:	f9b3 3000 	ldrsh.w	r3, [r3]
 8008d6a:	b29a      	uxth	r2, r3
 8008d6c:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8008d70:	4413      	add	r3, r2
 8008d72:	b29a      	uxth	r2, r3
 8008d74:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8008d78:	b29b      	uxth	r3, r3
 8008d7a:	4413      	add	r3, r2
 8008d7c:	b29b      	uxth	r3, r3
 8008d7e:	b21b      	sxth	r3, r3
 8008d80:	833b      	strh	r3, [r7, #24]
    ofs_lb.y = coords->y2 - radius - aa;
 8008d82:	68fb      	ldr	r3, [r7, #12]
 8008d84:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8008d88:	b29a      	uxth	r2, r3
 8008d8a:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8008d8e:	1ad3      	subs	r3, r2, r3
 8008d90:	b29a      	uxth	r2, r3
 8008d92:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8008d96:	b29b      	uxth	r3, r3
 8008d98:	1ad3      	subs	r3, r2, r3
 8008d9a:	b29b      	uxth	r3, r3
 8008d9c:	b21b      	sxth	r3, r3
 8008d9e:	837b      	strh	r3, [r7, #26]

    ofs_lt.x = coords->x1 + radius + aa;
 8008da0:	68fb      	ldr	r3, [r7, #12]
 8008da2:	f9b3 3000 	ldrsh.w	r3, [r3]
 8008da6:	b29a      	uxth	r2, r3
 8008da8:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8008dac:	4413      	add	r3, r2
 8008dae:	b29a      	uxth	r2, r3
 8008db0:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8008db4:	b29b      	uxth	r3, r3
 8008db6:	4413      	add	r3, r2
 8008db8:	b29b      	uxth	r3, r3
 8008dba:	b21b      	sxth	r3, r3
 8008dbc:	82bb      	strh	r3, [r7, #20]
    ofs_lt.y = coords->y1 + radius + aa;
 8008dbe:	68fb      	ldr	r3, [r7, #12]
 8008dc0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8008dc4:	b29a      	uxth	r2, r3
 8008dc6:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8008dca:	4413      	add	r3, r2
 8008dcc:	b29a      	uxth	r2, r3
 8008dce:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8008dd2:	b29b      	uxth	r3, r3
 8008dd4:	4413      	add	r3, r2
 8008dd6:	b29b      	uxth	r3, r3
 8008dd8:	b21b      	sxth	r3, r3
 8008dda:	82fb      	strh	r3, [r7, #22]
    bool line_ready;
    for(line = 0; line <= radius + swidth; line++) { /*Check all rows and make the 1D blur to 2D*/
 8008ddc:	2300      	movs	r3, #0
 8008dde:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 8008de2:	e1ba      	b.n	800915a <lv_draw_shadow_full+0x632>
        line_ready = false;
 8008de4:	2300      	movs	r3, #0
 8008de6:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
        for(col = 0; col <= radius + swidth; col++) { /*Check all pixels in a 1D blur line (from the origo to last
 8008dea:	2300      	movs	r3, #0
 8008dec:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
 8008df0:	e098      	b.n	8008f24 <lv_draw_shadow_full+0x3fc>
                                                         shadow pixel (radius + swidth))*/

            /*Sum the opacities from the lines above and below this 'row'*/
            int16_t line_rel;
            uint32_t px_opa_sum = 0;
 8008df2:	2300      	movs	r3, #0
 8008df4:	66fb      	str	r3, [r7, #108]	; 0x6c
            for(line_rel = -swidth; line_rel <= swidth; line_rel++) {
 8008df6:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8008dfa:	425b      	negs	r3, r3
 8008dfc:	b29b      	uxth	r3, r3
 8008dfe:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
 8008e02:	e06e      	b.n	8008ee2 <lv_draw_shadow_full+0x3ba>
                /*Get the relative x position of the 'line_rel' to 'line'*/
                int16_t col_rel;
                if(line + line_rel < 0) { /*Below the radius, here is the blur of the edge */
 8008e04:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 8008e08:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 8008e0c:	4413      	add	r3, r2
 8008e0e:	2b00      	cmp	r3, #0
 8008e10:	da12      	bge.n	8008e38 <lv_draw_shadow_full+0x310>
                    col_rel = radius - curve_x[line] - col;
 8008e12:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8008e16:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8008e1a:	005b      	lsls	r3, r3, #1
 8008e1c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8008e1e:	440b      	add	r3, r1
 8008e20:	f9b3 3000 	ldrsh.w	r3, [r3]
 8008e24:	b29b      	uxth	r3, r3
 8008e26:	1ad3      	subs	r3, r2, r3
 8008e28:	b29a      	uxth	r2, r3
 8008e2a:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8008e2e:	1ad3      	subs	r3, r2, r3
 8008e30:	b29b      	uxth	r3, r3
 8008e32:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 8008e36:	e023      	b.n	8008e80 <lv_draw_shadow_full+0x358>
                } else if(line + line_rel > radius) { /*Above the radius, here won't be more 1D blur*/
 8008e38:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 8008e3c:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 8008e40:	441a      	add	r2, r3
 8008e42:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 8008e46:	429a      	cmp	r2, r3
 8008e48:	dc52      	bgt.n	8008ef0 <lv_draw_shadow_full+0x3c8>
                    break;
                } else { /*Blur from the curve*/
                    col_rel = curve_x[line + line_rel] - curve_x[line] - col;
 8008e4a:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 8008e4e:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 8008e52:	4413      	add	r3, r2
 8008e54:	005b      	lsls	r3, r3, #1
 8008e56:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8008e58:	4413      	add	r3, r2
 8008e5a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8008e5e:	b29a      	uxth	r2, r3
 8008e60:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8008e64:	005b      	lsls	r3, r3, #1
 8008e66:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8008e68:	440b      	add	r3, r1
 8008e6a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8008e6e:	b29b      	uxth	r3, r3
 8008e70:	1ad3      	subs	r3, r2, r3
 8008e72:	b29a      	uxth	r2, r3
 8008e74:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8008e78:	1ad3      	subs	r3, r2, r3
 8008e7a:	b29b      	uxth	r3, r3
 8008e7c:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
                }

                /*Add the value of the 1D blur on 'col_rel' position*/
                if(col_rel < -swidth) { /*Outside of the blurred area. */
 8008e80:	f9b7 206a 	ldrsh.w	r2, [r7, #106]	; 0x6a
 8008e84:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8008e88:	425b      	negs	r3, r3
 8008e8a:	429a      	cmp	r2, r3
 8008e8c:	da0a      	bge.n	8008ea4 <lv_draw_shadow_full+0x37c>
                    if(line_rel == -swidth)
 8008e8e:	f9b7 2070 	ldrsh.w	r2, [r7, #112]	; 0x70
 8008e92:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8008e96:	425b      	negs	r3, r3
 8008e98:	429a      	cmp	r2, r3
 8008e9a:	d12b      	bne.n	8008ef4 <lv_draw_shadow_full+0x3cc>
                        line_ready = true; /*If no data even on the very first line then it wont't
 8008e9c:	2301      	movs	r3, #1
 8008e9e:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
                                              be anything else in this line*/
                    break;                 /*Break anyway because only smaller 'col_rel' values will come */
 8008ea2:	e027      	b.n	8008ef4 <lv_draw_shadow_full+0x3cc>
                } else if(col_rel > swidth)
 8008ea4:	f9b7 206a 	ldrsh.w	r2, [r7, #106]	; 0x6a
 8008ea8:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8008eac:	429a      	cmp	r2, r3
 8008eae:	dd05      	ble.n	8008ebc <lv_draw_shadow_full+0x394>
                    px_opa_sum += line_1d_blur[0]; /*Inside the not blurred area*/
 8008eb0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008eb2:	681b      	ldr	r3, [r3, #0]
 8008eb4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8008eb6:	4413      	add	r3, r2
 8008eb8:	66fb      	str	r3, [r7, #108]	; 0x6c
 8008eba:	e00b      	b.n	8008ed4 <lv_draw_shadow_full+0x3ac>
                else
                    px_opa_sum += line_1d_blur[swidth - col_rel]; /*On the 1D blur (+ swidth to align to the center)*/
 8008ebc:	f9b7 2062 	ldrsh.w	r2, [r7, #98]	; 0x62
 8008ec0:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8008ec4:	1ad3      	subs	r3, r2, r3
 8008ec6:	009b      	lsls	r3, r3, #2
 8008ec8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8008eca:	4413      	add	r3, r2
 8008ecc:	681b      	ldr	r3, [r3, #0]
 8008ece:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8008ed0:	4413      	add	r3, r2
 8008ed2:	66fb      	str	r3, [r7, #108]	; 0x6c
            for(line_rel = -swidth; line_rel <= swidth; line_rel++) {
 8008ed4:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 8008ed8:	b29b      	uxth	r3, r3
 8008eda:	3301      	adds	r3, #1
 8008edc:	b29b      	uxth	r3, r3
 8008ede:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
 8008ee2:	f9b7 2070 	ldrsh.w	r2, [r7, #112]	; 0x70
 8008ee6:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8008eea:	429a      	cmp	r2, r3
 8008eec:	dd8a      	ble.n	8008e04 <lv_draw_shadow_full+0x2dc>
 8008eee:	e002      	b.n	8008ef6 <lv_draw_shadow_full+0x3ce>
                    break;
 8008ef0:	bf00      	nop
 8008ef2:	e000      	b.n	8008ef6 <lv_draw_shadow_full+0x3ce>
                    break;                 /*Break anyway because only smaller 'col_rel' values will come */
 8008ef4:	bf00      	nop
            }

            line_2d_blur[col] = px_opa_sum >> SHADOW_OPA_EXTRA_PRECISION;
 8008ef6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8008ef8:	0a19      	lsrs	r1, r3, #8
 8008efa:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8008efe:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8008f00:	4413      	add	r3, r2
 8008f02:	b2ca      	uxtb	r2, r1
 8008f04:	701a      	strb	r2, [r3, #0]
            if(line_ready) {
 8008f06:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 8008f0a:	2b00      	cmp	r3, #0
 8008f0c:	d005      	beq.n	8008f1a <lv_draw_shadow_full+0x3f2>
                col++; /*To make this line to the last one ( drawing will go to '< col')*/
 8008f0e:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8008f12:	3301      	adds	r3, #1
 8008f14:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
                break;
 8008f18:	e00e      	b.n	8008f38 <lv_draw_shadow_full+0x410>
        for(col = 0; col <= radius + swidth; col++) { /*Check all pixels in a 1D blur line (from the origo to last
 8008f1a:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8008f1e:	3301      	adds	r3, #1
 8008f20:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
 8008f24:	f8b7 2074 	ldrh.w	r2, [r7, #116]	; 0x74
 8008f28:	f9b7 1064 	ldrsh.w	r1, [r7, #100]	; 0x64
 8008f2c:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8008f30:	440b      	add	r3, r1
 8008f32:	429a      	cmp	r2, r3
 8008f34:	f77f af5d 	ble.w	8008df2 <lv_draw_shadow_full+0x2ca>
            }
        }

        /*Flush the line*/
        point_rt.x = curve_x[line] + ofs_rt.x + 1;
 8008f38:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8008f3c:	005b      	lsls	r3, r3, #1
 8008f3e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8008f40:	4413      	add	r3, r2
 8008f42:	f9b3 3000 	ldrsh.w	r3, [r3]
 8008f46:	b29a      	uxth	r2, r3
 8008f48:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8008f4c:	b29b      	uxth	r3, r3
 8008f4e:	4413      	add	r3, r2
 8008f50:	b29b      	uxth	r3, r3
 8008f52:	3301      	adds	r3, #1
 8008f54:	b29b      	uxth	r3, r3
 8008f56:	b21b      	sxth	r3, r3
 8008f58:	863b      	strh	r3, [r7, #48]	; 0x30
        point_rt.y = ofs_rt.y - line;
 8008f5a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8008f5e:	b29a      	uxth	r2, r3
 8008f60:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8008f64:	1ad3      	subs	r3, r2, r3
 8008f66:	b29b      	uxth	r3, r3
 8008f68:	b21b      	sxth	r3, r3
 8008f6a:	867b      	strh	r3, [r7, #50]	; 0x32

        point_rb.x = curve_x[line] + ofs_rb.x + 1;
 8008f6c:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8008f70:	005b      	lsls	r3, r3, #1
 8008f72:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8008f74:	4413      	add	r3, r2
 8008f76:	f9b3 3000 	ldrsh.w	r3, [r3]
 8008f7a:	b29a      	uxth	r2, r3
 8008f7c:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8008f80:	b29b      	uxth	r3, r3
 8008f82:	4413      	add	r3, r2
 8008f84:	b29b      	uxth	r3, r3
 8008f86:	3301      	adds	r3, #1
 8008f88:	b29b      	uxth	r3, r3
 8008f8a:	b21b      	sxth	r3, r3
 8008f8c:	85bb      	strh	r3, [r7, #44]	; 0x2c
        point_rb.y = ofs_rb.y + line;
 8008f8e:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8008f92:	b29a      	uxth	r2, r3
 8008f94:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8008f98:	4413      	add	r3, r2
 8008f9a:	b29b      	uxth	r3, r3
 8008f9c:	b21b      	sxth	r3, r3
 8008f9e:	85fb      	strh	r3, [r7, #46]	; 0x2e

        point_lt.x = ofs_lt.x - curve_x[line] - 1;
 8008fa0:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8008fa4:	b29a      	uxth	r2, r3
 8008fa6:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8008faa:	005b      	lsls	r3, r3, #1
 8008fac:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8008fae:	440b      	add	r3, r1
 8008fb0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8008fb4:	b29b      	uxth	r3, r3
 8008fb6:	1ad3      	subs	r3, r2, r3
 8008fb8:	b29b      	uxth	r3, r3
 8008fba:	3b01      	subs	r3, #1
 8008fbc:	b29b      	uxth	r3, r3
 8008fbe:	b21b      	sxth	r3, r3
 8008fc0:	853b      	strh	r3, [r7, #40]	; 0x28
        point_lt.y = ofs_lt.y - line;
 8008fc2:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8008fc6:	b29a      	uxth	r2, r3
 8008fc8:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8008fcc:	1ad3      	subs	r3, r2, r3
 8008fce:	b29b      	uxth	r3, r3
 8008fd0:	b21b      	sxth	r3, r3
 8008fd2:	857b      	strh	r3, [r7, #42]	; 0x2a

        point_lb.x = ofs_lb.x - curve_x[line] - 1;
 8008fd4:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8008fd8:	b29a      	uxth	r2, r3
 8008fda:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8008fde:	005b      	lsls	r3, r3, #1
 8008fe0:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8008fe2:	440b      	add	r3, r1
 8008fe4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8008fe8:	b29b      	uxth	r3, r3
 8008fea:	1ad3      	subs	r3, r2, r3
 8008fec:	b29b      	uxth	r3, r3
 8008fee:	3b01      	subs	r3, #1
 8008ff0:	b29b      	uxth	r3, r3
 8008ff2:	b21b      	sxth	r3, r3
 8008ff4:	84bb      	strh	r3, [r7, #36]	; 0x24
        point_lb.y = ofs_lb.y + line;
 8008ff6:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8008ffa:	b29a      	uxth	r2, r3
 8008ffc:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8009000:	4413      	add	r3, r2
 8009002:	b29b      	uxth	r3, r3
 8009004:	b21b      	sxth	r3, r3
 8009006:	84fb      	strh	r3, [r7, #38]	; 0x26

        uint16_t d;
        for(d = 1; d < col; d++) {
 8009008:	2301      	movs	r3, #1
 800900a:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
 800900e:	e08c      	b.n	800912a <lv_draw_shadow_full+0x602>

            if(point_lt.x < ofs_lt.x && point_lt.y < ofs_lt.y) {
 8009010:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
 8009014:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8009018:	429a      	cmp	r2, r3
 800901a:	da14      	bge.n	8009046 <lv_draw_shadow_full+0x51e>
 800901c:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 8009020:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8009024:	429a      	cmp	r2, r3
 8009026:	da0e      	bge.n	8009046 <lv_draw_shadow_full+0x51e>
                lv_draw_px(point_lt.x, point_lt.y, mask, style->body.shadow.color, line_2d_blur[d]);
 8009028:	f9b7 0028 	ldrsh.w	r0, [r7, #40]	; 0x28
 800902c:	f9b7 102a 	ldrsh.w	r1, [r7, #42]	; 0x2a
 8009030:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 8009034:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8009036:	4413      	add	r3, r2
 8009038:	781a      	ldrb	r2, [r3, #0]
 800903a:	687b      	ldr	r3, [r7, #4]
 800903c:	9200      	str	r2, [sp, #0]
 800903e:	8a1b      	ldrh	r3, [r3, #16]
 8009040:	68ba      	ldr	r2, [r7, #8]
 8009042:	f7fb f854 	bl	80040ee <lv_draw_px>
            }

            if(point_lb.x < ofs_lb.x && point_lb.y > ofs_lb.y) {
 8009046:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 800904a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800904e:	429a      	cmp	r2, r3
 8009050:	da14      	bge.n	800907c <lv_draw_shadow_full+0x554>
 8009052:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8009056:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800905a:	429a      	cmp	r2, r3
 800905c:	dd0e      	ble.n	800907c <lv_draw_shadow_full+0x554>
                lv_draw_px(point_lb.x, point_lb.y, mask, style->body.shadow.color, line_2d_blur[d]);
 800905e:	f9b7 0024 	ldrsh.w	r0, [r7, #36]	; 0x24
 8009062:	f9b7 1026 	ldrsh.w	r1, [r7, #38]	; 0x26
 8009066:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 800906a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800906c:	4413      	add	r3, r2
 800906e:	781a      	ldrb	r2, [r3, #0]
 8009070:	687b      	ldr	r3, [r7, #4]
 8009072:	9200      	str	r2, [sp, #0]
 8009074:	8a1b      	ldrh	r3, [r3, #16]
 8009076:	68ba      	ldr	r2, [r7, #8]
 8009078:	f7fb f839 	bl	80040ee <lv_draw_px>
            }

            if(point_rt.x > ofs_rt.x && point_rt.y < ofs_rt.y) {
 800907c:	f9b7 2030 	ldrsh.w	r2, [r7, #48]	; 0x30
 8009080:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8009084:	429a      	cmp	r2, r3
 8009086:	dd14      	ble.n	80090b2 <lv_draw_shadow_full+0x58a>
 8009088:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 800908c:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8009090:	429a      	cmp	r2, r3
 8009092:	da0e      	bge.n	80090b2 <lv_draw_shadow_full+0x58a>
                lv_draw_px(point_rt.x, point_rt.y, mask, style->body.shadow.color, line_2d_blur[d]);
 8009094:	f9b7 0030 	ldrsh.w	r0, [r7, #48]	; 0x30
 8009098:	f9b7 1032 	ldrsh.w	r1, [r7, #50]	; 0x32
 800909c:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 80090a0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80090a2:	4413      	add	r3, r2
 80090a4:	781a      	ldrb	r2, [r3, #0]
 80090a6:	687b      	ldr	r3, [r7, #4]
 80090a8:	9200      	str	r2, [sp, #0]
 80090aa:	8a1b      	ldrh	r3, [r3, #16]
 80090ac:	68ba      	ldr	r2, [r7, #8]
 80090ae:	f7fb f81e 	bl	80040ee <lv_draw_px>
            }

            if(point_rb.x > ofs_rb.x && point_rb.y > ofs_rb.y) {
 80090b2:	f9b7 202c 	ldrsh.w	r2, [r7, #44]	; 0x2c
 80090b6:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 80090ba:	429a      	cmp	r2, r3
 80090bc:	dd14      	ble.n	80090e8 <lv_draw_shadow_full+0x5c0>
 80090be:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 80090c2:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 80090c6:	429a      	cmp	r2, r3
 80090c8:	dd0e      	ble.n	80090e8 <lv_draw_shadow_full+0x5c0>
                lv_draw_px(point_rb.x, point_rb.y, mask, style->body.shadow.color, line_2d_blur[d]);
 80090ca:	f9b7 002c 	ldrsh.w	r0, [r7, #44]	; 0x2c
 80090ce:	f9b7 102e 	ldrsh.w	r1, [r7, #46]	; 0x2e
 80090d2:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 80090d6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80090d8:	4413      	add	r3, r2
 80090da:	781a      	ldrb	r2, [r3, #0]
 80090dc:	687b      	ldr	r3, [r7, #4]
 80090de:	9200      	str	r2, [sp, #0]
 80090e0:	8a1b      	ldrh	r3, [r3, #16]
 80090e2:	68ba      	ldr	r2, [r7, #8]
 80090e4:	f7fb f803 	bl	80040ee <lv_draw_px>
            }

            point_rb.x++;
 80090e8:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 80090ec:	b29b      	uxth	r3, r3
 80090ee:	3301      	adds	r3, #1
 80090f0:	b29b      	uxth	r3, r3
 80090f2:	b21b      	sxth	r3, r3
 80090f4:	85bb      	strh	r3, [r7, #44]	; 0x2c
            point_lb.x--;
 80090f6:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 80090fa:	b29b      	uxth	r3, r3
 80090fc:	3b01      	subs	r3, #1
 80090fe:	b29b      	uxth	r3, r3
 8009100:	b21b      	sxth	r3, r3
 8009102:	84bb      	strh	r3, [r7, #36]	; 0x24

            point_rt.x++;
 8009104:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8009108:	b29b      	uxth	r3, r3
 800910a:	3301      	adds	r3, #1
 800910c:	b29b      	uxth	r3, r3
 800910e:	b21b      	sxth	r3, r3
 8009110:	863b      	strh	r3, [r7, #48]	; 0x30
            point_lt.x--;
 8009112:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8009116:	b29b      	uxth	r3, r3
 8009118:	3b01      	subs	r3, #1
 800911a:	b29b      	uxth	r3, r3
 800911c:	b21b      	sxth	r3, r3
 800911e:	853b      	strh	r3, [r7, #40]	; 0x28
        for(d = 1; d < col; d++) {
 8009120:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 8009124:	3301      	adds	r3, #1
 8009126:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
 800912a:	f8b7 2068 	ldrh.w	r2, [r7, #104]	; 0x68
 800912e:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8009132:	429a      	cmp	r2, r3
 8009134:	f4ff af6c 	bcc.w	8009010 <lv_draw_shadow_full+0x4e8>
        }

        /* Put the first line to the edges too.
         * It is not correct because blur should be done below the corner too
         * but is is simple, fast and gives a good enough result*/
        if(line == 0) lv_draw_shadow_full_straight(coords, mask, style, line_2d_blur);
 8009138:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 800913c:	2b00      	cmp	r3, #0
 800913e:	d105      	bne.n	800914c <lv_draw_shadow_full+0x624>
 8009140:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009142:	687a      	ldr	r2, [r7, #4]
 8009144:	68b9      	ldr	r1, [r7, #8]
 8009146:	68f8      	ldr	r0, [r7, #12]
 8009148:	f000 fa17 	bl	800957a <lv_draw_shadow_full_straight>
    for(line = 0; line <= radius + swidth; line++) { /*Check all rows and make the 1D blur to 2D*/
 800914c:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8009150:	b29b      	uxth	r3, r3
 8009152:	3301      	adds	r3, #1
 8009154:	b29b      	uxth	r3, r3
 8009156:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 800915a:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 800915e:	f9b7 1064 	ldrsh.w	r1, [r7, #100]	; 0x64
 8009162:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8009166:	440b      	add	r3, r1
 8009168:	429a      	cmp	r2, r3
 800916a:	f77f ae3b 	ble.w	8008de4 <lv_draw_shadow_full+0x2bc>
    }
}
 800916e:	bf00      	nop
 8009170:	3778      	adds	r7, #120	; 0x78
 8009172:	46bd      	mov	sp, r7
 8009174:	bd80      	pop	{r7, pc}

08009176 <lv_draw_shadow_bottom>:

static void lv_draw_shadow_bottom(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                  lv_opa_t opa_scale)
{
 8009176:	b580      	push	{r7, lr}
 8009178:	b09a      	sub	sp, #104	; 0x68
 800917a:	af02      	add	r7, sp, #8
 800917c:	60f8      	str	r0, [r7, #12]
 800917e:	60b9      	str	r1, [r7, #8]
 8009180:	607a      	str	r2, [r7, #4]
 8009182:	70fb      	strb	r3, [r7, #3]
    bool aa           = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8009184:	f7f9 fee6 	bl	8002f54 <lv_refr_get_disp_refreshing>
 8009188:	4603      	mov	r3, r0
 800918a:	4618      	mov	r0, r3
 800918c:	f002 fc63 	bl	800ba56 <lv_disp_get_antialiasing>
 8009190:	4603      	mov	r3, r0
 8009192:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
    lv_coord_t radius = style->body.radius;
 8009196:	687b      	ldr	r3, [r7, #4]
 8009198:	88db      	ldrh	r3, [r3, #6]
 800919a:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    lv_coord_t swidth = style->body.shadow.width;
 800919e:	687b      	ldr	r3, [r7, #4]
 80091a0:	8a5b      	ldrh	r3, [r3, #18]
 80091a2:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
    lv_coord_t width  = lv_area_get_width(coords);
 80091a6:	68f8      	ldr	r0, [r7, #12]
 80091a8:	f7fc fc97 	bl	8005ada <lv_area_get_width>
 80091ac:	4603      	mov	r3, r0
 80091ae:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
    lv_coord_t height = lv_area_get_height(coords);
 80091b2:	68f8      	ldr	r0, [r7, #12]
 80091b4:	f7fc fca8 	bl	8005b08 <lv_area_get_height>
 80091b8:	4603      	mov	r3, r0
 80091ba:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

    radius = lv_draw_cont_radius_corr(radius, width, height);
 80091be:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 80091c2:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 80091c6:	f9b7 1050 	ldrsh.w	r1, [r7, #80]	; 0x50
 80091ca:	4618      	mov	r0, r3
 80091cc:	f000 fb2c 	bl	8009828 <lv_draw_cont_radius_corr>
 80091d0:	4603      	mov	r3, r0
 80091d2:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    radius += aa * SHADOW_BOTTOM_AA_EXTRA_RADIUS;
 80091d6:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80091da:	b29b      	uxth	r3, r3
 80091dc:	461a      	mov	r2, r3
 80091de:	0052      	lsls	r2, r2, #1
 80091e0:	4413      	add	r3, r2
 80091e2:	b29a      	uxth	r2, r3
 80091e4:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 80091e8:	4413      	add	r3, r2
 80091ea:	b29b      	uxth	r3, r3
 80091ec:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    swidth += aa;
 80091f0:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80091f4:	b29a      	uxth	r2, r3
 80091f6:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 80091fa:	4413      	add	r3, r2
 80091fc:	b29b      	uxth	r3, r3
 80091fe:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    uint32_t curve_x_size = ((radius + 1) + 3) & ~0x3; /*Round to 4*/
 8009202:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8009206:	3304      	adds	r3, #4
 8009208:	f023 0303 	bic.w	r3, r3, #3
 800920c:	64bb      	str	r3, [r7, #72]	; 0x48
    curve_x_size *= sizeof(lv_coord_t);
 800920e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8009210:	005b      	lsls	r3, r3, #1
 8009212:	64bb      	str	r3, [r7, #72]	; 0x48
    lv_opa_t line_1d_blur_size = (swidth + 3) & ~0x3;     /*Round to 4*/
 8009214:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 8009218:	b2db      	uxtb	r3, r3
 800921a:	3303      	adds	r3, #3
 800921c:	b2db      	uxtb	r3, r3
 800921e:	f023 0303 	bic.w	r3, r3, #3
 8009222:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    line_1d_blur_size *= sizeof(lv_opa_t);

    uint8_t * draw_buf = lv_draw_get_buf(curve_x_size + line_1d_blur_size);
 8009226:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 800922a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800922c:	4413      	add	r3, r2
 800922e:	4618      	mov	r0, r3
 8009230:	f7fa fe10 	bl	8003e54 <lv_draw_get_buf>
 8009234:	6438      	str	r0, [r7, #64]	; 0x40

    /*Divide the draw buffer*/
    lv_coord_t  * curve_x = (lv_coord_t *)&draw_buf[0]; /*Stores the 'x' coordinates of a quarter circle.*/
 8009236:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009238:	63fb      	str	r3, [r7, #60]	; 0x3c
    lv_opa_t * line_1d_blur = (lv_opa_t *)&draw_buf[curve_x_size];
 800923a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800923c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800923e:	4413      	add	r3, r2
 8009240:	63bb      	str	r3, [r7, #56]	; 0x38

    lv_point_t circ;
    lv_coord_t circ_tmp;
    lv_circ_init(&circ, &circ_tmp, radius);
 8009242:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 8009246:	f107 012e 	add.w	r1, r7, #46	; 0x2e
 800924a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800924e:	4618      	mov	r0, r3
 8009250:	f003 f823 	bl	800c29a <lv_circ_init>
    while(lv_circ_cont(&circ)) {
 8009254:	e017      	b.n	8009286 <lv_draw_shadow_bottom+0x110>
        curve_x[LV_CIRC_OCT1_Y(circ)] = LV_CIRC_OCT1_X(circ);
 8009256:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 800925a:	005b      	lsls	r3, r3, #1
 800925c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800925e:	4413      	add	r3, r2
 8009260:	f9b7 2030 	ldrsh.w	r2, [r7, #48]	; 0x30
 8009264:	801a      	strh	r2, [r3, #0]
        curve_x[LV_CIRC_OCT2_Y(circ)] = LV_CIRC_OCT2_X(circ);
 8009266:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 800926a:	005b      	lsls	r3, r3, #1
 800926c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800926e:	4413      	add	r3, r2
 8009270:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 8009274:	801a      	strh	r2, [r3, #0]
        lv_circ_next(&circ, &circ_tmp);
 8009276:	f107 022e 	add.w	r2, r7, #46	; 0x2e
 800927a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800927e:	4611      	mov	r1, r2
 8009280:	4618      	mov	r0, r3
 8009282:	f003 f839 	bl	800c2f8 <lv_circ_next>
    while(lv_circ_cont(&circ)) {
 8009286:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800928a:	4618      	mov	r0, r3
 800928c:	f003 f81f 	bl	800c2ce <lv_circ_cont>
 8009290:	4603      	mov	r3, r0
 8009292:	2b00      	cmp	r3, #0
 8009294:	d1df      	bne.n	8009256 <lv_draw_shadow_bottom+0xe0>
    }

    int16_t col;

    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 8009296:	78fb      	ldrb	r3, [r7, #3]
 8009298:	2bff      	cmp	r3, #255	; 0xff
 800929a:	d102      	bne.n	80092a2 <lv_draw_shadow_bottom+0x12c>
 800929c:	687b      	ldr	r3, [r7, #4]
 800929e:	7a1b      	ldrb	r3, [r3, #8]
 80092a0:	e00a      	b.n	80092b8 <lv_draw_shadow_bottom+0x142>
 80092a2:	687b      	ldr	r3, [r7, #4]
 80092a4:	7a1b      	ldrb	r3, [r3, #8]
 80092a6:	b29a      	uxth	r2, r3
 80092a8:	78fb      	ldrb	r3, [r7, #3]
 80092aa:	b29b      	uxth	r3, r3
 80092ac:	fb12 f303 	smulbb	r3, r2, r3
 80092b0:	b29b      	uxth	r3, r3
 80092b2:	0a1b      	lsrs	r3, r3, #8
 80092b4:	b29b      	uxth	r3, r3
 80092b6:	b2db      	uxtb	r3, r3
 80092b8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    for(col = 0; col < swidth; col++) {
 80092bc:	2300      	movs	r3, #0
 80092be:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 80092c2:	e01b      	b.n	80092fc <lv_draw_shadow_bottom+0x186>
        line_1d_blur[col] = (uint32_t)((uint32_t)(swidth - col) * opa / 2) / (swidth);
 80092c4:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 80092c8:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80092cc:	1ad3      	subs	r3, r2, r3
 80092ce:	461a      	mov	r2, r3
 80092d0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80092d4:	fb03 f302 	mul.w	r3, r3, r2
 80092d8:	085a      	lsrs	r2, r3, #1
 80092da:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80092de:	fbb2 f1f3 	udiv	r1, r2, r3
 80092e2:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80092e6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80092e8:	4413      	add	r3, r2
 80092ea:	b2ca      	uxtb	r2, r1
 80092ec:	701a      	strb	r2, [r3, #0]
    for(col = 0; col < swidth; col++) {
 80092ee:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80092f2:	b29b      	uxth	r3, r3
 80092f4:	3301      	adds	r3, #1
 80092f6:	b29b      	uxth	r3, r3
 80092f8:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 80092fc:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 8009300:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8009304:	429a      	cmp	r2, r3
 8009306:	dbdd      	blt.n	80092c4 <lv_draw_shadow_bottom+0x14e>
    lv_point_t point_r;
    lv_area_t area_mid;
    lv_point_t ofs_l;
    lv_point_t ofs_r;

    ofs_l.x = coords->x1 + radius;
 8009308:	68fb      	ldr	r3, [r7, #12]
 800930a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800930e:	b29a      	uxth	r2, r3
 8009310:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8009314:	4413      	add	r3, r2
 8009316:	b29b      	uxth	r3, r3
 8009318:	b21b      	sxth	r3, r3
 800931a:	833b      	strh	r3, [r7, #24]
    ofs_l.y = coords->y2 - radius + 1 - aa;
 800931c:	68fb      	ldr	r3, [r7, #12]
 800931e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8009322:	b29a      	uxth	r2, r3
 8009324:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8009328:	1ad3      	subs	r3, r2, r3
 800932a:	b29a      	uxth	r2, r3
 800932c:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8009330:	b29b      	uxth	r3, r3
 8009332:	1ad3      	subs	r3, r2, r3
 8009334:	b29b      	uxth	r3, r3
 8009336:	3301      	adds	r3, #1
 8009338:	b29b      	uxth	r3, r3
 800933a:	b21b      	sxth	r3, r3
 800933c:	837b      	strh	r3, [r7, #26]

    ofs_r.x = coords->x2 - radius;
 800933e:	68fb      	ldr	r3, [r7, #12]
 8009340:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8009344:	b29a      	uxth	r2, r3
 8009346:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 800934a:	1ad3      	subs	r3, r2, r3
 800934c:	b29b      	uxth	r3, r3
 800934e:	b21b      	sxth	r3, r3
 8009350:	82bb      	strh	r3, [r7, #20]
    ofs_r.y = coords->y2 - radius + 1 - aa;
 8009352:	68fb      	ldr	r3, [r7, #12]
 8009354:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8009358:	b29a      	uxth	r2, r3
 800935a:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 800935e:	1ad3      	subs	r3, r2, r3
 8009360:	b29a      	uxth	r2, r3
 8009362:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8009366:	b29b      	uxth	r3, r3
 8009368:	1ad3      	subs	r3, r2, r3
 800936a:	b29b      	uxth	r3, r3
 800936c:	3301      	adds	r3, #1
 800936e:	b29b      	uxth	r3, r3
 8009370:	b21b      	sxth	r3, r3
 8009372:	82fb      	strh	r3, [r7, #22]

    for(col = 0; col <= radius; col++) {
 8009374:	2300      	movs	r3, #0
 8009376:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 800937a:	e0b0      	b.n	80094de <lv_draw_shadow_bottom+0x368>
        point_l.x = ofs_l.x - col;
 800937c:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8009380:	b29a      	uxth	r2, r3
 8009382:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8009386:	1ad3      	subs	r3, r2, r3
 8009388:	b29b      	uxth	r3, r3
 800938a:	b21b      	sxth	r3, r3
 800938c:	853b      	strh	r3, [r7, #40]	; 0x28
        point_l.y = ofs_l.y + curve_x[col];
 800938e:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8009392:	b29a      	uxth	r2, r3
 8009394:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8009398:	005b      	lsls	r3, r3, #1
 800939a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800939c:	440b      	add	r3, r1
 800939e:	f9b3 3000 	ldrsh.w	r3, [r3]
 80093a2:	b29b      	uxth	r3, r3
 80093a4:	4413      	add	r3, r2
 80093a6:	b29b      	uxth	r3, r3
 80093a8:	b21b      	sxth	r3, r3
 80093aa:	857b      	strh	r3, [r7, #42]	; 0x2a

        point_r.x = ofs_r.x + col;
 80093ac:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80093b0:	b29a      	uxth	r2, r3
 80093b2:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80093b6:	4413      	add	r3, r2
 80093b8:	b29b      	uxth	r3, r3
 80093ba:	b21b      	sxth	r3, r3
 80093bc:	84bb      	strh	r3, [r7, #36]	; 0x24
        point_r.y = ofs_r.y + curve_x[col];
 80093be:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80093c2:	b29a      	uxth	r2, r3
 80093c4:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80093c8:	005b      	lsls	r3, r3, #1
 80093ca:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 80093cc:	440b      	add	r3, r1
 80093ce:	f9b3 3000 	ldrsh.w	r3, [r3]
 80093d2:	b29b      	uxth	r3, r3
 80093d4:	4413      	add	r3, r2
 80093d6:	b29b      	uxth	r3, r3
 80093d8:	b21b      	sxth	r3, r3
 80093da:	84fb      	strh	r3, [r7, #38]	; 0x26

        lv_opa_t px_opa;
        int16_t diff = col == 0 ? 0 : curve_x[col - 1] - curve_x[col];
 80093dc:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80093e0:	2b00      	cmp	r3, #0
 80093e2:	d016      	beq.n	8009412 <lv_draw_shadow_bottom+0x29c>
 80093e4:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80093e8:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 80093ec:	3b01      	subs	r3, #1
 80093ee:	005b      	lsls	r3, r3, #1
 80093f0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80093f2:	4413      	add	r3, r2
 80093f4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80093f8:	b29a      	uxth	r2, r3
 80093fa:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80093fe:	005b      	lsls	r3, r3, #1
 8009400:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8009402:	440b      	add	r3, r1
 8009404:	f9b3 3000 	ldrsh.w	r3, [r3]
 8009408:	b29b      	uxth	r3, r3
 800940a:	1ad3      	subs	r3, r2, r3
 800940c:	b29b      	uxth	r3, r3
 800940e:	b21b      	sxth	r3, r3
 8009410:	e000      	b.n	8009414 <lv_draw_shadow_bottom+0x29e>
 8009412:	2300      	movs	r3, #0
 8009414:	86bb      	strh	r3, [r7, #52]	; 0x34
        uint16_t d;
        for(d = 0; d < swidth; d++) {
 8009416:	2300      	movs	r3, #0
 8009418:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
 800941c:	e052      	b.n	80094c4 <lv_draw_shadow_bottom+0x34e>
            /*When stepping a pixel in y calculate the average with the pixel from the prev. column
             * to make a blur */
            if(diff == 0) {
 800941e:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8009422:	2b00      	cmp	r3, #0
 8009424:	d107      	bne.n	8009436 <lv_draw_shadow_bottom+0x2c0>
                px_opa = line_1d_blur[d];
 8009426:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800942a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800942c:	4413      	add	r3, r2
 800942e:	781b      	ldrb	r3, [r3, #0]
 8009430:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
 8009434:	e015      	b.n	8009462 <lv_draw_shadow_bottom+0x2ec>
            } else {
                px_opa = (uint16_t)((uint16_t)line_1d_blur[d] + line_1d_blur[d - diff]) >> 1;
 8009436:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800943a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800943c:	4413      	add	r3, r2
 800943e:	781b      	ldrb	r3, [r3, #0]
 8009440:	b29a      	uxth	r2, r3
 8009442:	f8b7 105a 	ldrh.w	r1, [r7, #90]	; 0x5a
 8009446:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 800944a:	1acb      	subs	r3, r1, r3
 800944c:	4619      	mov	r1, r3
 800944e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009450:	440b      	add	r3, r1
 8009452:	781b      	ldrb	r3, [r3, #0]
 8009454:	b29b      	uxth	r3, r3
 8009456:	4413      	add	r3, r2
 8009458:	b29b      	uxth	r3, r3
 800945a:	085b      	lsrs	r3, r3, #1
 800945c:	b29b      	uxth	r3, r3
 800945e:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
            }
            lv_draw_px(point_l.x, point_l.y, mask, style->body.shadow.color, px_opa);
 8009462:	f9b7 0028 	ldrsh.w	r0, [r7, #40]	; 0x28
 8009466:	f9b7 102a 	ldrsh.w	r1, [r7, #42]	; 0x2a
 800946a:	687b      	ldr	r3, [r7, #4]
 800946c:	f897 205d 	ldrb.w	r2, [r7, #93]	; 0x5d
 8009470:	9200      	str	r2, [sp, #0]
 8009472:	8a1b      	ldrh	r3, [r3, #16]
 8009474:	68ba      	ldr	r2, [r7, #8]
 8009476:	f7fa fe3a 	bl	80040ee <lv_draw_px>
            point_l.y++;
 800947a:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 800947e:	b29b      	uxth	r3, r3
 8009480:	3301      	adds	r3, #1
 8009482:	b29b      	uxth	r3, r3
 8009484:	b21b      	sxth	r3, r3
 8009486:	857b      	strh	r3, [r7, #42]	; 0x2a

            /*Don't overdraw the pixel on the middle*/
            if(point_r.x > ofs_l.x) {
 8009488:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 800948c:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8009490:	429a      	cmp	r2, r3
 8009492:	dd0b      	ble.n	80094ac <lv_draw_shadow_bottom+0x336>
                lv_draw_px(point_r.x, point_r.y, mask, style->body.shadow.color, px_opa);
 8009494:	f9b7 0024 	ldrsh.w	r0, [r7, #36]	; 0x24
 8009498:	f9b7 1026 	ldrsh.w	r1, [r7, #38]	; 0x26
 800949c:	687b      	ldr	r3, [r7, #4]
 800949e:	f897 205d 	ldrb.w	r2, [r7, #93]	; 0x5d
 80094a2:	9200      	str	r2, [sp, #0]
 80094a4:	8a1b      	ldrh	r3, [r3, #16]
 80094a6:	68ba      	ldr	r2, [r7, #8]
 80094a8:	f7fa fe21 	bl	80040ee <lv_draw_px>
            }
            point_r.y++;
 80094ac:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 80094b0:	b29b      	uxth	r3, r3
 80094b2:	3301      	adds	r3, #1
 80094b4:	b29b      	uxth	r3, r3
 80094b6:	b21b      	sxth	r3, r3
 80094b8:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(d = 0; d < swidth; d++) {
 80094ba:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 80094be:	3301      	adds	r3, #1
 80094c0:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
 80094c4:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 80094c8:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80094cc:	429a      	cmp	r2, r3
 80094ce:	dba6      	blt.n	800941e <lv_draw_shadow_bottom+0x2a8>
    for(col = 0; col <= radius; col++) {
 80094d0:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80094d4:	b29b      	uxth	r3, r3
 80094d6:	3301      	adds	r3, #1
 80094d8:	b29b      	uxth	r3, r3
 80094da:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 80094de:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 80094e2:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 80094e6:	429a      	cmp	r2, r3
 80094e8:	f77f af48 	ble.w	800937c <lv_draw_shadow_bottom+0x206>
        }
    }

    area_mid.x1 = ofs_l.x + 1;
 80094ec:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80094f0:	b29b      	uxth	r3, r3
 80094f2:	3301      	adds	r3, #1
 80094f4:	b29b      	uxth	r3, r3
 80094f6:	b21b      	sxth	r3, r3
 80094f8:	83bb      	strh	r3, [r7, #28]
    area_mid.y1 = ofs_l.y + radius;
 80094fa:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80094fe:	b29a      	uxth	r2, r3
 8009500:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8009504:	4413      	add	r3, r2
 8009506:	b29b      	uxth	r3, r3
 8009508:	b21b      	sxth	r3, r3
 800950a:	83fb      	strh	r3, [r7, #30]
    area_mid.x2 = ofs_r.x - 1;
 800950c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8009510:	b29b      	uxth	r3, r3
 8009512:	3b01      	subs	r3, #1
 8009514:	b29b      	uxth	r3, r3
 8009516:	b21b      	sxth	r3, r3
 8009518:	843b      	strh	r3, [r7, #32]
    area_mid.y2 = area_mid.y1;
 800951a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800951e:	847b      	strh	r3, [r7, #34]	; 0x22

    uint16_t d;
    for(d = 0; d < swidth; d++) {
 8009520:	2300      	movs	r3, #0
 8009522:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
 8009526:	e01e      	b.n	8009566 <lv_draw_shadow_bottom+0x3f0>
        lv_draw_fill(&area_mid, mask, style->body.shadow.color, line_1d_blur[d]);
 8009528:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 800952c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800952e:	4413      	add	r3, r2
 8009530:	781b      	ldrb	r3, [r3, #0]
 8009532:	687a      	ldr	r2, [r7, #4]
 8009534:	f107 001c 	add.w	r0, r7, #28
 8009538:	8a12      	ldrh	r2, [r2, #16]
 800953a:	68b9      	ldr	r1, [r7, #8]
 800953c:	f7fa fe70 	bl	8004220 <lv_draw_fill>
        area_mid.y1++;
 8009540:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8009544:	b29b      	uxth	r3, r3
 8009546:	3301      	adds	r3, #1
 8009548:	b29b      	uxth	r3, r3
 800954a:	b21b      	sxth	r3, r3
 800954c:	83fb      	strh	r3, [r7, #30]
        area_mid.y2++;
 800954e:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8009552:	b29b      	uxth	r3, r3
 8009554:	3301      	adds	r3, #1
 8009556:	b29b      	uxth	r3, r3
 8009558:	b21b      	sxth	r3, r3
 800955a:	847b      	strh	r3, [r7, #34]	; 0x22
    for(d = 0; d < swidth; d++) {
 800955c:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 8009560:	3301      	adds	r3, #1
 8009562:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
 8009566:	f8b7 2058 	ldrh.w	r2, [r7, #88]	; 0x58
 800956a:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 800956e:	429a      	cmp	r2, r3
 8009570:	dbda      	blt.n	8009528 <lv_draw_shadow_bottom+0x3b2>
    }
}
 8009572:	bf00      	nop
 8009574:	3760      	adds	r7, #96	; 0x60
 8009576:	46bd      	mov	sp, r7
 8009578:	bd80      	pop	{r7, pc}

0800957a <lv_draw_shadow_full_straight>:

static void lv_draw_shadow_full_straight(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                         const lv_opa_t * map)
{
 800957a:	b580      	push	{r7, lr}
 800957c:	b090      	sub	sp, #64	; 0x40
 800957e:	af00      	add	r7, sp, #0
 8009580:	60f8      	str	r0, [r7, #12]
 8009582:	60b9      	str	r1, [r7, #8]
 8009584:	607a      	str	r2, [r7, #4]
 8009586:	603b      	str	r3, [r7, #0]
    bool aa           = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8009588:	f7f9 fce4 	bl	8002f54 <lv_refr_get_disp_refreshing>
 800958c:	4603      	mov	r3, r0
 800958e:	4618      	mov	r0, r3
 8009590:	f002 fa61 	bl	800ba56 <lv_disp_get_antialiasing>
 8009594:	4603      	mov	r3, r0
 8009596:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
    lv_coord_t radius = style->body.radius;
 800959a:	687b      	ldr	r3, [r7, #4]
 800959c:	88db      	ldrh	r3, [r3, #6]
 800959e:	877b      	strh	r3, [r7, #58]	; 0x3a
    lv_coord_t swidth = style->body.shadow.width;
 80095a0:	687b      	ldr	r3, [r7, #4]
 80095a2:	8a5b      	ldrh	r3, [r3, #18]
 80095a4:	873b      	strh	r3, [r7, #56]	; 0x38
    lv_coord_t width  = lv_area_get_width(coords);
 80095a6:	68f8      	ldr	r0, [r7, #12]
 80095a8:	f7fc fa97 	bl	8005ada <lv_area_get_width>
 80095ac:	4603      	mov	r3, r0
 80095ae:	86fb      	strh	r3, [r7, #54]	; 0x36
    lv_coord_t height = lv_area_get_height(coords);
 80095b0:	68f8      	ldr	r0, [r7, #12]
 80095b2:	f7fc faa9 	bl	8005b08 <lv_area_get_height>
 80095b6:	4603      	mov	r3, r0
 80095b8:	86bb      	strh	r3, [r7, #52]	; 0x34

    radius = lv_draw_cont_radius_corr(radius, width, height);
 80095ba:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80095bc:	f9b7 2034 	ldrsh.w	r2, [r7, #52]	; 0x34
 80095c0:	f9b7 1036 	ldrsh.w	r1, [r7, #54]	; 0x36
 80095c4:	4618      	mov	r0, r3
 80095c6:	f000 f92f 	bl	8009828 <lv_draw_cont_radius_corr>
 80095ca:	4603      	mov	r3, r0
 80095cc:	877b      	strh	r3, [r7, #58]	; 0x3a
    radius += aa;
 80095ce:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80095d2:	b29a      	uxth	r2, r3
 80095d4:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80095d6:	4413      	add	r3, r2
 80095d8:	b29b      	uxth	r3, r3
 80095da:	877b      	strh	r3, [r7, #58]	; 0x3a

    lv_area_t right_area;
    right_area.x1 = coords->x2 + 1 - aa;
 80095dc:	68fb      	ldr	r3, [r7, #12]
 80095de:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80095e2:	b29a      	uxth	r2, r3
 80095e4:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80095e8:	b29b      	uxth	r3, r3
 80095ea:	1ad3      	subs	r3, r2, r3
 80095ec:	b29b      	uxth	r3, r3
 80095ee:	3301      	adds	r3, #1
 80095f0:	b29b      	uxth	r3, r3
 80095f2:	b21b      	sxth	r3, r3
 80095f4:	853b      	strh	r3, [r7, #40]	; 0x28
    right_area.y1 = coords->y1 + radius + aa;
 80095f6:	68fb      	ldr	r3, [r7, #12]
 80095f8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80095fc:	b29a      	uxth	r2, r3
 80095fe:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8009600:	4413      	add	r3, r2
 8009602:	b29a      	uxth	r2, r3
 8009604:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 8009608:	b29b      	uxth	r3, r3
 800960a:	4413      	add	r3, r2
 800960c:	b29b      	uxth	r3, r3
 800960e:	b21b      	sxth	r3, r3
 8009610:	857b      	strh	r3, [r7, #42]	; 0x2a
    right_area.x2 = right_area.x1;
 8009612:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8009616:	85bb      	strh	r3, [r7, #44]	; 0x2c
    right_area.y2 = coords->y2 - radius - aa;
 8009618:	68fb      	ldr	r3, [r7, #12]
 800961a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800961e:	b29a      	uxth	r2, r3
 8009620:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8009622:	1ad3      	subs	r3, r2, r3
 8009624:	b29a      	uxth	r2, r3
 8009626:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 800962a:	b29b      	uxth	r3, r3
 800962c:	1ad3      	subs	r3, r2, r3
 800962e:	b29b      	uxth	r3, r3
 8009630:	b21b      	sxth	r3, r3
 8009632:	85fb      	strh	r3, [r7, #46]	; 0x2e

    lv_area_t left_area;
    left_area.x1 = coords->x1 - 1 + aa;
 8009634:	68fb      	ldr	r3, [r7, #12]
 8009636:	f9b3 3000 	ldrsh.w	r3, [r3]
 800963a:	b29a      	uxth	r2, r3
 800963c:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 8009640:	b29b      	uxth	r3, r3
 8009642:	4413      	add	r3, r2
 8009644:	b29b      	uxth	r3, r3
 8009646:	3b01      	subs	r3, #1
 8009648:	b29b      	uxth	r3, r3
 800964a:	b21b      	sxth	r3, r3
 800964c:	843b      	strh	r3, [r7, #32]
    left_area.y1 = coords->y1 + radius + aa;
 800964e:	68fb      	ldr	r3, [r7, #12]
 8009650:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8009654:	b29a      	uxth	r2, r3
 8009656:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8009658:	4413      	add	r3, r2
 800965a:	b29a      	uxth	r2, r3
 800965c:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 8009660:	b29b      	uxth	r3, r3
 8009662:	4413      	add	r3, r2
 8009664:	b29b      	uxth	r3, r3
 8009666:	b21b      	sxth	r3, r3
 8009668:	847b      	strh	r3, [r7, #34]	; 0x22
    left_area.x2 = left_area.x1;
 800966a:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 800966e:	84bb      	strh	r3, [r7, #36]	; 0x24
    left_area.y2 = coords->y2 - radius - aa;
 8009670:	68fb      	ldr	r3, [r7, #12]
 8009672:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8009676:	b29a      	uxth	r2, r3
 8009678:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 800967a:	1ad3      	subs	r3, r2, r3
 800967c:	b29a      	uxth	r2, r3
 800967e:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 8009682:	b29b      	uxth	r3, r3
 8009684:	1ad3      	subs	r3, r2, r3
 8009686:	b29b      	uxth	r3, r3
 8009688:	b21b      	sxth	r3, r3
 800968a:	84fb      	strh	r3, [r7, #38]	; 0x26

    lv_area_t top_area;
    top_area.x1 = coords->x1 + radius + aa;
 800968c:	68fb      	ldr	r3, [r7, #12]
 800968e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8009692:	b29a      	uxth	r2, r3
 8009694:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8009696:	4413      	add	r3, r2
 8009698:	b29a      	uxth	r2, r3
 800969a:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 800969e:	b29b      	uxth	r3, r3
 80096a0:	4413      	add	r3, r2
 80096a2:	b29b      	uxth	r3, r3
 80096a4:	b21b      	sxth	r3, r3
 80096a6:	833b      	strh	r3, [r7, #24]
    top_area.y1 = coords->y1 - 1 + aa;
 80096a8:	68fb      	ldr	r3, [r7, #12]
 80096aa:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80096ae:	b29a      	uxth	r2, r3
 80096b0:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80096b4:	b29b      	uxth	r3, r3
 80096b6:	4413      	add	r3, r2
 80096b8:	b29b      	uxth	r3, r3
 80096ba:	3b01      	subs	r3, #1
 80096bc:	b29b      	uxth	r3, r3
 80096be:	b21b      	sxth	r3, r3
 80096c0:	837b      	strh	r3, [r7, #26]
    top_area.x2 = coords->x2 - radius - aa;
 80096c2:	68fb      	ldr	r3, [r7, #12]
 80096c4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80096c8:	b29a      	uxth	r2, r3
 80096ca:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80096cc:	1ad3      	subs	r3, r2, r3
 80096ce:	b29a      	uxth	r2, r3
 80096d0:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80096d4:	b29b      	uxth	r3, r3
 80096d6:	1ad3      	subs	r3, r2, r3
 80096d8:	b29b      	uxth	r3, r3
 80096da:	b21b      	sxth	r3, r3
 80096dc:	83bb      	strh	r3, [r7, #28]
    top_area.y2 = top_area.y1;
 80096de:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80096e2:	83fb      	strh	r3, [r7, #30]

    lv_area_t bottom_area;
    bottom_area.x1 = coords->x1 + radius + aa;
 80096e4:	68fb      	ldr	r3, [r7, #12]
 80096e6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80096ea:	b29a      	uxth	r2, r3
 80096ec:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80096ee:	4413      	add	r3, r2
 80096f0:	b29a      	uxth	r2, r3
 80096f2:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80096f6:	b29b      	uxth	r3, r3
 80096f8:	4413      	add	r3, r2
 80096fa:	b29b      	uxth	r3, r3
 80096fc:	b21b      	sxth	r3, r3
 80096fe:	823b      	strh	r3, [r7, #16]
    bottom_area.y1 = coords->y2 + 1 - aa;
 8009700:	68fb      	ldr	r3, [r7, #12]
 8009702:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8009706:	b29a      	uxth	r2, r3
 8009708:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 800970c:	b29b      	uxth	r3, r3
 800970e:	1ad3      	subs	r3, r2, r3
 8009710:	b29b      	uxth	r3, r3
 8009712:	3301      	adds	r3, #1
 8009714:	b29b      	uxth	r3, r3
 8009716:	b21b      	sxth	r3, r3
 8009718:	827b      	strh	r3, [r7, #18]
    bottom_area.x2 = coords->x2 - radius - aa;
 800971a:	68fb      	ldr	r3, [r7, #12]
 800971c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8009720:	b29a      	uxth	r2, r3
 8009722:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8009724:	1ad3      	subs	r3, r2, r3
 8009726:	b29a      	uxth	r2, r3
 8009728:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 800972c:	b29b      	uxth	r3, r3
 800972e:	1ad3      	subs	r3, r2, r3
 8009730:	b29b      	uxth	r3, r3
 8009732:	b21b      	sxth	r3, r3
 8009734:	82bb      	strh	r3, [r7, #20]
    bottom_area.y2 = bottom_area.y1;
 8009736:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800973a:	82fb      	strh	r3, [r7, #22]

    lv_opa_t opa_act;
    int16_t d;
    for(d = 1 /*+ LV_ANTIALIAS*/; d <= swidth /* - LV_ANTIALIAS*/; d++) {
 800973c:	2301      	movs	r3, #1
 800973e:	87fb      	strh	r3, [r7, #62]	; 0x3e
 8009740:	e068      	b.n	8009814 <lv_draw_shadow_full_straight+0x29a>
        opa_act = map[d];
 8009742:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8009746:	683a      	ldr	r2, [r7, #0]
 8009748:	4413      	add	r3, r2
 800974a:	781b      	ldrb	r3, [r3, #0]
 800974c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

        lv_draw_fill(&right_area, mask, style->body.shadow.color, opa_act);
 8009750:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8009754:	687a      	ldr	r2, [r7, #4]
 8009756:	f107 0028 	add.w	r0, r7, #40	; 0x28
 800975a:	8a12      	ldrh	r2, [r2, #16]
 800975c:	68b9      	ldr	r1, [r7, #8]
 800975e:	f7fa fd5f 	bl	8004220 <lv_draw_fill>
        right_area.x1++;
 8009762:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8009766:	b29b      	uxth	r3, r3
 8009768:	3301      	adds	r3, #1
 800976a:	b29b      	uxth	r3, r3
 800976c:	b21b      	sxth	r3, r3
 800976e:	853b      	strh	r3, [r7, #40]	; 0x28
        right_area.x2++;
 8009770:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 8009774:	b29b      	uxth	r3, r3
 8009776:	3301      	adds	r3, #1
 8009778:	b29b      	uxth	r3, r3
 800977a:	b21b      	sxth	r3, r3
 800977c:	85bb      	strh	r3, [r7, #44]	; 0x2c

        lv_draw_fill(&left_area, mask, style->body.shadow.color, opa_act);
 800977e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8009782:	687a      	ldr	r2, [r7, #4]
 8009784:	f107 0020 	add.w	r0, r7, #32
 8009788:	8a12      	ldrh	r2, [r2, #16]
 800978a:	68b9      	ldr	r1, [r7, #8]
 800978c:	f7fa fd48 	bl	8004220 <lv_draw_fill>
        left_area.x1--;
 8009790:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8009794:	b29b      	uxth	r3, r3
 8009796:	3b01      	subs	r3, #1
 8009798:	b29b      	uxth	r3, r3
 800979a:	b21b      	sxth	r3, r3
 800979c:	843b      	strh	r3, [r7, #32]
        left_area.x2--;
 800979e:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 80097a2:	b29b      	uxth	r3, r3
 80097a4:	3b01      	subs	r3, #1
 80097a6:	b29b      	uxth	r3, r3
 80097a8:	b21b      	sxth	r3, r3
 80097aa:	84bb      	strh	r3, [r7, #36]	; 0x24

        lv_draw_fill(&top_area, mask, style->body.shadow.color, opa_act);
 80097ac:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80097b0:	687a      	ldr	r2, [r7, #4]
 80097b2:	f107 0018 	add.w	r0, r7, #24
 80097b6:	8a12      	ldrh	r2, [r2, #16]
 80097b8:	68b9      	ldr	r1, [r7, #8]
 80097ba:	f7fa fd31 	bl	8004220 <lv_draw_fill>
        top_area.y1--;
 80097be:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80097c2:	b29b      	uxth	r3, r3
 80097c4:	3b01      	subs	r3, #1
 80097c6:	b29b      	uxth	r3, r3
 80097c8:	b21b      	sxth	r3, r3
 80097ca:	837b      	strh	r3, [r7, #26]
        top_area.y2--;
 80097cc:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80097d0:	b29b      	uxth	r3, r3
 80097d2:	3b01      	subs	r3, #1
 80097d4:	b29b      	uxth	r3, r3
 80097d6:	b21b      	sxth	r3, r3
 80097d8:	83fb      	strh	r3, [r7, #30]

        lv_draw_fill(&bottom_area, mask, style->body.shadow.color, opa_act);
 80097da:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80097de:	687a      	ldr	r2, [r7, #4]
 80097e0:	f107 0010 	add.w	r0, r7, #16
 80097e4:	8a12      	ldrh	r2, [r2, #16]
 80097e6:	68b9      	ldr	r1, [r7, #8]
 80097e8:	f7fa fd1a 	bl	8004220 <lv_draw_fill>
        bottom_area.y1++;
 80097ec:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80097f0:	b29b      	uxth	r3, r3
 80097f2:	3301      	adds	r3, #1
 80097f4:	b29b      	uxth	r3, r3
 80097f6:	b21b      	sxth	r3, r3
 80097f8:	827b      	strh	r3, [r7, #18]
        bottom_area.y2++;
 80097fa:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80097fe:	b29b      	uxth	r3, r3
 8009800:	3301      	adds	r3, #1
 8009802:	b29b      	uxth	r3, r3
 8009804:	b21b      	sxth	r3, r3
 8009806:	82fb      	strh	r3, [r7, #22]
    for(d = 1 /*+ LV_ANTIALIAS*/; d <= swidth /* - LV_ANTIALIAS*/; d++) {
 8009808:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 800980c:	b29b      	uxth	r3, r3
 800980e:	3301      	adds	r3, #1
 8009810:	b29b      	uxth	r3, r3
 8009812:	87fb      	strh	r3, [r7, #62]	; 0x3e
 8009814:	f9b7 203e 	ldrsh.w	r2, [r7, #62]	; 0x3e
 8009818:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 800981c:	429a      	cmp	r2, r3
 800981e:	dd90      	ble.n	8009742 <lv_draw_shadow_full_straight+0x1c8>
    }
}
 8009820:	bf00      	nop
 8009822:	3740      	adds	r7, #64	; 0x40
 8009824:	46bd      	mov	sp, r7
 8009826:	bd80      	pop	{r7, pc}

08009828 <lv_draw_cont_radius_corr>:

#endif

static uint16_t lv_draw_cont_radius_corr(uint16_t r, lv_coord_t w, lv_coord_t h)
{
 8009828:	b580      	push	{r7, lr}
 800982a:	b084      	sub	sp, #16
 800982c:	af00      	add	r7, sp, #0
 800982e:	4603      	mov	r3, r0
 8009830:	80fb      	strh	r3, [r7, #6]
 8009832:	460b      	mov	r3, r1
 8009834:	80bb      	strh	r3, [r7, #4]
 8009836:	4613      	mov	r3, r2
 8009838:	807b      	strh	r3, [r7, #2]
    bool aa = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 800983a:	f7f9 fb8b 	bl	8002f54 <lv_refr_get_disp_refreshing>
 800983e:	4603      	mov	r3, r0
 8009840:	4618      	mov	r0, r3
 8009842:	f002 f908 	bl	800ba56 <lv_disp_get_antialiasing>
 8009846:	4603      	mov	r3, r0
 8009848:	73fb      	strb	r3, [r7, #15]

    if(r >= (w >> 1)) {
 800984a:	88fb      	ldrh	r3, [r7, #6]
 800984c:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 8009850:	1052      	asrs	r2, r2, #1
 8009852:	b212      	sxth	r2, r2
 8009854:	4293      	cmp	r3, r2
 8009856:	db0a      	blt.n	800986e <lv_draw_cont_radius_corr+0x46>
        r = (w >> 1);
 8009858:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 800985c:	105b      	asrs	r3, r3, #1
 800985e:	b21b      	sxth	r3, r3
 8009860:	80fb      	strh	r3, [r7, #6]
        if(r != 0) r--;
 8009862:	88fb      	ldrh	r3, [r7, #6]
 8009864:	2b00      	cmp	r3, #0
 8009866:	d002      	beq.n	800986e <lv_draw_cont_radius_corr+0x46>
 8009868:	88fb      	ldrh	r3, [r7, #6]
 800986a:	3b01      	subs	r3, #1
 800986c:	80fb      	strh	r3, [r7, #6]
    }
    if(r >= (h >> 1)) {
 800986e:	88fb      	ldrh	r3, [r7, #6]
 8009870:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 8009874:	1052      	asrs	r2, r2, #1
 8009876:	b212      	sxth	r2, r2
 8009878:	4293      	cmp	r3, r2
 800987a:	db0a      	blt.n	8009892 <lv_draw_cont_radius_corr+0x6a>
        r = (h >> 1);
 800987c:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8009880:	105b      	asrs	r3, r3, #1
 8009882:	b21b      	sxth	r3, r3
 8009884:	80fb      	strh	r3, [r7, #6]
        if(r != 0) r--;
 8009886:	88fb      	ldrh	r3, [r7, #6]
 8009888:	2b00      	cmp	r3, #0
 800988a:	d002      	beq.n	8009892 <lv_draw_cont_radius_corr+0x6a>
 800988c:	88fb      	ldrh	r3, [r7, #6]
 800988e:	3b01      	subs	r3, #1
 8009890:	80fb      	strh	r3, [r7, #6]
    }

    if(r > 0) r -= aa;
 8009892:	88fb      	ldrh	r3, [r7, #6]
 8009894:	2b00      	cmp	r3, #0
 8009896:	d004      	beq.n	80098a2 <lv_draw_cont_radius_corr+0x7a>
 8009898:	7bfb      	ldrb	r3, [r7, #15]
 800989a:	b29b      	uxth	r3, r3
 800989c:	88fa      	ldrh	r2, [r7, #6]
 800989e:	1ad3      	subs	r3, r2, r3
 80098a0:	80fb      	strh	r3, [r7, #6]

    return r;
 80098a2:	88fb      	ldrh	r3, [r7, #6]
}
 80098a4:	4618      	mov	r0, r3
 80098a6:	3710      	adds	r7, #16
 80098a8:	46bd      	mov	sp, r7
 80098aa:	bd80      	pop	{r7, pc}

080098ac <antialias_get_opa_circ>:
 * @param px_id index of pixel on the line segment
 * @param line_opa opacity of the lien (it will be the max opacity)
 * @return the desired opacity of the pixel
 */
static lv_opa_t antialias_get_opa_circ(lv_coord_t seg, lv_coord_t px_id, lv_opa_t opa)
{
 80098ac:	b480      	push	{r7}
 80098ae:	b085      	sub	sp, #20
 80098b0:	af00      	add	r7, sp, #0
 80098b2:	4603      	mov	r3, r0
 80098b4:	80fb      	strh	r3, [r7, #6]
 80098b6:	460b      	mov	r3, r1
 80098b8:	80bb      	strh	r3, [r7, #4]
 80098ba:	4613      	mov	r3, r2
 80098bc:	70fb      	strb	r3, [r7, #3]
#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 1
    if(seg == 1) return 170;
#endif

#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 2
    if(seg == 2) return (opa_map2[px_id] * opa) >> 8;
 80098be:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80098c2:	2b02      	cmp	r3, #2
 80098c4:	d10a      	bne.n	80098dc <antialias_get_opa_circ+0x30>
 80098c6:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 80098ca:	4a20      	ldr	r2, [pc, #128]	; (800994c <antialias_get_opa_circ+0xa0>)
 80098cc:	5cd3      	ldrb	r3, [r2, r3]
 80098ce:	461a      	mov	r2, r3
 80098d0:	78fb      	ldrb	r3, [r7, #3]
 80098d2:	fb03 f302 	mul.w	r3, r3, r2
 80098d6:	121b      	asrs	r3, r3, #8
 80098d8:	b2db      	uxtb	r3, r3
 80098da:	e031      	b.n	8009940 <antialias_get_opa_circ+0x94>
#endif

#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 3
    if(seg == 3) return (opa_map3[px_id] * opa) >> 8;
 80098dc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80098e0:	2b03      	cmp	r3, #3
 80098e2:	d10a      	bne.n	80098fa <antialias_get_opa_circ+0x4e>
 80098e4:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 80098e8:	4a19      	ldr	r2, [pc, #100]	; (8009950 <antialias_get_opa_circ+0xa4>)
 80098ea:	5cd3      	ldrb	r3, [r2, r3]
 80098ec:	461a      	mov	r2, r3
 80098ee:	78fb      	ldrb	r3, [r7, #3]
 80098f0:	fb03 f302 	mul.w	r3, r3, r2
 80098f4:	121b      	asrs	r3, r3, #8
 80098f6:	b2db      	uxtb	r3, r3
 80098f8:	e022      	b.n	8009940 <antialias_get_opa_circ+0x94>
#endif

#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 4
    if(seg == 4) return (opa_map4[px_id] * opa) >> 8;
 80098fa:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80098fe:	2b04      	cmp	r3, #4
 8009900:	d10a      	bne.n	8009918 <antialias_get_opa_circ+0x6c>
 8009902:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8009906:	4a13      	ldr	r2, [pc, #76]	; (8009954 <antialias_get_opa_circ+0xa8>)
 8009908:	5cd3      	ldrb	r3, [r2, r3]
 800990a:	461a      	mov	r2, r3
 800990c:	78fb      	ldrb	r3, [r7, #3]
 800990e:	fb03 f302 	mul.w	r3, r3, r2
 8009912:	121b      	asrs	r3, r3, #8
 8009914:	b2db      	uxtb	r3, r3
 8009916:	e013      	b.n	8009940 <antialias_get_opa_circ+0x94>
#endif

    uint8_t id = (uint32_t)((uint32_t)px_id * (sizeof(opa_map8) - 1)) / (seg - 1);
 8009918:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 800991c:	4613      	mov	r3, r2
 800991e:	00db      	lsls	r3, r3, #3
 8009920:	1a9b      	subs	r3, r3, r2
 8009922:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8009926:	3a01      	subs	r2, #1
 8009928:	fbb3 f3f2 	udiv	r3, r3, r2
 800992c:	73fb      	strb	r3, [r7, #15]
    return (uint32_t)((uint32_t)opa_map8[id] * opa) >> 8;
 800992e:	7bfb      	ldrb	r3, [r7, #15]
 8009930:	4a09      	ldr	r2, [pc, #36]	; (8009958 <antialias_get_opa_circ+0xac>)
 8009932:	5cd3      	ldrb	r3, [r2, r3]
 8009934:	461a      	mov	r2, r3
 8009936:	78fb      	ldrb	r3, [r7, #3]
 8009938:	fb03 f302 	mul.w	r3, r3, r2
 800993c:	0a1b      	lsrs	r3, r3, #8
 800993e:	b2db      	uxtb	r3, r3
}
 8009940:	4618      	mov	r0, r3
 8009942:	3714      	adds	r7, #20
 8009944:	46bd      	mov	sp, r7
 8009946:	f85d 7b04 	ldr.w	r7, [sp], #4
 800994a:	4770      	bx	lr
 800994c:	08013984 	.word	0x08013984
 8009950:	08013988 	.word	0x08013988
 8009954:	0801398c 	.word	0x0801398c
 8009958:	08013990 	.word	0x08013990

0800995c <lv_img_cache_set_size>:
 * More cached images mean more opened image at same time which might mean more memory usage.
 * E.g. if 20 PNG or JPG images are open in the RAM they consume memory while opened in the cache.
 * @param new_entry_cnt number of image to cache
 */
void lv_img_cache_set_size(uint16_t new_entry_cnt)
{
 800995c:	b590      	push	{r4, r7, lr}
 800995e:	b085      	sub	sp, #20
 8009960:	af00      	add	r7, sp, #0
 8009962:	4603      	mov	r3, r0
 8009964:	80fb      	strh	r3, [r7, #6]
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
 8009966:	4b2f      	ldr	r3, [pc, #188]	; (8009a24 <lv_img_cache_set_size+0xc8>)
 8009968:	681b      	ldr	r3, [r3, #0]
 800996a:	2b00      	cmp	r3, #0
 800996c:	d007      	beq.n	800997e <lv_img_cache_set_size+0x22>
        /*Clean the cache before free it*/
        lv_img_cache_invalidate_src(NULL);
 800996e:	2000      	movs	r0, #0
 8009970:	f000 f85e 	bl	8009a30 <lv_img_cache_invalidate_src>
        lv_mem_free(LV_GC_ROOT(_lv_img_cache_array));
 8009974:	4b2b      	ldr	r3, [pc, #172]	; (8009a24 <lv_img_cache_set_size+0xc8>)
 8009976:	681b      	ldr	r3, [r3, #0]
 8009978:	4618      	mov	r0, r3
 800997a:	f003 f979 	bl	800cc70 <lv_mem_free>
    }

    /*Reallocate the cache*/
    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(lv_img_cache_entry_t) * new_entry_cnt);
 800997e:	88fa      	ldrh	r2, [r7, #6]
 8009980:	4613      	mov	r3, r2
 8009982:	009b      	lsls	r3, r3, #2
 8009984:	4413      	add	r3, r2
 8009986:	00db      	lsls	r3, r3, #3
 8009988:	4618      	mov	r0, r3
 800998a:	f003 f93f 	bl	800cc0c <lv_mem_alloc>
 800998e:	4602      	mov	r2, r0
 8009990:	4b24      	ldr	r3, [pc, #144]	; (8009a24 <lv_img_cache_set_size+0xc8>)
 8009992:	601a      	str	r2, [r3, #0]
    LV_ASSERT_MEM(LV_GC_ROOT(_lv_img_cache_array));
 8009994:	4b23      	ldr	r3, [pc, #140]	; (8009a24 <lv_img_cache_set_size+0xc8>)
 8009996:	681b      	ldr	r3, [r3, #0]
 8009998:	4618      	mov	r0, r3
 800999a:	f7f6 fc2d 	bl	80001f8 <lv_debug_check_null>
 800999e:	4603      	mov	r3, r0
 80099a0:	f083 0301 	eor.w	r3, r3, #1
 80099a4:	b2db      	uxtb	r3, r3
 80099a6:	2b00      	cmp	r3, #0
 80099a8:	d009      	beq.n	80099be <lv_img_cache_set_size+0x62>
 80099aa:	4b1e      	ldr	r3, [pc, #120]	; (8009a24 <lv_img_cache_set_size+0xc8>)
 80099ac:	681b      	ldr	r3, [r3, #0]
 80099ae:	f04f 0400 	mov.w	r4, #0
 80099b2:	461a      	mov	r2, r3
 80099b4:	4623      	mov	r3, r4
 80099b6:	481c      	ldr	r0, [pc, #112]	; (8009a28 <lv_img_cache_set_size+0xcc>)
 80099b8:	f7f6 fc48 	bl	800024c <lv_debug_log_error>
 80099bc:	e7fe      	b.n	80099bc <lv_img_cache_set_size+0x60>
    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {
 80099be:	4b19      	ldr	r3, [pc, #100]	; (8009a24 <lv_img_cache_set_size+0xc8>)
 80099c0:	681b      	ldr	r3, [r3, #0]
 80099c2:	2b00      	cmp	r3, #0
 80099c4:	d103      	bne.n	80099ce <lv_img_cache_set_size+0x72>
        entry_cnt = 0;
 80099c6:	4b19      	ldr	r3, [pc, #100]	; (8009a2c <lv_img_cache_set_size+0xd0>)
 80099c8:	2200      	movs	r2, #0
 80099ca:	801a      	strh	r2, [r3, #0]
        return;
 80099cc:	e027      	b.n	8009a1e <lv_img_cache_set_size+0xc2>
    }
    entry_cnt = new_entry_cnt;
 80099ce:	4a17      	ldr	r2, [pc, #92]	; (8009a2c <lv_img_cache_set_size+0xd0>)
 80099d0:	88fb      	ldrh	r3, [r7, #6]
 80099d2:	8013      	strh	r3, [r2, #0]

    /*Clean the cache*/
    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
 80099d4:	2300      	movs	r3, #0
 80099d6:	81fb      	strh	r3, [r7, #14]
 80099d8:	e01c      	b.n	8009a14 <lv_img_cache_set_size+0xb8>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
 80099da:	4b12      	ldr	r3, [pc, #72]	; (8009a24 <lv_img_cache_set_size+0xc8>)
 80099dc:	6819      	ldr	r1, [r3, #0]
 80099de:	89fa      	ldrh	r2, [r7, #14]
 80099e0:	4613      	mov	r3, r2
 80099e2:	009b      	lsls	r3, r3, #2
 80099e4:	4413      	add	r3, r2
 80099e6:	00db      	lsls	r3, r3, #3
 80099e8:	440b      	add	r3, r1
 80099ea:	2224      	movs	r2, #36	; 0x24
 80099ec:	2100      	movs	r1, #0
 80099ee:	4618      	mov	r0, r3
 80099f0:	f009 feb5 	bl	801375e <memset>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i], 0, sizeof(lv_img_cache_entry_t));
 80099f4:	4b0b      	ldr	r3, [pc, #44]	; (8009a24 <lv_img_cache_set_size+0xc8>)
 80099f6:	6819      	ldr	r1, [r3, #0]
 80099f8:	89fa      	ldrh	r2, [r7, #14]
 80099fa:	4613      	mov	r3, r2
 80099fc:	009b      	lsls	r3, r3, #2
 80099fe:	4413      	add	r3, r2
 8009a00:	00db      	lsls	r3, r3, #3
 8009a02:	440b      	add	r3, r1
 8009a04:	2228      	movs	r2, #40	; 0x28
 8009a06:	2100      	movs	r1, #0
 8009a08:	4618      	mov	r0, r3
 8009a0a:	f009 fea8 	bl	801375e <memset>
    for(i = 0; i < entry_cnt; i++) {
 8009a0e:	89fb      	ldrh	r3, [r7, #14]
 8009a10:	3301      	adds	r3, #1
 8009a12:	81fb      	strh	r3, [r7, #14]
 8009a14:	4b05      	ldr	r3, [pc, #20]	; (8009a2c <lv_img_cache_set_size+0xd0>)
 8009a16:	881b      	ldrh	r3, [r3, #0]
 8009a18:	89fa      	ldrh	r2, [r7, #14]
 8009a1a:	429a      	cmp	r2, r3
 8009a1c:	d3dd      	bcc.n	80099da <lv_img_cache_set_size+0x7e>
    }
}
 8009a1e:	3714      	adds	r7, #20
 8009a20:	46bd      	mov	sp, r7
 8009a22:	bd90      	pop	{r4, r7, pc}
 8009a24:	20009984 	.word	0x20009984
 8009a28:	08013820 	.word	0x08013820
 8009a2c:	2000028c 	.word	0x2000028c

08009a30 <lv_img_cache_invalidate_src>:
 * Invalidate an image source in the cache.
 * Useful if the image source is updated therefore it needs to be cached again.
 * @param src an image source path to a file or pointer to an `lv_img_dsc_t` variable.
 */
void lv_img_cache_invalidate_src(const void * src)
{
 8009a30:	b580      	push	{r7, lr}
 8009a32:	b084      	sub	sp, #16
 8009a34:	af00      	add	r7, sp, #0
 8009a36:	6078      	str	r0, [r7, #4]

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
 8009a38:	4b28      	ldr	r3, [pc, #160]	; (8009adc <lv_img_cache_invalidate_src+0xac>)
 8009a3a:	681b      	ldr	r3, [r3, #0]
 8009a3c:	60bb      	str	r3, [r7, #8]

    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
 8009a3e:	2300      	movs	r3, #0
 8009a40:	81fb      	strh	r3, [r7, #14]
 8009a42:	e041      	b.n	8009ac8 <lv_img_cache_invalidate_src+0x98>
        if(cache[i].dec_dsc.src == src || src == NULL) {
 8009a44:	89fa      	ldrh	r2, [r7, #14]
 8009a46:	4613      	mov	r3, r2
 8009a48:	009b      	lsls	r3, r3, #2
 8009a4a:	4413      	add	r3, r2
 8009a4c:	00db      	lsls	r3, r3, #3
 8009a4e:	461a      	mov	r2, r3
 8009a50:	68bb      	ldr	r3, [r7, #8]
 8009a52:	4413      	add	r3, r2
 8009a54:	685b      	ldr	r3, [r3, #4]
 8009a56:	687a      	ldr	r2, [r7, #4]
 8009a58:	429a      	cmp	r2, r3
 8009a5a:	d002      	beq.n	8009a62 <lv_img_cache_invalidate_src+0x32>
 8009a5c:	687b      	ldr	r3, [r7, #4]
 8009a5e:	2b00      	cmp	r3, #0
 8009a60:	d12f      	bne.n	8009ac2 <lv_img_cache_invalidate_src+0x92>
            if(cache[i].dec_dsc.src != NULL) {
 8009a62:	89fa      	ldrh	r2, [r7, #14]
 8009a64:	4613      	mov	r3, r2
 8009a66:	009b      	lsls	r3, r3, #2
 8009a68:	4413      	add	r3, r2
 8009a6a:	00db      	lsls	r3, r3, #3
 8009a6c:	461a      	mov	r2, r3
 8009a6e:	68bb      	ldr	r3, [r7, #8]
 8009a70:	4413      	add	r3, r2
 8009a72:	685b      	ldr	r3, [r3, #4]
 8009a74:	2b00      	cmp	r3, #0
 8009a76:	d00a      	beq.n	8009a8e <lv_img_cache_invalidate_src+0x5e>
                lv_img_decoder_close(&cache[i].dec_dsc);
 8009a78:	89fa      	ldrh	r2, [r7, #14]
 8009a7a:	4613      	mov	r3, r2
 8009a7c:	009b      	lsls	r3, r3, #2
 8009a7e:	4413      	add	r3, r2
 8009a80:	00db      	lsls	r3, r3, #3
 8009a82:	461a      	mov	r2, r3
 8009a84:	68bb      	ldr	r3, [r7, #8]
 8009a86:	4413      	add	r3, r2
 8009a88:	4618      	mov	r0, r3
 8009a8a:	f000 f895 	bl	8009bb8 <lv_img_decoder_close>
            }

            memset(&cache[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
 8009a8e:	89fa      	ldrh	r2, [r7, #14]
 8009a90:	4613      	mov	r3, r2
 8009a92:	009b      	lsls	r3, r3, #2
 8009a94:	4413      	add	r3, r2
 8009a96:	00db      	lsls	r3, r3, #3
 8009a98:	461a      	mov	r2, r3
 8009a9a:	68bb      	ldr	r3, [r7, #8]
 8009a9c:	4413      	add	r3, r2
 8009a9e:	2224      	movs	r2, #36	; 0x24
 8009aa0:	2100      	movs	r1, #0
 8009aa2:	4618      	mov	r0, r3
 8009aa4:	f009 fe5b 	bl	801375e <memset>
            memset(&cache[i], 0, sizeof(lv_img_cache_entry_t));
 8009aa8:	89fa      	ldrh	r2, [r7, #14]
 8009aaa:	4613      	mov	r3, r2
 8009aac:	009b      	lsls	r3, r3, #2
 8009aae:	4413      	add	r3, r2
 8009ab0:	00db      	lsls	r3, r3, #3
 8009ab2:	461a      	mov	r2, r3
 8009ab4:	68bb      	ldr	r3, [r7, #8]
 8009ab6:	4413      	add	r3, r2
 8009ab8:	2228      	movs	r2, #40	; 0x28
 8009aba:	2100      	movs	r1, #0
 8009abc:	4618      	mov	r0, r3
 8009abe:	f009 fe4e 	bl	801375e <memset>
    for(i = 0; i < entry_cnt; i++) {
 8009ac2:	89fb      	ldrh	r3, [r7, #14]
 8009ac4:	3301      	adds	r3, #1
 8009ac6:	81fb      	strh	r3, [r7, #14]
 8009ac8:	4b05      	ldr	r3, [pc, #20]	; (8009ae0 <lv_img_cache_invalidate_src+0xb0>)
 8009aca:	881b      	ldrh	r3, [r3, #0]
 8009acc:	89fa      	ldrh	r2, [r7, #14]
 8009ace:	429a      	cmp	r2, r3
 8009ad0:	d3b8      	bcc.n	8009a44 <lv_img_cache_invalidate_src+0x14>
        }
    }
}
 8009ad2:	bf00      	nop
 8009ad4:	3710      	adds	r7, #16
 8009ad6:	46bd      	mov	sp, r7
 8009ad8:	bd80      	pop	{r7, pc}
 8009ada:	bf00      	nop
 8009adc:	20009984 	.word	0x20009984
 8009ae0:	2000028c 	.word	0x2000028c

08009ae4 <lv_color_make>:
{
 8009ae4:	b490      	push	{r4, r7}
 8009ae6:	b082      	sub	sp, #8
 8009ae8:	af00      	add	r7, sp, #0
 8009aea:	4604      	mov	r4, r0
 8009aec:	4608      	mov	r0, r1
 8009aee:	4611      	mov	r1, r2
 8009af0:	4622      	mov	r2, r4
 8009af2:	71fa      	strb	r2, [r7, #7]
 8009af4:	4602      	mov	r2, r0
 8009af6:	71ba      	strb	r2, [r7, #6]
 8009af8:	460a      	mov	r2, r1
 8009afa:	717a      	strb	r2, [r7, #5]
    return LV_COLOR_MAKE(r, g, b);
 8009afc:	797a      	ldrb	r2, [r7, #5]
 8009afe:	08d2      	lsrs	r2, r2, #3
 8009b00:	b2d2      	uxtb	r2, r2
 8009b02:	f002 021f 	and.w	r2, r2, #31
 8009b06:	b2d0      	uxtb	r0, r2
 8009b08:	79ba      	ldrb	r2, [r7, #6]
 8009b0a:	0892      	lsrs	r2, r2, #2
 8009b0c:	b2d2      	uxtb	r2, r2
 8009b0e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8009b12:	b2d1      	uxtb	r1, r2
 8009b14:	79fa      	ldrb	r2, [r7, #7]
 8009b16:	08d2      	lsrs	r2, r2, #3
 8009b18:	b2d2      	uxtb	r2, r2
 8009b1a:	f002 021f 	and.w	r2, r2, #31
 8009b1e:	b2d2      	uxtb	r2, r2
 8009b20:	f360 0304 	bfi	r3, r0, #0, #5
 8009b24:	f361 134a 	bfi	r3, r1, #5, #6
 8009b28:	f362 23cf 	bfi	r3, r2, #11, #5
}
 8009b2c:	4618      	mov	r0, r3
 8009b2e:	3708      	adds	r7, #8
 8009b30:	46bd      	mov	sp, r7
 8009b32:	bc90      	pop	{r4, r7}
 8009b34:	4770      	bx	lr
	...

08009b38 <lv_img_decoder_init>:

/**
 * Initialize the image decoder module
 * */
void lv_img_decoder_init(void)
{
 8009b38:	b590      	push	{r4, r7, lr}
 8009b3a:	b083      	sub	sp, #12
 8009b3c:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_img_defoder_ll), sizeof(lv_img_decoder_t));
 8009b3e:	2110      	movs	r1, #16
 8009b40:	4817      	ldr	r0, [pc, #92]	; (8009ba0 <lv_img_decoder_init+0x68>)
 8009b42:	f002 fdb9 	bl	800c6b8 <lv_ll_init>

    lv_img_decoder_t * decoder;

    /*Create a decoder for the built in color format*/
    decoder = lv_img_decoder_create();
 8009b46:	f000 f85d 	bl	8009c04 <lv_img_decoder_create>
 8009b4a:	6078      	str	r0, [r7, #4]
    if(decoder == NULL) {
 8009b4c:	687b      	ldr	r3, [r7, #4]
 8009b4e:	2b00      	cmp	r3, #0
 8009b50:	d111      	bne.n	8009b76 <lv_img_decoder_init+0x3e>
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
        LV_ASSERT_MEM(decoder);
 8009b52:	6878      	ldr	r0, [r7, #4]
 8009b54:	f7f6 fb50 	bl	80001f8 <lv_debug_check_null>
 8009b58:	4603      	mov	r3, r0
 8009b5a:	f083 0301 	eor.w	r3, r3, #1
 8009b5e:	b2db      	uxtb	r3, r3
 8009b60:	2b00      	cmp	r3, #0
 8009b62:	d019      	beq.n	8009b98 <lv_img_decoder_init+0x60>
 8009b64:	687b      	ldr	r3, [r7, #4]
 8009b66:	f04f 0400 	mov.w	r4, #0
 8009b6a:	461a      	mov	r2, r3
 8009b6c:	4623      	mov	r3, r4
 8009b6e:	480d      	ldr	r0, [pc, #52]	; (8009ba4 <lv_img_decoder_init+0x6c>)
 8009b70:	f7f6 fb6c 	bl	800024c <lv_debug_log_error>
 8009b74:	e7fe      	b.n	8009b74 <lv_img_decoder_init+0x3c>
        return;
    }

    lv_img_decoder_set_info_cb(decoder, lv_img_decoder_built_in_info);
 8009b76:	490c      	ldr	r1, [pc, #48]	; (8009ba8 <lv_img_decoder_init+0x70>)
 8009b78:	6878      	ldr	r0, [r7, #4]
 8009b7a:	f000 f86f 	bl	8009c5c <lv_img_decoder_set_info_cb>
    lv_img_decoder_set_open_cb(decoder, lv_img_decoder_built_in_open);
 8009b7e:	490b      	ldr	r1, [pc, #44]	; (8009bac <lv_img_decoder_init+0x74>)
 8009b80:	6878      	ldr	r0, [r7, #4]
 8009b82:	f000 f879 	bl	8009c78 <lv_img_decoder_set_open_cb>
    lv_img_decoder_set_read_line_cb(decoder, lv_img_decoder_built_in_read_line);
 8009b86:	490a      	ldr	r1, [pc, #40]	; (8009bb0 <lv_img_decoder_init+0x78>)
 8009b88:	6878      	ldr	r0, [r7, #4]
 8009b8a:	f000 f883 	bl	8009c94 <lv_img_decoder_set_read_line_cb>
    lv_img_decoder_set_close_cb(decoder, lv_img_decoder_built_in_close);
 8009b8e:	4909      	ldr	r1, [pc, #36]	; (8009bb4 <lv_img_decoder_init+0x7c>)
 8009b90:	6878      	ldr	r0, [r7, #4]
 8009b92:	f000 f88d 	bl	8009cb0 <lv_img_decoder_set_close_cb>
 8009b96:	e000      	b.n	8009b9a <lv_img_decoder_init+0x62>
        return;
 8009b98:	bf00      	nop
}
 8009b9a:	370c      	adds	r7, #12
 8009b9c:	46bd      	mov	sp, r7
 8009b9e:	bd90      	pop	{r4, r7, pc}
 8009ba0:	20009968 	.word	0x20009968
 8009ba4:	08013830 	.word	0x08013830
 8009ba8:	08009ccd 	.word	0x08009ccd
 8009bac:	08009dd9 	.word	0x08009dd9
 8009bb0:	0800a145 	.word	0x0800a145
 8009bb4:	0800a269 	.word	0x0800a269

08009bb8 <lv_img_decoder_close>:
/**
 * Close a decoding session
 * @param dsc pointer to `lv_img_decoder_dsc_t` used in `lv_img_decoder_open`
 */
void lv_img_decoder_close(lv_img_decoder_dsc_t * dsc)
{
 8009bb8:	b580      	push	{r7, lr}
 8009bba:	b082      	sub	sp, #8
 8009bbc:	af00      	add	r7, sp, #0
 8009bbe:	6078      	str	r0, [r7, #4]
    if(dsc->decoder) {
 8009bc0:	687b      	ldr	r3, [r7, #4]
 8009bc2:	681b      	ldr	r3, [r3, #0]
 8009bc4:	2b00      	cmp	r3, #0
 8009bc6:	d018      	beq.n	8009bfa <lv_img_decoder_close+0x42>
        if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);
 8009bc8:	687b      	ldr	r3, [r7, #4]
 8009bca:	681b      	ldr	r3, [r3, #0]
 8009bcc:	68db      	ldr	r3, [r3, #12]
 8009bce:	2b00      	cmp	r3, #0
 8009bd0:	d007      	beq.n	8009be2 <lv_img_decoder_close+0x2a>
 8009bd2:	687b      	ldr	r3, [r7, #4]
 8009bd4:	681b      	ldr	r3, [r3, #0]
 8009bd6:	68db      	ldr	r3, [r3, #12]
 8009bd8:	687a      	ldr	r2, [r7, #4]
 8009bda:	6812      	ldr	r2, [r2, #0]
 8009bdc:	6879      	ldr	r1, [r7, #4]
 8009bde:	4610      	mov	r0, r2
 8009be0:	4798      	blx	r3

        if(dsc->src_type == LV_IMG_SRC_FILE) {
 8009be2:	687b      	ldr	r3, [r7, #4]
 8009be4:	7b1b      	ldrb	r3, [r3, #12]
 8009be6:	2b01      	cmp	r3, #1
 8009be8:	d107      	bne.n	8009bfa <lv_img_decoder_close+0x42>
            lv_mem_free(dsc->src);
 8009bea:	687b      	ldr	r3, [r7, #4]
 8009bec:	685b      	ldr	r3, [r3, #4]
 8009bee:	4618      	mov	r0, r3
 8009bf0:	f003 f83e 	bl	800cc70 <lv_mem_free>
            dsc->src = NULL;
 8009bf4:	687b      	ldr	r3, [r7, #4]
 8009bf6:	2200      	movs	r2, #0
 8009bf8:	605a      	str	r2, [r3, #4]
        }
    }
}
 8009bfa:	bf00      	nop
 8009bfc:	3708      	adds	r7, #8
 8009bfe:	46bd      	mov	sp, r7
 8009c00:	bd80      	pop	{r7, pc}
	...

08009c04 <lv_img_decoder_create>:
/**
 * Create a new image decoder
 * @return pointer to the new image decoder
 */
lv_img_decoder_t * lv_img_decoder_create(void)
{
 8009c04:	b590      	push	{r4, r7, lr}
 8009c06:	b083      	sub	sp, #12
 8009c08:	af00      	add	r7, sp, #0
    lv_img_decoder_t * decoder;
    decoder = lv_ll_ins_head(&LV_GC_ROOT(_lv_img_defoder_ll));
 8009c0a:	4812      	ldr	r0, [pc, #72]	; (8009c54 <lv_img_decoder_create+0x50>)
 8009c0c:	f002 fd74 	bl	800c6f8 <lv_ll_ins_head>
 8009c10:	6078      	str	r0, [r7, #4]
    LV_ASSERT_MEM(decoder);
 8009c12:	6878      	ldr	r0, [r7, #4]
 8009c14:	f7f6 faf0 	bl	80001f8 <lv_debug_check_null>
 8009c18:	4603      	mov	r3, r0
 8009c1a:	f083 0301 	eor.w	r3, r3, #1
 8009c1e:	b2db      	uxtb	r3, r3
 8009c20:	2b00      	cmp	r3, #0
 8009c22:	d008      	beq.n	8009c36 <lv_img_decoder_create+0x32>
 8009c24:	687b      	ldr	r3, [r7, #4]
 8009c26:	f04f 0400 	mov.w	r4, #0
 8009c2a:	461a      	mov	r2, r3
 8009c2c:	4623      	mov	r3, r4
 8009c2e:	480a      	ldr	r0, [pc, #40]	; (8009c58 <lv_img_decoder_create+0x54>)
 8009c30:	f7f6 fb0c 	bl	800024c <lv_debug_log_error>
 8009c34:	e7fe      	b.n	8009c34 <lv_img_decoder_create+0x30>
    if(decoder == NULL) return NULL;
 8009c36:	687b      	ldr	r3, [r7, #4]
 8009c38:	2b00      	cmp	r3, #0
 8009c3a:	d101      	bne.n	8009c40 <lv_img_decoder_create+0x3c>
 8009c3c:	2300      	movs	r3, #0
 8009c3e:	e005      	b.n	8009c4c <lv_img_decoder_create+0x48>

    memset(decoder, 0, sizeof(lv_img_decoder_t));
 8009c40:	2210      	movs	r2, #16
 8009c42:	2100      	movs	r1, #0
 8009c44:	6878      	ldr	r0, [r7, #4]
 8009c46:	f009 fd8a 	bl	801375e <memset>

    return decoder;
 8009c4a:	687b      	ldr	r3, [r7, #4]
}
 8009c4c:	4618      	mov	r0, r3
 8009c4e:	370c      	adds	r7, #12
 8009c50:	46bd      	mov	sp, r7
 8009c52:	bd90      	pop	{r4, r7, pc}
 8009c54:	20009968 	.word	0x20009968
 8009c58:	08013830 	.word	0x08013830

08009c5c <lv_img_decoder_set_info_cb>:
 * Set a callback to get information about the image
 * @param decoder pointer to an image decoder
 * @param info_cb a function to collect info about an image (fill an `lv_img_header_t` struct)
 */
void lv_img_decoder_set_info_cb(lv_img_decoder_t * decoder, lv_img_decoder_info_f_t info_cb)
{
 8009c5c:	b480      	push	{r7}
 8009c5e:	b083      	sub	sp, #12
 8009c60:	af00      	add	r7, sp, #0
 8009c62:	6078      	str	r0, [r7, #4]
 8009c64:	6039      	str	r1, [r7, #0]
    decoder->info_cb = info_cb;
 8009c66:	687b      	ldr	r3, [r7, #4]
 8009c68:	683a      	ldr	r2, [r7, #0]
 8009c6a:	601a      	str	r2, [r3, #0]
}
 8009c6c:	bf00      	nop
 8009c6e:	370c      	adds	r7, #12
 8009c70:	46bd      	mov	sp, r7
 8009c72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c76:	4770      	bx	lr

08009c78 <lv_img_decoder_set_open_cb>:
 * Set a callback to open an image
 * @param decoder pointer to an image decoder
 * @param open_cb a function to open an image
 */
void lv_img_decoder_set_open_cb(lv_img_decoder_t * decoder, lv_img_decoder_open_f_t open_cb)
{
 8009c78:	b480      	push	{r7}
 8009c7a:	b083      	sub	sp, #12
 8009c7c:	af00      	add	r7, sp, #0
 8009c7e:	6078      	str	r0, [r7, #4]
 8009c80:	6039      	str	r1, [r7, #0]
    decoder->open_cb = open_cb;
 8009c82:	687b      	ldr	r3, [r7, #4]
 8009c84:	683a      	ldr	r2, [r7, #0]
 8009c86:	605a      	str	r2, [r3, #4]
}
 8009c88:	bf00      	nop
 8009c8a:	370c      	adds	r7, #12
 8009c8c:	46bd      	mov	sp, r7
 8009c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c92:	4770      	bx	lr

08009c94 <lv_img_decoder_set_read_line_cb>:
 * Set a callback to a decoded line of an image
 * @param decoder pointer to an image decoder
 * @param read_line_cb a function to read a line of an image
 */
void lv_img_decoder_set_read_line_cb(lv_img_decoder_t * decoder, lv_img_decoder_read_line_f_t read_line_cb)
{
 8009c94:	b480      	push	{r7}
 8009c96:	b083      	sub	sp, #12
 8009c98:	af00      	add	r7, sp, #0
 8009c9a:	6078      	str	r0, [r7, #4]
 8009c9c:	6039      	str	r1, [r7, #0]
    decoder->read_line_cb = read_line_cb;
 8009c9e:	687b      	ldr	r3, [r7, #4]
 8009ca0:	683a      	ldr	r2, [r7, #0]
 8009ca2:	609a      	str	r2, [r3, #8]
}
 8009ca4:	bf00      	nop
 8009ca6:	370c      	adds	r7, #12
 8009ca8:	46bd      	mov	sp, r7
 8009caa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009cae:	4770      	bx	lr

08009cb0 <lv_img_decoder_set_close_cb>:
 * Set a callback to close a decoding session. E.g. close files and free other resources.
 * @param decoder pointer to an image decoder
 * @param close_cb a function to close a decoding session
 */
void lv_img_decoder_set_close_cb(lv_img_decoder_t * decoder, lv_img_decoder_close_f_t close_cb)
{
 8009cb0:	b480      	push	{r7}
 8009cb2:	b083      	sub	sp, #12
 8009cb4:	af00      	add	r7, sp, #0
 8009cb6:	6078      	str	r0, [r7, #4]
 8009cb8:	6039      	str	r1, [r7, #0]
    decoder->close_cb = close_cb;
 8009cba:	687b      	ldr	r3, [r7, #4]
 8009cbc:	683a      	ldr	r2, [r7, #0]
 8009cbe:	60da      	str	r2, [r3, #12]
}
 8009cc0:	bf00      	nop
 8009cc2:	370c      	adds	r7, #12
 8009cc4:	46bd      	mov	sp, r7
 8009cc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009cca:	4770      	bx	lr

08009ccc <lv_img_decoder_built_in_info>:
 * @param src the image source: pointer to an `lv_img_dsc_t` variable, a file path or a symbol
 * @param header store the image data here
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_info(lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header)
{
 8009ccc:	b580      	push	{r7, lr}
 8009cce:	b088      	sub	sp, #32
 8009cd0:	af00      	add	r7, sp, #0
 8009cd2:	60f8      	str	r0, [r7, #12]
 8009cd4:	60b9      	str	r1, [r7, #8]
 8009cd6:	607a      	str	r2, [r7, #4]
    (void)decoder; /*Unused*/

    lv_img_src_t src_type = lv_img_src_get_type(src);
 8009cd8:	68b8      	ldr	r0, [r7, #8]
 8009cda:	f7fb f9cd 	bl	8005078 <lv_img_src_get_type>
 8009cde:	4603      	mov	r3, r0
 8009ce0:	77fb      	strb	r3, [r7, #31]
    if(src_type == LV_IMG_SRC_VARIABLE) {
 8009ce2:	7ffb      	ldrb	r3, [r7, #31]
 8009ce4:	2b00      	cmp	r3, #0
 8009ce6:	d12c      	bne.n	8009d42 <lv_img_decoder_built_in_info+0x76>
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
 8009ce8:	68bb      	ldr	r3, [r7, #8]
 8009cea:	781b      	ldrb	r3, [r3, #0]
 8009cec:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8009cf0:	b2db      	uxtb	r3, r3
 8009cf2:	777b      	strb	r3, [r7, #29]
        if(cf < CF_BUILT_IN_FIRST || cf > CF_BUILT_IN_LAST) return LV_RES_INV;
 8009cf4:	7f7b      	ldrb	r3, [r7, #29]
 8009cf6:	2b03      	cmp	r3, #3
 8009cf8:	d902      	bls.n	8009d00 <lv_img_decoder_built_in_info+0x34>
 8009cfa:	7f7b      	ldrb	r3, [r7, #29]
 8009cfc:	2b0e      	cmp	r3, #14
 8009cfe:	d901      	bls.n	8009d04 <lv_img_decoder_built_in_info+0x38>
 8009d00:	2300      	movs	r3, #0
 8009d02:	e065      	b.n	8009dd0 <lv_img_decoder_built_in_info+0x104>

        header->w  = ((lv_img_dsc_t *)src)->header.w;
 8009d04:	68bb      	ldr	r3, [r7, #8]
 8009d06:	681b      	ldr	r3, [r3, #0]
 8009d08:	f3c3 238a 	ubfx	r3, r3, #10, #11
 8009d0c:	b299      	uxth	r1, r3
 8009d0e:	687a      	ldr	r2, [r7, #4]
 8009d10:	6813      	ldr	r3, [r2, #0]
 8009d12:	f361 2394 	bfi	r3, r1, #10, #11
 8009d16:	6013      	str	r3, [r2, #0]
        header->h  = ((lv_img_dsc_t *)src)->header.h;
 8009d18:	68bb      	ldr	r3, [r7, #8]
 8009d1a:	885b      	ldrh	r3, [r3, #2]
 8009d1c:	f3c3 134a 	ubfx	r3, r3, #5, #11
 8009d20:	b299      	uxth	r1, r3
 8009d22:	687a      	ldr	r2, [r7, #4]
 8009d24:	8853      	ldrh	r3, [r2, #2]
 8009d26:	f361 134f 	bfi	r3, r1, #5, #11
 8009d2a:	8053      	strh	r3, [r2, #2]
        header->cf = ((lv_img_dsc_t *)src)->header.cf;
 8009d2c:	68bb      	ldr	r3, [r7, #8]
 8009d2e:	781b      	ldrb	r3, [r3, #0]
 8009d30:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8009d34:	b2d9      	uxtb	r1, r3
 8009d36:	687a      	ldr	r2, [r7, #4]
 8009d38:	7813      	ldrb	r3, [r2, #0]
 8009d3a:	f361 0304 	bfi	r3, r1, #0, #5
 8009d3e:	7013      	strb	r3, [r2, #0]
 8009d40:	e045      	b.n	8009dce <lv_img_decoder_built_in_info+0x102>
    }
#if LV_USE_FILESYSTEM
    else if(src_type == LV_IMG_SRC_FILE) {
 8009d42:	7ffb      	ldrb	r3, [r7, #31]
 8009d44:	2b01      	cmp	r3, #1
 8009d46:	d12a      	bne.n	8009d9e <lv_img_decoder_built_in_info+0xd2>
        lv_fs_file_t file;
        lv_fs_res_t res;
        uint32_t rn;
        res = lv_fs_open(&file, src, LV_FS_MODE_RD);
 8009d48:	f107 0314 	add.w	r3, r7, #20
 8009d4c:	2202      	movs	r2, #2
 8009d4e:	68b9      	ldr	r1, [r7, #8]
 8009d50:	4618      	mov	r0, r3
 8009d52:	f002 fb25 	bl	800c3a0 <lv_fs_open>
 8009d56:	4603      	mov	r3, r0
 8009d58:	77bb      	strb	r3, [r7, #30]
        if(res == LV_FS_RES_OK) {
 8009d5a:	7fbb      	ldrb	r3, [r7, #30]
 8009d5c:	2b00      	cmp	r3, #0
 8009d5e:	d10e      	bne.n	8009d7e <lv_img_decoder_built_in_info+0xb2>
            res = lv_fs_read(&file, header, sizeof(lv_img_header_t), &rn);
 8009d60:	f107 0310 	add.w	r3, r7, #16
 8009d64:	f107 0014 	add.w	r0, r7, #20
 8009d68:	2204      	movs	r2, #4
 8009d6a:	6879      	ldr	r1, [r7, #4]
 8009d6c:	f002 fbd9 	bl	800c522 <lv_fs_read>
 8009d70:	4603      	mov	r3, r0
 8009d72:	77bb      	strb	r3, [r7, #30]
            lv_fs_close(&file);
 8009d74:	f107 0314 	add.w	r3, r7, #20
 8009d78:	4618      	mov	r0, r3
 8009d7a:	f002 fba3 	bl	800c4c4 <lv_fs_close>
        }

        if(header->cf < CF_BUILT_IN_FIRST || header->cf > CF_BUILT_IN_LAST) return LV_RES_INV;
 8009d7e:	687b      	ldr	r3, [r7, #4]
 8009d80:	781b      	ldrb	r3, [r3, #0]
 8009d82:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8009d86:	b2db      	uxtb	r3, r3
 8009d88:	2b03      	cmp	r3, #3
 8009d8a:	d906      	bls.n	8009d9a <lv_img_decoder_built_in_info+0xce>
 8009d8c:	687b      	ldr	r3, [r7, #4]
 8009d8e:	781b      	ldrb	r3, [r3, #0]
 8009d90:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8009d94:	b2db      	uxtb	r3, r3
 8009d96:	2b0e      	cmp	r3, #14
 8009d98:	d919      	bls.n	8009dce <lv_img_decoder_built_in_info+0x102>
 8009d9a:	2300      	movs	r3, #0
 8009d9c:	e018      	b.n	8009dd0 <lv_img_decoder_built_in_info+0x104>

    }
#endif
    else if(src_type == LV_IMG_SRC_SYMBOL) {
 8009d9e:	7ffb      	ldrb	r3, [r7, #31]
 8009da0:	2b02      	cmp	r3, #2
 8009da2:	d112      	bne.n	8009dca <lv_img_decoder_built_in_info+0xfe>
        /*The size depend on the font but it is unknown here. It should be handled outside of the
         * function*/
        header->w = 1;
 8009da4:	687a      	ldr	r2, [r7, #4]
 8009da6:	6813      	ldr	r3, [r2, #0]
 8009da8:	2101      	movs	r1, #1
 8009daa:	f361 2394 	bfi	r3, r1, #10, #11
 8009dae:	6013      	str	r3, [r2, #0]
        header->h = 1;
 8009db0:	687a      	ldr	r2, [r7, #4]
 8009db2:	8853      	ldrh	r3, [r2, #2]
 8009db4:	2101      	movs	r1, #1
 8009db6:	f361 134f 	bfi	r3, r1, #5, #11
 8009dba:	8053      	strh	r3, [r2, #2]
        /* Symbols always have transparent parts. Important because of cover check in the design
         * function. The actual value doesn't matter because lv_draw_label will draw it*/
        header->cf = LV_IMG_CF_ALPHA_1BIT;
 8009dbc:	687a      	ldr	r2, [r7, #4]
 8009dbe:	7813      	ldrb	r3, [r2, #0]
 8009dc0:	210b      	movs	r1, #11
 8009dc2:	f361 0304 	bfi	r3, r1, #0, #5
 8009dc6:	7013      	strb	r3, [r2, #0]
 8009dc8:	e001      	b.n	8009dce <lv_img_decoder_built_in_info+0x102>
    } else {
        LV_LOG_WARN("Image get info found unknown src type");
        return LV_RES_INV;
 8009dca:	2300      	movs	r3, #0
 8009dcc:	e000      	b.n	8009dd0 <lv_img_decoder_built_in_info+0x104>
    }
    return LV_RES_OK;
 8009dce:	2301      	movs	r3, #1
}
 8009dd0:	4618      	mov	r0, r3
 8009dd2:	3720      	adds	r7, #32
 8009dd4:	46bd      	mov	sp, r7
 8009dd6:	bd80      	pop	{r7, pc}

08009dd8 <lv_img_decoder_built_in_open>:
 * @param decoder the decoder where this function belongs
 * @param dsc pointer to decoder descriptor. `src`, `style` are already initialized in it.
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
 8009dd8:	b5b0      	push	{r4, r5, r7, lr}
 8009dda:	b08e      	sub	sp, #56	; 0x38
 8009ddc:	af00      	add	r7, sp, #0
 8009dde:	6078      	str	r0, [r7, #4]
 8009de0:	6039      	str	r1, [r7, #0]
    /*Open the file if it's a file*/
    if(dsc->src_type == LV_IMG_SRC_FILE) {
 8009de2:	683b      	ldr	r3, [r7, #0]
 8009de4:	7b1b      	ldrb	r3, [r3, #12]
 8009de6:	2b01      	cmp	r3, #1
 8009de8:	d173      	bne.n	8009ed2 <lv_img_decoder_built_in_open+0xfa>
#if LV_USE_FILESYSTEM

        /*Support only "*.bin" files*/
        if(strcmp(lv_fs_get_ext(dsc->src), "bin")) return LV_RES_INV;
 8009dea:	683b      	ldr	r3, [r7, #0]
 8009dec:	685b      	ldr	r3, [r3, #4]
 8009dee:	4618      	mov	r0, r3
 8009df0:	f002 fc10 	bl	800c614 <lv_fs_get_ext>
 8009df4:	4603      	mov	r3, r0
 8009df6:	49aa      	ldr	r1, [pc, #680]	; (800a0a0 <lv_img_decoder_built_in_open+0x2c8>)
 8009df8:	4618      	mov	r0, r3
 8009dfa:	f7f6 f9eb 	bl	80001d4 <strcmp>
 8009dfe:	4603      	mov	r3, r0
 8009e00:	2b00      	cmp	r3, #0
 8009e02:	d001      	beq.n	8009e08 <lv_img_decoder_built_in_open+0x30>
 8009e04:	2300      	movs	r3, #0
 8009e06:	e198      	b.n	800a13a <lv_img_decoder_built_in_open+0x362>

        lv_fs_file_t f;
        lv_fs_res_t res = lv_fs_open(&f, dsc->src, LV_FS_MODE_RD);
 8009e08:	683b      	ldr	r3, [r7, #0]
 8009e0a:	6859      	ldr	r1, [r3, #4]
 8009e0c:	f107 0310 	add.w	r3, r7, #16
 8009e10:	2202      	movs	r2, #2
 8009e12:	4618      	mov	r0, r3
 8009e14:	f002 fac4 	bl	800c3a0 <lv_fs_open>
 8009e18:	4603      	mov	r3, r0
 8009e1a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        if(res != LV_FS_RES_OK) {
 8009e1e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8009e22:	2b00      	cmp	r3, #0
 8009e24:	d001      	beq.n	8009e2a <lv_img_decoder_built_in_open+0x52>
            LV_LOG_WARN("Built-in image decoder can't open the file");
            return LV_RES_INV;
 8009e26:	2300      	movs	r3, #0
 8009e28:	e187      	b.n	800a13a <lv_img_decoder_built_in_open+0x362>
        }

        /*If the file was open successfully save the file descriptor*/
        if(dsc->user_data == NULL) {
 8009e2a:	683b      	ldr	r3, [r7, #0]
 8009e2c:	6a1b      	ldr	r3, [r3, #32]
 8009e2e:	2b00      	cmp	r3, #0
 8009e30:	d125      	bne.n	8009e7e <lv_img_decoder_built_in_open+0xa6>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
 8009e32:	200c      	movs	r0, #12
 8009e34:	f002 feea 	bl	800cc0c <lv_mem_alloc>
 8009e38:	4602      	mov	r2, r0
 8009e3a:	683b      	ldr	r3, [r7, #0]
 8009e3c:	621a      	str	r2, [r3, #32]
            if(dsc->user_data == NULL) {
 8009e3e:	683b      	ldr	r3, [r7, #0]
 8009e40:	6a1b      	ldr	r3, [r3, #32]
 8009e42:	2b00      	cmp	r3, #0
 8009e44:	d114      	bne.n	8009e70 <lv_img_decoder_built_in_open+0x98>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
                LV_ASSERT_MEM(dsc->user_data);
 8009e46:	683b      	ldr	r3, [r7, #0]
 8009e48:	6a1b      	ldr	r3, [r3, #32]
 8009e4a:	4618      	mov	r0, r3
 8009e4c:	f7f6 f9d4 	bl	80001f8 <lv_debug_check_null>
 8009e50:	4603      	mov	r3, r0
 8009e52:	f083 0301 	eor.w	r3, r3, #1
 8009e56:	b2db      	uxtb	r3, r3
 8009e58:	2b00      	cmp	r3, #0
 8009e5a:	d009      	beq.n	8009e70 <lv_img_decoder_built_in_open+0x98>
 8009e5c:	683b      	ldr	r3, [r7, #0]
 8009e5e:	6a1b      	ldr	r3, [r3, #32]
 8009e60:	f04f 0400 	mov.w	r4, #0
 8009e64:	461a      	mov	r2, r3
 8009e66:	4623      	mov	r3, r4
 8009e68:	488e      	ldr	r0, [pc, #568]	; (800a0a4 <lv_img_decoder_built_in_open+0x2cc>)
 8009e6a:	f7f6 f9ef 	bl	800024c <lv_debug_log_error>
 8009e6e:	e7fe      	b.n	8009e6e <lv_img_decoder_built_in_open+0x96>
            }
            memset(dsc->user_data, 0, sizeof(lv_img_decoder_built_in_data_t));
 8009e70:	683b      	ldr	r3, [r7, #0]
 8009e72:	6a1b      	ldr	r3, [r3, #32]
 8009e74:	220c      	movs	r2, #12
 8009e76:	2100      	movs	r1, #0
 8009e78:	4618      	mov	r0, r3
 8009e7a:	f009 fc70 	bl	801375e <memset>
        }

        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 8009e7e:	683b      	ldr	r3, [r7, #0]
 8009e80:	6a1b      	ldr	r3, [r3, #32]
 8009e82:	62bb      	str	r3, [r7, #40]	; 0x28
        user_data->f                               = lv_mem_alloc(sizeof(f));
 8009e84:	2008      	movs	r0, #8
 8009e86:	f002 fec1 	bl	800cc0c <lv_mem_alloc>
 8009e8a:	4602      	mov	r2, r0
 8009e8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009e8e:	601a      	str	r2, [r3, #0]
        if(user_data->f == NULL) {
 8009e90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009e92:	681b      	ldr	r3, [r3, #0]
 8009e94:	2b00      	cmp	r3, #0
 8009e96:	d114      	bne.n	8009ec2 <lv_img_decoder_built_in_open+0xea>
            LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
            LV_ASSERT_MEM(user_data->f);
 8009e98:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009e9a:	681b      	ldr	r3, [r3, #0]
 8009e9c:	4618      	mov	r0, r3
 8009e9e:	f7f6 f9ab 	bl	80001f8 <lv_debug_check_null>
 8009ea2:	4603      	mov	r3, r0
 8009ea4:	f083 0301 	eor.w	r3, r3, #1
 8009ea8:	b2db      	uxtb	r3, r3
 8009eaa:	2b00      	cmp	r3, #0
 8009eac:	d009      	beq.n	8009ec2 <lv_img_decoder_built_in_open+0xea>
 8009eae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009eb0:	681b      	ldr	r3, [r3, #0]
 8009eb2:	f04f 0400 	mov.w	r4, #0
 8009eb6:	461a      	mov	r2, r3
 8009eb8:	4623      	mov	r3, r4
 8009eba:	487a      	ldr	r0, [pc, #488]	; (800a0a4 <lv_img_decoder_built_in_open+0x2cc>)
 8009ebc:	f7f6 f9c6 	bl	800024c <lv_debug_log_error>
 8009ec0:	e7fe      	b.n	8009ec0 <lv_img_decoder_built_in_open+0xe8>
        }

        memcpy(user_data->f, &f, sizeof(f));
 8009ec2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009ec4:	681b      	ldr	r3, [r3, #0]
 8009ec6:	f107 0110 	add.w	r1, r7, #16
 8009eca:	2208      	movs	r2, #8
 8009ecc:	4618      	mov	r0, r3
 8009ece:	f009 fc3b 	bl	8013748 <memcpy>
        LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
        return LV_RES_INV;
#endif
    }

    lv_img_cf_t cf = dsc->header.cf;
 8009ed2:	683b      	ldr	r3, [r7, #0]
 8009ed4:	7c1b      	ldrb	r3, [r3, #16]
 8009ed6:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8009eda:	b2db      	uxtb	r3, r3
 8009edc:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    /*Process true color formats*/
    if(cf == LV_IMG_CF_TRUE_COLOR || cf == LV_IMG_CF_TRUE_COLOR_ALPHA || cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
 8009ee0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8009ee4:	2b04      	cmp	r3, #4
 8009ee6:	d007      	beq.n	8009ef8 <lv_img_decoder_built_in_open+0x120>
 8009ee8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8009eec:	2b05      	cmp	r3, #5
 8009eee:	d003      	beq.n	8009ef8 <lv_img_decoder_built_in_open+0x120>
 8009ef0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8009ef4:	2b06      	cmp	r3, #6
 8009ef6:	d10f      	bne.n	8009f18 <lv_img_decoder_built_in_open+0x140>
        if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 8009ef8:	683b      	ldr	r3, [r7, #0]
 8009efa:	7b1b      	ldrb	r3, [r3, #12]
 8009efc:	2b00      	cmp	r3, #0
 8009efe:	d106      	bne.n	8009f0e <lv_img_decoder_built_in_open+0x136>
            /* In case of uncompressed formats the image stored in the ROM/RAM.
             * So simply give its pointer*/
            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
 8009f00:	683b      	ldr	r3, [r7, #0]
 8009f02:	685b      	ldr	r3, [r3, #4]
 8009f04:	689a      	ldr	r2, [r3, #8]
 8009f06:	683b      	ldr	r3, [r7, #0]
 8009f08:	615a      	str	r2, [r3, #20]
            return LV_RES_OK;
 8009f0a:	2301      	movs	r3, #1
 8009f0c:	e115      	b.n	800a13a <lv_img_decoder_built_in_open+0x362>
        } else {
            /*If it's a file it need to be read line by line later*/
            dsc->img_data = NULL;
 8009f0e:	683b      	ldr	r3, [r7, #0]
 8009f10:	2200      	movs	r2, #0
 8009f12:	615a      	str	r2, [r3, #20]
            return LV_RES_OK;
 8009f14:	2301      	movs	r3, #1
 8009f16:	e110      	b.n	800a13a <lv_img_decoder_built_in_open+0x362>
        }
    }
    /*Process indexed images. Build a palette*/
    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||
 8009f18:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8009f1c:	2b07      	cmp	r3, #7
 8009f1e:	d00c      	beq.n	8009f3a <lv_img_decoder_built_in_open+0x162>
 8009f20:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8009f24:	2b08      	cmp	r3, #8
 8009f26:	d008      	beq.n	8009f3a <lv_img_decoder_built_in_open+0x162>
 8009f28:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8009f2c:	2b09      	cmp	r3, #9
 8009f2e:	d004      	beq.n	8009f3a <lv_img_decoder_built_in_open+0x162>
 8009f30:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8009f34:	2b0a      	cmp	r3, #10
 8009f36:	f040 80e6 	bne.w	800a106 <lv_img_decoder_built_in_open+0x32e>
            cf == LV_IMG_CF_INDEXED_8BIT) {

#if LV_IMG_CF_INDEXED
        uint8_t px_size       = lv_img_color_format_get_px_size(cf);
 8009f3a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8009f3e:	4618      	mov	r0, r3
 8009f40:	f7fb f84e 	bl	8004fe0 <lv_img_color_format_get_px_size>
 8009f44:	4603      	mov	r3, r0
 8009f46:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
        uint32_t palette_size = 1 << px_size;
 8009f4a:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8009f4e:	2201      	movs	r2, #1
 8009f50:	fa02 f303 	lsl.w	r3, r2, r3
 8009f54:	623b      	str	r3, [r7, #32]

        /*Allocate the palette*/
        if(dsc->user_data == NULL) {
 8009f56:	683b      	ldr	r3, [r7, #0]
 8009f58:	6a1b      	ldr	r3, [r3, #32]
 8009f5a:	2b00      	cmp	r3, #0
 8009f5c:	d125      	bne.n	8009faa <lv_img_decoder_built_in_open+0x1d2>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
 8009f5e:	200c      	movs	r0, #12
 8009f60:	f002 fe54 	bl	800cc0c <lv_mem_alloc>
 8009f64:	4602      	mov	r2, r0
 8009f66:	683b      	ldr	r3, [r7, #0]
 8009f68:	621a      	str	r2, [r3, #32]
            if(dsc->user_data == NULL) {
 8009f6a:	683b      	ldr	r3, [r7, #0]
 8009f6c:	6a1b      	ldr	r3, [r3, #32]
 8009f6e:	2b00      	cmp	r3, #0
 8009f70:	d114      	bne.n	8009f9c <lv_img_decoder_built_in_open+0x1c4>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
                LV_ASSERT_MEM(dsc->user_data);
 8009f72:	683b      	ldr	r3, [r7, #0]
 8009f74:	6a1b      	ldr	r3, [r3, #32]
 8009f76:	4618      	mov	r0, r3
 8009f78:	f7f6 f93e 	bl	80001f8 <lv_debug_check_null>
 8009f7c:	4603      	mov	r3, r0
 8009f7e:	f083 0301 	eor.w	r3, r3, #1
 8009f82:	b2db      	uxtb	r3, r3
 8009f84:	2b00      	cmp	r3, #0
 8009f86:	d009      	beq.n	8009f9c <lv_img_decoder_built_in_open+0x1c4>
 8009f88:	683b      	ldr	r3, [r7, #0]
 8009f8a:	6a1b      	ldr	r3, [r3, #32]
 8009f8c:	f04f 0400 	mov.w	r4, #0
 8009f90:	461a      	mov	r2, r3
 8009f92:	4623      	mov	r3, r4
 8009f94:	4843      	ldr	r0, [pc, #268]	; (800a0a4 <lv_img_decoder_built_in_open+0x2cc>)
 8009f96:	f7f6 f959 	bl	800024c <lv_debug_log_error>
 8009f9a:	e7fe      	b.n	8009f9a <lv_img_decoder_built_in_open+0x1c2>
            }
            memset(dsc->user_data, 0, sizeof(lv_img_decoder_built_in_data_t));
 8009f9c:	683b      	ldr	r3, [r7, #0]
 8009f9e:	6a1b      	ldr	r3, [r3, #32]
 8009fa0:	220c      	movs	r2, #12
 8009fa2:	2100      	movs	r1, #0
 8009fa4:	4618      	mov	r0, r3
 8009fa6:	f009 fbda 	bl	801375e <memset>
        }

        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 8009faa:	683b      	ldr	r3, [r7, #0]
 8009fac:	6a1b      	ldr	r3, [r3, #32]
 8009fae:	61fb      	str	r3, [r7, #28]
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
 8009fb0:	6a3b      	ldr	r3, [r7, #32]
 8009fb2:	005b      	lsls	r3, r3, #1
 8009fb4:	4618      	mov	r0, r3
 8009fb6:	f002 fe29 	bl	800cc0c <lv_mem_alloc>
 8009fba:	4602      	mov	r2, r0
 8009fbc:	69fb      	ldr	r3, [r7, #28]
 8009fbe:	605a      	str	r2, [r3, #4]
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
 8009fc0:	6a38      	ldr	r0, [r7, #32]
 8009fc2:	f002 fe23 	bl	800cc0c <lv_mem_alloc>
 8009fc6:	4602      	mov	r2, r0
 8009fc8:	69fb      	ldr	r3, [r7, #28]
 8009fca:	609a      	str	r2, [r3, #8]
        if(user_data->palette == NULL || user_data->opa == NULL) {
 8009fcc:	69fb      	ldr	r3, [r7, #28]
 8009fce:	685b      	ldr	r3, [r3, #4]
 8009fd0:	2b00      	cmp	r3, #0
 8009fd2:	d003      	beq.n	8009fdc <lv_img_decoder_built_in_open+0x204>
 8009fd4:	69fb      	ldr	r3, [r7, #28]
 8009fd6:	689b      	ldr	r3, [r3, #8]
 8009fd8:	2b00      	cmp	r3, #0
 8009fda:	d129      	bne.n	800a030 <lv_img_decoder_built_in_open+0x258>
            LV_LOG_ERROR("img_decoder_built_in_open: out of memory");

            LV_ASSERT_MEM(user_data->palette);
 8009fdc:	69fb      	ldr	r3, [r7, #28]
 8009fde:	685b      	ldr	r3, [r3, #4]
 8009fe0:	4618      	mov	r0, r3
 8009fe2:	f7f6 f909 	bl	80001f8 <lv_debug_check_null>
 8009fe6:	4603      	mov	r3, r0
 8009fe8:	f083 0301 	eor.w	r3, r3, #1
 8009fec:	b2db      	uxtb	r3, r3
 8009fee:	2b00      	cmp	r3, #0
 8009ff0:	d009      	beq.n	800a006 <lv_img_decoder_built_in_open+0x22e>
 8009ff2:	69fb      	ldr	r3, [r7, #28]
 8009ff4:	685b      	ldr	r3, [r3, #4]
 8009ff6:	f04f 0400 	mov.w	r4, #0
 8009ffa:	461a      	mov	r2, r3
 8009ffc:	4623      	mov	r3, r4
 8009ffe:	4829      	ldr	r0, [pc, #164]	; (800a0a4 <lv_img_decoder_built_in_open+0x2cc>)
 800a000:	f7f6 f924 	bl	800024c <lv_debug_log_error>
 800a004:	e7fe      	b.n	800a004 <lv_img_decoder_built_in_open+0x22c>
            LV_ASSERT_MEM(user_data->opa);
 800a006:	69fb      	ldr	r3, [r7, #28]
 800a008:	689b      	ldr	r3, [r3, #8]
 800a00a:	4618      	mov	r0, r3
 800a00c:	f7f6 f8f4 	bl	80001f8 <lv_debug_check_null>
 800a010:	4603      	mov	r3, r0
 800a012:	f083 0301 	eor.w	r3, r3, #1
 800a016:	b2db      	uxtb	r3, r3
 800a018:	2b00      	cmp	r3, #0
 800a01a:	d009      	beq.n	800a030 <lv_img_decoder_built_in_open+0x258>
 800a01c:	69fb      	ldr	r3, [r7, #28]
 800a01e:	689b      	ldr	r3, [r3, #8]
 800a020:	f04f 0400 	mov.w	r4, #0
 800a024:	461a      	mov	r2, r3
 800a026:	4623      	mov	r3, r4
 800a028:	481e      	ldr	r0, [pc, #120]	; (800a0a4 <lv_img_decoder_built_in_open+0x2cc>)
 800a02a:	f7f6 f90f 	bl	800024c <lv_debug_log_error>
 800a02e:	e7fe      	b.n	800a02e <lv_img_decoder_built_in_open+0x256>
        }

        if(dsc->src_type == LV_IMG_SRC_FILE) {
 800a030:	683b      	ldr	r3, [r7, #0]
 800a032:	7b1b      	ldrb	r3, [r3, #12]
 800a034:	2b01      	cmp	r3, #1
 800a036:	d12b      	bne.n	800a090 <lv_img_decoder_built_in_open+0x2b8>
            /*Read the palette from file*/
#if LV_USE_FILESYSTEM
            lv_fs_seek(user_data->f, 4); /*Skip the header*/
 800a038:	69fb      	ldr	r3, [r7, #28]
 800a03a:	681b      	ldr	r3, [r3, #0]
 800a03c:	2104      	movs	r1, #4
 800a03e:	4618      	mov	r0, r3
 800a040:	f002 faa5 	bl	800c58e <lv_fs_seek>
            lv_color32_t cur_color;
            uint32_t i;
            for(i = 0; i < palette_size; i++) {
 800a044:	2300      	movs	r3, #0
 800a046:	637b      	str	r3, [r7, #52]	; 0x34
 800a048:	e01d      	b.n	800a086 <lv_img_decoder_built_in_open+0x2ae>
                lv_fs_read(user_data->f, &cur_color, sizeof(lv_color32_t), NULL);
 800a04a:	69fb      	ldr	r3, [r7, #28]
 800a04c:	6818      	ldr	r0, [r3, #0]
 800a04e:	f107 010c 	add.w	r1, r7, #12
 800a052:	2300      	movs	r3, #0
 800a054:	2204      	movs	r2, #4
 800a056:	f002 fa64 	bl	800c522 <lv_fs_read>
                user_data->palette[i] = lv_color_make(cur_color.ch.red, cur_color.ch.green, cur_color.ch.blue);
 800a05a:	7bb8      	ldrb	r0, [r7, #14]
 800a05c:	7b79      	ldrb	r1, [r7, #13]
 800a05e:	7b3d      	ldrb	r5, [r7, #12]
 800a060:	69fb      	ldr	r3, [r7, #28]
 800a062:	685a      	ldr	r2, [r3, #4]
 800a064:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a066:	005b      	lsls	r3, r3, #1
 800a068:	18d4      	adds	r4, r2, r3
 800a06a:	462a      	mov	r2, r5
 800a06c:	f7ff fd3a 	bl	8009ae4 <lv_color_make>
 800a070:	4603      	mov	r3, r0
 800a072:	8023      	strh	r3, [r4, #0]
                user_data->opa[i]     = cur_color.ch.alpha;
 800a074:	69fb      	ldr	r3, [r7, #28]
 800a076:	689a      	ldr	r2, [r3, #8]
 800a078:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a07a:	4413      	add	r3, r2
 800a07c:	7bfa      	ldrb	r2, [r7, #15]
 800a07e:	701a      	strb	r2, [r3, #0]
            for(i = 0; i < palette_size; i++) {
 800a080:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a082:	3301      	adds	r3, #1
 800a084:	637b      	str	r3, [r7, #52]	; 0x34
 800a086:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a088:	6a3b      	ldr	r3, [r7, #32]
 800a08a:	429a      	cmp	r2, r3
 800a08c:	d3dd      	bcc.n	800a04a <lv_img_decoder_built_in_open+0x272>
 800a08e:	e035      	b.n	800a0fc <lv_img_decoder_built_in_open+0x324>
            LV_LOG_WARN("Image built-in decoder can read the palette because LV_USE_FILESYSTEM = 0");
            return LV_RES_INV;
#endif
        } else {
            /*The palette begins in the beginning of the image data. Just point to it.*/
            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;
 800a090:	683b      	ldr	r3, [r7, #0]
 800a092:	685b      	ldr	r3, [r3, #4]
 800a094:	689b      	ldr	r3, [r3, #8]
 800a096:	61bb      	str	r3, [r7, #24]

            uint32_t i;
            for(i = 0; i < palette_size; i++) {
 800a098:	2300      	movs	r3, #0
 800a09a:	633b      	str	r3, [r7, #48]	; 0x30
 800a09c:	e02a      	b.n	800a0f4 <lv_img_decoder_built_in_open+0x31c>
 800a09e:	bf00      	nop
 800a0a0:	08013840 	.word	0x08013840
 800a0a4:	08013830 	.word	0x08013830
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
 800a0a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a0aa:	009b      	lsls	r3, r3, #2
 800a0ac:	69ba      	ldr	r2, [r7, #24]
 800a0ae:	4413      	add	r3, r2
 800a0b0:	7898      	ldrb	r0, [r3, #2]
 800a0b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a0b4:	009b      	lsls	r3, r3, #2
 800a0b6:	69ba      	ldr	r2, [r7, #24]
 800a0b8:	4413      	add	r3, r2
 800a0ba:	7859      	ldrb	r1, [r3, #1]
 800a0bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a0be:	009b      	lsls	r3, r3, #2
 800a0c0:	69ba      	ldr	r2, [r7, #24]
 800a0c2:	4413      	add	r3, r2
 800a0c4:	781d      	ldrb	r5, [r3, #0]
 800a0c6:	69fb      	ldr	r3, [r7, #28]
 800a0c8:	685a      	ldr	r2, [r3, #4]
 800a0ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a0cc:	005b      	lsls	r3, r3, #1
 800a0ce:	18d4      	adds	r4, r2, r3
 800a0d0:	462a      	mov	r2, r5
 800a0d2:	f7ff fd07 	bl	8009ae4 <lv_color_make>
 800a0d6:	4603      	mov	r3, r0
 800a0d8:	8023      	strh	r3, [r4, #0]
                user_data->opa[i]     = palette_p[i].ch.alpha;
 800a0da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a0dc:	009b      	lsls	r3, r3, #2
 800a0de:	69ba      	ldr	r2, [r7, #24]
 800a0e0:	441a      	add	r2, r3
 800a0e2:	69fb      	ldr	r3, [r7, #28]
 800a0e4:	6899      	ldr	r1, [r3, #8]
 800a0e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a0e8:	440b      	add	r3, r1
 800a0ea:	78d2      	ldrb	r2, [r2, #3]
 800a0ec:	701a      	strb	r2, [r3, #0]
            for(i = 0; i < palette_size; i++) {
 800a0ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a0f0:	3301      	adds	r3, #1
 800a0f2:	633b      	str	r3, [r7, #48]	; 0x30
 800a0f4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800a0f6:	6a3b      	ldr	r3, [r7, #32]
 800a0f8:	429a      	cmp	r2, r3
 800a0fa:	d3d5      	bcc.n	800a0a8 <lv_img_decoder_built_in_open+0x2d0>
            }
        }

        dsc->img_data = NULL;
 800a0fc:	683b      	ldr	r3, [r7, #0]
 800a0fe:	2200      	movs	r2, #0
 800a100:	615a      	str	r2, [r3, #20]
        return LV_RES_OK;
 800a102:	2301      	movs	r3, #1
 800a104:	e019      	b.n	800a13a <lv_img_decoder_built_in_open+0x362>
        LV_LOG_WARN("Indexed (palette) images are not enabled in lv_conf.h. See LV_IMG_CF_INDEXED");
        return LV_RES_INV;
#endif
    }
    /*Alpha indexed images. */
    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||
 800a106:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800a10a:	2b0b      	cmp	r3, #11
 800a10c:	d00b      	beq.n	800a126 <lv_img_decoder_built_in_open+0x34e>
 800a10e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800a112:	2b0c      	cmp	r3, #12
 800a114:	d007      	beq.n	800a126 <lv_img_decoder_built_in_open+0x34e>
 800a116:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800a11a:	2b0d      	cmp	r3, #13
 800a11c:	d003      	beq.n	800a126 <lv_img_decoder_built_in_open+0x34e>
 800a11e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800a122:	2b0e      	cmp	r3, #14
 800a124:	d104      	bne.n	800a130 <lv_img_decoder_built_in_open+0x358>
            cf == LV_IMG_CF_ALPHA_8BIT) {
#if LV_IMG_CF_ALPHA
        dsc->img_data = NULL;
 800a126:	683b      	ldr	r3, [r7, #0]
 800a128:	2200      	movs	r2, #0
 800a12a:	615a      	str	r2, [r3, #20]
        return LV_RES_OK; /*Nothing to process*/
 800a12c:	2301      	movs	r3, #1
 800a12e:	e004      	b.n	800a13a <lv_img_decoder_built_in_open+0x362>
#endif
    }
    /*Unknown format. Can't decode it.*/
    else {
        /*Free the potentially allocated memories*/
        lv_img_decoder_built_in_close(decoder, dsc);
 800a130:	6839      	ldr	r1, [r7, #0]
 800a132:	6878      	ldr	r0, [r7, #4]
 800a134:	f000 f898 	bl	800a268 <lv_img_decoder_built_in_close>

        LV_LOG_WARN("Image decoder open: unknown color format")
        return LV_RES_INV;
 800a138:	2300      	movs	r3, #0
    }
}
 800a13a:	4618      	mov	r0, r3
 800a13c:	3738      	adds	r7, #56	; 0x38
 800a13e:	46bd      	mov	sp, r7
 800a140:	bdb0      	pop	{r4, r5, r7, pc}
 800a142:	bf00      	nop

0800a144 <lv_img_decoder_built_in_read_line>:
 * @param buf a buffer to store the decoded pixels
 * @return LV_RES_OK: ok; LV_RES_INV: failed
 */
lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,
                                                  lv_coord_t y, lv_coord_t len, uint8_t * buf)
{
 800a144:	b580      	push	{r7, lr}
 800a146:	b088      	sub	sp, #32
 800a148:	af02      	add	r7, sp, #8
 800a14a:	60f8      	str	r0, [r7, #12]
 800a14c:	60b9      	str	r1, [r7, #8]
 800a14e:	4611      	mov	r1, r2
 800a150:	461a      	mov	r2, r3
 800a152:	460b      	mov	r3, r1
 800a154:	80fb      	strh	r3, [r7, #6]
 800a156:	4613      	mov	r3, r2
 800a158:	80bb      	strh	r3, [r7, #4]
    (void)decoder; /*Unused*/

    lv_res_t res = LV_RES_INV;
 800a15a:	2300      	movs	r3, #0
 800a15c:	75fb      	strb	r3, [r7, #23]

    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
 800a15e:	68bb      	ldr	r3, [r7, #8]
 800a160:	7c1b      	ldrb	r3, [r3, #16]
 800a162:	f003 031f 	and.w	r3, r3, #31
 800a166:	b2db      	uxtb	r3, r3
 800a168:	2b04      	cmp	r3, #4
 800a16a:	d00d      	beq.n	800a188 <lv_img_decoder_built_in_read_line+0x44>
 800a16c:	68bb      	ldr	r3, [r7, #8]
 800a16e:	7c1b      	ldrb	r3, [r3, #16]
 800a170:	f003 031f 	and.w	r3, r3, #31
 800a174:	b2db      	uxtb	r3, r3
 800a176:	2b05      	cmp	r3, #5
 800a178:	d006      	beq.n	800a188 <lv_img_decoder_built_in_read_line+0x44>
       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
 800a17a:	68bb      	ldr	r3, [r7, #8]
 800a17c:	7c1b      	ldrb	r3, [r3, #16]
 800a17e:	f003 031f 	and.w	r3, r3, #31
 800a182:	b2db      	uxtb	r3, r3
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
 800a184:	2b06      	cmp	r3, #6
 800a186:	d112      	bne.n	800a1ae <lv_img_decoder_built_in_read_line+0x6a>
        /* For TRUE_COLOR images read line required only for files.
         * For variables the image data was returned in `open`*/
        if(dsc->src_type == LV_IMG_SRC_FILE) {
 800a188:	68bb      	ldr	r3, [r7, #8]
 800a18a:	7b1b      	ldrb	r3, [r3, #12]
 800a18c:	2b01      	cmp	r3, #1
 800a18e:	d166      	bne.n	800a25e <lv_img_decoder_built_in_read_line+0x11a>
            res = lv_img_decoder_built_in_line_true_color(dsc, x, y, len, buf);
 800a190:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 800a194:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 800a198:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 800a19c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a19e:	9300      	str	r3, [sp, #0]
 800a1a0:	4603      	mov	r3, r0
 800a1a2:	68b8      	ldr	r0, [r7, #8]
 800a1a4:	f000 f895 	bl	800a2d2 <lv_img_decoder_built_in_line_true_color>
 800a1a8:	4603      	mov	r3, r0
 800a1aa:	75fb      	strb	r3, [r7, #23]
        if(dsc->src_type == LV_IMG_SRC_FILE) {
 800a1ac:	e057      	b.n	800a25e <lv_img_decoder_built_in_read_line+0x11a>
        }
    } else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
 800a1ae:	68bb      	ldr	r3, [r7, #8]
 800a1b0:	7c1b      	ldrb	r3, [r3, #16]
 800a1b2:	f003 031f 	and.w	r3, r3, #31
 800a1b6:	b2db      	uxtb	r3, r3
 800a1b8:	2b0b      	cmp	r3, #11
 800a1ba:	d014      	beq.n	800a1e6 <lv_img_decoder_built_in_read_line+0xa2>
 800a1bc:	68bb      	ldr	r3, [r7, #8]
 800a1be:	7c1b      	ldrb	r3, [r3, #16]
 800a1c0:	f003 031f 	and.w	r3, r3, #31
 800a1c4:	b2db      	uxtb	r3, r3
 800a1c6:	2b0c      	cmp	r3, #12
 800a1c8:	d00d      	beq.n	800a1e6 <lv_img_decoder_built_in_read_line+0xa2>
              dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
 800a1ca:	68bb      	ldr	r3, [r7, #8]
 800a1cc:	7c1b      	ldrb	r3, [r3, #16]
 800a1ce:	f003 031f 	and.w	r3, r3, #31
 800a1d2:	b2db      	uxtb	r3, r3
    } else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
 800a1d4:	2b0d      	cmp	r3, #13
 800a1d6:	d006      	beq.n	800a1e6 <lv_img_decoder_built_in_read_line+0xa2>
              dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
 800a1d8:	68bb      	ldr	r3, [r7, #8]
 800a1da:	7c1b      	ldrb	r3, [r3, #16]
 800a1dc:	f003 031f 	and.w	r3, r3, #31
 800a1e0:	b2db      	uxtb	r3, r3
 800a1e2:	2b0e      	cmp	r3, #14
 800a1e4:	d10e      	bne.n	800a204 <lv_img_decoder_built_in_read_line+0xc0>

        res = lv_img_decoder_built_in_line_alpha(dsc, x, y, len, buf);
 800a1e6:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 800a1ea:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 800a1ee:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 800a1f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a1f4:	9300      	str	r3, [sp, #0]
 800a1f6:	4603      	mov	r3, r0
 800a1f8:	68b8      	ldr	r0, [r7, #8]
 800a1fa:	f000 f8c9 	bl	800a390 <lv_img_decoder_built_in_line_alpha>
 800a1fe:	4603      	mov	r3, r0
 800a200:	75fb      	strb	r3, [r7, #23]
 800a202:	e02c      	b.n	800a25e <lv_img_decoder_built_in_read_line+0x11a>
    } else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
 800a204:	68bb      	ldr	r3, [r7, #8]
 800a206:	7c1b      	ldrb	r3, [r3, #16]
 800a208:	f003 031f 	and.w	r3, r3, #31
 800a20c:	b2db      	uxtb	r3, r3
 800a20e:	2b07      	cmp	r3, #7
 800a210:	d014      	beq.n	800a23c <lv_img_decoder_built_in_read_line+0xf8>
 800a212:	68bb      	ldr	r3, [r7, #8]
 800a214:	7c1b      	ldrb	r3, [r3, #16]
 800a216:	f003 031f 	and.w	r3, r3, #31
 800a21a:	b2db      	uxtb	r3, r3
 800a21c:	2b08      	cmp	r3, #8
 800a21e:	d00d      	beq.n	800a23c <lv_img_decoder_built_in_read_line+0xf8>
              dsc->header.cf == LV_IMG_CF_INDEXED_4BIT || dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {
 800a220:	68bb      	ldr	r3, [r7, #8]
 800a222:	7c1b      	ldrb	r3, [r3, #16]
 800a224:	f003 031f 	and.w	r3, r3, #31
 800a228:	b2db      	uxtb	r3, r3
    } else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
 800a22a:	2b09      	cmp	r3, #9
 800a22c:	d006      	beq.n	800a23c <lv_img_decoder_built_in_read_line+0xf8>
              dsc->header.cf == LV_IMG_CF_INDEXED_4BIT || dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {
 800a22e:	68bb      	ldr	r3, [r7, #8]
 800a230:	7c1b      	ldrb	r3, [r3, #16]
 800a232:	f003 031f 	and.w	r3, r3, #31
 800a236:	b2db      	uxtb	r3, r3
 800a238:	2b0a      	cmp	r3, #10
 800a23a:	d10e      	bne.n	800a25a <lv_img_decoder_built_in_read_line+0x116>
        res = lv_img_decoder_built_in_line_indexed(dsc, x, y, len, buf);
 800a23c:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 800a240:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 800a244:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 800a248:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a24a:	9300      	str	r3, [sp, #0]
 800a24c:	4603      	mov	r3, r0
 800a24e:	68b8      	ldr	r0, [r7, #8]
 800a250:	f000 fab4 	bl	800a7bc <lv_img_decoder_built_in_line_indexed>
 800a254:	4603      	mov	r3, r0
 800a256:	75fb      	strb	r3, [r7, #23]
 800a258:	e001      	b.n	800a25e <lv_img_decoder_built_in_read_line+0x11a>
    } else {
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
        return LV_RES_INV;
 800a25a:	2300      	movs	r3, #0
 800a25c:	e000      	b.n	800a260 <lv_img_decoder_built_in_read_line+0x11c>
    }

    return res;
 800a25e:	7dfb      	ldrb	r3, [r7, #23]
}
 800a260:	4618      	mov	r0, r3
 800a262:	3718      	adds	r7, #24
 800a264:	46bd      	mov	sp, r7
 800a266:	bd80      	pop	{r7, pc}

0800a268 <lv_img_decoder_built_in_close>:
 * Close the pending decoding. Free resources etc.
 * @param decoder pointer to the decoder the function associated with
 * @param dsc pointer to decoder descriptor
 */
void lv_img_decoder_built_in_close(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
 800a268:	b580      	push	{r7, lr}
 800a26a:	b084      	sub	sp, #16
 800a26c:	af00      	add	r7, sp, #0
 800a26e:	6078      	str	r0, [r7, #4]
 800a270:	6039      	str	r1, [r7, #0]
    (void)decoder; /*Unused*/

    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 800a272:	683b      	ldr	r3, [r7, #0]
 800a274:	6a1b      	ldr	r3, [r3, #32]
 800a276:	60fb      	str	r3, [r7, #12]
    if(user_data) {
 800a278:	68fb      	ldr	r3, [r7, #12]
 800a27a:	2b00      	cmp	r3, #0
 800a27c:	d025      	beq.n	800a2ca <lv_img_decoder_built_in_close+0x62>
#if LV_USE_FILESYSTEM
        if(user_data->f) {
 800a27e:	68fb      	ldr	r3, [r7, #12]
 800a280:	681b      	ldr	r3, [r3, #0]
 800a282:	2b00      	cmp	r3, #0
 800a284:	d009      	beq.n	800a29a <lv_img_decoder_built_in_close+0x32>
            lv_fs_close(user_data->f);
 800a286:	68fb      	ldr	r3, [r7, #12]
 800a288:	681b      	ldr	r3, [r3, #0]
 800a28a:	4618      	mov	r0, r3
 800a28c:	f002 f91a 	bl	800c4c4 <lv_fs_close>
            lv_mem_free(user_data->f);
 800a290:	68fb      	ldr	r3, [r7, #12]
 800a292:	681b      	ldr	r3, [r3, #0]
 800a294:	4618      	mov	r0, r3
 800a296:	f002 fceb 	bl	800cc70 <lv_mem_free>
        }
#endif
        if(user_data->palette) lv_mem_free(user_data->palette);
 800a29a:	68fb      	ldr	r3, [r7, #12]
 800a29c:	685b      	ldr	r3, [r3, #4]
 800a29e:	2b00      	cmp	r3, #0
 800a2a0:	d004      	beq.n	800a2ac <lv_img_decoder_built_in_close+0x44>
 800a2a2:	68fb      	ldr	r3, [r7, #12]
 800a2a4:	685b      	ldr	r3, [r3, #4]
 800a2a6:	4618      	mov	r0, r3
 800a2a8:	f002 fce2 	bl	800cc70 <lv_mem_free>
        if(user_data->opa) lv_mem_free(user_data->opa);
 800a2ac:	68fb      	ldr	r3, [r7, #12]
 800a2ae:	689b      	ldr	r3, [r3, #8]
 800a2b0:	2b00      	cmp	r3, #0
 800a2b2:	d004      	beq.n	800a2be <lv_img_decoder_built_in_close+0x56>
 800a2b4:	68fb      	ldr	r3, [r7, #12]
 800a2b6:	689b      	ldr	r3, [r3, #8]
 800a2b8:	4618      	mov	r0, r3
 800a2ba:	f002 fcd9 	bl	800cc70 <lv_mem_free>

        lv_mem_free(user_data);
 800a2be:	68f8      	ldr	r0, [r7, #12]
 800a2c0:	f002 fcd6 	bl	800cc70 <lv_mem_free>

        dsc->user_data = NULL;
 800a2c4:	683b      	ldr	r3, [r7, #0]
 800a2c6:	2200      	movs	r2, #0
 800a2c8:	621a      	str	r2, [r3, #32]
    }
}
 800a2ca:	bf00      	nop
 800a2cc:	3710      	adds	r7, #16
 800a2ce:	46bd      	mov	sp, r7
 800a2d0:	bd80      	pop	{r7, pc}

0800a2d2 <lv_img_decoder_built_in_line_true_color>:
 *   STATIC FUNCTIONS
 **********************/

static lv_res_t lv_img_decoder_built_in_line_true_color(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                        lv_coord_t len, uint8_t * buf)
{
 800a2d2:	b580      	push	{r7, lr}
 800a2d4:	b08a      	sub	sp, #40	; 0x28
 800a2d6:	af00      	add	r7, sp, #0
 800a2d8:	60f8      	str	r0, [r7, #12]
 800a2da:	4608      	mov	r0, r1
 800a2dc:	4611      	mov	r1, r2
 800a2de:	461a      	mov	r2, r3
 800a2e0:	4603      	mov	r3, r0
 800a2e2:	817b      	strh	r3, [r7, #10]
 800a2e4:	460b      	mov	r3, r1
 800a2e6:	813b      	strh	r3, [r7, #8]
 800a2e8:	4613      	mov	r3, r2
 800a2ea:	80fb      	strh	r3, [r7, #6]
#if LV_USE_FILESYSTEM
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 800a2ec:	68fb      	ldr	r3, [r7, #12]
 800a2ee:	6a1b      	ldr	r3, [r3, #32]
 800a2f0:	627b      	str	r3, [r7, #36]	; 0x24
    lv_fs_res_t res;
    uint8_t px_size = lv_img_color_format_get_px_size(dsc->header.cf);
 800a2f2:	68fb      	ldr	r3, [r7, #12]
 800a2f4:	7c1b      	ldrb	r3, [r3, #16]
 800a2f6:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800a2fa:	b2db      	uxtb	r3, r3
 800a2fc:	4618      	mov	r0, r3
 800a2fe:	f7fa fe6f 	bl	8004fe0 <lv_img_color_format_get_px_size>
 800a302:	4603      	mov	r3, r0
 800a304:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

    uint32_t pos = ((y * dsc->header.w + x) * px_size) >> 3;
 800a308:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 800a30c:	68fa      	ldr	r2, [r7, #12]
 800a30e:	6912      	ldr	r2, [r2, #16]
 800a310:	f3c2 228a 	ubfx	r2, r2, #10, #11
 800a314:	b292      	uxth	r2, r2
 800a316:	fb02 f203 	mul.w	r2, r2, r3
 800a31a:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 800a31e:	4413      	add	r3, r2
 800a320:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800a324:	fb02 f303 	mul.w	r3, r2, r3
 800a328:	10db      	asrs	r3, r3, #3
 800a32a:	61fb      	str	r3, [r7, #28]
    pos += 4; /*Skip the header*/
 800a32c:	69fb      	ldr	r3, [r7, #28]
 800a32e:	3304      	adds	r3, #4
 800a330:	61fb      	str	r3, [r7, #28]
    res = lv_fs_seek(user_data->f, pos);
 800a332:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a334:	681b      	ldr	r3, [r3, #0]
 800a336:	69f9      	ldr	r1, [r7, #28]
 800a338:	4618      	mov	r0, r3
 800a33a:	f002 f928 	bl	800c58e <lv_fs_seek>
 800a33e:	4603      	mov	r3, r0
 800a340:	76fb      	strb	r3, [r7, #27]
    if(res != LV_FS_RES_OK) {
 800a342:	7efb      	ldrb	r3, [r7, #27]
 800a344:	2b00      	cmp	r3, #0
 800a346:	d001      	beq.n	800a34c <lv_img_decoder_built_in_line_true_color+0x7a>
        LV_LOG_WARN("Built-in image decoder seek failed");
        return LV_RES_INV;
 800a348:	2300      	movs	r3, #0
 800a34a:	e01c      	b.n	800a386 <lv_img_decoder_built_in_line_true_color+0xb4>
    }
    uint32_t btr = len * (px_size >> 3);
 800a34c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800a350:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800a354:	08d2      	lsrs	r2, r2, #3
 800a356:	b2d2      	uxtb	r2, r2
 800a358:	fb02 f303 	mul.w	r3, r2, r3
 800a35c:	617b      	str	r3, [r7, #20]
    uint32_t br  = 0;
 800a35e:	2300      	movs	r3, #0
 800a360:	613b      	str	r3, [r7, #16]
    lv_fs_read(user_data->f, buf, btr, &br);
 800a362:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a364:	6818      	ldr	r0, [r3, #0]
 800a366:	f107 0310 	add.w	r3, r7, #16
 800a36a:	697a      	ldr	r2, [r7, #20]
 800a36c:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800a36e:	f002 f8d8 	bl	800c522 <lv_fs_read>
    if(res != LV_FS_RES_OK || btr != br) {
 800a372:	7efb      	ldrb	r3, [r7, #27]
 800a374:	2b00      	cmp	r3, #0
 800a376:	d103      	bne.n	800a380 <lv_img_decoder_built_in_line_true_color+0xae>
 800a378:	693b      	ldr	r3, [r7, #16]
 800a37a:	697a      	ldr	r2, [r7, #20]
 800a37c:	429a      	cmp	r2, r3
 800a37e:	d001      	beq.n	800a384 <lv_img_decoder_built_in_line_true_color+0xb2>
        LV_LOG_WARN("Built-in image decoder read failed");
        return LV_RES_INV;
 800a380:	2300      	movs	r3, #0
 800a382:	e000      	b.n	800a386 <lv_img_decoder_built_in_line_true_color+0xb4>
    }

    return LV_RES_OK;
 800a384:	2301      	movs	r3, #1
#else
    LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
    return LV_RES_INV;
#endif
}
 800a386:	4618      	mov	r0, r3
 800a388:	3728      	adds	r7, #40	; 0x28
 800a38a:	46bd      	mov	sp, r7
 800a38c:	bd80      	pop	{r7, pc}
	...

0800a390 <lv_img_decoder_built_in_line_alpha>:

static lv_res_t lv_img_decoder_built_in_line_alpha(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                   lv_coord_t len, uint8_t * buf)
{
 800a390:	b590      	push	{r4, r7, lr}
 800a392:	b0d1      	sub	sp, #324	; 0x144
 800a394:	af00      	add	r7, sp, #0
 800a396:	f107 040c 	add.w	r4, r7, #12
 800a39a:	6020      	str	r0, [r4, #0]
 800a39c:	460c      	mov	r4, r1
 800a39e:	4610      	mov	r0, r2
 800a3a0:	4619      	mov	r1, r3
 800a3a2:	f107 030a 	add.w	r3, r7, #10
 800a3a6:	4622      	mov	r2, r4
 800a3a8:	801a      	strh	r2, [r3, #0]
 800a3aa:	f107 0308 	add.w	r3, r7, #8
 800a3ae:	4602      	mov	r2, r0
 800a3b0:	801a      	strh	r2, [r3, #0]
 800a3b2:	1dbb      	adds	r3, r7, #6
 800a3b4:	460a      	mov	r2, r1
 800a3b6:	801a      	strh	r2, [r3, #0]

#if LV_IMG_CF_ALPHA
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
 800a3b8:	2300      	movs	r3, #0
 800a3ba:	f887 3118 	strb.w	r3, [r7, #280]	; 0x118
 800a3be:	23ff      	movs	r3, #255	; 0xff
 800a3c0:	f887 3119 	strb.w	r3, [r7, #281]	; 0x119
    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
 800a3c4:	4bcc      	ldr	r3, [pc, #816]	; (800a6f8 <lv_img_decoder_built_in_line_alpha+0x368>)
 800a3c6:	681b      	ldr	r3, [r3, #0]
 800a3c8:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
 800a3cc:	4bcb      	ldr	r3, [pc, #812]	; (800a6fc <lv_img_decoder_built_in_line_alpha+0x36c>)
 800a3ce:	f507 7482 	add.w	r4, r7, #260	; 0x104
 800a3d2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800a3d4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                                           68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};

    /*Simply fill the buffer with the color. Later only the alpha value will be modified.*/
    lv_color_t bg_color = dsc->style->image.color;
 800a3d8:	f107 030c 	add.w	r3, r7, #12
 800a3dc:	681b      	ldr	r3, [r3, #0]
 800a3de:	689b      	ldr	r3, [r3, #8]
 800a3e0:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 800a3e2:	f8a7 3100 	strh.w	r3, [r7, #256]	; 0x100
    lv_coord_t i;
    for(i = 0; i < len; i++) {
 800a3e6:	2300      	movs	r3, #0
 800a3e8:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
 800a3ec:	e022      	b.n	800a434 <lv_img_decoder_built_in_line_alpha+0xa4>
#if LV_COLOR_DEPTH == 8 || LV_COLOR_DEPTH == 1
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full;
#elif LV_COLOR_DEPTH == 16
        /*Because of Alpha byte 16 bit color can start on odd address which can cause crash*/
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full & 0xFF;
 800a3ee:	f8b7 1100 	ldrh.w	r1, [r7, #256]	; 0x100
 800a3f2:	f9b7 213e 	ldrsh.w	r2, [r7, #318]	; 0x13e
 800a3f6:	4613      	mov	r3, r2
 800a3f8:	005b      	lsls	r3, r3, #1
 800a3fa:	4413      	add	r3, r2
 800a3fc:	461a      	mov	r2, r3
 800a3fe:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 800a402:	4413      	add	r3, r2
 800a404:	b2ca      	uxtb	r2, r1
 800a406:	701a      	strb	r2, [r3, #0]
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + 1] = (bg_color.full >> 8) & 0xFF;
 800a408:	f8b7 3100 	ldrh.w	r3, [r7, #256]	; 0x100
 800a40c:	0a1b      	lsrs	r3, r3, #8
 800a40e:	b299      	uxth	r1, r3
 800a410:	f9b7 213e 	ldrsh.w	r2, [r7, #318]	; 0x13e
 800a414:	4613      	mov	r3, r2
 800a416:	005b      	lsls	r3, r3, #1
 800a418:	4413      	add	r3, r2
 800a41a:	3301      	adds	r3, #1
 800a41c:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 800a420:	4413      	add	r3, r2
 800a422:	b2ca      	uxtb	r2, r1
 800a424:	701a      	strb	r2, [r3, #0]
    for(i = 0; i < len; i++) {
 800a426:	f9b7 313e 	ldrsh.w	r3, [r7, #318]	; 0x13e
 800a42a:	b29b      	uxth	r3, r3
 800a42c:	3301      	adds	r3, #1
 800a42e:	b29b      	uxth	r3, r3
 800a430:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
 800a434:	1dbb      	adds	r3, r7, #6
 800a436:	f9b7 213e 	ldrsh.w	r2, [r7, #318]	; 0x13e
 800a43a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800a43e:	429a      	cmp	r2, r3
 800a440:	dbd5      	blt.n	800a3ee <lv_img_decoder_built_in_line_alpha+0x5e>
#else
#error "Invalid LV_COLOR_DEPTH. Check it in lv_conf.h"
#endif
    }

    const lv_opa_t * opa_table = NULL;
 800a442:	2300      	movs	r3, #0
 800a444:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    uint8_t px_size            = lv_img_color_format_get_px_size(dsc->header.cf);
 800a448:	f107 030c 	add.w	r3, r7, #12
 800a44c:	681b      	ldr	r3, [r3, #0]
 800a44e:	7c1b      	ldrb	r3, [r3, #16]
 800a450:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800a454:	b2db      	uxtb	r3, r3
 800a456:	4618      	mov	r0, r3
 800a458:	f7fa fdc2 	bl	8004fe0 <lv_img_color_format_get_px_size>
 800a45c:	4603      	mov	r3, r0
 800a45e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
 800a462:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 800a466:	2201      	movs	r2, #1
 800a468:	fa02 f303 	lsl.w	r3, r2, r3
 800a46c:	b29b      	uxth	r3, r3
 800a46e:	3b01      	subs	r3, #1
 800a470:	f8a7 3124 	strh.w	r3, [r7, #292]	; 0x124

    lv_coord_t w = 0;
 800a474:	2300      	movs	r3, #0
 800a476:	f8a7 3136 	strh.w	r3, [r7, #310]	; 0x136
    uint32_t ofs = 0;
 800a47a:	2300      	movs	r3, #0
 800a47c:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    int8_t pos   = 0;
 800a480:	2300      	movs	r3, #0
 800a482:	f887 312f 	strb.w	r3, [r7, #303]	; 0x12f
    switch(dsc->header.cf) {
 800a486:	f107 030c 	add.w	r3, r7, #12
 800a48a:	681b      	ldr	r3, [r3, #0]
 800a48c:	7c1b      	ldrb	r3, [r3, #16]
 800a48e:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800a492:	b2db      	uxtb	r3, r3
 800a494:	3b0b      	subs	r3, #11
 800a496:	2b03      	cmp	r3, #3
 800a498:	f200 80f0 	bhi.w	800a67c <lv_img_decoder_built_in_line_alpha+0x2ec>
 800a49c:	a201      	add	r2, pc, #4	; (adr r2, 800a4a4 <lv_img_decoder_built_in_line_alpha+0x114>)
 800a49e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a4a2:	bf00      	nop
 800a4a4:	0800a4b5 	.word	0x0800a4b5
 800a4a8:	0800a535 	.word	0x0800a535
 800a4ac:	0800a5b9 	.word	0x0800a5b9
 800a4b0:	0800a63d 	.word	0x0800a63d
        case LV_IMG_CF_ALPHA_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
 800a4b4:	f107 030c 	add.w	r3, r7, #12
 800a4b8:	681b      	ldr	r3, [r3, #0]
 800a4ba:	691b      	ldr	r3, [r3, #16]
 800a4bc:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a4c0:	b29b      	uxth	r3, r3
 800a4c2:	10db      	asrs	r3, r3, #3
 800a4c4:	f8a7 3136 	strh.w	r3, [r7, #310]	; 0x136
            if(dsc->header.w & 0x7) w++;
 800a4c8:	f107 030c 	add.w	r3, r7, #12
 800a4cc:	681b      	ldr	r3, [r3, #0]
 800a4ce:	691b      	ldr	r3, [r3, #16]
 800a4d0:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a4d4:	b29b      	uxth	r3, r3
 800a4d6:	f003 0307 	and.w	r3, r3, #7
 800a4da:	2b00      	cmp	r3, #0
 800a4dc:	d006      	beq.n	800a4ec <lv_img_decoder_built_in_line_alpha+0x15c>
 800a4de:	f9b7 3136 	ldrsh.w	r3, [r7, #310]	; 0x136
 800a4e2:	b29b      	uxth	r3, r3
 800a4e4:	3301      	adds	r3, #1
 800a4e6:	b29b      	uxth	r3, r3
 800a4e8:	f8a7 3136 	strh.w	r3, [r7, #310]	; 0x136
            ofs += w * y + (x >> 3); /*First pixel*/
 800a4ec:	f9b7 3136 	ldrsh.w	r3, [r7, #310]	; 0x136
 800a4f0:	f107 0208 	add.w	r2, r7, #8
 800a4f4:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a4f8:	fb02 f303 	mul.w	r3, r2, r3
 800a4fc:	f107 020a 	add.w	r2, r7, #10
 800a500:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a504:	10d2      	asrs	r2, r2, #3
 800a506:	b212      	sxth	r2, r2
 800a508:	4413      	add	r3, r2
 800a50a:	461a      	mov	r2, r3
 800a50c:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 800a510:	4413      	add	r3, r2
 800a512:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
            pos       = 7 - (x & 0x7);
 800a516:	f107 030a 	add.w	r3, r7, #10
 800a51a:	881b      	ldrh	r3, [r3, #0]
 800a51c:	b25b      	sxtb	r3, r3
 800a51e:	43db      	mvns	r3, r3
 800a520:	b25b      	sxtb	r3, r3
 800a522:	f003 0307 	and.w	r3, r3, #7
 800a526:	f887 312f 	strb.w	r3, [r7, #303]	; 0x12f
            opa_table = alpha1_opa_table;
 800a52a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 800a52e:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
            break;
 800a532:	e0a3      	b.n	800a67c <lv_img_decoder_built_in_line_alpha+0x2ec>
        case LV_IMG_CF_ALPHA_2BIT:
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
 800a534:	f107 030c 	add.w	r3, r7, #12
 800a538:	681b      	ldr	r3, [r3, #0]
 800a53a:	691b      	ldr	r3, [r3, #16]
 800a53c:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a540:	b29b      	uxth	r3, r3
 800a542:	109b      	asrs	r3, r3, #2
 800a544:	f8a7 3136 	strh.w	r3, [r7, #310]	; 0x136
            if(dsc->header.w & 0x3) w++;
 800a548:	f107 030c 	add.w	r3, r7, #12
 800a54c:	681b      	ldr	r3, [r3, #0]
 800a54e:	691b      	ldr	r3, [r3, #16]
 800a550:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a554:	b29b      	uxth	r3, r3
 800a556:	f003 0303 	and.w	r3, r3, #3
 800a55a:	2b00      	cmp	r3, #0
 800a55c:	d006      	beq.n	800a56c <lv_img_decoder_built_in_line_alpha+0x1dc>
 800a55e:	f9b7 3136 	ldrsh.w	r3, [r7, #310]	; 0x136
 800a562:	b29b      	uxth	r3, r3
 800a564:	3301      	adds	r3, #1
 800a566:	b29b      	uxth	r3, r3
 800a568:	f8a7 3136 	strh.w	r3, [r7, #310]	; 0x136
            ofs += w * y + (x >> 2); /*First pixel*/
 800a56c:	f9b7 3136 	ldrsh.w	r3, [r7, #310]	; 0x136
 800a570:	f107 0208 	add.w	r2, r7, #8
 800a574:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a578:	fb02 f303 	mul.w	r3, r2, r3
 800a57c:	f107 020a 	add.w	r2, r7, #10
 800a580:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a584:	1092      	asrs	r2, r2, #2
 800a586:	b212      	sxth	r2, r2
 800a588:	4413      	add	r3, r2
 800a58a:	461a      	mov	r2, r3
 800a58c:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 800a590:	4413      	add	r3, r2
 800a592:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
            pos       = 6 - ((x & 0x3) * 2);
 800a596:	f107 030a 	add.w	r3, r7, #10
 800a59a:	881b      	ldrh	r3, [r3, #0]
 800a59c:	43db      	mvns	r3, r3
 800a59e:	b2db      	uxtb	r3, r3
 800a5a0:	f003 0303 	and.w	r3, r3, #3
 800a5a4:	b2db      	uxtb	r3, r3
 800a5a6:	005b      	lsls	r3, r3, #1
 800a5a8:	b2db      	uxtb	r3, r3
 800a5aa:	f887 312f 	strb.w	r3, [r7, #303]	; 0x12f
            opa_table = alpha2_opa_table;
 800a5ae:	f507 738a 	add.w	r3, r7, #276	; 0x114
 800a5b2:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
            break;
 800a5b6:	e061      	b.n	800a67c <lv_img_decoder_built_in_line_alpha+0x2ec>
        case LV_IMG_CF_ALPHA_4BIT:
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
 800a5b8:	f107 030c 	add.w	r3, r7, #12
 800a5bc:	681b      	ldr	r3, [r3, #0]
 800a5be:	691b      	ldr	r3, [r3, #16]
 800a5c0:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a5c4:	b29b      	uxth	r3, r3
 800a5c6:	105b      	asrs	r3, r3, #1
 800a5c8:	f8a7 3136 	strh.w	r3, [r7, #310]	; 0x136
            if(dsc->header.w & 0x1) w++;
 800a5cc:	f107 030c 	add.w	r3, r7, #12
 800a5d0:	681b      	ldr	r3, [r3, #0]
 800a5d2:	691b      	ldr	r3, [r3, #16]
 800a5d4:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a5d8:	b29b      	uxth	r3, r3
 800a5da:	f003 0301 	and.w	r3, r3, #1
 800a5de:	2b00      	cmp	r3, #0
 800a5e0:	d006      	beq.n	800a5f0 <lv_img_decoder_built_in_line_alpha+0x260>
 800a5e2:	f9b7 3136 	ldrsh.w	r3, [r7, #310]	; 0x136
 800a5e6:	b29b      	uxth	r3, r3
 800a5e8:	3301      	adds	r3, #1
 800a5ea:	b29b      	uxth	r3, r3
 800a5ec:	f8a7 3136 	strh.w	r3, [r7, #310]	; 0x136
            ofs += w * y + (x >> 1); /*First pixel*/
 800a5f0:	f9b7 3136 	ldrsh.w	r3, [r7, #310]	; 0x136
 800a5f4:	f107 0208 	add.w	r2, r7, #8
 800a5f8:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a5fc:	fb02 f303 	mul.w	r3, r2, r3
 800a600:	f107 020a 	add.w	r2, r7, #10
 800a604:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a608:	1052      	asrs	r2, r2, #1
 800a60a:	b212      	sxth	r2, r2
 800a60c:	4413      	add	r3, r2
 800a60e:	461a      	mov	r2, r3
 800a610:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 800a614:	4413      	add	r3, r2
 800a616:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
            pos       = 4 - ((x & 0x1) * 4);
 800a61a:	f107 030a 	add.w	r3, r7, #10
 800a61e:	881b      	ldrh	r3, [r3, #0]
 800a620:	f003 0301 	and.w	r3, r3, #1
 800a624:	2b00      	cmp	r3, #0
 800a626:	d101      	bne.n	800a62c <lv_img_decoder_built_in_line_alpha+0x29c>
 800a628:	2304      	movs	r3, #4
 800a62a:	e000      	b.n	800a62e <lv_img_decoder_built_in_line_alpha+0x29e>
 800a62c:	2300      	movs	r3, #0
 800a62e:	f887 312f 	strb.w	r3, [r7, #303]	; 0x12f
            opa_table = alpha4_opa_table;
 800a632:	f507 7382 	add.w	r3, r7, #260	; 0x104
 800a636:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
            break;
 800a63a:	e01f      	b.n	800a67c <lv_img_decoder_built_in_line_alpha+0x2ec>
        case LV_IMG_CF_ALPHA_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
 800a63c:	f107 030c 	add.w	r3, r7, #12
 800a640:	681b      	ldr	r3, [r3, #0]
 800a642:	691b      	ldr	r3, [r3, #16]
 800a644:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a648:	b29b      	uxth	r3, r3
 800a64a:	f8a7 3136 	strh.w	r3, [r7, #310]	; 0x136
            ofs += w * y + x;  /*First pixel*/
 800a64e:	f9b7 3136 	ldrsh.w	r3, [r7, #310]	; 0x136
 800a652:	f107 0208 	add.w	r2, r7, #8
 800a656:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a65a:	fb02 f203 	mul.w	r2, r2, r3
 800a65e:	f107 030a 	add.w	r3, r7, #10
 800a662:	f9b3 3000 	ldrsh.w	r3, [r3]
 800a666:	4413      	add	r3, r2
 800a668:	461a      	mov	r2, r3
 800a66a:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 800a66e:	4413      	add	r3, r2
 800a670:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
            pos = 0;
 800a674:	2300      	movs	r3, #0
 800a676:	f887 312f 	strb.w	r3, [r7, #303]	; 0x12f
            break;
 800a67a:	bf00      	nop
    }

#if LV_USE_FILESYSTEM
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 800a67c:	f107 030c 	add.w	r3, r7, #12
 800a680:	681b      	ldr	r3, [r3, #0]
 800a682:	6a1b      	ldr	r3, [r3, #32]
 800a684:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    uint8_t fs_buf[LV_HOR_RES_MAX];
#endif

    const uint8_t * data_tmp = NULL;
 800a688:	2300      	movs	r3, #0
 800a68a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 800a68e:	f107 030c 	add.w	r3, r7, #12
 800a692:	681b      	ldr	r3, [r3, #0]
 800a694:	7b1b      	ldrb	r3, [r3, #12]
 800a696:	2b00      	cmp	r3, #0
 800a698:	d10e      	bne.n	800a6b8 <lv_img_decoder_built_in_line_alpha+0x328>
        const lv_img_dsc_t * img_dsc = dsc->src;
 800a69a:	f107 030c 	add.w	r3, r7, #12
 800a69e:	681b      	ldr	r3, [r3, #0]
 800a6a0:	685b      	ldr	r3, [r3, #4]
 800a6a2:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

        data_tmp = img_dsc->data + ofs;
 800a6a6:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 800a6aa:	689a      	ldr	r2, [r3, #8]
 800a6ac:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 800a6b0:	4413      	add	r3, r2
 800a6b2:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
 800a6b6:	e017      	b.n	800a6e8 <lv_img_decoder_built_in_line_alpha+0x358>
    } else {
#if LV_USE_FILESYSTEM
        lv_fs_seek(user_data->f, ofs + 4); /*+4 to skip the header*/
 800a6b8:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800a6bc:	681a      	ldr	r2, [r3, #0]
 800a6be:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 800a6c2:	3304      	adds	r3, #4
 800a6c4:	4619      	mov	r1, r3
 800a6c6:	4610      	mov	r0, r2
 800a6c8:	f001 ff61 	bl	800c58e <lv_fs_seek>
        lv_fs_read(user_data->f, fs_buf, w, NULL);
 800a6cc:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800a6d0:	6818      	ldr	r0, [r3, #0]
 800a6d2:	f9b7 2136 	ldrsh.w	r2, [r7, #310]	; 0x136
 800a6d6:	f107 0110 	add.w	r1, r7, #16
 800a6da:	2300      	movs	r3, #0
 800a6dc:	f001 ff21 	bl	800c522 <lv_fs_read>
        data_tmp = fs_buf;
 800a6e0:	f107 0310 	add.w	r3, r7, #16
 800a6e4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
        data_tmp = NULL; /*To avoid warnings*/
        return LV_RES_INV;
#endif
    }

    uint8_t byte_act = 0;
 800a6e8:	2300      	movs	r3, #0
 800a6ea:	f887 311b 	strb.w	r3, [r7, #283]	; 0x11b
    uint8_t val_act;
    for(i = 0; i < len; i++) {
 800a6ee:	2300      	movs	r3, #0
 800a6f0:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
 800a6f4:	e054      	b.n	800a7a0 <lv_img_decoder_built_in_line_alpha+0x410>
 800a6f6:	bf00      	nop
 800a6f8:	08013844 	.word	0x08013844
 800a6fc:	08013848 	.word	0x08013848
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
 800a700:	f897 311b 	ldrb.w	r3, [r7, #283]	; 0x11b
 800a704:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 800a708:	4413      	add	r3, r2
 800a70a:	781b      	ldrb	r3, [r3, #0]
 800a70c:	4619      	mov	r1, r3
 800a70e:	f8b7 2124 	ldrh.w	r2, [r7, #292]	; 0x124
 800a712:	f997 312f 	ldrsb.w	r3, [r7, #303]	; 0x12f
 800a716:	fa02 f303 	lsl.w	r3, r2, r3
 800a71a:	ea01 0203 	and.w	r2, r1, r3
 800a71e:	f997 312f 	ldrsb.w	r3, [r7, #303]	; 0x12f
 800a722:	fa42 f303 	asr.w	r3, r2, r3
 800a726:	f887 311a 	strb.w	r3, [r7, #282]	; 0x11a

        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
 800a72a:	f107 030c 	add.w	r3, r7, #12
 800a72e:	681b      	ldr	r3, [r3, #0]
 800a730:	7c1b      	ldrb	r3, [r3, #16]
 800a732:	f003 031f 	and.w	r3, r3, #31
 800a736:	b2db      	uxtb	r3, r3
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
 800a738:	2b0e      	cmp	r3, #14
 800a73a:	d006      	beq.n	800a74a <lv_img_decoder_built_in_line_alpha+0x3ba>
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
 800a73c:	f897 311a 	ldrb.w	r3, [r7, #282]	; 0x11a
 800a740:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 800a744:	4413      	add	r3, r2
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
 800a746:	781a      	ldrb	r2, [r3, #0]
 800a748:	e001      	b.n	800a74e <lv_img_decoder_built_in_line_alpha+0x3be>
 800a74a:	f897 211a 	ldrb.w	r2, [r7, #282]	; 0x11a
 800a74e:	f9b7 113e 	ldrsh.w	r1, [r7, #318]	; 0x13e
 800a752:	460b      	mov	r3, r1
 800a754:	005b      	lsls	r3, r3, #1
 800a756:	440b      	add	r3, r1
 800a758:	3302      	adds	r3, #2
 800a75a:	f8d7 1150 	ldr.w	r1, [r7, #336]	; 0x150
 800a75e:	440b      	add	r3, r1
 800a760:	701a      	strb	r2, [r3, #0]

        pos -= px_size;
 800a762:	f897 212f 	ldrb.w	r2, [r7, #303]	; 0x12f
 800a766:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 800a76a:	1ad3      	subs	r3, r2, r3
 800a76c:	b2db      	uxtb	r3, r3
 800a76e:	f887 312f 	strb.w	r3, [r7, #303]	; 0x12f
        if(pos < 0) {
 800a772:	f997 312f 	ldrsb.w	r3, [r7, #303]	; 0x12f
 800a776:	2b00      	cmp	r3, #0
 800a778:	da0b      	bge.n	800a792 <lv_img_decoder_built_in_line_alpha+0x402>
            pos = 8 - px_size;
 800a77a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 800a77e:	f1c3 0308 	rsb	r3, r3, #8
 800a782:	b2db      	uxtb	r3, r3
 800a784:	f887 312f 	strb.w	r3, [r7, #303]	; 0x12f
            data_tmp++;
 800a788:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 800a78c:	3301      	adds	r3, #1
 800a78e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    for(i = 0; i < len; i++) {
 800a792:	f9b7 313e 	ldrsh.w	r3, [r7, #318]	; 0x13e
 800a796:	b29b      	uxth	r3, r3
 800a798:	3301      	adds	r3, #1
 800a79a:	b29b      	uxth	r3, r3
 800a79c:	f8a7 313e 	strh.w	r3, [r7, #318]	; 0x13e
 800a7a0:	1dbb      	adds	r3, r7, #6
 800a7a2:	f9b7 213e 	ldrsh.w	r2, [r7, #318]	; 0x13e
 800a7a6:	f9b3 3000 	ldrsh.w	r3, [r3]
 800a7aa:	429a      	cmp	r2, r3
 800a7ac:	dba8      	blt.n	800a700 <lv_img_decoder_built_in_line_alpha+0x370>
        }
    }

    return LV_RES_OK;
 800a7ae:	2301      	movs	r3, #1

#else
    LV_LOG_WARN("Image built-in alpha line reader failed because LV_IMG_CF_ALPHA is 0 in lv_conf.h");
    return LV_RES_INV;
#endif
}
 800a7b0:	4618      	mov	r0, r3
 800a7b2:	f507 77a2 	add.w	r7, r7, #324	; 0x144
 800a7b6:	46bd      	mov	sp, r7
 800a7b8:	bd90      	pop	{r4, r7, pc}
 800a7ba:	bf00      	nop

0800a7bc <lv_img_decoder_built_in_line_indexed>:

static lv_res_t lv_img_decoder_built_in_line_indexed(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                     lv_coord_t len, uint8_t * buf)
{
 800a7bc:	b590      	push	{r4, r7, lr}
 800a7be:	b0cb      	sub	sp, #300	; 0x12c
 800a7c0:	af00      	add	r7, sp, #0
 800a7c2:	f107 040c 	add.w	r4, r7, #12
 800a7c6:	6020      	str	r0, [r4, #0]
 800a7c8:	460c      	mov	r4, r1
 800a7ca:	4610      	mov	r0, r2
 800a7cc:	4619      	mov	r1, r3
 800a7ce:	f107 030a 	add.w	r3, r7, #10
 800a7d2:	4622      	mov	r2, r4
 800a7d4:	801a      	strh	r2, [r3, #0]
 800a7d6:	f107 0308 	add.w	r3, r7, #8
 800a7da:	4602      	mov	r2, r0
 800a7dc:	801a      	strh	r2, [r3, #0]
 800a7de:	1dbb      	adds	r3, r7, #6
 800a7e0:	460a      	mov	r2, r1
 800a7e2:	801a      	strh	r2, [r3, #0]

#if LV_IMG_CF_INDEXED
    uint8_t px_size = lv_img_color_format_get_px_size(dsc->header.cf);
 800a7e4:	f107 030c 	add.w	r3, r7, #12
 800a7e8:	681b      	ldr	r3, [r3, #0]
 800a7ea:	7c1b      	ldrb	r3, [r3, #16]
 800a7ec:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800a7f0:	b2db      	uxtb	r3, r3
 800a7f2:	4618      	mov	r0, r3
 800a7f4:	f7fa fbf4 	bl	8004fe0 <lv_img_color_format_get_px_size>
 800a7f8:	4603      	mov	r3, r0
 800a7fa:	f887 3119 	strb.w	r3, [r7, #281]	; 0x119
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
 800a7fe:	f897 3119 	ldrb.w	r3, [r7, #281]	; 0x119
 800a802:	2201      	movs	r2, #1
 800a804:	fa02 f303 	lsl.w	r3, r2, r3
 800a808:	b29b      	uxth	r3, r3
 800a80a:	3b01      	subs	r3, #1
 800a80c:	f8a7 3116 	strh.w	r3, [r7, #278]	; 0x116

    lv_coord_t w = 0;
 800a810:	2300      	movs	r3, #0
 800a812:	f8a7 3126 	strh.w	r3, [r7, #294]	; 0x126
    int8_t pos   = 0;
 800a816:	2300      	movs	r3, #0
 800a818:	f887 3125 	strb.w	r3, [r7, #293]	; 0x125
    uint32_t ofs = 0;
 800a81c:	2300      	movs	r3, #0
 800a81e:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    switch(dsc->header.cf) {
 800a822:	f107 030c 	add.w	r3, r7, #12
 800a826:	681b      	ldr	r3, [r3, #0]
 800a828:	7c1b      	ldrb	r3, [r3, #16]
 800a82a:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800a82e:	b2db      	uxtb	r3, r3
 800a830:	3b07      	subs	r3, #7
 800a832:	2b03      	cmp	r3, #3
 800a834:	f200 80f9 	bhi.w	800aa2a <lv_img_decoder_built_in_line_indexed+0x26e>
 800a838:	a201      	add	r2, pc, #4	; (adr r2, 800a840 <lv_img_decoder_built_in_line_indexed+0x84>)
 800a83a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a83e:	bf00      	nop
 800a840:	0800a851 	.word	0x0800a851
 800a844:	0800a8d3 	.word	0x0800a8d3
 800a848:	0800a959 	.word	0x0800a959
 800a84c:	0800a9df 	.word	0x0800a9df
        case LV_IMG_CF_INDEXED_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
 800a850:	f107 030c 	add.w	r3, r7, #12
 800a854:	681b      	ldr	r3, [r3, #0]
 800a856:	691b      	ldr	r3, [r3, #16]
 800a858:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a85c:	b29b      	uxth	r3, r3
 800a85e:	10db      	asrs	r3, r3, #3
 800a860:	f8a7 3126 	strh.w	r3, [r7, #294]	; 0x126
            if(dsc->header.w & 0x7) w++;
 800a864:	f107 030c 	add.w	r3, r7, #12
 800a868:	681b      	ldr	r3, [r3, #0]
 800a86a:	691b      	ldr	r3, [r3, #16]
 800a86c:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a870:	b29b      	uxth	r3, r3
 800a872:	f003 0307 	and.w	r3, r3, #7
 800a876:	2b00      	cmp	r3, #0
 800a878:	d006      	beq.n	800a888 <lv_img_decoder_built_in_line_indexed+0xcc>
 800a87a:	f9b7 3126 	ldrsh.w	r3, [r7, #294]	; 0x126
 800a87e:	b29b      	uxth	r3, r3
 800a880:	3301      	adds	r3, #1
 800a882:	b29b      	uxth	r3, r3
 800a884:	f8a7 3126 	strh.w	r3, [r7, #294]	; 0x126
            ofs += w * y + (x >> 3); /*First pixel*/
 800a888:	f9b7 3126 	ldrsh.w	r3, [r7, #294]	; 0x126
 800a88c:	f107 0208 	add.w	r2, r7, #8
 800a890:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a894:	fb02 f303 	mul.w	r3, r2, r3
 800a898:	f107 020a 	add.w	r2, r7, #10
 800a89c:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a8a0:	10d2      	asrs	r2, r2, #3
 800a8a2:	b212      	sxth	r2, r2
 800a8a4:	4413      	add	r3, r2
 800a8a6:	461a      	mov	r2, r3
 800a8a8:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800a8ac:	4413      	add	r3, r2
 800a8ae:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
            ofs += 8;                /*Skip the palette*/
 800a8b2:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800a8b6:	3308      	adds	r3, #8
 800a8b8:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
            pos = 7 - (x & 0x7);
 800a8bc:	f107 030a 	add.w	r3, r7, #10
 800a8c0:	881b      	ldrh	r3, [r3, #0]
 800a8c2:	b25b      	sxtb	r3, r3
 800a8c4:	43db      	mvns	r3, r3
 800a8c6:	b25b      	sxtb	r3, r3
 800a8c8:	f003 0307 	and.w	r3, r3, #7
 800a8cc:	f887 3125 	strb.w	r3, [r7, #293]	; 0x125
            break;
 800a8d0:	e0ab      	b.n	800aa2a <lv_img_decoder_built_in_line_indexed+0x26e>
        case LV_IMG_CF_INDEXED_2BIT:
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
 800a8d2:	f107 030c 	add.w	r3, r7, #12
 800a8d6:	681b      	ldr	r3, [r3, #0]
 800a8d8:	691b      	ldr	r3, [r3, #16]
 800a8da:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a8de:	b29b      	uxth	r3, r3
 800a8e0:	109b      	asrs	r3, r3, #2
 800a8e2:	f8a7 3126 	strh.w	r3, [r7, #294]	; 0x126
            if(dsc->header.w & 0x3) w++;
 800a8e6:	f107 030c 	add.w	r3, r7, #12
 800a8ea:	681b      	ldr	r3, [r3, #0]
 800a8ec:	691b      	ldr	r3, [r3, #16]
 800a8ee:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a8f2:	b29b      	uxth	r3, r3
 800a8f4:	f003 0303 	and.w	r3, r3, #3
 800a8f8:	2b00      	cmp	r3, #0
 800a8fa:	d006      	beq.n	800a90a <lv_img_decoder_built_in_line_indexed+0x14e>
 800a8fc:	f9b7 3126 	ldrsh.w	r3, [r7, #294]	; 0x126
 800a900:	b29b      	uxth	r3, r3
 800a902:	3301      	adds	r3, #1
 800a904:	b29b      	uxth	r3, r3
 800a906:	f8a7 3126 	strh.w	r3, [r7, #294]	; 0x126
            ofs += w * y + (x >> 2); /*First pixel*/
 800a90a:	f9b7 3126 	ldrsh.w	r3, [r7, #294]	; 0x126
 800a90e:	f107 0208 	add.w	r2, r7, #8
 800a912:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a916:	fb02 f303 	mul.w	r3, r2, r3
 800a91a:	f107 020a 	add.w	r2, r7, #10
 800a91e:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a922:	1092      	asrs	r2, r2, #2
 800a924:	b212      	sxth	r2, r2
 800a926:	4413      	add	r3, r2
 800a928:	461a      	mov	r2, r3
 800a92a:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800a92e:	4413      	add	r3, r2
 800a930:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
            ofs += 16;               /*Skip the palette*/
 800a934:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800a938:	3310      	adds	r3, #16
 800a93a:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
            pos = 6 - ((x & 0x3) * 2);
 800a93e:	f107 030a 	add.w	r3, r7, #10
 800a942:	881b      	ldrh	r3, [r3, #0]
 800a944:	43db      	mvns	r3, r3
 800a946:	b2db      	uxtb	r3, r3
 800a948:	f003 0303 	and.w	r3, r3, #3
 800a94c:	b2db      	uxtb	r3, r3
 800a94e:	005b      	lsls	r3, r3, #1
 800a950:	b2db      	uxtb	r3, r3
 800a952:	f887 3125 	strb.w	r3, [r7, #293]	; 0x125
            break;
 800a956:	e068      	b.n	800aa2a <lv_img_decoder_built_in_line_indexed+0x26e>
        case LV_IMG_CF_INDEXED_4BIT:
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
 800a958:	f107 030c 	add.w	r3, r7, #12
 800a95c:	681b      	ldr	r3, [r3, #0]
 800a95e:	691b      	ldr	r3, [r3, #16]
 800a960:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a964:	b29b      	uxth	r3, r3
 800a966:	105b      	asrs	r3, r3, #1
 800a968:	f8a7 3126 	strh.w	r3, [r7, #294]	; 0x126
            if(dsc->header.w & 0x1) w++;
 800a96c:	f107 030c 	add.w	r3, r7, #12
 800a970:	681b      	ldr	r3, [r3, #0]
 800a972:	691b      	ldr	r3, [r3, #16]
 800a974:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a978:	b29b      	uxth	r3, r3
 800a97a:	f003 0301 	and.w	r3, r3, #1
 800a97e:	2b00      	cmp	r3, #0
 800a980:	d006      	beq.n	800a990 <lv_img_decoder_built_in_line_indexed+0x1d4>
 800a982:	f9b7 3126 	ldrsh.w	r3, [r7, #294]	; 0x126
 800a986:	b29b      	uxth	r3, r3
 800a988:	3301      	adds	r3, #1
 800a98a:	b29b      	uxth	r3, r3
 800a98c:	f8a7 3126 	strh.w	r3, [r7, #294]	; 0x126
            ofs += w * y + (x >> 1); /*First pixel*/
 800a990:	f9b7 3126 	ldrsh.w	r3, [r7, #294]	; 0x126
 800a994:	f107 0208 	add.w	r2, r7, #8
 800a998:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a99c:	fb02 f303 	mul.w	r3, r2, r3
 800a9a0:	f107 020a 	add.w	r2, r7, #10
 800a9a4:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a9a8:	1052      	asrs	r2, r2, #1
 800a9aa:	b212      	sxth	r2, r2
 800a9ac:	4413      	add	r3, r2
 800a9ae:	461a      	mov	r2, r3
 800a9b0:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800a9b4:	4413      	add	r3, r2
 800a9b6:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
            ofs += 64;               /*Skip the palette*/
 800a9ba:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800a9be:	3340      	adds	r3, #64	; 0x40
 800a9c0:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
            pos = 4 - ((x & 0x1) * 4);
 800a9c4:	f107 030a 	add.w	r3, r7, #10
 800a9c8:	881b      	ldrh	r3, [r3, #0]
 800a9ca:	f003 0301 	and.w	r3, r3, #1
 800a9ce:	2b00      	cmp	r3, #0
 800a9d0:	d101      	bne.n	800a9d6 <lv_img_decoder_built_in_line_indexed+0x21a>
 800a9d2:	2304      	movs	r3, #4
 800a9d4:	e000      	b.n	800a9d8 <lv_img_decoder_built_in_line_indexed+0x21c>
 800a9d6:	2300      	movs	r3, #0
 800a9d8:	f887 3125 	strb.w	r3, [r7, #293]	; 0x125
            break;
 800a9dc:	e025      	b.n	800aa2a <lv_img_decoder_built_in_line_indexed+0x26e>
        case LV_IMG_CF_INDEXED_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
 800a9de:	f107 030c 	add.w	r3, r7, #12
 800a9e2:	681b      	ldr	r3, [r3, #0]
 800a9e4:	691b      	ldr	r3, [r3, #16]
 800a9e6:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800a9ea:	b29b      	uxth	r3, r3
 800a9ec:	f8a7 3126 	strh.w	r3, [r7, #294]	; 0x126
            ofs += w * y + x;  /*First pixel*/
 800a9f0:	f9b7 3126 	ldrsh.w	r3, [r7, #294]	; 0x126
 800a9f4:	f107 0208 	add.w	r2, r7, #8
 800a9f8:	f9b2 2000 	ldrsh.w	r2, [r2]
 800a9fc:	fb02 f203 	mul.w	r2, r2, r3
 800aa00:	f107 030a 	add.w	r3, r7, #10
 800aa04:	f9b3 3000 	ldrsh.w	r3, [r3]
 800aa08:	4413      	add	r3, r2
 800aa0a:	461a      	mov	r2, r3
 800aa0c:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800aa10:	4413      	add	r3, r2
 800aa12:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
            ofs += 1024;       /*Skip the palette*/
 800aa16:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800aa1a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800aa1e:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
            pos = 0;
 800aa22:	2300      	movs	r3, #0
 800aa24:	f887 3125 	strb.w	r3, [r7, #293]	; 0x125
            break;
 800aa28:	bf00      	nop
    }

    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 800aa2a:	f107 030c 	add.w	r3, r7, #12
 800aa2e:	681b      	ldr	r3, [r3, #0]
 800aa30:	6a1b      	ldr	r3, [r3, #32]
 800aa32:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110

#if LV_USE_FILESYSTEM
    uint8_t fs_buf[LV_HOR_RES_MAX];
#endif
    const uint8_t * data_tmp = NULL;
 800aa36:	2300      	movs	r3, #0
 800aa38:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 800aa3c:	f107 030c 	add.w	r3, r7, #12
 800aa40:	681b      	ldr	r3, [r3, #0]
 800aa42:	7b1b      	ldrb	r3, [r3, #12]
 800aa44:	2b00      	cmp	r3, #0
 800aa46:	d10e      	bne.n	800aa66 <lv_img_decoder_built_in_line_indexed+0x2aa>
        const lv_img_dsc_t * img_dsc = dsc->src;
 800aa48:	f107 030c 	add.w	r3, r7, #12
 800aa4c:	681b      	ldr	r3, [r3, #0]
 800aa4e:	685b      	ldr	r3, [r3, #4]
 800aa50:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
        data_tmp                     = img_dsc->data + ofs;
 800aa54:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800aa58:	689a      	ldr	r2, [r3, #8]
 800aa5a:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800aa5e:	4413      	add	r3, r2
 800aa60:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 800aa64:	e017      	b.n	800aa96 <lv_img_decoder_built_in_line_indexed+0x2da>
    } else {
#if LV_USE_FILESYSTEM
        lv_fs_seek(user_data->f, ofs + 4); /*+4 to skip the header*/
 800aa66:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800aa6a:	681a      	ldr	r2, [r3, #0]
 800aa6c:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800aa70:	3304      	adds	r3, #4
 800aa72:	4619      	mov	r1, r3
 800aa74:	4610      	mov	r0, r2
 800aa76:	f001 fd8a 	bl	800c58e <lv_fs_seek>
        lv_fs_read(user_data->f, fs_buf, w, NULL);
 800aa7a:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800aa7e:	6818      	ldr	r0, [r3, #0]
 800aa80:	f9b7 2126 	ldrsh.w	r2, [r7, #294]	; 0x126
 800aa84:	f107 0118 	add.w	r1, r7, #24
 800aa88:	2300      	movs	r3, #0
 800aa8a:	f001 fd4a 	bl	800c522 <lv_fs_read>
        data_tmp = fs_buf;
 800aa8e:	f107 0318 	add.w	r3, r7, #24
 800aa92:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
#endif
    }

    uint8_t val_act;
    lv_coord_t i;
    for(i = 0; i < len; i++) {
 800aa96:	2300      	movs	r3, #0
 800aa98:	f8a7 311a 	strh.w	r3, [r7, #282]	; 0x11a
 800aa9c:	e06a      	b.n	800ab74 <lv_img_decoder_built_in_line_indexed+0x3b8>
        val_act = (*data_tmp & (mask << pos)) >> pos;
 800aa9e:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 800aaa2:	781b      	ldrb	r3, [r3, #0]
 800aaa4:	4619      	mov	r1, r3
 800aaa6:	f8b7 2116 	ldrh.w	r2, [r7, #278]	; 0x116
 800aaaa:	f997 3125 	ldrsb.w	r3, [r7, #293]	; 0x125
 800aaae:	fa02 f303 	lsl.w	r3, r2, r3
 800aab2:	ea01 0203 	and.w	r2, r1, r3
 800aab6:	f997 3125 	ldrsb.w	r3, [r7, #293]	; 0x125
 800aaba:	fa42 f303 	asr.w	r3, r2, r3
 800aabe:	f887 310b 	strb.w	r3, [r7, #267]	; 0x10b

        lv_color_t color = user_data->palette[val_act];
 800aac2:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800aac6:	685a      	ldr	r2, [r3, #4]
 800aac8:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 800aacc:	005b      	lsls	r3, r3, #1
 800aace:	441a      	add	r2, r3
 800aad0:	f107 0314 	add.w	r3, r7, #20
 800aad4:	8812      	ldrh	r2, [r2, #0]
 800aad6:	801a      	strh	r2, [r3, #0]
#if LV_COLOR_DEPTH == 8 || LV_COLOR_DEPTH == 1
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = color.full;
#elif LV_COLOR_DEPTH == 16
        /*Because of Alpha byte 16 bit color can start on odd address which can cause crash*/
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = color.full & 0xFF;
 800aad8:	f107 0314 	add.w	r3, r7, #20
 800aadc:	8819      	ldrh	r1, [r3, #0]
 800aade:	f9b7 211a 	ldrsh.w	r2, [r7, #282]	; 0x11a
 800aae2:	4613      	mov	r3, r2
 800aae4:	005b      	lsls	r3, r3, #1
 800aae6:	4413      	add	r3, r2
 800aae8:	461a      	mov	r2, r3
 800aaea:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 800aaee:	4413      	add	r3, r2
 800aaf0:	b2ca      	uxtb	r2, r1
 800aaf2:	701a      	strb	r2, [r3, #0]
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + 1] = (color.full >> 8) & 0xFF;
 800aaf4:	f107 0314 	add.w	r3, r7, #20
 800aaf8:	881b      	ldrh	r3, [r3, #0]
 800aafa:	0a1b      	lsrs	r3, r3, #8
 800aafc:	b299      	uxth	r1, r3
 800aafe:	f9b7 211a 	ldrsh.w	r2, [r7, #282]	; 0x11a
 800ab02:	4613      	mov	r3, r2
 800ab04:	005b      	lsls	r3, r3, #1
 800ab06:	4413      	add	r3, r2
 800ab08:	3301      	adds	r3, #1
 800ab0a:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 800ab0e:	4413      	add	r3, r2
 800ab10:	b2ca      	uxtb	r2, r1
 800ab12:	701a      	strb	r2, [r3, #0]
#elif LV_COLOR_DEPTH == 32
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = color.full;
#else
#error "Invalid LV_COLOR_DEPTH. Check it in lv_conf.h"
#endif
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
 800ab14:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 800ab18:	689a      	ldr	r2, [r3, #8]
 800ab1a:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 800ab1e:	18d1      	adds	r1, r2, r3
 800ab20:	f9b7 211a 	ldrsh.w	r2, [r7, #282]	; 0x11a
 800ab24:	4613      	mov	r3, r2
 800ab26:	005b      	lsls	r3, r3, #1
 800ab28:	4413      	add	r3, r2
 800ab2a:	3302      	adds	r3, #2
 800ab2c:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 800ab30:	4413      	add	r3, r2
 800ab32:	780a      	ldrb	r2, [r1, #0]
 800ab34:	701a      	strb	r2, [r3, #0]

        pos -= px_size;
 800ab36:	f897 2125 	ldrb.w	r2, [r7, #293]	; 0x125
 800ab3a:	f897 3119 	ldrb.w	r3, [r7, #281]	; 0x119
 800ab3e:	1ad3      	subs	r3, r2, r3
 800ab40:	b2db      	uxtb	r3, r3
 800ab42:	f887 3125 	strb.w	r3, [r7, #293]	; 0x125
        if(pos < 0) {
 800ab46:	f997 3125 	ldrsb.w	r3, [r7, #293]	; 0x125
 800ab4a:	2b00      	cmp	r3, #0
 800ab4c:	da0b      	bge.n	800ab66 <lv_img_decoder_built_in_line_indexed+0x3aa>
            pos = 8 - px_size;
 800ab4e:	f897 3119 	ldrb.w	r3, [r7, #281]	; 0x119
 800ab52:	f1c3 0308 	rsb	r3, r3, #8
 800ab56:	b2db      	uxtb	r3, r3
 800ab58:	f887 3125 	strb.w	r3, [r7, #293]	; 0x125
            data_tmp++;
 800ab5c:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 800ab60:	3301      	adds	r3, #1
 800ab62:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    for(i = 0; i < len; i++) {
 800ab66:	f9b7 311a 	ldrsh.w	r3, [r7, #282]	; 0x11a
 800ab6a:	b29b      	uxth	r3, r3
 800ab6c:	3301      	adds	r3, #1
 800ab6e:	b29b      	uxth	r3, r3
 800ab70:	f8a7 311a 	strh.w	r3, [r7, #282]	; 0x11a
 800ab74:	1dbb      	adds	r3, r7, #6
 800ab76:	f9b7 211a 	ldrsh.w	r2, [r7, #282]	; 0x11a
 800ab7a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800ab7e:	429a      	cmp	r2, r3
 800ab80:	db8d      	blt.n	800aa9e <lv_img_decoder_built_in_line_indexed+0x2e2>
        }
    }

    return LV_RES_OK;
 800ab82:	2301      	movs	r3, #1
#else
    LV_LOG_WARN("Image built-in indexed line reader failed because LV_IMG_CF_INDEXED is 0 in lv_conf.h");
    return LV_RES_INV;
#endif
}
 800ab84:	4618      	mov	r0, r3
 800ab86:	f507 7796 	add.w	r7, r7, #300	; 0x12c
 800ab8a:	46bd      	mov	sp, r7
 800ab8c:	bd90      	pop	{r4, r7, pc}
 800ab8e:	bf00      	nop

0800ab90 <lv_font_get_glyph_bitmap>:
 * @param font_p pointer to a font
 * @param letter an UNICODE character code
 * @return  pointer to the bitmap of the letter
 */
const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)
{
 800ab90:	b580      	push	{r7, lr}
 800ab92:	b082      	sub	sp, #8
 800ab94:	af00      	add	r7, sp, #0
 800ab96:	6078      	str	r0, [r7, #4]
 800ab98:	6039      	str	r1, [r7, #0]
    return font_p->get_glyph_bitmap(font_p, letter);
 800ab9a:	687b      	ldr	r3, [r7, #4]
 800ab9c:	685b      	ldr	r3, [r3, #4]
 800ab9e:	6839      	ldr	r1, [r7, #0]
 800aba0:	6878      	ldr	r0, [r7, #4]
 800aba2:	4798      	blx	r3
 800aba4:	4603      	mov	r3, r0
}
 800aba6:	4618      	mov	r0, r3
 800aba8:	3708      	adds	r7, #8
 800abaa:	46bd      	mov	sp, r7
 800abac:	bd80      	pop	{r7, pc}

0800abae <lv_font_get_glyph_dsc>:
 * @param letter an UNICODE letter code
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter, uint32_t letter_next)
{
 800abae:	b590      	push	{r4, r7, lr}
 800abb0:	b085      	sub	sp, #20
 800abb2:	af00      	add	r7, sp, #0
 800abb4:	60f8      	str	r0, [r7, #12]
 800abb6:	60b9      	str	r1, [r7, #8]
 800abb8:	607a      	str	r2, [r7, #4]
 800abba:	603b      	str	r3, [r7, #0]
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
 800abbc:	68fb      	ldr	r3, [r7, #12]
 800abbe:	681c      	ldr	r4, [r3, #0]
 800abc0:	683b      	ldr	r3, [r7, #0]
 800abc2:	687a      	ldr	r2, [r7, #4]
 800abc4:	68b9      	ldr	r1, [r7, #8]
 800abc6:	68f8      	ldr	r0, [r7, #12]
 800abc8:	47a0      	blx	r4
 800abca:	4603      	mov	r3, r0
}
 800abcc:	4618      	mov	r0, r3
 800abce:	3714      	adds	r7, #20
 800abd0:	46bd      	mov	sp, r7
 800abd2:	bd90      	pop	{r4, r7, pc}

0800abd4 <lv_font_get_glyph_width>:
 * @param letter an UNICODE letter
 * @param letter_next the next letter after `letter`. Used for kerning
 * @return the width of the glyph
 */
uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
{
 800abd4:	b580      	push	{r7, lr}
 800abd6:	b088      	sub	sp, #32
 800abd8:	af00      	add	r7, sp, #0
 800abda:	60f8      	str	r0, [r7, #12]
 800abdc:	60b9      	str	r1, [r7, #8]
 800abde:	607a      	str	r2, [r7, #4]
    lv_font_glyph_dsc_t g;
    bool ret;
    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);
 800abe0:	f107 0114 	add.w	r1, r7, #20
 800abe4:	687b      	ldr	r3, [r7, #4]
 800abe6:	68ba      	ldr	r2, [r7, #8]
 800abe8:	68f8      	ldr	r0, [r7, #12]
 800abea:	f7ff ffe0 	bl	800abae <lv_font_get_glyph_dsc>
 800abee:	4603      	mov	r3, r0
 800abf0:	77fb      	strb	r3, [r7, #31]
    if(ret) return g.adv_w;
 800abf2:	7ffb      	ldrb	r3, [r7, #31]
 800abf4:	2b00      	cmp	r3, #0
 800abf6:	d001      	beq.n	800abfc <lv_font_get_glyph_width+0x28>
 800abf8:	8abb      	ldrh	r3, [r7, #20]
 800abfa:	e000      	b.n	800abfe <lv_font_get_glyph_width+0x2a>
    else return 0;
 800abfc:	2300      	movs	r3, #0
}
 800abfe:	4618      	mov	r0, r3
 800ac00:	3720      	adds	r7, #32
 800ac02:	46bd      	mov	sp, r7
 800ac04:	bd80      	pop	{r7, pc}
	...

0800ac08 <lv_font_get_bitmap_fmt_txt>:
 * @param font pointer to font
 * @param unicode_letter an unicode letter which bitmap should be get
 * @return pointer to the bitmap or NULL if not found
 */
const uint8_t * lv_font_get_bitmap_fmt_txt(const lv_font_t * font, uint32_t unicode_letter)
{
 800ac08:	b590      	push	{r4, r7, lr}
 800ac0a:	b08b      	sub	sp, #44	; 0x2c
 800ac0c:	af02      	add	r7, sp, #8
 800ac0e:	6078      	str	r0, [r7, #4]
 800ac10:	6039      	str	r1, [r7, #0]
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 800ac12:	687b      	ldr	r3, [r7, #4]
 800ac14:	68db      	ldr	r3, [r3, #12]
 800ac16:	61bb      	str	r3, [r7, #24]
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
 800ac18:	6839      	ldr	r1, [r7, #0]
 800ac1a:	6878      	ldr	r0, [r7, #4]
 800ac1c:	f000 f90e 	bl	800ae3c <get_glyph_dsc_id>
 800ac20:	6178      	str	r0, [r7, #20]
    if(!gid) return NULL;
 800ac22:	697b      	ldr	r3, [r7, #20]
 800ac24:	2b00      	cmp	r3, #0
 800ac26:	d101      	bne.n	800ac2c <lv_font_get_bitmap_fmt_txt+0x24>
 800ac28:	2300      	movs	r3, #0
 800ac2a:	e094      	b.n	800ad56 <lv_font_get_bitmap_fmt_txt+0x14e>

    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
 800ac2c:	69bb      	ldr	r3, [r7, #24]
 800ac2e:	685a      	ldr	r2, [r3, #4]
 800ac30:	697b      	ldr	r3, [r7, #20]
 800ac32:	00db      	lsls	r3, r3, #3
 800ac34:	4413      	add	r3, r2
 800ac36:	613b      	str	r3, [r7, #16]

    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
 800ac38:	69bb      	ldr	r3, [r7, #24]
 800ac3a:	7cdb      	ldrb	r3, [r3, #19]
 800ac3c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800ac40:	b2db      	uxtb	r3, r3
 800ac42:	2b00      	cmp	r3, #0
 800ac44:	d10b      	bne.n	800ac5e <lv_font_get_bitmap_fmt_txt+0x56>
        if(gdsc) return &fdsc->glyph_bitmap[gdsc->bitmap_index];
 800ac46:	693b      	ldr	r3, [r7, #16]
 800ac48:	2b00      	cmp	r3, #0
 800ac4a:	f000 8083 	beq.w	800ad54 <lv_font_get_bitmap_fmt_txt+0x14c>
 800ac4e:	69bb      	ldr	r3, [r7, #24]
 800ac50:	681b      	ldr	r3, [r3, #0]
 800ac52:	693a      	ldr	r2, [r7, #16]
 800ac54:	6812      	ldr	r2, [r2, #0]
 800ac56:	f3c2 0213 	ubfx	r2, r2, #0, #20
 800ac5a:	4413      	add	r3, r2
 800ac5c:	e07b      	b.n	800ad56 <lv_font_get_bitmap_fmt_txt+0x14e>
    /*Handle compressed bitmap*/
    else
    {
        static uint8_t * buf = NULL;

        uint32_t gsize = gdsc->box_w * gdsc->box_h;
 800ac5e:	693b      	ldr	r3, [r7, #16]
 800ac60:	791b      	ldrb	r3, [r3, #4]
 800ac62:	461a      	mov	r2, r3
 800ac64:	693b      	ldr	r3, [r7, #16]
 800ac66:	795b      	ldrb	r3, [r3, #5]
 800ac68:	fb03 f302 	mul.w	r3, r3, r2
 800ac6c:	60fb      	str	r3, [r7, #12]
        if(gsize == 0) return NULL;
 800ac6e:	68fb      	ldr	r3, [r7, #12]
 800ac70:	2b00      	cmp	r3, #0
 800ac72:	d101      	bne.n	800ac78 <lv_font_get_bitmap_fmt_txt+0x70>
 800ac74:	2300      	movs	r3, #0
 800ac76:	e06e      	b.n	800ad56 <lv_font_get_bitmap_fmt_txt+0x14e>

        uint32_t buf_size = gsize;
 800ac78:	68fb      	ldr	r3, [r7, #12]
 800ac7a:	61fb      	str	r3, [r7, #28]
        switch(fdsc->bpp) {
 800ac7c:	69bb      	ldr	r3, [r7, #24]
 800ac7e:	7cdb      	ldrb	r3, [r3, #19]
 800ac80:	f3c3 0382 	ubfx	r3, r3, #2, #3
 800ac84:	b2db      	uxtb	r3, r3
 800ac86:	3b01      	subs	r3, #1
 800ac88:	2b03      	cmp	r3, #3
 800ac8a:	d81b      	bhi.n	800acc4 <lv_font_get_bitmap_fmt_txt+0xbc>
 800ac8c:	a201      	add	r2, pc, #4	; (adr r2, 800ac94 <lv_font_get_bitmap_fmt_txt+0x8c>)
 800ac8e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ac92:	bf00      	nop
 800ac94:	0800aca5 	.word	0x0800aca5
 800ac98:	0800acad 	.word	0x0800acad
 800ac9c:	0800acb5 	.word	0x0800acb5
 800aca0:	0800acbd 	.word	0x0800acbd
        case 1: buf_size = gsize >> 3;  break;
 800aca4:	68fb      	ldr	r3, [r7, #12]
 800aca6:	08db      	lsrs	r3, r3, #3
 800aca8:	61fb      	str	r3, [r7, #28]
 800acaa:	e00b      	b.n	800acc4 <lv_font_get_bitmap_fmt_txt+0xbc>
        case 2: buf_size = gsize >> 2;  break;
 800acac:	68fb      	ldr	r3, [r7, #12]
 800acae:	089b      	lsrs	r3, r3, #2
 800acb0:	61fb      	str	r3, [r7, #28]
 800acb2:	e007      	b.n	800acc4 <lv_font_get_bitmap_fmt_txt+0xbc>
        case 3: buf_size = gsize >> 1;  break;
 800acb4:	68fb      	ldr	r3, [r7, #12]
 800acb6:	085b      	lsrs	r3, r3, #1
 800acb8:	61fb      	str	r3, [r7, #28]
 800acba:	e003      	b.n	800acc4 <lv_font_get_bitmap_fmt_txt+0xbc>
        case 4: buf_size = gsize >> 1;  break;
 800acbc:	68fb      	ldr	r3, [r7, #12]
 800acbe:	085b      	lsrs	r3, r3, #1
 800acc0:	61fb      	str	r3, [r7, #28]
 800acc2:	bf00      	nop
        }

        if(lv_mem_get_size(buf) < buf_size) {
 800acc4:	4b26      	ldr	r3, [pc, #152]	; (800ad60 <lv_font_get_bitmap_fmt_txt+0x158>)
 800acc6:	681b      	ldr	r3, [r3, #0]
 800acc8:	4618      	mov	r0, r3
 800acca:	f002 f861 	bl	800cd90 <lv_mem_get_size>
 800acce:	4602      	mov	r2, r0
 800acd0:	69fb      	ldr	r3, [r7, #28]
 800acd2:	4293      	cmp	r3, r2
 800acd4:	d923      	bls.n	800ad1e <lv_font_get_bitmap_fmt_txt+0x116>
            buf = lv_mem_realloc(buf, buf_size);
 800acd6:	4b22      	ldr	r3, [pc, #136]	; (800ad60 <lv_font_get_bitmap_fmt_txt+0x158>)
 800acd8:	681b      	ldr	r3, [r3, #0]
 800acda:	69f9      	ldr	r1, [r7, #28]
 800acdc:	4618      	mov	r0, r3
 800acde:	f002 f80b 	bl	800ccf8 <lv_mem_realloc>
 800ace2:	4602      	mov	r2, r0
 800ace4:	4b1e      	ldr	r3, [pc, #120]	; (800ad60 <lv_font_get_bitmap_fmt_txt+0x158>)
 800ace6:	601a      	str	r2, [r3, #0]
            LV_ASSERT_MEM(buf);
 800ace8:	4b1d      	ldr	r3, [pc, #116]	; (800ad60 <lv_font_get_bitmap_fmt_txt+0x158>)
 800acea:	681b      	ldr	r3, [r3, #0]
 800acec:	4618      	mov	r0, r3
 800acee:	f7f5 fa83 	bl	80001f8 <lv_debug_check_null>
 800acf2:	4603      	mov	r3, r0
 800acf4:	f083 0301 	eor.w	r3, r3, #1
 800acf8:	b2db      	uxtb	r3, r3
 800acfa:	2b00      	cmp	r3, #0
 800acfc:	d009      	beq.n	800ad12 <lv_font_get_bitmap_fmt_txt+0x10a>
 800acfe:	4b18      	ldr	r3, [pc, #96]	; (800ad60 <lv_font_get_bitmap_fmt_txt+0x158>)
 800ad00:	681b      	ldr	r3, [r3, #0]
 800ad02:	f04f 0400 	mov.w	r4, #0
 800ad06:	461a      	mov	r2, r3
 800ad08:	4623      	mov	r3, r4
 800ad0a:	4816      	ldr	r0, [pc, #88]	; (800ad64 <lv_font_get_bitmap_fmt_txt+0x15c>)
 800ad0c:	f7f5 fa9e 	bl	800024c <lv_debug_log_error>
 800ad10:	e7fe      	b.n	800ad10 <lv_font_get_bitmap_fmt_txt+0x108>
            if(buf == NULL) return NULL;
 800ad12:	4b13      	ldr	r3, [pc, #76]	; (800ad60 <lv_font_get_bitmap_fmt_txt+0x158>)
 800ad14:	681b      	ldr	r3, [r3, #0]
 800ad16:	2b00      	cmp	r3, #0
 800ad18:	d101      	bne.n	800ad1e <lv_font_get_bitmap_fmt_txt+0x116>
 800ad1a:	2300      	movs	r3, #0
 800ad1c:	e01b      	b.n	800ad56 <lv_font_get_bitmap_fmt_txt+0x14e>
        }

        decompress(&fdsc->glyph_bitmap[gdsc->bitmap_index], buf, gdsc->box_w , gdsc->box_h, (uint8_t)fdsc->bpp);
 800ad1e:	69bb      	ldr	r3, [r7, #24]
 800ad20:	681b      	ldr	r3, [r3, #0]
 800ad22:	693a      	ldr	r2, [r7, #16]
 800ad24:	6812      	ldr	r2, [r2, #0]
 800ad26:	f3c2 0213 	ubfx	r2, r2, #0, #20
 800ad2a:	1898      	adds	r0, r3, r2
 800ad2c:	4b0c      	ldr	r3, [pc, #48]	; (800ad60 <lv_font_get_bitmap_fmt_txt+0x158>)
 800ad2e:	6819      	ldr	r1, [r3, #0]
 800ad30:	693b      	ldr	r3, [r7, #16]
 800ad32:	791b      	ldrb	r3, [r3, #4]
 800ad34:	b21a      	sxth	r2, r3
 800ad36:	693b      	ldr	r3, [r7, #16]
 800ad38:	795b      	ldrb	r3, [r3, #5]
 800ad3a:	b21c      	sxth	r4, r3
 800ad3c:	69bb      	ldr	r3, [r7, #24]
 800ad3e:	7cdb      	ldrb	r3, [r3, #19]
 800ad40:	f3c3 0382 	ubfx	r3, r3, #2, #3
 800ad44:	b2db      	uxtb	r3, r3
 800ad46:	9300      	str	r3, [sp, #0]
 800ad48:	4623      	mov	r3, r4
 800ad4a:	f000 fa9b 	bl	800b284 <decompress>
        return buf;
 800ad4e:	4b04      	ldr	r3, [pc, #16]	; (800ad60 <lv_font_get_bitmap_fmt_txt+0x158>)
 800ad50:	681b      	ldr	r3, [r3, #0]
 800ad52:	e000      	b.n	800ad56 <lv_font_get_bitmap_fmt_txt+0x14e>
    }

    /*If not returned earlier then the letter is not found in this font*/
    return NULL;
 800ad54:	2300      	movs	r3, #0
}
 800ad56:	4618      	mov	r0, r3
 800ad58:	3724      	adds	r7, #36	; 0x24
 800ad5a:	46bd      	mov	sp, r7
 800ad5c:	bd90      	pop	{r4, r7, pc}
 800ad5e:	bf00      	nop
 800ad60:	2000029c 	.word	0x2000029c
 800ad64:	08013858 	.word	0x08013858

0800ad68 <lv_font_get_glyph_dsc_fmt_txt>:
 * @param letter an UNICODE letter code
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc_fmt_txt(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out, uint32_t unicode_letter, uint32_t unicode_letter_next)
{
 800ad68:	b580      	push	{r7, lr}
 800ad6a:	b08c      	sub	sp, #48	; 0x30
 800ad6c:	af00      	add	r7, sp, #0
 800ad6e:	60f8      	str	r0, [r7, #12]
 800ad70:	60b9      	str	r1, [r7, #8]
 800ad72:	607a      	str	r2, [r7, #4]
 800ad74:	603b      	str	r3, [r7, #0]
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 800ad76:	68fb      	ldr	r3, [r7, #12]
 800ad78:	68db      	ldr	r3, [r3, #12]
 800ad7a:	62bb      	str	r3, [r7, #40]	; 0x28
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
 800ad7c:	6879      	ldr	r1, [r7, #4]
 800ad7e:	68f8      	ldr	r0, [r7, #12]
 800ad80:	f000 f85c 	bl	800ae3c <get_glyph_dsc_id>
 800ad84:	6278      	str	r0, [r7, #36]	; 0x24
    if(!gid) return false;
 800ad86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ad88:	2b00      	cmp	r3, #0
 800ad8a:	d101      	bne.n	800ad90 <lv_font_get_glyph_dsc_fmt_txt+0x28>
 800ad8c:	2300      	movs	r3, #0
 800ad8e:	e050      	b.n	800ae32 <lv_font_get_glyph_dsc_fmt_txt+0xca>

    int8_t kvalue = 0;
 800ad90:	2300      	movs	r3, #0
 800ad92:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    if(fdsc->kern_dsc) {
 800ad96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ad98:	68db      	ldr	r3, [r3, #12]
 800ad9a:	2b00      	cmp	r3, #0
 800ad9c:	d00f      	beq.n	800adbe <lv_font_get_glyph_dsc_fmt_txt+0x56>
        uint32_t gid_next = get_glyph_dsc_id(font, unicode_letter_next);
 800ad9e:	6839      	ldr	r1, [r7, #0]
 800ada0:	68f8      	ldr	r0, [r7, #12]
 800ada2:	f000 f84b 	bl	800ae3c <get_glyph_dsc_id>
 800ada6:	6238      	str	r0, [r7, #32]
        if(gid_next) {
 800ada8:	6a3b      	ldr	r3, [r7, #32]
 800adaa:	2b00      	cmp	r3, #0
 800adac:	d007      	beq.n	800adbe <lv_font_get_glyph_dsc_fmt_txt+0x56>
            kvalue = get_kern_value(font, gid, gid_next);
 800adae:	6a3a      	ldr	r2, [r7, #32]
 800adb0:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800adb2:	68f8      	ldr	r0, [r7, #12]
 800adb4:	f000 f972 	bl	800b09c <get_kern_value>
 800adb8:	4603      	mov	r3, r0
 800adba:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        }
    }

    /*Put together a glyph dsc*/
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
 800adbe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800adc0:	685a      	ldr	r2, [r3, #4]
 800adc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800adc4:	00db      	lsls	r3, r3, #3
 800adc6:	4413      	add	r3, r2
 800adc8:	61fb      	str	r3, [r7, #28]

    int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
 800adca:	f997 302f 	ldrsb.w	r3, [r7, #47]	; 0x2f
 800adce:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800add0:	8a12      	ldrh	r2, [r2, #16]
 800add2:	fb02 f303 	mul.w	r3, r2, r3
 800add6:	111b      	asrs	r3, r3, #4
 800add8:	61bb      	str	r3, [r7, #24]

    uint32_t adv_w = gdsc->adv_w + kv;
 800adda:	69fb      	ldr	r3, [r7, #28]
 800addc:	885b      	ldrh	r3, [r3, #2]
 800adde:	f3c3 130b 	ubfx	r3, r3, #4, #12
 800ade2:	b29b      	uxth	r3, r3
 800ade4:	461a      	mov	r2, r3
 800ade6:	69bb      	ldr	r3, [r7, #24]
 800ade8:	4413      	add	r3, r2
 800adea:	617b      	str	r3, [r7, #20]
    adv_w  = (adv_w + (1 << 3)) >> 4;
 800adec:	697b      	ldr	r3, [r7, #20]
 800adee:	3308      	adds	r3, #8
 800adf0:	091b      	lsrs	r3, r3, #4
 800adf2:	617b      	str	r3, [r7, #20]

    dsc_out->adv_w = adv_w;
 800adf4:	697b      	ldr	r3, [r7, #20]
 800adf6:	b29a      	uxth	r2, r3
 800adf8:	68bb      	ldr	r3, [r7, #8]
 800adfa:	801a      	strh	r2, [r3, #0]
    dsc_out->box_h = gdsc->box_h;
 800adfc:	69fb      	ldr	r3, [r7, #28]
 800adfe:	795a      	ldrb	r2, [r3, #5]
 800ae00:	68bb      	ldr	r3, [r7, #8]
 800ae02:	70da      	strb	r2, [r3, #3]
    dsc_out->box_w = gdsc->box_w;
 800ae04:	69fb      	ldr	r3, [r7, #28]
 800ae06:	791a      	ldrb	r2, [r3, #4]
 800ae08:	68bb      	ldr	r3, [r7, #8]
 800ae0a:	709a      	strb	r2, [r3, #2]
    dsc_out->ofs_x = gdsc->ofs_x;
 800ae0c:	69fb      	ldr	r3, [r7, #28]
 800ae0e:	f993 2006 	ldrsb.w	r2, [r3, #6]
 800ae12:	68bb      	ldr	r3, [r7, #8]
 800ae14:	711a      	strb	r2, [r3, #4]
    dsc_out->ofs_y = gdsc->ofs_y;
 800ae16:	69fb      	ldr	r3, [r7, #28]
 800ae18:	f993 2007 	ldrsb.w	r2, [r3, #7]
 800ae1c:	68bb      	ldr	r3, [r7, #8]
 800ae1e:	715a      	strb	r2, [r3, #5]
    dsc_out->bpp   = (uint8_t)fdsc->bpp;
 800ae20:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae22:	7cdb      	ldrb	r3, [r3, #19]
 800ae24:	f3c3 0382 	ubfx	r3, r3, #2, #3
 800ae28:	b2db      	uxtb	r3, r3
 800ae2a:	461a      	mov	r2, r3
 800ae2c:	68bb      	ldr	r3, [r7, #8]
 800ae2e:	719a      	strb	r2, [r3, #6]

    return true;
 800ae30:	2301      	movs	r3, #1
}
 800ae32:	4618      	mov	r0, r3
 800ae34:	3730      	adds	r7, #48	; 0x30
 800ae36:	46bd      	mov	sp, r7
 800ae38:	bd80      	pop	{r7, pc}
	...

0800ae3c <get_glyph_dsc_id>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
{
 800ae3c:	b590      	push	{r4, r7, lr}
 800ae3e:	b08f      	sub	sp, #60	; 0x3c
 800ae40:	af02      	add	r7, sp, #8
 800ae42:	6078      	str	r0, [r7, #4]
 800ae44:	6039      	str	r1, [r7, #0]
    if(letter == '\0') return 0;
 800ae46:	683b      	ldr	r3, [r7, #0]
 800ae48:	2b00      	cmp	r3, #0
 800ae4a:	d101      	bne.n	800ae50 <get_glyph_dsc_id+0x14>
 800ae4c:	2300      	movs	r3, #0
 800ae4e:	e11e      	b.n	800b08e <get_glyph_dsc_id+0x252>

    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 800ae50:	687b      	ldr	r3, [r7, #4]
 800ae52:	68db      	ldr	r3, [r3, #12]
 800ae54:	627b      	str	r3, [r7, #36]	; 0x24

    /*Check the cache first*/
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
 800ae56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ae58:	695b      	ldr	r3, [r3, #20]
 800ae5a:	683a      	ldr	r2, [r7, #0]
 800ae5c:	429a      	cmp	r2, r3
 800ae5e:	d102      	bne.n	800ae66 <get_glyph_dsc_id+0x2a>
 800ae60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ae62:	699b      	ldr	r3, [r3, #24]
 800ae64:	e113      	b.n	800b08e <get_glyph_dsc_id+0x252>

    uint16_t i;
    for(i = 0; i < fdsc->cmap_num; i++) {
 800ae66:	2300      	movs	r3, #0
 800ae68:	85fb      	strh	r3, [r7, #46]	; 0x2e
 800ae6a:	e0ff      	b.n	800b06c <get_glyph_dsc_id+0x230>

        /*Relative code point*/
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
 800ae6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ae6e:	6899      	ldr	r1, [r3, #8]
 800ae70:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800ae72:	4613      	mov	r3, r2
 800ae74:	009b      	lsls	r3, r3, #2
 800ae76:	4413      	add	r3, r2
 800ae78:	009b      	lsls	r3, r3, #2
 800ae7a:	440b      	add	r3, r1
 800ae7c:	681b      	ldr	r3, [r3, #0]
 800ae7e:	683a      	ldr	r2, [r7, #0]
 800ae80:	1ad3      	subs	r3, r2, r3
 800ae82:	60bb      	str	r3, [r7, #8]
        if(rcp > fdsc->cmaps[i].range_length) continue;
 800ae84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ae86:	6899      	ldr	r1, [r3, #8]
 800ae88:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800ae8a:	4613      	mov	r3, r2
 800ae8c:	009b      	lsls	r3, r3, #2
 800ae8e:	4413      	add	r3, r2
 800ae90:	009b      	lsls	r3, r3, #2
 800ae92:	440b      	add	r3, r1
 800ae94:	889b      	ldrh	r3, [r3, #4]
 800ae96:	461a      	mov	r2, r3
 800ae98:	68bb      	ldr	r3, [r7, #8]
 800ae9a:	429a      	cmp	r2, r3
 800ae9c:	d203      	bcs.n	800aea6 <get_glyph_dsc_id+0x6a>
    for(i = 0; i < fdsc->cmap_num; i++) {
 800ae9e:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 800aea0:	3301      	adds	r3, #1
 800aea2:	85fb      	strh	r3, [r7, #46]	; 0x2e
 800aea4:	e0e2      	b.n	800b06c <get_glyph_dsc_id+0x230>
        uint32_t glyph_id = 0;
 800aea6:	2300      	movs	r3, #0
 800aea8:	62bb      	str	r3, [r7, #40]	; 0x28
        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
 800aeaa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800aeac:	6899      	ldr	r1, [r3, #8]
 800aeae:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800aeb0:	4613      	mov	r3, r2
 800aeb2:	009b      	lsls	r3, r3, #2
 800aeb4:	4413      	add	r3, r2
 800aeb6:	009b      	lsls	r3, r3, #2
 800aeb8:	440b      	add	r3, r1
 800aeba:	7c9b      	ldrb	r3, [r3, #18]
 800aebc:	2b00      	cmp	r3, #0
 800aebe:	d10d      	bne.n	800aedc <get_glyph_dsc_id+0xa0>
            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
 800aec0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800aec2:	6899      	ldr	r1, [r3, #8]
 800aec4:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800aec6:	4613      	mov	r3, r2
 800aec8:	009b      	lsls	r3, r3, #2
 800aeca:	4413      	add	r3, r2
 800aecc:	009b      	lsls	r3, r3, #2
 800aece:	440b      	add	r3, r1
 800aed0:	88db      	ldrh	r3, [r3, #6]
 800aed2:	461a      	mov	r2, r3
 800aed4:	68bb      	ldr	r3, [r7, #8]
 800aed6:	4413      	add	r3, r2
 800aed8:	62bb      	str	r3, [r7, #40]	; 0x28
 800aeda:	e0bf      	b.n	800b05c <get_glyph_dsc_id+0x220>
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
 800aedc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800aede:	6899      	ldr	r1, [r3, #8]
 800aee0:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800aee2:	4613      	mov	r3, r2
 800aee4:	009b      	lsls	r3, r3, #2
 800aee6:	4413      	add	r3, r2
 800aee8:	009b      	lsls	r3, r3, #2
 800aeea:	440b      	add	r3, r1
 800aeec:	7c9b      	ldrb	r3, [r3, #18]
 800aeee:	2b01      	cmp	r3, #1
 800aef0:	d11a      	bne.n	800af28 <get_glyph_dsc_id+0xec>
            const uint8_t * gid_ofs_8 = fdsc->cmaps[i].glyph_id_ofs_list;
 800aef2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800aef4:	6899      	ldr	r1, [r3, #8]
 800aef6:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800aef8:	4613      	mov	r3, r2
 800aefa:	009b      	lsls	r3, r3, #2
 800aefc:	4413      	add	r3, r2
 800aefe:	009b      	lsls	r3, r3, #2
 800af00:	440b      	add	r3, r1
 800af02:	68db      	ldr	r3, [r3, #12]
 800af04:	60fb      	str	r3, [r7, #12]
            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
 800af06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af08:	6899      	ldr	r1, [r3, #8]
 800af0a:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800af0c:	4613      	mov	r3, r2
 800af0e:	009b      	lsls	r3, r3, #2
 800af10:	4413      	add	r3, r2
 800af12:	009b      	lsls	r3, r3, #2
 800af14:	440b      	add	r3, r1
 800af16:	88db      	ldrh	r3, [r3, #6]
 800af18:	4619      	mov	r1, r3
 800af1a:	68bb      	ldr	r3, [r7, #8]
 800af1c:	68fa      	ldr	r2, [r7, #12]
 800af1e:	4413      	add	r3, r2
 800af20:	781b      	ldrb	r3, [r3, #0]
 800af22:	440b      	add	r3, r1
 800af24:	62bb      	str	r3, [r7, #40]	; 0x28
 800af26:	e099      	b.n	800b05c <get_glyph_dsc_id+0x220>
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
 800af28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af2a:	6899      	ldr	r1, [r3, #8]
 800af2c:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800af2e:	4613      	mov	r3, r2
 800af30:	009b      	lsls	r3, r3, #2
 800af32:	4413      	add	r3, r2
 800af34:	009b      	lsls	r3, r3, #2
 800af36:	440b      	add	r3, r1
 800af38:	7c9b      	ldrb	r3, [r3, #18]
 800af3a:	2b02      	cmp	r3, #2
 800af3c:	d13b      	bne.n	800afb6 <get_glyph_dsc_id+0x17a>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
 800af3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af40:	6899      	ldr	r1, [r3, #8]
 800af42:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800af44:	4613      	mov	r3, r2
 800af46:	009b      	lsls	r3, r3, #2
 800af48:	4413      	add	r3, r2
 800af4a:	009b      	lsls	r3, r3, #2
 800af4c:	440b      	add	r3, r1
 800af4e:	689c      	ldr	r4, [r3, #8]
 800af50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af52:	6899      	ldr	r1, [r3, #8]
 800af54:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800af56:	4613      	mov	r3, r2
 800af58:	009b      	lsls	r3, r3, #2
 800af5a:	4413      	add	r3, r2
 800af5c:	009b      	lsls	r3, r3, #2
 800af5e:	440b      	add	r3, r1
 800af60:	8a1b      	ldrh	r3, [r3, #16]
 800af62:	461a      	mov	r2, r3
 800af64:	f107 0008 	add.w	r0, r7, #8
 800af68:	4b4b      	ldr	r3, [pc, #300]	; (800b098 <get_glyph_dsc_id+0x25c>)
 800af6a:	9300      	str	r3, [sp, #0]
 800af6c:	2302      	movs	r3, #2
 800af6e:	4621      	mov	r1, r4
 800af70:	f002 ffc8 	bl	800df04 <lv_utils_bsearch>
 800af74:	6178      	str	r0, [r7, #20]

            if(p) {
 800af76:	697b      	ldr	r3, [r7, #20]
 800af78:	2b00      	cmp	r3, #0
 800af7a:	d06f      	beq.n	800b05c <get_glyph_dsc_id+0x220>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t *) fdsc->cmaps[i].unicode_list);
 800af7c:	6979      	ldr	r1, [r7, #20]
 800af7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af80:	6898      	ldr	r0, [r3, #8]
 800af82:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800af84:	4613      	mov	r3, r2
 800af86:	009b      	lsls	r3, r3, #2
 800af88:	4413      	add	r3, r2
 800af8a:	009b      	lsls	r3, r3, #2
 800af8c:	4403      	add	r3, r0
 800af8e:	689b      	ldr	r3, [r3, #8]
 800af90:	1acb      	subs	r3, r1, r3
 800af92:	613b      	str	r3, [r7, #16]
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
 800af94:	693b      	ldr	r3, [r7, #16]
 800af96:	085b      	lsrs	r3, r3, #1
 800af98:	613b      	str	r3, [r7, #16]
                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
 800af9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af9c:	6899      	ldr	r1, [r3, #8]
 800af9e:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800afa0:	4613      	mov	r3, r2
 800afa2:	009b      	lsls	r3, r3, #2
 800afa4:	4413      	add	r3, r2
 800afa6:	009b      	lsls	r3, r3, #2
 800afa8:	440b      	add	r3, r1
 800afaa:	88db      	ldrh	r3, [r3, #6]
 800afac:	461a      	mov	r2, r3
 800afae:	693b      	ldr	r3, [r7, #16]
 800afb0:	4413      	add	r3, r2
 800afb2:	62bb      	str	r3, [r7, #40]	; 0x28
 800afb4:	e052      	b.n	800b05c <get_glyph_dsc_id+0x220>
            }
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
 800afb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800afb8:	6899      	ldr	r1, [r3, #8]
 800afba:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800afbc:	4613      	mov	r3, r2
 800afbe:	009b      	lsls	r3, r3, #2
 800afc0:	4413      	add	r3, r2
 800afc2:	009b      	lsls	r3, r3, #2
 800afc4:	440b      	add	r3, r1
 800afc6:	7c9b      	ldrb	r3, [r3, #18]
 800afc8:	2b03      	cmp	r3, #3
 800afca:	d147      	bne.n	800b05c <get_glyph_dsc_id+0x220>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
 800afcc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800afce:	6899      	ldr	r1, [r3, #8]
 800afd0:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800afd2:	4613      	mov	r3, r2
 800afd4:	009b      	lsls	r3, r3, #2
 800afd6:	4413      	add	r3, r2
 800afd8:	009b      	lsls	r3, r3, #2
 800afda:	440b      	add	r3, r1
 800afdc:	689c      	ldr	r4, [r3, #8]
 800afde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800afe0:	6899      	ldr	r1, [r3, #8]
 800afe2:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800afe4:	4613      	mov	r3, r2
 800afe6:	009b      	lsls	r3, r3, #2
 800afe8:	4413      	add	r3, r2
 800afea:	009b      	lsls	r3, r3, #2
 800afec:	440b      	add	r3, r1
 800afee:	8a1b      	ldrh	r3, [r3, #16]
 800aff0:	461a      	mov	r2, r3
 800aff2:	f107 0008 	add.w	r0, r7, #8
 800aff6:	4b28      	ldr	r3, [pc, #160]	; (800b098 <get_glyph_dsc_id+0x25c>)
 800aff8:	9300      	str	r3, [sp, #0]
 800affa:	2302      	movs	r3, #2
 800affc:	4621      	mov	r1, r4
 800affe:	f002 ff81 	bl	800df04 <lv_utils_bsearch>
 800b002:	6238      	str	r0, [r7, #32]

            if(p) {
 800b004:	6a3b      	ldr	r3, [r7, #32]
 800b006:	2b00      	cmp	r3, #0
 800b008:	d028      	beq.n	800b05c <get_glyph_dsc_id+0x220>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t*) fdsc->cmaps[i].unicode_list);
 800b00a:	6a39      	ldr	r1, [r7, #32]
 800b00c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b00e:	6898      	ldr	r0, [r3, #8]
 800b010:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800b012:	4613      	mov	r3, r2
 800b014:	009b      	lsls	r3, r3, #2
 800b016:	4413      	add	r3, r2
 800b018:	009b      	lsls	r3, r3, #2
 800b01a:	4403      	add	r3, r0
 800b01c:	689b      	ldr	r3, [r3, #8]
 800b01e:	1acb      	subs	r3, r1, r3
 800b020:	61fb      	str	r3, [r7, #28]
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
 800b022:	69fb      	ldr	r3, [r7, #28]
 800b024:	085b      	lsrs	r3, r3, #1
 800b026:	61fb      	str	r3, [r7, #28]
                const uint8_t * gid_ofs_16 = fdsc->cmaps[i].glyph_id_ofs_list;
 800b028:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b02a:	6899      	ldr	r1, [r3, #8]
 800b02c:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800b02e:	4613      	mov	r3, r2
 800b030:	009b      	lsls	r3, r3, #2
 800b032:	4413      	add	r3, r2
 800b034:	009b      	lsls	r3, r3, #2
 800b036:	440b      	add	r3, r1
 800b038:	68db      	ldr	r3, [r3, #12]
 800b03a:	61bb      	str	r3, [r7, #24]
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
 800b03c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b03e:	6899      	ldr	r1, [r3, #8]
 800b040:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800b042:	4613      	mov	r3, r2
 800b044:	009b      	lsls	r3, r3, #2
 800b046:	4413      	add	r3, r2
 800b048:	009b      	lsls	r3, r3, #2
 800b04a:	440b      	add	r3, r1
 800b04c:	88db      	ldrh	r3, [r3, #6]
 800b04e:	4619      	mov	r1, r3
 800b050:	69ba      	ldr	r2, [r7, #24]
 800b052:	69fb      	ldr	r3, [r7, #28]
 800b054:	4413      	add	r3, r2
 800b056:	781b      	ldrb	r3, [r3, #0]
 800b058:	440b      	add	r3, r1
 800b05a:	62bb      	str	r3, [r7, #40]	; 0x28
            }
        }

        /*Update the cache*/
        fdsc->last_letter = letter;
 800b05c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b05e:	683a      	ldr	r2, [r7, #0]
 800b060:	615a      	str	r2, [r3, #20]
        fdsc->last_glyph_id = glyph_id;
 800b062:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b064:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b066:	619a      	str	r2, [r3, #24]
        return glyph_id;
 800b068:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b06a:	e010      	b.n	800b08e <get_glyph_dsc_id+0x252>
    for(i = 0; i < fdsc->cmap_num; i++) {
 800b06c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b06e:	8a5b      	ldrh	r3, [r3, #18]
 800b070:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b074:	b29b      	uxth	r3, r3
 800b076:	461a      	mov	r2, r3
 800b078:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 800b07a:	4293      	cmp	r3, r2
 800b07c:	f4ff aef6 	bcc.w	800ae6c <get_glyph_dsc_id+0x30>
    }

    fdsc->last_letter = letter;
 800b080:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b082:	683a      	ldr	r2, [r7, #0]
 800b084:	615a      	str	r2, [r3, #20]
    fdsc->last_glyph_id = 0;
 800b086:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b088:	2200      	movs	r2, #0
 800b08a:	619a      	str	r2, [r3, #24]
    return 0;
 800b08c:	2300      	movs	r3, #0

}
 800b08e:	4618      	mov	r0, r3
 800b090:	3734      	adds	r7, #52	; 0x34
 800b092:	46bd      	mov	sp, r7
 800b094:	bd90      	pop	{r4, r7, pc}
 800b096:	bf00      	nop
 800b098:	0800b775 	.word	0x0800b775

0800b09c <get_kern_value>:

static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t gid_right)
{
 800b09c:	b580      	push	{r7, lr}
 800b09e:	b094      	sub	sp, #80	; 0x50
 800b0a0:	af02      	add	r7, sp, #8
 800b0a2:	60f8      	str	r0, [r7, #12]
 800b0a4:	60b9      	str	r1, [r7, #8]
 800b0a6:	607a      	str	r2, [r7, #4]
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 800b0a8:	68fb      	ldr	r3, [r7, #12]
 800b0aa:	68db      	ldr	r3, [r3, #12]
 800b0ac:	643b      	str	r3, [r7, #64]	; 0x40

    int8_t value = 0;
 800b0ae:	2300      	movs	r3, #0
 800b0b0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

    if(fdsc->kern_classes == 0) {
 800b0b4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b0b6:	7cdb      	ldrb	r3, [r3, #19]
 800b0b8:	f003 0320 	and.w	r3, r3, #32
 800b0bc:	b2db      	uxtb	r3, r3
 800b0be:	2b00      	cmp	r3, #0
 800b0c0:	d164      	bne.n	800b18c <get_kern_value+0xf0>
        /*Kern pairs*/
        const lv_font_fmt_txt_kern_pair_t * kdsc = fdsc->kern_dsc;
 800b0c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b0c4:	68db      	ldr	r3, [r3, #12]
 800b0c6:	637b      	str	r3, [r7, #52]	; 0x34
        if(kdsc->glyph_ids_size == 0) {
 800b0c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b0ca:	7adb      	ldrb	r3, [r3, #11]
 800b0cc:	f003 0303 	and.w	r3, r3, #3
 800b0d0:	b2db      	uxtb	r3, r3
 800b0d2:	2b00      	cmp	r3, #0
 800b0d4:	d12b      	bne.n	800b12e <get_kern_value+0x92>
            /* Use binary search to find the kern value.
             * The pairs are ordered left_id first, then right_id secondly. */
            const uint8_t * g_ids = kdsc->glyph_ids;
 800b0d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b0d8:	681b      	ldr	r3, [r3, #0]
 800b0da:	627b      	str	r3, [r7, #36]	; 0x24
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
 800b0dc:	687b      	ldr	r3, [r7, #4]
 800b0de:	b29b      	uxth	r3, r3
 800b0e0:	021b      	lsls	r3, r3, #8
 800b0e2:	b29a      	uxth	r2, r3
 800b0e4:	68bb      	ldr	r3, [r7, #8]
 800b0e6:	b29b      	uxth	r3, r3
 800b0e8:	4413      	add	r3, r2
 800b0ea:	b29b      	uxth	r3, r3
 800b0ec:	837b      	strh	r3, [r7, #26]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
 800b0ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b0f0:	689b      	ldr	r3, [r3, #8]
 800b0f2:	f3c3 0317 	ubfx	r3, r3, #0, #24
 800b0f6:	461a      	mov	r2, r3
 800b0f8:	f107 001a 	add.w	r0, r7, #26
 800b0fc:	4b3b      	ldr	r3, [pc, #236]	; (800b1ec <get_kern_value+0x150>)
 800b0fe:	9300      	str	r3, [sp, #0]
 800b100:	2302      	movs	r3, #2
 800b102:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800b104:	f002 fefe 	bl	800df04 <lv_utils_bsearch>
 800b108:	6238      	str	r0, [r7, #32]

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
 800b10a:	6a3b      	ldr	r3, [r7, #32]
 800b10c:	2b00      	cmp	r3, #0
 800b10e:	d067      	beq.n	800b1e0 <get_kern_value+0x144>
                lv_uintptr_t ofs = (lv_uintptr_t)(kid_p - g_ids);
 800b110:	6a3a      	ldr	r2, [r7, #32]
 800b112:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b114:	1ad3      	subs	r3, r2, r3
 800b116:	61fb      	str	r3, [r7, #28]
                ofs = ofs >> 1;     /*ofs is for pair, divide by 2 to refer as a single value*/
 800b118:	69fb      	ldr	r3, [r7, #28]
 800b11a:	085b      	lsrs	r3, r3, #1
 800b11c:	61fb      	str	r3, [r7, #28]
                value = kdsc->values[ofs];
 800b11e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b120:	685a      	ldr	r2, [r3, #4]
 800b122:	69fb      	ldr	r3, [r7, #28]
 800b124:	4413      	add	r3, r2
 800b126:	781b      	ldrb	r3, [r3, #0]
 800b128:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 800b12c:	e058      	b.n	800b1e0 <get_kern_value+0x144>
            }
        } else if(kdsc->glyph_ids_size == 1) {
 800b12e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b130:	7adb      	ldrb	r3, [r3, #11]
 800b132:	f003 0303 	and.w	r3, r3, #3
 800b136:	b2db      	uxtb	r3, r3
 800b138:	2b01      	cmp	r3, #1
 800b13a:	d151      	bne.n	800b1e0 <get_kern_value+0x144>
            /* Use binary search to find the kern value.
             * The pairs are ordered left_id first, then right_id secondly. */
            const uint16_t * g_ids = kdsc->glyph_ids;
 800b13c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b13e:	681b      	ldr	r3, [r3, #0]
 800b140:	633b      	str	r3, [r7, #48]	; 0x30
            lv_uintptr_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
 800b142:	687b      	ldr	r3, [r7, #4]
 800b144:	021a      	lsls	r2, r3, #8
 800b146:	68bb      	ldr	r3, [r7, #8]
 800b148:	4413      	add	r3, r2
 800b14a:	617b      	str	r3, [r7, #20]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
 800b14c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b14e:	689b      	ldr	r3, [r3, #8]
 800b150:	f3c3 0317 	ubfx	r3, r3, #0, #24
 800b154:	461a      	mov	r2, r3
 800b156:	f107 0014 	add.w	r0, r7, #20
 800b15a:	4b25      	ldr	r3, [pc, #148]	; (800b1f0 <get_kern_value+0x154>)
 800b15c:	9300      	str	r3, [sp, #0]
 800b15e:	2304      	movs	r3, #4
 800b160:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800b162:	f002 fecf 	bl	800df04 <lv_utils_bsearch>
 800b166:	62f8      	str	r0, [r7, #44]	; 0x2c

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
 800b168:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b16a:	2b00      	cmp	r3, #0
 800b16c:	d038      	beq.n	800b1e0 <get_kern_value+0x144>
                lv_uintptr_t ofs = (lv_uintptr_t) (kid_p - (const uint8_t *)g_ids);
 800b16e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b170:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b172:	1ad3      	subs	r3, r2, r3
 800b174:	62bb      	str	r3, [r7, #40]	; 0x28
                ofs = ofs >> 4;     /*ofs is 4 byte pairs, divide by 4 to refer as a single value*/
 800b176:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b178:	091b      	lsrs	r3, r3, #4
 800b17a:	62bb      	str	r3, [r7, #40]	; 0x28
                value = kdsc->values[ofs];
 800b17c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b17e:	685a      	ldr	r2, [r3, #4]
 800b180:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b182:	4413      	add	r3, r2
 800b184:	781b      	ldrb	r3, [r3, #0]
 800b186:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 800b18a:	e029      	b.n	800b1e0 <get_kern_value+0x144>
        } else {
            /*Invalid value*/
        }
    } else {
        /*Kern classes*/
        const lv_font_fmt_txt_kern_classes_t * kdsc = fdsc->kern_dsc;
 800b18c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b18e:	68db      	ldr	r3, [r3, #12]
 800b190:	63fb      	str	r3, [r7, #60]	; 0x3c
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
 800b192:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b194:	685a      	ldr	r2, [r3, #4]
 800b196:	68bb      	ldr	r3, [r7, #8]
 800b198:	4413      	add	r3, r2
 800b19a:	781b      	ldrb	r3, [r3, #0]
 800b19c:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
        uint8_t right_class = kdsc->right_class_mapping[gid_right];
 800b1a0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b1a2:	689a      	ldr	r2, [r3, #8]
 800b1a4:	687b      	ldr	r3, [r7, #4]
 800b1a6:	4413      	add	r3, r2
 800b1a8:	781b      	ldrb	r3, [r3, #0]
 800b1aa:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a

        /* If class = 0, kerning not exist for that glyph
         * else got the value form `class_pair_values` 2D array*/
        if(left_class > 0 && right_class > 0) {
 800b1ae:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 800b1b2:	2b00      	cmp	r3, #0
 800b1b4:	d014      	beq.n	800b1e0 <get_kern_value+0x144>
 800b1b6:	f897 303a 	ldrb.w	r3, [r7, #58]	; 0x3a
 800b1ba:	2b00      	cmp	r3, #0
 800b1bc:	d010      	beq.n	800b1e0 <get_kern_value+0x144>
            value = kdsc->class_pair_values[(left_class-1)* kdsc->right_class_cnt + (right_class-1)];
 800b1be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b1c0:	681b      	ldr	r3, [r3, #0]
 800b1c2:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 800b1c6:	3a01      	subs	r2, #1
 800b1c8:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800b1ca:	7b49      	ldrb	r1, [r1, #13]
 800b1cc:	fb01 f102 	mul.w	r1, r1, r2
 800b1d0:	f897 203a 	ldrb.w	r2, [r7, #58]	; 0x3a
 800b1d4:	3a01      	subs	r2, #1
 800b1d6:	440a      	add	r2, r1
 800b1d8:	4413      	add	r3, r2
 800b1da:	781b      	ldrb	r3, [r3, #0]
 800b1dc:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        }

    }
    return value;
 800b1e0:	f997 3047 	ldrsb.w	r3, [r7, #71]	; 0x47
}
 800b1e4:	4618      	mov	r0, r3
 800b1e6:	3748      	adds	r7, #72	; 0x48
 800b1e8:	46bd      	mov	sp, r7
 800b1ea:	bd80      	pop	{r7, pc}
 800b1ec:	0800b1f5 	.word	0x0800b1f5
 800b1f0:	0800b23d 	.word	0x0800b23d

0800b1f4 <kern_pair_8_compare>:

static int32_t kern_pair_8_compare(const void * ref, const void * element)
{
 800b1f4:	b480      	push	{r7}
 800b1f6:	b085      	sub	sp, #20
 800b1f8:	af00      	add	r7, sp, #0
 800b1fa:	6078      	str	r0, [r7, #4]
 800b1fc:	6039      	str	r1, [r7, #0]
    const uint8_t * ref8_p = ref;
 800b1fe:	687b      	ldr	r3, [r7, #4]
 800b200:	60fb      	str	r3, [r7, #12]
    const uint8_t * element8_p = element;
 800b202:	683b      	ldr	r3, [r7, #0]
 800b204:	60bb      	str	r3, [r7, #8]

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];
 800b206:	68fb      	ldr	r3, [r7, #12]
 800b208:	781a      	ldrb	r2, [r3, #0]
 800b20a:	68bb      	ldr	r3, [r7, #8]
 800b20c:	781b      	ldrb	r3, [r3, #0]
 800b20e:	429a      	cmp	r2, r3
 800b210:	d006      	beq.n	800b220 <kern_pair_8_compare+0x2c>
 800b212:	68fb      	ldr	r3, [r7, #12]
 800b214:	781b      	ldrb	r3, [r3, #0]
 800b216:	461a      	mov	r2, r3
 800b218:	68bb      	ldr	r3, [r7, #8]
 800b21a:	781b      	ldrb	r3, [r3, #0]
 800b21c:	1ad3      	subs	r3, r2, r3
 800b21e:	e007      	b.n	800b230 <kern_pair_8_compare+0x3c>
    else return (int32_t) ref8_p[1] - element8_p[1];
 800b220:	68fb      	ldr	r3, [r7, #12]
 800b222:	3301      	adds	r3, #1
 800b224:	781b      	ldrb	r3, [r3, #0]
 800b226:	461a      	mov	r2, r3
 800b228:	68bb      	ldr	r3, [r7, #8]
 800b22a:	3301      	adds	r3, #1
 800b22c:	781b      	ldrb	r3, [r3, #0]
 800b22e:	1ad3      	subs	r3, r2, r3

}
 800b230:	4618      	mov	r0, r3
 800b232:	3714      	adds	r7, #20
 800b234:	46bd      	mov	sp, r7
 800b236:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b23a:	4770      	bx	lr

0800b23c <kern_pair_16_compare>:

static int32_t kern_pair_16_compare(const void * ref, const void * element)
{
 800b23c:	b480      	push	{r7}
 800b23e:	b085      	sub	sp, #20
 800b240:	af00      	add	r7, sp, #0
 800b242:	6078      	str	r0, [r7, #4]
 800b244:	6039      	str	r1, [r7, #0]
    const uint16_t * ref16_p = ref;
 800b246:	687b      	ldr	r3, [r7, #4]
 800b248:	60fb      	str	r3, [r7, #12]
    const uint16_t * element16_p = element;
 800b24a:	683b      	ldr	r3, [r7, #0]
 800b24c:	60bb      	str	r3, [r7, #8]

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];
 800b24e:	68fb      	ldr	r3, [r7, #12]
 800b250:	881a      	ldrh	r2, [r3, #0]
 800b252:	68bb      	ldr	r3, [r7, #8]
 800b254:	881b      	ldrh	r3, [r3, #0]
 800b256:	429a      	cmp	r2, r3
 800b258:	d006      	beq.n	800b268 <kern_pair_16_compare+0x2c>
 800b25a:	68fb      	ldr	r3, [r7, #12]
 800b25c:	881b      	ldrh	r3, [r3, #0]
 800b25e:	461a      	mov	r2, r3
 800b260:	68bb      	ldr	r3, [r7, #8]
 800b262:	881b      	ldrh	r3, [r3, #0]
 800b264:	1ad3      	subs	r3, r2, r3
 800b266:	e007      	b.n	800b278 <kern_pair_16_compare+0x3c>
    else return (int32_t) ref16_p[1] - element16_p[1];
 800b268:	68fb      	ldr	r3, [r7, #12]
 800b26a:	3302      	adds	r3, #2
 800b26c:	881b      	ldrh	r3, [r3, #0]
 800b26e:	461a      	mov	r2, r3
 800b270:	68bb      	ldr	r3, [r7, #8]
 800b272:	3302      	adds	r3, #2
 800b274:	881b      	ldrh	r3, [r3, #0]
 800b276:	1ad3      	subs	r3, r2, r3
}
 800b278:	4618      	mov	r0, r3
 800b27a:	3714      	adds	r7, #20
 800b27c:	46bd      	mov	sp, r7
 800b27e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b282:	4770      	bx	lr

0800b284 <decompress>:
 * @param out buffer to store the result
 * @param px_num number of pixels in the glyph (width * height)
 * @param bpp bit per pixel (bpp = 3 will be converted to bpp = 4)
 */
static void decompress(const uint8_t * in, uint8_t * out, lv_coord_t w, lv_coord_t h, uint8_t bpp)
{
 800b284:	b580      	push	{r7, lr}
 800b286:	b08a      	sub	sp, #40	; 0x28
 800b288:	af00      	add	r7, sp, #0
 800b28a:	60f8      	str	r0, [r7, #12]
 800b28c:	60b9      	str	r1, [r7, #8]
 800b28e:	4611      	mov	r1, r2
 800b290:	461a      	mov	r2, r3
 800b292:	460b      	mov	r3, r1
 800b294:	80fb      	strh	r3, [r7, #6]
 800b296:	4613      	mov	r3, r2
 800b298:	80bb      	strh	r3, [r7, #4]
    uint32_t wrp = 0;
 800b29a:	2300      	movs	r3, #0
 800b29c:	627b      	str	r3, [r7, #36]	; 0x24
    uint8_t wr_size = bpp;
 800b29e:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800b2a2:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    if(bpp == 3) wr_size = 4;
 800b2a6:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800b2aa:	2b03      	cmp	r3, #3
 800b2ac:	d102      	bne.n	800b2b4 <decompress+0x30>
 800b2ae:	2304      	movs	r3, #4
 800b2b0:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

    rle_init(in, bpp);
 800b2b4:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800b2b8:	4619      	mov	r1, r3
 800b2ba:	68f8      	ldr	r0, [r7, #12]
 800b2bc:	f000 f954 	bl	800b568 <rle_init>

    uint8_t * line_buf = lv_draw_get_buf(w * 2);
 800b2c0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800b2c4:	005b      	lsls	r3, r3, #1
 800b2c6:	4618      	mov	r0, r3
 800b2c8:	f7f8 fdc4 	bl	8003e54 <lv_draw_get_buf>
 800b2cc:	61b8      	str	r0, [r7, #24]
    uint8_t * line_buf1 = line_buf;
 800b2ce:	69bb      	ldr	r3, [r7, #24]
 800b2d0:	617b      	str	r3, [r7, #20]
    uint8_t * line_buf2 = line_buf + w;
 800b2d2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800b2d6:	69ba      	ldr	r2, [r7, #24]
 800b2d8:	4413      	add	r3, r2
 800b2da:	613b      	str	r3, [r7, #16]

    decompress_line(line_buf1, w);
 800b2dc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800b2e0:	4619      	mov	r1, r3
 800b2e2:	6978      	ldr	r0, [r7, #20]
 800b2e4:	f000 f868 	bl	800b3b8 <decompress_line>

    lv_coord_t y;
    lv_coord_t x;
    for(x = 0; x < w; x++) {
 800b2e8:	2300      	movs	r3, #0
 800b2ea:	83fb      	strh	r3, [r7, #30]
 800b2ec:	e015      	b.n	800b31a <decompress+0x96>
        bits_write(out,wrp, line_buf1[x], bpp);
 800b2ee:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800b2f2:	697a      	ldr	r2, [r7, #20]
 800b2f4:	4413      	add	r3, r2
 800b2f6:	781a      	ldrb	r2, [r3, #0]
 800b2f8:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800b2fc:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800b2fe:	68b8      	ldr	r0, [r7, #8]
 800b300:	f000 f8b6 	bl	800b470 <bits_write>
        wrp += wr_size;
 800b304:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800b308:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b30a:	4413      	add	r3, r2
 800b30c:	627b      	str	r3, [r7, #36]	; 0x24
    for(x = 0; x < w; x++) {
 800b30e:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800b312:	b29b      	uxth	r3, r3
 800b314:	3301      	adds	r3, #1
 800b316:	b29b      	uxth	r3, r3
 800b318:	83fb      	strh	r3, [r7, #30]
 800b31a:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 800b31e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800b322:	429a      	cmp	r2, r3
 800b324:	dbe3      	blt.n	800b2ee <decompress+0x6a>
    }

    for(y = 1; y < h; y++) {
 800b326:	2301      	movs	r3, #1
 800b328:	843b      	strh	r3, [r7, #32]
 800b32a:	e03b      	b.n	800b3a4 <decompress+0x120>
        decompress_line(line_buf2, w);
 800b32c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800b330:	4619      	mov	r1, r3
 800b332:	6938      	ldr	r0, [r7, #16]
 800b334:	f000 f840 	bl	800b3b8 <decompress_line>

        for(x = 0; x < w; x++) {
 800b338:	2300      	movs	r3, #0
 800b33a:	83fb      	strh	r3, [r7, #30]
 800b33c:	e026      	b.n	800b38c <decompress+0x108>
            line_buf1[x] = line_buf2[x] ^ line_buf1[x];
 800b33e:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800b342:	693a      	ldr	r2, [r7, #16]
 800b344:	4413      	add	r3, r2
 800b346:	7819      	ldrb	r1, [r3, #0]
 800b348:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800b34c:	697a      	ldr	r2, [r7, #20]
 800b34e:	4413      	add	r3, r2
 800b350:	781a      	ldrb	r2, [r3, #0]
 800b352:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800b356:	6978      	ldr	r0, [r7, #20]
 800b358:	4403      	add	r3, r0
 800b35a:	404a      	eors	r2, r1
 800b35c:	b2d2      	uxtb	r2, r2
 800b35e:	701a      	strb	r2, [r3, #0]
            bits_write(out,wrp, line_buf1[x], bpp);
 800b360:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800b364:	697a      	ldr	r2, [r7, #20]
 800b366:	4413      	add	r3, r2
 800b368:	781a      	ldrb	r2, [r3, #0]
 800b36a:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800b36e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800b370:	68b8      	ldr	r0, [r7, #8]
 800b372:	f000 f87d 	bl	800b470 <bits_write>
            wrp += wr_size;
 800b376:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800b37a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b37c:	4413      	add	r3, r2
 800b37e:	627b      	str	r3, [r7, #36]	; 0x24
        for(x = 0; x < w; x++) {
 800b380:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800b384:	b29b      	uxth	r3, r3
 800b386:	3301      	adds	r3, #1
 800b388:	b29b      	uxth	r3, r3
 800b38a:	83fb      	strh	r3, [r7, #30]
 800b38c:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 800b390:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800b394:	429a      	cmp	r2, r3
 800b396:	dbd2      	blt.n	800b33e <decompress+0xba>
    for(y = 1; y < h; y++) {
 800b398:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 800b39c:	b29b      	uxth	r3, r3
 800b39e:	3301      	adds	r3, #1
 800b3a0:	b29b      	uxth	r3, r3
 800b3a2:	843b      	strh	r3, [r7, #32]
 800b3a4:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 800b3a8:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 800b3ac:	429a      	cmp	r2, r3
 800b3ae:	dbbd      	blt.n	800b32c <decompress+0xa8>
        }
    }
}
 800b3b0:	bf00      	nop
 800b3b2:	3728      	adds	r7, #40	; 0x28
 800b3b4:	46bd      	mov	sp, r7
 800b3b6:	bd80      	pop	{r7, pc}

0800b3b8 <decompress_line>:
 * Decompress one line. Store one pixel per byte
 * @param out output buffer
 * @param w width of the line in pixel count
 */
static void decompress_line(uint8_t * out, lv_coord_t w)
{
 800b3b8:	b590      	push	{r4, r7, lr}
 800b3ba:	b085      	sub	sp, #20
 800b3bc:	af00      	add	r7, sp, #0
 800b3be:	6078      	str	r0, [r7, #4]
 800b3c0:	460b      	mov	r3, r1
 800b3c2:	807b      	strh	r3, [r7, #2]
    lv_coord_t i;
    for(i = 0; i < w; i++) {
 800b3c4:	2300      	movs	r3, #0
 800b3c6:	81fb      	strh	r3, [r7, #14]
 800b3c8:	e00d      	b.n	800b3e6 <decompress_line+0x2e>
        out[i] = rle_next();
 800b3ca:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800b3ce:	687a      	ldr	r2, [r7, #4]
 800b3d0:	18d4      	adds	r4, r2, r3
 800b3d2:	f000 f8f3 	bl	800b5bc <rle_next>
 800b3d6:	4603      	mov	r3, r0
 800b3d8:	7023      	strb	r3, [r4, #0]
    for(i = 0; i < w; i++) {
 800b3da:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800b3de:	b29b      	uxth	r3, r3
 800b3e0:	3301      	adds	r3, #1
 800b3e2:	b29b      	uxth	r3, r3
 800b3e4:	81fb      	strh	r3, [r7, #14]
 800b3e6:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 800b3ea:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800b3ee:	429a      	cmp	r2, r3
 800b3f0:	dbeb      	blt.n	800b3ca <decompress_line+0x12>
    }
}
 800b3f2:	bf00      	nop
 800b3f4:	3714      	adds	r7, #20
 800b3f6:	46bd      	mov	sp, r7
 800b3f8:	bd90      	pop	{r4, r7, pc}

0800b3fa <get_bits>:
 * @param bit_pos index of teh first bit to read.
 * @param len number of bits to read (must be <= 8).
 * @return the read bits
 */
static uint8_t get_bits(const uint8_t * in, uint32_t bit_pos, uint8_t len)
{
 800b3fa:	b480      	push	{r7}
 800b3fc:	b089      	sub	sp, #36	; 0x24
 800b3fe:	af00      	add	r7, sp, #0
 800b400:	60f8      	str	r0, [r7, #12]
 800b402:	60b9      	str	r1, [r7, #8]
 800b404:	4613      	mov	r3, r2
 800b406:	71fb      	strb	r3, [r7, #7]
    uint8_t res = 0;
 800b408:	2300      	movs	r3, #0
 800b40a:	77fb      	strb	r3, [r7, #31]
    uint32_t byte_pos = bit_pos >> 3;
 800b40c:	68bb      	ldr	r3, [r7, #8]
 800b40e:	08db      	lsrs	r3, r3, #3
 800b410:	61bb      	str	r3, [r7, #24]
    bit_pos = bit_pos & 0x7;
 800b412:	68bb      	ldr	r3, [r7, #8]
 800b414:	f003 0307 	and.w	r3, r3, #7
 800b418:	60bb      	str	r3, [r7, #8]
    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
 800b41a:	79fb      	ldrb	r3, [r7, #7]
 800b41c:	2201      	movs	r2, #1
 800b41e:	fa02 f303 	lsl.w	r3, r2, r3
 800b422:	b2db      	uxtb	r3, r3
 800b424:	3b01      	subs	r3, #1
 800b426:	75fb      	strb	r3, [r7, #23]
    uint16_t in16 = (in[byte_pos] << 8) + in[byte_pos + 1];
 800b428:	68fa      	ldr	r2, [r7, #12]
 800b42a:	69bb      	ldr	r3, [r7, #24]
 800b42c:	4413      	add	r3, r2
 800b42e:	781b      	ldrb	r3, [r3, #0]
 800b430:	b29b      	uxth	r3, r3
 800b432:	021b      	lsls	r3, r3, #8
 800b434:	b29a      	uxth	r2, r3
 800b436:	69bb      	ldr	r3, [r7, #24]
 800b438:	3301      	adds	r3, #1
 800b43a:	68f9      	ldr	r1, [r7, #12]
 800b43c:	440b      	add	r3, r1
 800b43e:	781b      	ldrb	r3, [r3, #0]
 800b440:	b29b      	uxth	r3, r3
 800b442:	4413      	add	r3, r2
 800b444:	82bb      	strh	r3, [r7, #20]

    res = (in16 >> (16 - bit_pos - len)) & bit_mask;
 800b446:	8aba      	ldrh	r2, [r7, #20]
 800b448:	79fb      	ldrb	r3, [r7, #7]
 800b44a:	4259      	negs	r1, r3
 800b44c:	68bb      	ldr	r3, [r7, #8]
 800b44e:	1acb      	subs	r3, r1, r3
 800b450:	3310      	adds	r3, #16
 800b452:	fa42 f303 	asr.w	r3, r2, r3
 800b456:	b25a      	sxtb	r2, r3
 800b458:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800b45c:	4013      	ands	r3, r2
 800b45e:	b25b      	sxtb	r3, r3
 800b460:	77fb      	strb	r3, [r7, #31]
    return res;
 800b462:	7ffb      	ldrb	r3, [r7, #31]
}
 800b464:	4618      	mov	r0, r3
 800b466:	3724      	adds	r7, #36	; 0x24
 800b468:	46bd      	mov	sp, r7
 800b46a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b46e:	4770      	bx	lr

0800b470 <bits_write>:
 * @param val value to write
 * @param len length of bits to write from `val`. (Counted from the LSB).
 * @note `len == 3` will be converted to `len = 4` and `val` will be upscaled too
 */
static void bits_write(uint8_t * out, uint32_t bit_pos, uint8_t val, uint8_t len)
{
 800b470:	b480      	push	{r7}
 800b472:	b087      	sub	sp, #28
 800b474:	af00      	add	r7, sp, #0
 800b476:	60f8      	str	r0, [r7, #12]
 800b478:	60b9      	str	r1, [r7, #8]
 800b47a:	4611      	mov	r1, r2
 800b47c:	461a      	mov	r2, r3
 800b47e:	460b      	mov	r3, r1
 800b480:	71fb      	strb	r3, [r7, #7]
 800b482:	4613      	mov	r3, r2
 800b484:	71bb      	strb	r3, [r7, #6]
    if(len == 3) {
 800b486:	79bb      	ldrb	r3, [r7, #6]
 800b488:	2b03      	cmp	r3, #3
 800b48a:	d12f      	bne.n	800b4ec <bits_write+0x7c>
        len = 4;
 800b48c:	2304      	movs	r3, #4
 800b48e:	71bb      	strb	r3, [r7, #6]
        switch(val) {
 800b490:	79fb      	ldrb	r3, [r7, #7]
 800b492:	2b07      	cmp	r3, #7
 800b494:	d82a      	bhi.n	800b4ec <bits_write+0x7c>
 800b496:	a201      	add	r2, pc, #4	; (adr r2, 800b49c <bits_write+0x2c>)
 800b498:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b49c:	0800b4bd 	.word	0x0800b4bd
 800b4a0:	0800b4c3 	.word	0x0800b4c3
 800b4a4:	0800b4c9 	.word	0x0800b4c9
 800b4a8:	0800b4cf 	.word	0x0800b4cf
 800b4ac:	0800b4d5 	.word	0x0800b4d5
 800b4b0:	0800b4db 	.word	0x0800b4db
 800b4b4:	0800b4e1 	.word	0x0800b4e1
 800b4b8:	0800b4e7 	.word	0x0800b4e7
        case 0: val = 0; break;
 800b4bc:	2300      	movs	r3, #0
 800b4be:	71fb      	strb	r3, [r7, #7]
 800b4c0:	e014      	b.n	800b4ec <bits_write+0x7c>
        case 1: val = 2; break;
 800b4c2:	2302      	movs	r3, #2
 800b4c4:	71fb      	strb	r3, [r7, #7]
 800b4c6:	e011      	b.n	800b4ec <bits_write+0x7c>
        case 2: val = 4; break;
 800b4c8:	2304      	movs	r3, #4
 800b4ca:	71fb      	strb	r3, [r7, #7]
 800b4cc:	e00e      	b.n	800b4ec <bits_write+0x7c>
        case 3: val = 6; break;
 800b4ce:	2306      	movs	r3, #6
 800b4d0:	71fb      	strb	r3, [r7, #7]
 800b4d2:	e00b      	b.n	800b4ec <bits_write+0x7c>
        case 4: val = 9; break;
 800b4d4:	2309      	movs	r3, #9
 800b4d6:	71fb      	strb	r3, [r7, #7]
 800b4d8:	e008      	b.n	800b4ec <bits_write+0x7c>
        case 5: val = 11; break;
 800b4da:	230b      	movs	r3, #11
 800b4dc:	71fb      	strb	r3, [r7, #7]
 800b4de:	e005      	b.n	800b4ec <bits_write+0x7c>
        case 6: val = 13; break;
 800b4e0:	230d      	movs	r3, #13
 800b4e2:	71fb      	strb	r3, [r7, #7]
 800b4e4:	e002      	b.n	800b4ec <bits_write+0x7c>
        case 7: val = 15; break;
 800b4e6:	230f      	movs	r3, #15
 800b4e8:	71fb      	strb	r3, [r7, #7]
 800b4ea:	bf00      	nop
        }
    }

    uint16_t byte_pos = bit_pos >> 3;
 800b4ec:	68bb      	ldr	r3, [r7, #8]
 800b4ee:	08db      	lsrs	r3, r3, #3
 800b4f0:	82fb      	strh	r3, [r7, #22]
    bit_pos = bit_pos & 0x7;
 800b4f2:	68bb      	ldr	r3, [r7, #8]
 800b4f4:	f003 0307 	and.w	r3, r3, #7
 800b4f8:	60bb      	str	r3, [r7, #8]
    bit_pos = 8 - bit_pos - len;
 800b4fa:	79bb      	ldrb	r3, [r7, #6]
 800b4fc:	425a      	negs	r2, r3
 800b4fe:	68bb      	ldr	r3, [r7, #8]
 800b500:	1ad3      	subs	r3, r2, r3
 800b502:	3308      	adds	r3, #8
 800b504:	60bb      	str	r3, [r7, #8]

    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
 800b506:	79bb      	ldrb	r3, [r7, #6]
 800b508:	2201      	movs	r2, #1
 800b50a:	fa02 f303 	lsl.w	r3, r2, r3
 800b50e:	b2db      	uxtb	r3, r3
 800b510:	3b01      	subs	r3, #1
 800b512:	757b      	strb	r3, [r7, #21]
    out[byte_pos] &= ((~bit_mask) << bit_pos);
 800b514:	8afb      	ldrh	r3, [r7, #22]
 800b516:	68fa      	ldr	r2, [r7, #12]
 800b518:	4413      	add	r3, r2
 800b51a:	781b      	ldrb	r3, [r3, #0]
 800b51c:	b25a      	sxtb	r2, r3
 800b51e:	7d7b      	ldrb	r3, [r7, #21]
 800b520:	43d9      	mvns	r1, r3
 800b522:	68bb      	ldr	r3, [r7, #8]
 800b524:	fa01 f303 	lsl.w	r3, r1, r3
 800b528:	b25b      	sxtb	r3, r3
 800b52a:	4013      	ands	r3, r2
 800b52c:	b259      	sxtb	r1, r3
 800b52e:	8afb      	ldrh	r3, [r7, #22]
 800b530:	68fa      	ldr	r2, [r7, #12]
 800b532:	4413      	add	r3, r2
 800b534:	b2ca      	uxtb	r2, r1
 800b536:	701a      	strb	r2, [r3, #0]
    out[byte_pos] |= (val << bit_pos);
 800b538:	8afb      	ldrh	r3, [r7, #22]
 800b53a:	68fa      	ldr	r2, [r7, #12]
 800b53c:	4413      	add	r3, r2
 800b53e:	781b      	ldrb	r3, [r3, #0]
 800b540:	b25a      	sxtb	r2, r3
 800b542:	79f9      	ldrb	r1, [r7, #7]
 800b544:	68bb      	ldr	r3, [r7, #8]
 800b546:	fa01 f303 	lsl.w	r3, r1, r3
 800b54a:	b25b      	sxtb	r3, r3
 800b54c:	4313      	orrs	r3, r2
 800b54e:	b259      	sxtb	r1, r3
 800b550:	8afb      	ldrh	r3, [r7, #22]
 800b552:	68fa      	ldr	r2, [r7, #12]
 800b554:	4413      	add	r3, r2
 800b556:	b2ca      	uxtb	r2, r1
 800b558:	701a      	strb	r2, [r3, #0]
}
 800b55a:	bf00      	nop
 800b55c:	371c      	adds	r7, #28
 800b55e:	46bd      	mov	sp, r7
 800b560:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b564:	4770      	bx	lr
 800b566:	bf00      	nop

0800b568 <rle_init>:

static void rle_init(const uint8_t * in,  uint8_t bpp)
{
 800b568:	b480      	push	{r7}
 800b56a:	b083      	sub	sp, #12
 800b56c:	af00      	add	r7, sp, #0
 800b56e:	6078      	str	r0, [r7, #4]
 800b570:	460b      	mov	r3, r1
 800b572:	70fb      	strb	r3, [r7, #3]
    rle_in = in;
 800b574:	4a0b      	ldr	r2, [pc, #44]	; (800b5a4 <rle_init+0x3c>)
 800b576:	687b      	ldr	r3, [r7, #4]
 800b578:	6013      	str	r3, [r2, #0]
    rle_bpp = bpp;
 800b57a:	4a0b      	ldr	r2, [pc, #44]	; (800b5a8 <rle_init+0x40>)
 800b57c:	78fb      	ldrb	r3, [r7, #3]
 800b57e:	7013      	strb	r3, [r2, #0]
    rle_state = RLE_STATE_SINGLE;
 800b580:	4b0a      	ldr	r3, [pc, #40]	; (800b5ac <rle_init+0x44>)
 800b582:	2200      	movs	r2, #0
 800b584:	701a      	strb	r2, [r3, #0]
    rle_rdp = 0;
 800b586:	4b0a      	ldr	r3, [pc, #40]	; (800b5b0 <rle_init+0x48>)
 800b588:	2200      	movs	r2, #0
 800b58a:	601a      	str	r2, [r3, #0]
    rle_prev_v = 0;
 800b58c:	4b09      	ldr	r3, [pc, #36]	; (800b5b4 <rle_init+0x4c>)
 800b58e:	2200      	movs	r2, #0
 800b590:	701a      	strb	r2, [r3, #0]
    rle_cnt = 0;
 800b592:	4b09      	ldr	r3, [pc, #36]	; (800b5b8 <rle_init+0x50>)
 800b594:	2200      	movs	r2, #0
 800b596:	701a      	strb	r2, [r3, #0]
}
 800b598:	bf00      	nop
 800b59a:	370c      	adds	r7, #12
 800b59c:	46bd      	mov	sp, r7
 800b59e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b5a2:	4770      	bx	lr
 800b5a4:	20000294 	.word	0x20000294
 800b5a8:	20000298 	.word	0x20000298
 800b5ac:	2000029b 	.word	0x2000029b
 800b5b0:	20000290 	.word	0x20000290
 800b5b4:	20000299 	.word	0x20000299
 800b5b8:	2000029a 	.word	0x2000029a

0800b5bc <rle_next>:

static uint8_t rle_next(void)
{
 800b5bc:	b580      	push	{r7, lr}
 800b5be:	b082      	sub	sp, #8
 800b5c0:	af00      	add	r7, sp, #0
    uint8_t v = 0;
 800b5c2:	2300      	movs	r3, #0
 800b5c4:	71bb      	strb	r3, [r7, #6]
    uint8_t ret = 0;
 800b5c6:	2300      	movs	r3, #0
 800b5c8:	71fb      	strb	r3, [r7, #7]

    if(rle_state == RLE_STATE_SINGLE) {
 800b5ca:	4b64      	ldr	r3, [pc, #400]	; (800b75c <rle_next+0x1a0>)
 800b5cc:	781b      	ldrb	r3, [r3, #0]
 800b5ce:	2b00      	cmp	r3, #0
 800b5d0:	d125      	bne.n	800b61e <rle_next+0x62>
        ret = get_bits(rle_in, rle_rdp, rle_bpp);
 800b5d2:	4b63      	ldr	r3, [pc, #396]	; (800b760 <rle_next+0x1a4>)
 800b5d4:	6818      	ldr	r0, [r3, #0]
 800b5d6:	4b63      	ldr	r3, [pc, #396]	; (800b764 <rle_next+0x1a8>)
 800b5d8:	6819      	ldr	r1, [r3, #0]
 800b5da:	4b63      	ldr	r3, [pc, #396]	; (800b768 <rle_next+0x1ac>)
 800b5dc:	781b      	ldrb	r3, [r3, #0]
 800b5de:	461a      	mov	r2, r3
 800b5e0:	f7ff ff0b 	bl	800b3fa <get_bits>
 800b5e4:	4603      	mov	r3, r0
 800b5e6:	71fb      	strb	r3, [r7, #7]
        if(rle_rdp != 0 && rle_prev_v == ret) {
 800b5e8:	4b5e      	ldr	r3, [pc, #376]	; (800b764 <rle_next+0x1a8>)
 800b5ea:	681b      	ldr	r3, [r3, #0]
 800b5ec:	2b00      	cmp	r3, #0
 800b5ee:	d00a      	beq.n	800b606 <rle_next+0x4a>
 800b5f0:	4b5e      	ldr	r3, [pc, #376]	; (800b76c <rle_next+0x1b0>)
 800b5f2:	781b      	ldrb	r3, [r3, #0]
 800b5f4:	79fa      	ldrb	r2, [r7, #7]
 800b5f6:	429a      	cmp	r2, r3
 800b5f8:	d105      	bne.n	800b606 <rle_next+0x4a>
            rle_cnt = 0;
 800b5fa:	4b5d      	ldr	r3, [pc, #372]	; (800b770 <rle_next+0x1b4>)
 800b5fc:	2200      	movs	r2, #0
 800b5fe:	701a      	strb	r2, [r3, #0]
            rle_state = RLE_STATE_REPEATE;
 800b600:	4b56      	ldr	r3, [pc, #344]	; (800b75c <rle_next+0x1a0>)
 800b602:	2201      	movs	r2, #1
 800b604:	701a      	strb	r2, [r3, #0]
        }

        rle_prev_v = ret;
 800b606:	4a59      	ldr	r2, [pc, #356]	; (800b76c <rle_next+0x1b0>)
 800b608:	79fb      	ldrb	r3, [r7, #7]
 800b60a:	7013      	strb	r3, [r2, #0]
        rle_rdp += rle_bpp;
 800b60c:	4b56      	ldr	r3, [pc, #344]	; (800b768 <rle_next+0x1ac>)
 800b60e:	781b      	ldrb	r3, [r3, #0]
 800b610:	461a      	mov	r2, r3
 800b612:	4b54      	ldr	r3, [pc, #336]	; (800b764 <rle_next+0x1a8>)
 800b614:	681b      	ldr	r3, [r3, #0]
 800b616:	4413      	add	r3, r2
 800b618:	4a52      	ldr	r2, [pc, #328]	; (800b764 <rle_next+0x1a8>)
 800b61a:	6013      	str	r3, [r2, #0]
 800b61c:	e099      	b.n	800b752 <rle_next+0x196>
    }
    else if(rle_state == RLE_STATE_REPEATE) {
 800b61e:	4b4f      	ldr	r3, [pc, #316]	; (800b75c <rle_next+0x1a0>)
 800b620:	781b      	ldrb	r3, [r3, #0]
 800b622:	2b01      	cmp	r3, #1
 800b624:	d16b      	bne.n	800b6fe <rle_next+0x142>
        v = get_bits(rle_in, rle_rdp, 1);
 800b626:	4b4e      	ldr	r3, [pc, #312]	; (800b760 <rle_next+0x1a4>)
 800b628:	6818      	ldr	r0, [r3, #0]
 800b62a:	4b4e      	ldr	r3, [pc, #312]	; (800b764 <rle_next+0x1a8>)
 800b62c:	681b      	ldr	r3, [r3, #0]
 800b62e:	2201      	movs	r2, #1
 800b630:	4619      	mov	r1, r3
 800b632:	f7ff fee2 	bl	800b3fa <get_bits>
 800b636:	4603      	mov	r3, r0
 800b638:	71bb      	strb	r3, [r7, #6]
        rle_cnt++;
 800b63a:	4b4d      	ldr	r3, [pc, #308]	; (800b770 <rle_next+0x1b4>)
 800b63c:	781b      	ldrb	r3, [r3, #0]
 800b63e:	3301      	adds	r3, #1
 800b640:	b2da      	uxtb	r2, r3
 800b642:	4b4b      	ldr	r3, [pc, #300]	; (800b770 <rle_next+0x1b4>)
 800b644:	701a      	strb	r2, [r3, #0]
        rle_rdp += 1;
 800b646:	4b47      	ldr	r3, [pc, #284]	; (800b764 <rle_next+0x1a8>)
 800b648:	681b      	ldr	r3, [r3, #0]
 800b64a:	3301      	adds	r3, #1
 800b64c:	4a45      	ldr	r2, [pc, #276]	; (800b764 <rle_next+0x1a8>)
 800b64e:	6013      	str	r3, [r2, #0]
        if(v == 1) {
 800b650:	79bb      	ldrb	r3, [r7, #6]
 800b652:	2b01      	cmp	r3, #1
 800b654:	d139      	bne.n	800b6ca <rle_next+0x10e>
            ret = rle_prev_v;
 800b656:	4b45      	ldr	r3, [pc, #276]	; (800b76c <rle_next+0x1b0>)
 800b658:	781b      	ldrb	r3, [r3, #0]
 800b65a:	71fb      	strb	r3, [r7, #7]
            if(rle_cnt == 11) {
 800b65c:	4b44      	ldr	r3, [pc, #272]	; (800b770 <rle_next+0x1b4>)
 800b65e:	781b      	ldrb	r3, [r3, #0]
 800b660:	2b0b      	cmp	r3, #11
 800b662:	d176      	bne.n	800b752 <rle_next+0x196>
                rle_cnt = get_bits(rle_in, rle_rdp, 6);
 800b664:	4b3e      	ldr	r3, [pc, #248]	; (800b760 <rle_next+0x1a4>)
 800b666:	6818      	ldr	r0, [r3, #0]
 800b668:	4b3e      	ldr	r3, [pc, #248]	; (800b764 <rle_next+0x1a8>)
 800b66a:	681b      	ldr	r3, [r3, #0]
 800b66c:	2206      	movs	r2, #6
 800b66e:	4619      	mov	r1, r3
 800b670:	f7ff fec3 	bl	800b3fa <get_bits>
 800b674:	4603      	mov	r3, r0
 800b676:	461a      	mov	r2, r3
 800b678:	4b3d      	ldr	r3, [pc, #244]	; (800b770 <rle_next+0x1b4>)
 800b67a:	701a      	strb	r2, [r3, #0]
                rle_rdp += 6;
 800b67c:	4b39      	ldr	r3, [pc, #228]	; (800b764 <rle_next+0x1a8>)
 800b67e:	681b      	ldr	r3, [r3, #0]
 800b680:	3306      	adds	r3, #6
 800b682:	4a38      	ldr	r2, [pc, #224]	; (800b764 <rle_next+0x1a8>)
 800b684:	6013      	str	r3, [r2, #0]
                if(rle_cnt != 0) {
 800b686:	4b3a      	ldr	r3, [pc, #232]	; (800b770 <rle_next+0x1b4>)
 800b688:	781b      	ldrb	r3, [r3, #0]
 800b68a:	2b00      	cmp	r3, #0
 800b68c:	d003      	beq.n	800b696 <rle_next+0xda>
                    rle_state = RLE_STATE_COUNTER;
 800b68e:	4b33      	ldr	r3, [pc, #204]	; (800b75c <rle_next+0x1a0>)
 800b690:	2202      	movs	r2, #2
 800b692:	701a      	strb	r2, [r3, #0]
 800b694:	e05d      	b.n	800b752 <rle_next+0x196>
                } else {
                    ret = get_bits(rle_in, rle_rdp, rle_bpp);
 800b696:	4b32      	ldr	r3, [pc, #200]	; (800b760 <rle_next+0x1a4>)
 800b698:	6818      	ldr	r0, [r3, #0]
 800b69a:	4b32      	ldr	r3, [pc, #200]	; (800b764 <rle_next+0x1a8>)
 800b69c:	6819      	ldr	r1, [r3, #0]
 800b69e:	4b32      	ldr	r3, [pc, #200]	; (800b768 <rle_next+0x1ac>)
 800b6a0:	781b      	ldrb	r3, [r3, #0]
 800b6a2:	461a      	mov	r2, r3
 800b6a4:	f7ff fea9 	bl	800b3fa <get_bits>
 800b6a8:	4603      	mov	r3, r0
 800b6aa:	71fb      	strb	r3, [r7, #7]
                    rle_prev_v = ret;
 800b6ac:	4a2f      	ldr	r2, [pc, #188]	; (800b76c <rle_next+0x1b0>)
 800b6ae:	79fb      	ldrb	r3, [r7, #7]
 800b6b0:	7013      	strb	r3, [r2, #0]
                    rle_rdp += rle_bpp;
 800b6b2:	4b2d      	ldr	r3, [pc, #180]	; (800b768 <rle_next+0x1ac>)
 800b6b4:	781b      	ldrb	r3, [r3, #0]
 800b6b6:	461a      	mov	r2, r3
 800b6b8:	4b2a      	ldr	r3, [pc, #168]	; (800b764 <rle_next+0x1a8>)
 800b6ba:	681b      	ldr	r3, [r3, #0]
 800b6bc:	4413      	add	r3, r2
 800b6be:	4a29      	ldr	r2, [pc, #164]	; (800b764 <rle_next+0x1a8>)
 800b6c0:	6013      	str	r3, [r2, #0]
                    rle_state = RLE_STATE_SINGLE;
 800b6c2:	4b26      	ldr	r3, [pc, #152]	; (800b75c <rle_next+0x1a0>)
 800b6c4:	2200      	movs	r2, #0
 800b6c6:	701a      	strb	r2, [r3, #0]
 800b6c8:	e043      	b.n	800b752 <rle_next+0x196>
                }
            }
        } else {
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
 800b6ca:	4b25      	ldr	r3, [pc, #148]	; (800b760 <rle_next+0x1a4>)
 800b6cc:	6818      	ldr	r0, [r3, #0]
 800b6ce:	4b25      	ldr	r3, [pc, #148]	; (800b764 <rle_next+0x1a8>)
 800b6d0:	6819      	ldr	r1, [r3, #0]
 800b6d2:	4b25      	ldr	r3, [pc, #148]	; (800b768 <rle_next+0x1ac>)
 800b6d4:	781b      	ldrb	r3, [r3, #0]
 800b6d6:	461a      	mov	r2, r3
 800b6d8:	f7ff fe8f 	bl	800b3fa <get_bits>
 800b6dc:	4603      	mov	r3, r0
 800b6de:	71fb      	strb	r3, [r7, #7]
            rle_prev_v = ret;
 800b6e0:	4a22      	ldr	r2, [pc, #136]	; (800b76c <rle_next+0x1b0>)
 800b6e2:	79fb      	ldrb	r3, [r7, #7]
 800b6e4:	7013      	strb	r3, [r2, #0]
            rle_rdp += rle_bpp;
 800b6e6:	4b20      	ldr	r3, [pc, #128]	; (800b768 <rle_next+0x1ac>)
 800b6e8:	781b      	ldrb	r3, [r3, #0]
 800b6ea:	461a      	mov	r2, r3
 800b6ec:	4b1d      	ldr	r3, [pc, #116]	; (800b764 <rle_next+0x1a8>)
 800b6ee:	681b      	ldr	r3, [r3, #0]
 800b6f0:	4413      	add	r3, r2
 800b6f2:	4a1c      	ldr	r2, [pc, #112]	; (800b764 <rle_next+0x1a8>)
 800b6f4:	6013      	str	r3, [r2, #0]
            rle_state = RLE_STATE_SINGLE;
 800b6f6:	4b19      	ldr	r3, [pc, #100]	; (800b75c <rle_next+0x1a0>)
 800b6f8:	2200      	movs	r2, #0
 800b6fa:	701a      	strb	r2, [r3, #0]
 800b6fc:	e029      	b.n	800b752 <rle_next+0x196>
        }


    }
    else if(rle_state == RLE_STATE_COUNTER) {
 800b6fe:	4b17      	ldr	r3, [pc, #92]	; (800b75c <rle_next+0x1a0>)
 800b700:	781b      	ldrb	r3, [r3, #0]
 800b702:	2b02      	cmp	r3, #2
 800b704:	d125      	bne.n	800b752 <rle_next+0x196>
        ret = rle_prev_v;
 800b706:	4b19      	ldr	r3, [pc, #100]	; (800b76c <rle_next+0x1b0>)
 800b708:	781b      	ldrb	r3, [r3, #0]
 800b70a:	71fb      	strb	r3, [r7, #7]
        rle_cnt--;
 800b70c:	4b18      	ldr	r3, [pc, #96]	; (800b770 <rle_next+0x1b4>)
 800b70e:	781b      	ldrb	r3, [r3, #0]
 800b710:	3b01      	subs	r3, #1
 800b712:	b2da      	uxtb	r2, r3
 800b714:	4b16      	ldr	r3, [pc, #88]	; (800b770 <rle_next+0x1b4>)
 800b716:	701a      	strb	r2, [r3, #0]
        if(rle_cnt == 0) {
 800b718:	4b15      	ldr	r3, [pc, #84]	; (800b770 <rle_next+0x1b4>)
 800b71a:	781b      	ldrb	r3, [r3, #0]
 800b71c:	2b00      	cmp	r3, #0
 800b71e:	d118      	bne.n	800b752 <rle_next+0x196>
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
 800b720:	4b0f      	ldr	r3, [pc, #60]	; (800b760 <rle_next+0x1a4>)
 800b722:	6818      	ldr	r0, [r3, #0]
 800b724:	4b0f      	ldr	r3, [pc, #60]	; (800b764 <rle_next+0x1a8>)
 800b726:	6819      	ldr	r1, [r3, #0]
 800b728:	4b0f      	ldr	r3, [pc, #60]	; (800b768 <rle_next+0x1ac>)
 800b72a:	781b      	ldrb	r3, [r3, #0]
 800b72c:	461a      	mov	r2, r3
 800b72e:	f7ff fe64 	bl	800b3fa <get_bits>
 800b732:	4603      	mov	r3, r0
 800b734:	71fb      	strb	r3, [r7, #7]
            rle_prev_v = ret;
 800b736:	4a0d      	ldr	r2, [pc, #52]	; (800b76c <rle_next+0x1b0>)
 800b738:	79fb      	ldrb	r3, [r7, #7]
 800b73a:	7013      	strb	r3, [r2, #0]
            rle_rdp += rle_bpp;
 800b73c:	4b0a      	ldr	r3, [pc, #40]	; (800b768 <rle_next+0x1ac>)
 800b73e:	781b      	ldrb	r3, [r3, #0]
 800b740:	461a      	mov	r2, r3
 800b742:	4b08      	ldr	r3, [pc, #32]	; (800b764 <rle_next+0x1a8>)
 800b744:	681b      	ldr	r3, [r3, #0]
 800b746:	4413      	add	r3, r2
 800b748:	4a06      	ldr	r2, [pc, #24]	; (800b764 <rle_next+0x1a8>)
 800b74a:	6013      	str	r3, [r2, #0]
            rle_state = RLE_STATE_SINGLE;
 800b74c:	4b03      	ldr	r3, [pc, #12]	; (800b75c <rle_next+0x1a0>)
 800b74e:	2200      	movs	r2, #0
 800b750:	701a      	strb	r2, [r3, #0]
        }
    }

    return ret;
 800b752:	79fb      	ldrb	r3, [r7, #7]
}
 800b754:	4618      	mov	r0, r3
 800b756:	3708      	adds	r7, #8
 800b758:	46bd      	mov	sp, r7
 800b75a:	bd80      	pop	{r7, pc}
 800b75c:	2000029b 	.word	0x2000029b
 800b760:	20000294 	.word	0x20000294
 800b764:	20000290 	.word	0x20000290
 800b768:	20000298 	.word	0x20000298
 800b76c:	20000299 	.word	0x20000299
 800b770:	2000029a 	.word	0x2000029a

0800b774 <unicode_list_compare>:
 *  @retval = 0   Reference is equal to element.
 *  @retval > 0   Reference is less than element.
 *
 */
static int32_t unicode_list_compare(const void * ref, const void * element)
{
 800b774:	b480      	push	{r7}
 800b776:	b083      	sub	sp, #12
 800b778:	af00      	add	r7, sp, #0
 800b77a:	6078      	str	r0, [r7, #4]
 800b77c:	6039      	str	r1, [r7, #0]
    return ((int32_t)(*(uint16_t *)ref)) - ((int32_t)(*(uint16_t *)element));
 800b77e:	687b      	ldr	r3, [r7, #4]
 800b780:	881b      	ldrh	r3, [r3, #0]
 800b782:	461a      	mov	r2, r3
 800b784:	683b      	ldr	r3, [r7, #0]
 800b786:	881b      	ldrh	r3, [r3, #0]
 800b788:	1ad3      	subs	r3, r2, r3
}
 800b78a:	4618      	mov	r0, r3
 800b78c:	370c      	adds	r7, #12
 800b78e:	46bd      	mov	sp, r7
 800b790:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b794:	4770      	bx	lr

0800b796 <lv_disp_drv_init>:
 * It is used to surly have known values in the fields ant not memory junk.
 * After it you can set the fields.
 * @param driver pointer to driver variable to initialize
 */
void lv_disp_drv_init(lv_disp_drv_t * driver)
{
 800b796:	b580      	push	{r7, lr}
 800b798:	b082      	sub	sp, #8
 800b79a:	af00      	add	r7, sp, #0
 800b79c:	6078      	str	r0, [r7, #4]
    memset(driver, 0, sizeof(lv_disp_drv_t));
 800b79e:	2228      	movs	r2, #40	; 0x28
 800b7a0:	2100      	movs	r1, #0
 800b7a2:	6878      	ldr	r0, [r7, #4]
 800b7a4:	f007 ffdb 	bl	801375e <memset>

    driver->flush_cb         = NULL;
 800b7a8:	687b      	ldr	r3, [r7, #4]
 800b7aa:	2200      	movs	r2, #0
 800b7ac:	60da      	str	r2, [r3, #12]
    driver->hor_res          = LV_HOR_RES_MAX;
 800b7ae:	687b      	ldr	r3, [r7, #4]
 800b7b0:	22f0      	movs	r2, #240	; 0xf0
 800b7b2:	801a      	strh	r2, [r3, #0]
    driver->ver_res          = LV_VER_RES_MAX;
 800b7b4:	687b      	ldr	r3, [r7, #4]
 800b7b6:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800b7ba:	805a      	strh	r2, [r3, #2]
    driver->buffer           = NULL;
 800b7bc:	687b      	ldr	r3, [r7, #4]
 800b7be:	2200      	movs	r2, #0
 800b7c0:	605a      	str	r2, [r3, #4]
    driver->rotated          = 0;
 800b7c2:	687a      	ldr	r2, [r7, #4]
 800b7c4:	7a13      	ldrb	r3, [r2, #8]
 800b7c6:	f36f 0341 	bfc	r3, #1, #1
 800b7ca:	7213      	strb	r3, [r2, #8]
    driver->color_chroma_key = LV_COLOR_TRANSP;
 800b7cc:	687a      	ldr	r2, [r7, #4]
 800b7ce:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 800b7d2:	f36f 0304 	bfc	r3, #0, #5
 800b7d6:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
 800b7da:	687a      	ldr	r2, [r7, #4]
 800b7dc:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 800b7de:	f443 63fc 	orr.w	r3, r3, #2016	; 0x7e0
 800b7e2:	8493      	strh	r3, [r2, #36]	; 0x24
 800b7e4:	687a      	ldr	r2, [r7, #4]
 800b7e6:	f892 3025 	ldrb.w	r3, [r2, #37]	; 0x25
 800b7ea:	f36f 03c7 	bfc	r3, #3, #5
 800b7ee:	f882 3025 	strb.w	r3, [r2, #37]	; 0x25

#if LV_ANTIALIAS
    driver->antialiasing = true;
 800b7f2:	687a      	ldr	r2, [r7, #4]
 800b7f4:	7a13      	ldrb	r3, [r2, #8]
 800b7f6:	f043 0301 	orr.w	r3, r3, #1
 800b7fa:	7213      	strb	r3, [r2, #8]
#if LV_COLOR_SCREEN_TRANSP
    driver->screen_transp = 1;
#endif

#if LV_USE_GPU
    driver->gpu_blend_cb = NULL;
 800b7fc:	687b      	ldr	r3, [r7, #4]
 800b7fe:	2200      	movs	r2, #0
 800b800:	61da      	str	r2, [r3, #28]
    driver->gpu_fill_cb  = NULL;
 800b802:	687b      	ldr	r3, [r7, #4]
 800b804:	2200      	movs	r2, #0
 800b806:	621a      	str	r2, [r3, #32]

#if LV_USE_USER_DATA
    driver->user_data = NULL;
#endif

    driver->set_px_cb = NULL;
 800b808:	687b      	ldr	r3, [r7, #4]
 800b80a:	2200      	movs	r2, #0
 800b80c:	615a      	str	r2, [r3, #20]
}
 800b80e:	bf00      	nop
 800b810:	3708      	adds	r7, #8
 800b812:	46bd      	mov	sp, r7
 800b814:	bd80      	pop	{r7, pc}

0800b816 <lv_disp_buf_init>:
 *             It lets LittlevGL to render next frame into the other buffer while previous is being
 * sent. Set to `NULL` if unused.
 * @param size_in_px_cnt size of the `buf1` and `buf2` in pixel count.
 */
void lv_disp_buf_init(lv_disp_buf_t * disp_buf, void * buf1, void * buf2, uint32_t size_in_px_cnt)
{
 800b816:	b580      	push	{r7, lr}
 800b818:	b084      	sub	sp, #16
 800b81a:	af00      	add	r7, sp, #0
 800b81c:	60f8      	str	r0, [r7, #12]
 800b81e:	60b9      	str	r1, [r7, #8]
 800b820:	607a      	str	r2, [r7, #4]
 800b822:	603b      	str	r3, [r7, #0]
    memset(disp_buf, 0, sizeof(lv_disp_buf_t));
 800b824:	221c      	movs	r2, #28
 800b826:	2100      	movs	r1, #0
 800b828:	68f8      	ldr	r0, [r7, #12]
 800b82a:	f007 ff98 	bl	801375e <memset>

    disp_buf->buf1    = buf1;
 800b82e:	68fb      	ldr	r3, [r7, #12]
 800b830:	68ba      	ldr	r2, [r7, #8]
 800b832:	601a      	str	r2, [r3, #0]
    disp_buf->buf2    = buf2;
 800b834:	68fb      	ldr	r3, [r7, #12]
 800b836:	687a      	ldr	r2, [r7, #4]
 800b838:	605a      	str	r2, [r3, #4]
    disp_buf->buf_act = disp_buf->buf1;
 800b83a:	68fb      	ldr	r3, [r7, #12]
 800b83c:	681a      	ldr	r2, [r3, #0]
 800b83e:	68fb      	ldr	r3, [r7, #12]
 800b840:	609a      	str	r2, [r3, #8]
    disp_buf->size    = size_in_px_cnt;
 800b842:	68fb      	ldr	r3, [r7, #12]
 800b844:	683a      	ldr	r2, [r7, #0]
 800b846:	60da      	str	r2, [r3, #12]
}
 800b848:	bf00      	nop
 800b84a:	3710      	adds	r7, #16
 800b84c:	46bd      	mov	sp, r7
 800b84e:	bd80      	pop	{r7, pc}

0800b850 <lv_disp_drv_register>:
 * Automatically set the first display as active.
 * @param driver pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)
 * @return pointer to the new display or NULL on error
 */
lv_disp_t * lv_disp_drv_register(lv_disp_drv_t * driver)
{
 800b850:	b590      	push	{r4, r7, lr}
 800b852:	b085      	sub	sp, #20
 800b854:	af00      	add	r7, sp, #0
 800b856:	6078      	str	r0, [r7, #4]
    lv_disp_t * disp = lv_ll_ins_head(&LV_GC_ROOT(_lv_disp_ll));
 800b858:	4852      	ldr	r0, [pc, #328]	; (800b9a4 <lv_disp_drv_register+0x154>)
 800b85a:	f000 ff4d 	bl	800c6f8 <lv_ll_ins_head>
 800b85e:	60f8      	str	r0, [r7, #12]
    if(!disp) {
 800b860:	68fb      	ldr	r3, [r7, #12]
 800b862:	2b00      	cmp	r3, #0
 800b864:	d113      	bne.n	800b88e <lv_disp_drv_register+0x3e>
        LV_ASSERT_MEM(disp);
 800b866:	68f8      	ldr	r0, [r7, #12]
 800b868:	f7f4 fcc6 	bl	80001f8 <lv_debug_check_null>
 800b86c:	4603      	mov	r3, r0
 800b86e:	f083 0301 	eor.w	r3, r3, #1
 800b872:	b2db      	uxtb	r3, r3
 800b874:	2b00      	cmp	r3, #0
 800b876:	d008      	beq.n	800b88a <lv_disp_drv_register+0x3a>
 800b878:	68fb      	ldr	r3, [r7, #12]
 800b87a:	f04f 0400 	mov.w	r4, #0
 800b87e:	461a      	mov	r2, r3
 800b880:	4623      	mov	r3, r4
 800b882:	4849      	ldr	r0, [pc, #292]	; (800b9a8 <lv_disp_drv_register+0x158>)
 800b884:	f7f4 fce2 	bl	800024c <lv_debug_log_error>
 800b888:	e7fe      	b.n	800b888 <lv_disp_drv_register+0x38>
        return NULL;
 800b88a:	2300      	movs	r3, #0
 800b88c:	e086      	b.n	800b99c <lv_disp_drv_register+0x14c>
    }

    memcpy(&disp->driver, driver, sizeof(lv_disp_drv_t));
 800b88e:	68fb      	ldr	r3, [r7, #12]
 800b890:	2228      	movs	r2, #40	; 0x28
 800b892:	6879      	ldr	r1, [r7, #4]
 800b894:	4618      	mov	r0, r3
 800b896:	f007 ff57 	bl	8013748 <memcpy>
    memset(&disp->inv_area_joined, 0, sizeof(disp->inv_area_joined));
 800b89a:	68fb      	ldr	r3, [r7, #12]
 800b89c:	f503 73a2 	add.w	r3, r3, #324	; 0x144
 800b8a0:	2220      	movs	r2, #32
 800b8a2:	2100      	movs	r1, #0
 800b8a4:	4618      	mov	r0, r3
 800b8a6:	f007 ff5a 	bl	801375e <memset>
    memset(&disp->inv_areas, 0, sizeof(disp->inv_areas));
 800b8aa:	68fb      	ldr	r3, [r7, #12]
 800b8ac:	3344      	adds	r3, #68	; 0x44
 800b8ae:	f44f 7280 	mov.w	r2, #256	; 0x100
 800b8b2:	2100      	movs	r1, #0
 800b8b4:	4618      	mov	r0, r3
 800b8b6:	f007 ff52 	bl	801375e <memset>
    lv_ll_init(&disp->scr_ll, sizeof(lv_obj_t));
 800b8ba:	68fb      	ldr	r3, [r7, #12]
 800b8bc:	332c      	adds	r3, #44	; 0x2c
 800b8be:	2144      	movs	r1, #68	; 0x44
 800b8c0:	4618      	mov	r0, r3
 800b8c2:	f000 fef9 	bl	800c6b8 <lv_ll_init>
    disp->last_activity_time = 0;
 800b8c6:	68fb      	ldr	r3, [r7, #12]
 800b8c8:	2200      	movs	r2, #0
 800b8ca:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168

    if(disp_def == NULL) disp_def = disp;
 800b8ce:	4b37      	ldr	r3, [pc, #220]	; (800b9ac <lv_disp_drv_register+0x15c>)
 800b8d0:	681b      	ldr	r3, [r3, #0]
 800b8d2:	2b00      	cmp	r3, #0
 800b8d4:	d102      	bne.n	800b8dc <lv_disp_drv_register+0x8c>
 800b8d6:	4a35      	ldr	r2, [pc, #212]	; (800b9ac <lv_disp_drv_register+0x15c>)
 800b8d8:	68fb      	ldr	r3, [r7, #12]
 800b8da:	6013      	str	r3, [r2, #0]

    lv_disp_t * disp_def_tmp = disp_def;
 800b8dc:	4b33      	ldr	r3, [pc, #204]	; (800b9ac <lv_disp_drv_register+0x15c>)
 800b8de:	681b      	ldr	r3, [r3, #0]
 800b8e0:	60bb      	str	r3, [r7, #8]
    disp_def                 = disp; /*Temporarily change the default screen to create the default screens on the
 800b8e2:	4a32      	ldr	r2, [pc, #200]	; (800b9ac <lv_disp_drv_register+0x15c>)
 800b8e4:	68fb      	ldr	r3, [r7, #12]
 800b8e6:	6013      	str	r3, [r2, #0]
                                        new display*/

    disp->inv_p = 0;
 800b8e8:	68fa      	ldr	r2, [r7, #12]
 800b8ea:	f8b2 3164 	ldrh.w	r3, [r2, #356]	; 0x164
 800b8ee:	f36f 0309 	bfc	r3, #0, #10
 800b8f2:	f8a2 3164 	strh.w	r3, [r2, #356]	; 0x164

    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
 800b8f6:	2100      	movs	r1, #0
 800b8f8:	2000      	movs	r0, #0
 800b8fa:	f7f5 f83b 	bl	8000974 <lv_obj_create>
 800b8fe:	4602      	mov	r2, r0
 800b900:	68fb      	ldr	r3, [r7, #12]
 800b902:	639a      	str	r2, [r3, #56]	; 0x38
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
 800b904:	2100      	movs	r1, #0
 800b906:	2000      	movs	r0, #0
 800b908:	f7f5 f834 	bl	8000974 <lv_obj_create>
 800b90c:	4602      	mov	r2, r0
 800b90e:	68fb      	ldr	r3, [r7, #12]
 800b910:	63da      	str	r2, [r3, #60]	; 0x3c
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
 800b912:	2100      	movs	r1, #0
 800b914:	2000      	movs	r0, #0
 800b916:	f7f5 f82d 	bl	8000974 <lv_obj_create>
 800b91a:	4602      	mov	r2, r0
 800b91c:	68fb      	ldr	r3, [r7, #12]
 800b91e:	641a      	str	r2, [r3, #64]	; 0x40
    lv_obj_set_style(disp->top_layer, &lv_style_transp);
 800b920:	68fb      	ldr	r3, [r7, #12]
 800b922:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b924:	4922      	ldr	r1, [pc, #136]	; (800b9b0 <lv_disp_drv_register+0x160>)
 800b926:	4618      	mov	r0, r3
 800b928:	f7f6 fb08 	bl	8001f3c <lv_obj_set_style>
    lv_obj_set_style(disp->sys_layer, &lv_style_transp);
 800b92c:	68fb      	ldr	r3, [r7, #12]
 800b92e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b930:	491f      	ldr	r1, [pc, #124]	; (800b9b0 <lv_disp_drv_register+0x160>)
 800b932:	4618      	mov	r0, r3
 800b934:	f7f6 fb02 	bl	8001f3c <lv_obj_set_style>

    lv_obj_invalidate(disp->act_scr);
 800b938:	68fb      	ldr	r3, [r7, #12]
 800b93a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b93c:	4618      	mov	r0, r3
 800b93e:	f7f5 fbad 	bl	800109c <lv_obj_invalidate>

    disp_def = disp_def_tmp; /*Revert the default display*/
 800b942:	4a1a      	ldr	r2, [pc, #104]	; (800b9ac <lv_disp_drv_register+0x15c>)
 800b944:	68bb      	ldr	r3, [r7, #8]
 800b946:	6013      	str	r3, [r2, #0]

    /*Create a refresh task*/
    disp->refr_task = lv_task_create(lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, disp);
 800b948:	68fb      	ldr	r3, [r7, #12]
 800b94a:	2203      	movs	r2, #3
 800b94c:	211e      	movs	r1, #30
 800b94e:	4819      	ldr	r0, [pc, #100]	; (800b9b4 <lv_disp_drv_register+0x164>)
 800b950:	f001 fc94 	bl	800d27c <lv_task_create>
 800b954:	4602      	mov	r2, r0
 800b956:	68fb      	ldr	r3, [r7, #12]
 800b958:	629a      	str	r2, [r3, #40]	; 0x28
    LV_ASSERT_MEM(disp->refr_task);
 800b95a:	68fb      	ldr	r3, [r7, #12]
 800b95c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b95e:	4618      	mov	r0, r3
 800b960:	f7f4 fc4a 	bl	80001f8 <lv_debug_check_null>
 800b964:	4603      	mov	r3, r0
 800b966:	f083 0301 	eor.w	r3, r3, #1
 800b96a:	b2db      	uxtb	r3, r3
 800b96c:	2b00      	cmp	r3, #0
 800b96e:	d009      	beq.n	800b984 <lv_disp_drv_register+0x134>
 800b970:	68fb      	ldr	r3, [r7, #12]
 800b972:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b974:	f04f 0400 	mov.w	r4, #0
 800b978:	461a      	mov	r2, r3
 800b97a:	4623      	mov	r3, r4
 800b97c:	480a      	ldr	r0, [pc, #40]	; (800b9a8 <lv_disp_drv_register+0x158>)
 800b97e:	f7f4 fc65 	bl	800024c <lv_debug_log_error>
 800b982:	e7fe      	b.n	800b982 <lv_disp_drv_register+0x132>
    if(disp->refr_task == NULL) return NULL;
 800b984:	68fb      	ldr	r3, [r7, #12]
 800b986:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b988:	2b00      	cmp	r3, #0
 800b98a:	d101      	bne.n	800b990 <lv_disp_drv_register+0x140>
 800b98c:	2300      	movs	r3, #0
 800b98e:	e005      	b.n	800b99c <lv_disp_drv_register+0x14c>

    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
 800b990:	68fb      	ldr	r3, [r7, #12]
 800b992:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b994:	4618      	mov	r0, r3
 800b996:	f001 fd2f 	bl	800d3f8 <lv_task_ready>

    return disp;
 800b99a:	68fb      	ldr	r3, [r7, #12]
}
 800b99c:	4618      	mov	r0, r3
 800b99e:	3714      	adds	r7, #20
 800b9a0:	46bd      	mov	sp, r7
 800b9a2:	bd90      	pop	{r4, r7, pc}
 800b9a4:	2000995c 	.word	0x2000995c
 800b9a8:	08013868 	.word	0x08013868
 800b9ac:	200002a0 	.word	0x200002a0
 800b9b0:	20009640 	.word	0x20009640
 800b9b4:	08002f6d 	.word	0x08002f6d

0800b9b8 <lv_disp_get_default>:
/**
 * Get the default display
 * @return pointer to the default display
 */
lv_disp_t * lv_disp_get_default(void)
{
 800b9b8:	b480      	push	{r7}
 800b9ba:	af00      	add	r7, sp, #0
    return disp_def;
 800b9bc:	4b03      	ldr	r3, [pc, #12]	; (800b9cc <lv_disp_get_default+0x14>)
 800b9be:	681b      	ldr	r3, [r3, #0]
}
 800b9c0:	4618      	mov	r0, r3
 800b9c2:	46bd      	mov	sp, r7
 800b9c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9c8:	4770      	bx	lr
 800b9ca:	bf00      	nop
 800b9cc:	200002a0 	.word	0x200002a0

0800b9d0 <lv_disp_get_hor_res>:
 * Get the horizontal resolution of a display
 * @param disp pointer to a display (NULL to use the default display)
 * @return the horizontal resolution of the display
 */
lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)
{
 800b9d0:	b580      	push	{r7, lr}
 800b9d2:	b082      	sub	sp, #8
 800b9d4:	af00      	add	r7, sp, #0
 800b9d6:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_disp_get_default();
 800b9d8:	687b      	ldr	r3, [r7, #4]
 800b9da:	2b00      	cmp	r3, #0
 800b9dc:	d102      	bne.n	800b9e4 <lv_disp_get_hor_res+0x14>
 800b9de:	f7ff ffeb 	bl	800b9b8 <lv_disp_get_default>
 800b9e2:	6078      	str	r0, [r7, #4]

    if(disp == NULL)
 800b9e4:	687b      	ldr	r3, [r7, #4]
 800b9e6:	2b00      	cmp	r3, #0
 800b9e8:	d101      	bne.n	800b9ee <lv_disp_get_hor_res+0x1e>
        return LV_HOR_RES_MAX;
 800b9ea:	23f0      	movs	r3, #240	; 0xf0
 800b9ec:	e00d      	b.n	800ba0a <lv_disp_get_hor_res+0x3a>
    else
        return disp->driver.rotated == 0 ? disp->driver.hor_res : disp->driver.ver_res;
 800b9ee:	687b      	ldr	r3, [r7, #4]
 800b9f0:	7a1b      	ldrb	r3, [r3, #8]
 800b9f2:	f003 0302 	and.w	r3, r3, #2
 800b9f6:	b2db      	uxtb	r3, r3
 800b9f8:	2b00      	cmp	r3, #0
 800b9fa:	d103      	bne.n	800ba04 <lv_disp_get_hor_res+0x34>
 800b9fc:	687b      	ldr	r3, [r7, #4]
 800b9fe:	f9b3 3000 	ldrsh.w	r3, [r3]
 800ba02:	e002      	b.n	800ba0a <lv_disp_get_hor_res+0x3a>
 800ba04:	687b      	ldr	r3, [r7, #4]
 800ba06:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
}
 800ba0a:	4618      	mov	r0, r3
 800ba0c:	3708      	adds	r7, #8
 800ba0e:	46bd      	mov	sp, r7
 800ba10:	bd80      	pop	{r7, pc}

0800ba12 <lv_disp_get_ver_res>:
 * Get the vertical resolution of a display
 * @param disp pointer to a display (NULL to use the default display)
 * @return the vertical resolution of the display
 */
lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)
{
 800ba12:	b580      	push	{r7, lr}
 800ba14:	b082      	sub	sp, #8
 800ba16:	af00      	add	r7, sp, #0
 800ba18:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_disp_get_default();
 800ba1a:	687b      	ldr	r3, [r7, #4]
 800ba1c:	2b00      	cmp	r3, #0
 800ba1e:	d102      	bne.n	800ba26 <lv_disp_get_ver_res+0x14>
 800ba20:	f7ff ffca 	bl	800b9b8 <lv_disp_get_default>
 800ba24:	6078      	str	r0, [r7, #4]

    if(disp == NULL)
 800ba26:	687b      	ldr	r3, [r7, #4]
 800ba28:	2b00      	cmp	r3, #0
 800ba2a:	d102      	bne.n	800ba32 <lv_disp_get_ver_res+0x20>
        return LV_VER_RES_MAX;
 800ba2c:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800ba30:	e00d      	b.n	800ba4e <lv_disp_get_ver_res+0x3c>
    else
        return disp->driver.rotated == 0 ? disp->driver.ver_res : disp->driver.hor_res;
 800ba32:	687b      	ldr	r3, [r7, #4]
 800ba34:	7a1b      	ldrb	r3, [r3, #8]
 800ba36:	f003 0302 	and.w	r3, r3, #2
 800ba3a:	b2db      	uxtb	r3, r3
 800ba3c:	2b00      	cmp	r3, #0
 800ba3e:	d103      	bne.n	800ba48 <lv_disp_get_ver_res+0x36>
 800ba40:	687b      	ldr	r3, [r7, #4]
 800ba42:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800ba46:	e002      	b.n	800ba4e <lv_disp_get_ver_res+0x3c>
 800ba48:	687b      	ldr	r3, [r7, #4]
 800ba4a:	f9b3 3000 	ldrsh.w	r3, [r3]
}
 800ba4e:	4618      	mov	r0, r3
 800ba50:	3708      	adds	r7, #8
 800ba52:	46bd      	mov	sp, r7
 800ba54:	bd80      	pop	{r7, pc}

0800ba56 <lv_disp_get_antialiasing>:
 * Get if anti-aliasing is enabled for a display or not
 * @param disp pointer to a display (NULL to use the default display)
 * @return true: anti-aliasing is enabled; false: disabled
 */
bool lv_disp_get_antialiasing(lv_disp_t * disp)
{
 800ba56:	b580      	push	{r7, lr}
 800ba58:	b082      	sub	sp, #8
 800ba5a:	af00      	add	r7, sp, #0
 800ba5c:	6078      	str	r0, [r7, #4]
#if LV_ANTIALIAS == 0
    return false;
#else
    if(disp == NULL) disp = lv_disp_get_default();
 800ba5e:	687b      	ldr	r3, [r7, #4]
 800ba60:	2b00      	cmp	r3, #0
 800ba62:	d102      	bne.n	800ba6a <lv_disp_get_antialiasing+0x14>
 800ba64:	f7ff ffa8 	bl	800b9b8 <lv_disp_get_default>
 800ba68:	6078      	str	r0, [r7, #4]
    if(disp == NULL) return false;
 800ba6a:	687b      	ldr	r3, [r7, #4]
 800ba6c:	2b00      	cmp	r3, #0
 800ba6e:	d101      	bne.n	800ba74 <lv_disp_get_antialiasing+0x1e>
 800ba70:	2300      	movs	r3, #0
 800ba72:	e008      	b.n	800ba86 <lv_disp_get_antialiasing+0x30>

    return disp->driver.antialiasing ? true : false;
 800ba74:	687b      	ldr	r3, [r7, #4]
 800ba76:	7a1b      	ldrb	r3, [r3, #8]
 800ba78:	f003 0301 	and.w	r3, r3, #1
 800ba7c:	2b00      	cmp	r3, #0
 800ba7e:	bf14      	ite	ne
 800ba80:	2301      	movne	r3, #1
 800ba82:	2300      	moveq	r3, #0
 800ba84:	b2db      	uxtb	r3, r3
#endif
}
 800ba86:	4618      	mov	r0, r3
 800ba88:	3708      	adds	r7, #8
 800ba8a:	46bd      	mov	sp, r7
 800ba8c:	bd80      	pop	{r7, pc}

0800ba8e <lv_disp_flush_ready>:
/**
 * Call in the display driver's `flush_cb` function when the flushing is finished
 * @param disp_drv pointer to display driver in `flush_cb` where this function is called
 */
LV_ATTRIBUTE_FLUSH_READY void lv_disp_flush_ready(lv_disp_drv_t * disp_drv)
{
 800ba8e:	b480      	push	{r7}
 800ba90:	b083      	sub	sp, #12
 800ba92:	af00      	add	r7, sp, #0
 800ba94:	6078      	str	r0, [r7, #4]
    if(disp_drv->screen_transp) {
        memset(disp_drv->buffer->buf_act, 0x00, disp_drv->buffer->size * sizeof(lv_color32_t));
    }
#endif

    disp_drv->buffer->flushing = 0;
 800ba96:	687b      	ldr	r3, [r7, #4]
 800ba98:	685a      	ldr	r2, [r3, #4]
 800ba9a:	7e13      	ldrb	r3, [r2, #24]
 800ba9c:	f36f 0300 	bfc	r3, #0, #1
 800baa0:	7613      	strb	r3, [r2, #24]
}
 800baa2:	bf00      	nop
 800baa4:	370c      	adds	r7, #12
 800baa6:	46bd      	mov	sp, r7
 800baa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800baac:	4770      	bx	lr

0800baae <lv_disp_get_buf>:
 * Get the internal buffer of a display
 * @param disp pointer to a display
 * @return pointer to the internal buffers
 */
lv_disp_buf_t * lv_disp_get_buf(lv_disp_t * disp)
{
 800baae:	b480      	push	{r7}
 800bab0:	b083      	sub	sp, #12
 800bab2:	af00      	add	r7, sp, #0
 800bab4:	6078      	str	r0, [r7, #4]
    return disp->driver.buffer;
 800bab6:	687b      	ldr	r3, [r7, #4]
 800bab8:	685b      	ldr	r3, [r3, #4]
}
 800baba:	4618      	mov	r0, r3
 800babc:	370c      	adds	r7, #12
 800babe:	46bd      	mov	sp, r7
 800bac0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bac4:	4770      	bx	lr

0800bac6 <lv_disp_is_double_buf>:
 * Check the driver configuration if it's double buffered (both `buf1` and `buf2` are set)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_double_buf(lv_disp_t * disp)
{
 800bac6:	b480      	push	{r7}
 800bac8:	b083      	sub	sp, #12
 800baca:	af00      	add	r7, sp, #0
 800bacc:	6078      	str	r0, [r7, #4]
    if(disp->driver.buffer->buf1 && disp->driver.buffer->buf2)
 800bace:	687b      	ldr	r3, [r7, #4]
 800bad0:	685b      	ldr	r3, [r3, #4]
 800bad2:	681b      	ldr	r3, [r3, #0]
 800bad4:	2b00      	cmp	r3, #0
 800bad6:	d006      	beq.n	800bae6 <lv_disp_is_double_buf+0x20>
 800bad8:	687b      	ldr	r3, [r7, #4]
 800bada:	685b      	ldr	r3, [r3, #4]
 800badc:	685b      	ldr	r3, [r3, #4]
 800bade:	2b00      	cmp	r3, #0
 800bae0:	d001      	beq.n	800bae6 <lv_disp_is_double_buf+0x20>
        return true;
 800bae2:	2301      	movs	r3, #1
 800bae4:	e000      	b.n	800bae8 <lv_disp_is_double_buf+0x22>
    else
        return false;
 800bae6:	2300      	movs	r3, #0
}
 800bae8:	4618      	mov	r0, r3
 800baea:	370c      	adds	r7, #12
 800baec:	46bd      	mov	sp, r7
 800baee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800baf2:	4770      	bx	lr

0800baf4 <lv_disp_is_true_double_buf>:
 * `size` is screen sized)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_true_double_buf(lv_disp_t * disp)
{
 800baf4:	b580      	push	{r7, lr}
 800baf6:	b084      	sub	sp, #16
 800baf8:	af00      	add	r7, sp, #0
 800bafa:	6078      	str	r0, [r7, #4]
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;
 800bafc:	687b      	ldr	r3, [r7, #4]
 800bafe:	f9b3 3000 	ldrsh.w	r3, [r3]
 800bb02:	461a      	mov	r2, r3
 800bb04:	687b      	ldr	r3, [r7, #4]
 800bb06:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800bb0a:	fb03 f302 	mul.w	r3, r3, r2
 800bb0e:	60fb      	str	r3, [r7, #12]

    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
 800bb10:	6878      	ldr	r0, [r7, #4]
 800bb12:	f7ff ffd8 	bl	800bac6 <lv_disp_is_double_buf>
 800bb16:	4603      	mov	r3, r0
 800bb18:	2b00      	cmp	r3, #0
 800bb1a:	d007      	beq.n	800bb2c <lv_disp_is_true_double_buf+0x38>
 800bb1c:	687b      	ldr	r3, [r7, #4]
 800bb1e:	685b      	ldr	r3, [r3, #4]
 800bb20:	68db      	ldr	r3, [r3, #12]
 800bb22:	68fa      	ldr	r2, [r7, #12]
 800bb24:	429a      	cmp	r2, r3
 800bb26:	d101      	bne.n	800bb2c <lv_disp_is_true_double_buf+0x38>
        return true;
 800bb28:	2301      	movs	r3, #1
 800bb2a:	e000      	b.n	800bb2e <lv_disp_is_true_double_buf+0x3a>
    } else {
        return false;
 800bb2c:	2300      	movs	r3, #0
    }
}
 800bb2e:	4618      	mov	r0, r3
 800bb30:	3710      	adds	r7, #16
 800bb32:	46bd      	mov	sp, r7
 800bb34:	bd80      	pop	{r7, pc}
	...

0800bb38 <lv_indev_get_next>:
 * @param indev pointer to the current input device. NULL to initialize.
 * @return the next input devise or NULL if no more. Give the first input device when the parameter
 * is NULL
 */
lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
{
 800bb38:	b580      	push	{r7, lr}
 800bb3a:	b082      	sub	sp, #8
 800bb3c:	af00      	add	r7, sp, #0
 800bb3e:	6078      	str	r0, [r7, #4]
    if(indev == NULL)
 800bb40:	687b      	ldr	r3, [r7, #4]
 800bb42:	2b00      	cmp	r3, #0
 800bb44:	d104      	bne.n	800bb50 <lv_indev_get_next+0x18>
        return lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
 800bb46:	4807      	ldr	r0, [pc, #28]	; (800bb64 <lv_indev_get_next+0x2c>)
 800bb48:	f000 ff38 	bl	800c9bc <lv_ll_get_head>
 800bb4c:	4603      	mov	r3, r0
 800bb4e:	e004      	b.n	800bb5a <lv_indev_get_next+0x22>
    else
        return lv_ll_get_next(&LV_GC_ROOT(_lv_indev_ll), indev);
 800bb50:	6879      	ldr	r1, [r7, #4]
 800bb52:	4804      	ldr	r0, [pc, #16]	; (800bb64 <lv_indev_get_next+0x2c>)
 800bb54:	f000 ff58 	bl	800ca08 <lv_ll_get_next>
 800bb58:	4603      	mov	r3, r0
}
 800bb5a:	4618      	mov	r0, r3
 800bb5c:	3708      	adds	r7, #8
 800bb5e:	46bd      	mov	sp, r7
 800bb60:	bd80      	pop	{r7, pc}
 800bb62:	bf00      	nop
 800bb64:	2000994c 	.word	0x2000994c

0800bb68 <lv_tick_inc>:
/**
 * You have to call this function periodically
 * @param tick_period the call period of this function in milliseconds
 */
LV_ATTRIBUTE_TICK_INC void lv_tick_inc(uint32_t tick_period)
{
 800bb68:	b480      	push	{r7}
 800bb6a:	b083      	sub	sp, #12
 800bb6c:	af00      	add	r7, sp, #0
 800bb6e:	6078      	str	r0, [r7, #4]
    tick_irq_flag = 0;
 800bb70:	4b07      	ldr	r3, [pc, #28]	; (800bb90 <lv_tick_inc+0x28>)
 800bb72:	2200      	movs	r2, #0
 800bb74:	701a      	strb	r2, [r3, #0]
    sys_time += tick_period;
 800bb76:	4b07      	ldr	r3, [pc, #28]	; (800bb94 <lv_tick_inc+0x2c>)
 800bb78:	681a      	ldr	r2, [r3, #0]
 800bb7a:	687b      	ldr	r3, [r7, #4]
 800bb7c:	4413      	add	r3, r2
 800bb7e:	4a05      	ldr	r2, [pc, #20]	; (800bb94 <lv_tick_inc+0x2c>)
 800bb80:	6013      	str	r3, [r2, #0]
}
 800bb82:	bf00      	nop
 800bb84:	370c      	adds	r7, #12
 800bb86:	46bd      	mov	sp, r7
 800bb88:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb8c:	4770      	bx	lr
 800bb8e:	bf00      	nop
 800bb90:	200002a8 	.word	0x200002a8
 800bb94:	200002a4 	.word	0x200002a4

0800bb98 <lv_tick_get>:
/**
 * Get the elapsed milliseconds since start up
 * @return the elapsed milliseconds
 */
uint32_t lv_tick_get(void)
{
 800bb98:	b480      	push	{r7}
 800bb9a:	b083      	sub	sp, #12
 800bb9c:	af00      	add	r7, sp, #0
#if LV_TICK_CUSTOM == 0
    uint32_t result;
    do {
        tick_irq_flag = 1;
 800bb9e:	4b09      	ldr	r3, [pc, #36]	; (800bbc4 <lv_tick_get+0x2c>)
 800bba0:	2201      	movs	r2, #1
 800bba2:	701a      	strb	r2, [r3, #0]
        result        = sys_time;
 800bba4:	4b08      	ldr	r3, [pc, #32]	; (800bbc8 <lv_tick_get+0x30>)
 800bba6:	681b      	ldr	r3, [r3, #0]
 800bba8:	607b      	str	r3, [r7, #4]
    } while(!tick_irq_flag); /*'lv_tick_inc()' clears this flag which can be in an interrupt.
 800bbaa:	4b06      	ldr	r3, [pc, #24]	; (800bbc4 <lv_tick_get+0x2c>)
 800bbac:	781b      	ldrb	r3, [r3, #0]
 800bbae:	b2db      	uxtb	r3, r3
 800bbb0:	2b00      	cmp	r3, #0
 800bbb2:	d0f4      	beq.n	800bb9e <lv_tick_get+0x6>
                                Continue until make a non interrupted cycle */

    return result;
 800bbb4:	687b      	ldr	r3, [r7, #4]
#else
    return LV_TICK_CUSTOM_SYS_TIME_EXPR;
#endif
}
 800bbb6:	4618      	mov	r0, r3
 800bbb8:	370c      	adds	r7, #12
 800bbba:	46bd      	mov	sp, r7
 800bbbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bbc0:	4770      	bx	lr
 800bbc2:	bf00      	nop
 800bbc4:	200002a8 	.word	0x200002a8
 800bbc8:	200002a4 	.word	0x200002a4

0800bbcc <lv_tick_elaps>:
 * Get the elapsed milliseconds since a previous time stamp
 * @param prev_tick a previous time stamp (return value of systick_get() )
 * @return the elapsed milliseconds since 'prev_tick'
 */
uint32_t lv_tick_elaps(uint32_t prev_tick)
{
 800bbcc:	b580      	push	{r7, lr}
 800bbce:	b084      	sub	sp, #16
 800bbd0:	af00      	add	r7, sp, #0
 800bbd2:	6078      	str	r0, [r7, #4]
    uint32_t act_time = lv_tick_get();
 800bbd4:	f7ff ffe0 	bl	800bb98 <lv_tick_get>
 800bbd8:	60f8      	str	r0, [r7, #12]

    /*If there is no overflow in sys_time simple subtract*/
    if(act_time >= prev_tick) {
 800bbda:	68fa      	ldr	r2, [r7, #12]
 800bbdc:	687b      	ldr	r3, [r7, #4]
 800bbde:	429a      	cmp	r2, r3
 800bbe0:	d304      	bcc.n	800bbec <lv_tick_elaps+0x20>
        prev_tick = act_time - prev_tick;
 800bbe2:	68fa      	ldr	r2, [r7, #12]
 800bbe4:	687b      	ldr	r3, [r7, #4]
 800bbe6:	1ad3      	subs	r3, r2, r3
 800bbe8:	607b      	str	r3, [r7, #4]
 800bbea:	e006      	b.n	800bbfa <lv_tick_elaps+0x2e>
    } else {
        prev_tick = UINT32_MAX - prev_tick + 1;
 800bbec:	687b      	ldr	r3, [r7, #4]
 800bbee:	425b      	negs	r3, r3
 800bbf0:	607b      	str	r3, [r7, #4]
        prev_tick += act_time;
 800bbf2:	687a      	ldr	r2, [r7, #4]
 800bbf4:	68fb      	ldr	r3, [r7, #12]
 800bbf6:	4413      	add	r3, r2
 800bbf8:	607b      	str	r3, [r7, #4]
    }

    return prev_tick;
 800bbfa:	687b      	ldr	r3, [r7, #4]
}
 800bbfc:	4618      	mov	r0, r3
 800bbfe:	3710      	adds	r7, #16
 800bc00:	46bd      	mov	sp, r7
 800bc02:	bd80      	pop	{r7, pc}

0800bc04 <lv_anim_core_init>:

/**
 * Init. the animation module
 */
void lv_anim_core_init(void)
{
 800bc04:	b580      	push	{r7, lr}
 800bc06:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_anim_ll), sizeof(lv_anim_t));
 800bc08:	2124      	movs	r1, #36	; 0x24
 800bc0a:	4808      	ldr	r0, [pc, #32]	; (800bc2c <lv_anim_core_init+0x28>)
 800bc0c:	f000 fd54 	bl	800c6b8 <lv_ll_init>
    last_task_run = lv_tick_get();
 800bc10:	f7ff ffc2 	bl	800bb98 <lv_tick_get>
 800bc14:	4602      	mov	r2, r0
 800bc16:	4b06      	ldr	r3, [pc, #24]	; (800bc30 <lv_anim_core_init+0x2c>)
 800bc18:	601a      	str	r2, [r3, #0]
    lv_task_create(anim_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, NULL);
 800bc1a:	2300      	movs	r3, #0
 800bc1c:	2203      	movs	r2, #3
 800bc1e:	211e      	movs	r1, #30
 800bc20:	4804      	ldr	r0, [pc, #16]	; (800bc34 <lv_anim_core_init+0x30>)
 800bc22:	f001 fb2b 	bl	800d27c <lv_task_create>
}
 800bc26:	bf00      	nop
 800bc28:	bd80      	pop	{r7, pc}
 800bc2a:	bf00      	nop
 800bc2c:	20009988 	.word	0x20009988
 800bc30:	200002ac 	.word	0x200002ac
 800bc34:	0800be0d 	.word	0x0800be0d

0800bc38 <lv_anim_create>:
/**
 * Create an animation
 * @param a an initialized 'anim_t' variable. Not required after call.
 */
void lv_anim_create(lv_anim_t * a)
{
 800bc38:	b590      	push	{r4, r7, lr}
 800bc3a:	b085      	sub	sp, #20
 800bc3c:	af00      	add	r7, sp, #0
 800bc3e:	6078      	str	r0, [r7, #4]
    LV_LOG_TRACE("animation create started")
    /* Do not let two animations for the  same 'var' with the same 'fp'*/
    if(a->exec_cb != NULL) lv_anim_del(a->var, a->exec_cb); /*fp == NULL would delete all animations of var*/
 800bc40:	687b      	ldr	r3, [r7, #4]
 800bc42:	685b      	ldr	r3, [r3, #4]
 800bc44:	2b00      	cmp	r3, #0
 800bc46:	d007      	beq.n	800bc58 <lv_anim_create+0x20>
 800bc48:	687b      	ldr	r3, [r7, #4]
 800bc4a:	681a      	ldr	r2, [r3, #0]
 800bc4c:	687b      	ldr	r3, [r7, #4]
 800bc4e:	685b      	ldr	r3, [r3, #4]
 800bc50:	4619      	mov	r1, r3
 800bc52:	4610      	mov	r0, r2
 800bc54:	f000 f840 	bl	800bcd8 <lv_anim_del>

    /*Add the new animation to the animation linked list*/
    lv_anim_t * new_anim = lv_ll_ins_head(&LV_GC_ROOT(_lv_anim_ll));
 800bc58:	481c      	ldr	r0, [pc, #112]	; (800bccc <lv_anim_create+0x94>)
 800bc5a:	f000 fd4d 	bl	800c6f8 <lv_ll_ins_head>
 800bc5e:	60f8      	str	r0, [r7, #12]
    LV_ASSERT_MEM(new_anim);
 800bc60:	68f8      	ldr	r0, [r7, #12]
 800bc62:	f7f4 fac9 	bl	80001f8 <lv_debug_check_null>
 800bc66:	4603      	mov	r3, r0
 800bc68:	f083 0301 	eor.w	r3, r3, #1
 800bc6c:	b2db      	uxtb	r3, r3
 800bc6e:	2b00      	cmp	r3, #0
 800bc70:	d008      	beq.n	800bc84 <lv_anim_create+0x4c>
 800bc72:	68fb      	ldr	r3, [r7, #12]
 800bc74:	f04f 0400 	mov.w	r4, #0
 800bc78:	461a      	mov	r2, r3
 800bc7a:	4623      	mov	r3, r4
 800bc7c:	4814      	ldr	r0, [pc, #80]	; (800bcd0 <lv_anim_create+0x98>)
 800bc7e:	f7f4 fae5 	bl	800024c <lv_debug_log_error>
 800bc82:	e7fe      	b.n	800bc82 <lv_anim_create+0x4a>
    if(new_anim == NULL) return;
 800bc84:	68fb      	ldr	r3, [r7, #12]
 800bc86:	2b00      	cmp	r3, #0
 800bc88:	d01c      	beq.n	800bcc4 <lv_anim_create+0x8c>

    /*Initialize the animation descriptor*/
    a->playback_now = 0;
 800bc8a:	687a      	ldr	r2, [r7, #4]
 800bc8c:	f892 3020 	ldrb.w	r3, [r2, #32]
 800bc90:	f36f 0382 	bfc	r3, #2, #1
 800bc94:	f882 3020 	strb.w	r3, [r2, #32]
    memcpy(new_anim, a, sizeof(lv_anim_t));
 800bc98:	2224      	movs	r2, #36	; 0x24
 800bc9a:	6879      	ldr	r1, [r7, #4]
 800bc9c:	68f8      	ldr	r0, [r7, #12]
 800bc9e:	f007 fd53 	bl	8013748 <memcpy>

    /*Set the start value*/
    if(new_anim->exec_cb) new_anim->exec_cb(new_anim->var, new_anim->start);
 800bca2:	68fb      	ldr	r3, [r7, #12]
 800bca4:	685b      	ldr	r3, [r3, #4]
 800bca6:	2b00      	cmp	r3, #0
 800bca8:	d008      	beq.n	800bcbc <lv_anim_create+0x84>
 800bcaa:	68fb      	ldr	r3, [r7, #12]
 800bcac:	685b      	ldr	r3, [r3, #4]
 800bcae:	68fa      	ldr	r2, [r7, #12]
 800bcb0:	6810      	ldr	r0, [r2, #0]
 800bcb2:	68fa      	ldr	r2, [r7, #12]
 800bcb4:	6912      	ldr	r2, [r2, #16]
 800bcb6:	b212      	sxth	r2, r2
 800bcb8:	4611      	mov	r1, r2
 800bcba:	4798      	blx	r3

    /* Creating an animation changed the linked list.
     * It's important if it happens in a ready callback. (see `anim_task`)*/
    anim_list_changed = true;
 800bcbc:	4b05      	ldr	r3, [pc, #20]	; (800bcd4 <lv_anim_create+0x9c>)
 800bcbe:	2201      	movs	r2, #1
 800bcc0:	701a      	strb	r2, [r3, #0]
 800bcc2:	e000      	b.n	800bcc6 <lv_anim_create+0x8e>
    if(new_anim == NULL) return;
 800bcc4:	bf00      	nop

    LV_LOG_TRACE("animation created")
}
 800bcc6:	3714      	adds	r7, #20
 800bcc8:	46bd      	mov	sp, r7
 800bcca:	bd90      	pop	{r4, r7, pc}
 800bccc:	20009988 	.word	0x20009988
 800bcd0:	08013878 	.word	0x08013878
 800bcd4:	200002b0 	.word	0x200002b0

0800bcd8 <lv_anim_del>:
 * @param exec_cb a function pointer which is animating 'var',
 *           or NULL to delete all the animations of 'var'
 * @return true: at least 1 animation is deleted, false: no animation is deleted
 */
bool lv_anim_del(void * var, lv_anim_exec_xcb_t exec_cb)
{
 800bcd8:	b580      	push	{r7, lr}
 800bcda:	b086      	sub	sp, #24
 800bcdc:	af00      	add	r7, sp, #0
 800bcde:	6078      	str	r0, [r7, #4]
 800bce0:	6039      	str	r1, [r7, #0]
    lv_anim_t * a;
    lv_anim_t * a_next;
    bool del = false;
 800bce2:	2300      	movs	r3, #0
 800bce4:	74fb      	strb	r3, [r7, #19]
    a        = lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 800bce6:	4816      	ldr	r0, [pc, #88]	; (800bd40 <lv_anim_del+0x68>)
 800bce8:	f000 fe68 	bl	800c9bc <lv_ll_get_head>
 800bcec:	6178      	str	r0, [r7, #20]
    while(a != NULL) {
 800bcee:	e01f      	b.n	800bd30 <lv_anim_del+0x58>
        /*'a' might be deleted, so get the next object while 'a' is valid*/
        a_next = lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
 800bcf0:	6979      	ldr	r1, [r7, #20]
 800bcf2:	4813      	ldr	r0, [pc, #76]	; (800bd40 <lv_anim_del+0x68>)
 800bcf4:	f000 fe88 	bl	800ca08 <lv_ll_get_next>
 800bcf8:	60f8      	str	r0, [r7, #12]

        if(a->var == var && (a->exec_cb == exec_cb || exec_cb == NULL)) {
 800bcfa:	697b      	ldr	r3, [r7, #20]
 800bcfc:	681b      	ldr	r3, [r3, #0]
 800bcfe:	687a      	ldr	r2, [r7, #4]
 800bd00:	429a      	cmp	r2, r3
 800bd02:	d113      	bne.n	800bd2c <lv_anim_del+0x54>
 800bd04:	697b      	ldr	r3, [r7, #20]
 800bd06:	685b      	ldr	r3, [r3, #4]
 800bd08:	683a      	ldr	r2, [r7, #0]
 800bd0a:	429a      	cmp	r2, r3
 800bd0c:	d002      	beq.n	800bd14 <lv_anim_del+0x3c>
 800bd0e:	683b      	ldr	r3, [r7, #0]
 800bd10:	2b00      	cmp	r3, #0
 800bd12:	d10b      	bne.n	800bd2c <lv_anim_del+0x54>
            lv_ll_rem(&LV_GC_ROOT(_lv_anim_ll), a);
 800bd14:	6979      	ldr	r1, [r7, #20]
 800bd16:	480a      	ldr	r0, [pc, #40]	; (800bd40 <lv_anim_del+0x68>)
 800bd18:	f000 fda2 	bl	800c860 <lv_ll_rem>
            lv_mem_free(a);
 800bd1c:	6978      	ldr	r0, [r7, #20]
 800bd1e:	f000 ffa7 	bl	800cc70 <lv_mem_free>
            anim_list_changed = true; /*Read by `anim_task`. It need to know if a delete occurred in
 800bd22:	4b08      	ldr	r3, [pc, #32]	; (800bd44 <lv_anim_del+0x6c>)
 800bd24:	2201      	movs	r2, #1
 800bd26:	701a      	strb	r2, [r3, #0]
                                         the linked list*/
            del = true;
 800bd28:	2301      	movs	r3, #1
 800bd2a:	74fb      	strb	r3, [r7, #19]
        }

        a = a_next;
 800bd2c:	68fb      	ldr	r3, [r7, #12]
 800bd2e:	617b      	str	r3, [r7, #20]
    while(a != NULL) {
 800bd30:	697b      	ldr	r3, [r7, #20]
 800bd32:	2b00      	cmp	r3, #0
 800bd34:	d1dc      	bne.n	800bcf0 <lv_anim_del+0x18>
    }

    return del;
 800bd36:	7cfb      	ldrb	r3, [r7, #19]
}
 800bd38:	4618      	mov	r0, r3
 800bd3a:	3718      	adds	r7, #24
 800bd3c:	46bd      	mov	sp, r7
 800bd3e:	bd80      	pop	{r7, pc}
 800bd40:	20009988 	.word	0x20009988
 800bd44:	200002b0 	.word	0x200002b0

0800bd48 <lv_anim_speed_to_time>:
 * @param start start value of the animation
 * @param end end value of the animation
 * @return the required time [ms] for the animation with the given parameters
 */
uint16_t lv_anim_speed_to_time(uint16_t speed, lv_anim_value_t start, lv_anim_value_t end)
{
 800bd48:	b480      	push	{r7}
 800bd4a:	b085      	sub	sp, #20
 800bd4c:	af00      	add	r7, sp, #0
 800bd4e:	4603      	mov	r3, r0
 800bd50:	80fb      	strh	r3, [r7, #6]
 800bd52:	460b      	mov	r3, r1
 800bd54:	80bb      	strh	r3, [r7, #4]
 800bd56:	4613      	mov	r3, r2
 800bd58:	807b      	strh	r3, [r7, #2]
    int32_t d     = LV_MATH_ABS((int32_t)start - end);
 800bd5a:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 800bd5e:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800bd62:	1ad3      	subs	r3, r2, r3
 800bd64:	2b00      	cmp	r3, #0
 800bd66:	bfb8      	it	lt
 800bd68:	425b      	neglt	r3, r3
 800bd6a:	60bb      	str	r3, [r7, #8]
    uint32_t time = (int32_t)((int32_t)(d * 1000) / speed);
 800bd6c:	68bb      	ldr	r3, [r7, #8]
 800bd6e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800bd72:	fb02 f203 	mul.w	r2, r2, r3
 800bd76:	88fb      	ldrh	r3, [r7, #6]
 800bd78:	fb92 f3f3 	sdiv	r3, r2, r3
 800bd7c:	60fb      	str	r3, [r7, #12]

    if(time > UINT16_MAX) time = UINT16_MAX;
 800bd7e:	68fb      	ldr	r3, [r7, #12]
 800bd80:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800bd84:	d302      	bcc.n	800bd8c <lv_anim_speed_to_time+0x44>
 800bd86:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800bd8a:	60fb      	str	r3, [r7, #12]

    if(time == 0) {
 800bd8c:	68fb      	ldr	r3, [r7, #12]
 800bd8e:	2b00      	cmp	r3, #0
 800bd90:	d102      	bne.n	800bd98 <lv_anim_speed_to_time+0x50>
        time++;
 800bd92:	68fb      	ldr	r3, [r7, #12]
 800bd94:	3301      	adds	r3, #1
 800bd96:	60fb      	str	r3, [r7, #12]
    }

    return time;
 800bd98:	68fb      	ldr	r3, [r7, #12]
 800bd9a:	b29b      	uxth	r3, r3
}
 800bd9c:	4618      	mov	r0, r3
 800bd9e:	3714      	adds	r7, #20
 800bda0:	46bd      	mov	sp, r7
 800bda2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bda6:	4770      	bx	lr

0800bda8 <lv_anim_path_linear>:
 * Calculate the current value of an animation applying linear characteristic
 * @param a pointer to an animation
 * @return the current value to set
 */
lv_anim_value_t lv_anim_path_linear(const lv_anim_t * a)
{
 800bda8:	b480      	push	{r7}
 800bdaa:	b085      	sub	sp, #20
 800bdac:	af00      	add	r7, sp, #0
 800bdae:	6078      	str	r0, [r7, #4]
    /*Calculate the current step*/
    uint32_t step;
    if(a->time == a->act_time) {
 800bdb0:	687b      	ldr	r3, [r7, #4]
 800bdb2:	8b1b      	ldrh	r3, [r3, #24]
 800bdb4:	461a      	mov	r2, r3
 800bdb6:	687b      	ldr	r3, [r7, #4]
 800bdb8:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 800bdbc:	429a      	cmp	r2, r3
 800bdbe:	d103      	bne.n	800bdc8 <lv_anim_path_linear+0x20>
        step = LV_ANIM_RESOLUTION; /*Use the last value if the time fully elapsed*/
 800bdc0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bdc4:	60fb      	str	r3, [r7, #12]
 800bdc6:	e008      	b.n	800bdda <lv_anim_path_linear+0x32>
    } else {
        step = ((int32_t)a->act_time * LV_ANIM_RESOLUTION) / a->time;
 800bdc8:	687b      	ldr	r3, [r7, #4]
 800bdca:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 800bdce:	029b      	lsls	r3, r3, #10
 800bdd0:	687a      	ldr	r2, [r7, #4]
 800bdd2:	8b12      	ldrh	r2, [r2, #24]
 800bdd4:	fb93 f3f2 	sdiv	r3, r3, r2
 800bdd8:	60fb      	str	r3, [r7, #12]
    }

    /* Get the new value which will be proportional to `step`
     * and the `start` and `end` values*/
    int32_t new_value;
    new_value = (int32_t)step * (a->end - a->start);
 800bdda:	687b      	ldr	r3, [r7, #4]
 800bddc:	695a      	ldr	r2, [r3, #20]
 800bdde:	687b      	ldr	r3, [r7, #4]
 800bde0:	691b      	ldr	r3, [r3, #16]
 800bde2:	1ad3      	subs	r3, r2, r3
 800bde4:	68fa      	ldr	r2, [r7, #12]
 800bde6:	fb02 f303 	mul.w	r3, r2, r3
 800bdea:	60bb      	str	r3, [r7, #8]
    new_value = new_value >> LV_ANIM_RES_SHIFT;
 800bdec:	68bb      	ldr	r3, [r7, #8]
 800bdee:	129b      	asrs	r3, r3, #10
 800bdf0:	60bb      	str	r3, [r7, #8]
    new_value += a->start;
 800bdf2:	687b      	ldr	r3, [r7, #4]
 800bdf4:	691b      	ldr	r3, [r3, #16]
 800bdf6:	68ba      	ldr	r2, [r7, #8]
 800bdf8:	4413      	add	r3, r2
 800bdfa:	60bb      	str	r3, [r7, #8]

    return (lv_anim_value_t)new_value;
 800bdfc:	68bb      	ldr	r3, [r7, #8]
 800bdfe:	b21b      	sxth	r3, r3
}
 800be00:	4618      	mov	r0, r3
 800be02:	3714      	adds	r7, #20
 800be04:	46bd      	mov	sp, r7
 800be06:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be0a:	4770      	bx	lr

0800be0c <anim_task>:
/**
 * Periodically handle the animations.
 * @param param unused
 */
static void anim_task(lv_task_t * param)
{
 800be0c:	b580      	push	{r7, lr}
 800be0e:	b086      	sub	sp, #24
 800be10:	af00      	add	r7, sp, #0
 800be12:	6078      	str	r0, [r7, #4]
    (void)param;

    lv_anim_t * a;
    LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a)
 800be14:	4842      	ldr	r0, [pc, #264]	; (800bf20 <anim_task+0x114>)
 800be16:	f000 fdd1 	bl	800c9bc <lv_ll_get_head>
 800be1a:	6178      	str	r0, [r7, #20]
 800be1c:	e00b      	b.n	800be36 <anim_task+0x2a>
    {
        a->has_run = 0;
 800be1e:	697a      	ldr	r2, [r7, #20]
 800be20:	f892 3020 	ldrb.w	r3, [r2, #32]
 800be24:	f36f 03c3 	bfc	r3, #3, #1
 800be28:	f882 3020 	strb.w	r3, [r2, #32]
    LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a)
 800be2c:	6979      	ldr	r1, [r7, #20]
 800be2e:	483c      	ldr	r0, [pc, #240]	; (800bf20 <anim_task+0x114>)
 800be30:	f000 fdea 	bl	800ca08 <lv_ll_get_next>
 800be34:	6178      	str	r0, [r7, #20]
 800be36:	697b      	ldr	r3, [r7, #20]
 800be38:	2b00      	cmp	r3, #0
 800be3a:	d1f0      	bne.n	800be1e <anim_task+0x12>
    }

    uint32_t elaps = lv_tick_elaps(last_task_run);
 800be3c:	4b39      	ldr	r3, [pc, #228]	; (800bf24 <anim_task+0x118>)
 800be3e:	681b      	ldr	r3, [r3, #0]
 800be40:	4618      	mov	r0, r3
 800be42:	f7ff fec3 	bl	800bbcc <lv_tick_elaps>
 800be46:	6138      	str	r0, [r7, #16]

    a = lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 800be48:	4835      	ldr	r0, [pc, #212]	; (800bf20 <anim_task+0x114>)
 800be4a:	f000 fdb7 	bl	800c9bc <lv_ll_get_head>
 800be4e:	6178      	str	r0, [r7, #20]

    while(a != NULL) {
 800be50:	e059      	b.n	800bf06 <anim_task+0xfa>
        /*It can be set by `lv_anim_del()` typically in `end_cb`. If set then an animation delete
         * happened in `anim_ready_handler` which could make this linked list reading corrupt
         * because the list is changed meanwhile
         */
        anim_list_changed = false;
 800be52:	4b35      	ldr	r3, [pc, #212]	; (800bf28 <anim_task+0x11c>)
 800be54:	2200      	movs	r2, #0
 800be56:	701a      	strb	r2, [r3, #0]

        if(!a->has_run) {
 800be58:	697b      	ldr	r3, [r7, #20]
 800be5a:	f893 3020 	ldrb.w	r3, [r3, #32]
 800be5e:	f003 0308 	and.w	r3, r3, #8
 800be62:	b2db      	uxtb	r3, r3
 800be64:	2b00      	cmp	r3, #0
 800be66:	d140      	bne.n	800beea <anim_task+0xde>
            a->has_run = 1; /*The list readying might be reseted so need to know which anim has run already*/
 800be68:	697a      	ldr	r2, [r7, #20]
 800be6a:	f892 3020 	ldrb.w	r3, [r2, #32]
 800be6e:	f043 0308 	orr.w	r3, r3, #8
 800be72:	f882 3020 	strb.w	r3, [r2, #32]
            a->act_time += elaps;
 800be76:	697b      	ldr	r3, [r7, #20]
 800be78:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 800be7c:	b29a      	uxth	r2, r3
 800be7e:	693b      	ldr	r3, [r7, #16]
 800be80:	b29b      	uxth	r3, r3
 800be82:	4413      	add	r3, r2
 800be84:	b29b      	uxth	r3, r3
 800be86:	b21a      	sxth	r2, r3
 800be88:	697b      	ldr	r3, [r7, #20]
 800be8a:	835a      	strh	r2, [r3, #26]
            if(a->act_time >= 0) {
 800be8c:	697b      	ldr	r3, [r7, #20]
 800be8e:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 800be92:	2b00      	cmp	r3, #0
 800be94:	db29      	blt.n	800beea <anim_task+0xde>
                if(a->act_time > a->time) a->act_time = a->time;
 800be96:	697b      	ldr	r3, [r7, #20]
 800be98:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 800be9c:	461a      	mov	r2, r3
 800be9e:	697b      	ldr	r3, [r7, #20]
 800bea0:	8b1b      	ldrh	r3, [r3, #24]
 800bea2:	429a      	cmp	r2, r3
 800bea4:	dd04      	ble.n	800beb0 <anim_task+0xa4>
 800bea6:	697b      	ldr	r3, [r7, #20]
 800bea8:	8b1b      	ldrh	r3, [r3, #24]
 800beaa:	b21a      	sxth	r2, r3
 800beac:	697b      	ldr	r3, [r7, #20]
 800beae:	835a      	strh	r2, [r3, #26]

                int32_t new_value;
                new_value = a->path_cb(a);
 800beb0:	697b      	ldr	r3, [r7, #20]
 800beb2:	689b      	ldr	r3, [r3, #8]
 800beb4:	6978      	ldr	r0, [r7, #20]
 800beb6:	4798      	blx	r3
 800beb8:	4603      	mov	r3, r0
 800beba:	60fb      	str	r3, [r7, #12]

                /*Apply the calculated value*/
                if(a->exec_cb) a->exec_cb(a->var, new_value);
 800bebc:	697b      	ldr	r3, [r7, #20]
 800bebe:	685b      	ldr	r3, [r3, #4]
 800bec0:	2b00      	cmp	r3, #0
 800bec2:	d007      	beq.n	800bed4 <anim_task+0xc8>
 800bec4:	697b      	ldr	r3, [r7, #20]
 800bec6:	685b      	ldr	r3, [r3, #4]
 800bec8:	697a      	ldr	r2, [r7, #20]
 800beca:	6812      	ldr	r2, [r2, #0]
 800becc:	68f9      	ldr	r1, [r7, #12]
 800bece:	b209      	sxth	r1, r1
 800bed0:	4610      	mov	r0, r2
 800bed2:	4798      	blx	r3

                /*If the time is elapsed the animation is ready*/
                if(a->act_time >= a->time) {
 800bed4:	697b      	ldr	r3, [r7, #20]
 800bed6:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 800beda:	461a      	mov	r2, r3
 800bedc:	697b      	ldr	r3, [r7, #20]
 800bede:	8b1b      	ldrh	r3, [r3, #24]
 800bee0:	429a      	cmp	r2, r3
 800bee2:	db02      	blt.n	800beea <anim_task+0xde>
                    anim_ready_handler(a);
 800bee4:	6978      	ldr	r0, [r7, #20]
 800bee6:	f000 f821 	bl	800bf2c <anim_ready_handler>
            }
        }

        /* If the linked list changed due to anim. delete then it's not safe to continue
         * the reading of the list from here -> start from the head*/
        if(anim_list_changed)
 800beea:	4b0f      	ldr	r3, [pc, #60]	; (800bf28 <anim_task+0x11c>)
 800beec:	781b      	ldrb	r3, [r3, #0]
 800beee:	2b00      	cmp	r3, #0
 800bef0:	d004      	beq.n	800befc <anim_task+0xf0>
            a = lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 800bef2:	480b      	ldr	r0, [pc, #44]	; (800bf20 <anim_task+0x114>)
 800bef4:	f000 fd62 	bl	800c9bc <lv_ll_get_head>
 800bef8:	6178      	str	r0, [r7, #20]
 800befa:	e004      	b.n	800bf06 <anim_task+0xfa>
        else
            a = lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
 800befc:	6979      	ldr	r1, [r7, #20]
 800befe:	4808      	ldr	r0, [pc, #32]	; (800bf20 <anim_task+0x114>)
 800bf00:	f000 fd82 	bl	800ca08 <lv_ll_get_next>
 800bf04:	6178      	str	r0, [r7, #20]
    while(a != NULL) {
 800bf06:	697b      	ldr	r3, [r7, #20]
 800bf08:	2b00      	cmp	r3, #0
 800bf0a:	d1a2      	bne.n	800be52 <anim_task+0x46>
    }

    last_task_run = lv_tick_get();
 800bf0c:	f7ff fe44 	bl	800bb98 <lv_tick_get>
 800bf10:	4602      	mov	r2, r0
 800bf12:	4b04      	ldr	r3, [pc, #16]	; (800bf24 <anim_task+0x118>)
 800bf14:	601a      	str	r2, [r3, #0]
}
 800bf16:	bf00      	nop
 800bf18:	3718      	adds	r7, #24
 800bf1a:	46bd      	mov	sp, r7
 800bf1c:	bd80      	pop	{r7, pc}
 800bf1e:	bf00      	nop
 800bf20:	20009988 	.word	0x20009988
 800bf24:	200002ac 	.word	0x200002ac
 800bf28:	200002b0 	.word	0x200002b0

0800bf2c <anim_ready_handler>:
 * e.g. repeat, play back, delete etc.
 * @param a pointer to an animation descriptor
 * @return true: animation delete occurred nnd the `LV_GC_ROOT(_lv_anim_ll)` has changed
 * */
static bool anim_ready_handler(lv_anim_t * a)
{
 800bf2c:	b580      	push	{r7, lr}
 800bf2e:	b08c      	sub	sp, #48	; 0x30
 800bf30:	af00      	add	r7, sp, #0
 800bf32:	6078      	str	r0, [r7, #4]

    /*Delete the animation if
     * - no repeat and no play back (simple one shot animation)
     * - no repeat, play back is enabled and play back is ready */
    if((a->repeat == 0 && a->playback == 0) || (a->repeat == 0 && a->playback == 1 && a->playback_now == 1)) {
 800bf34:	687b      	ldr	r3, [r7, #4]
 800bf36:	f893 3020 	ldrb.w	r3, [r3, #32]
 800bf3a:	f003 0302 	and.w	r3, r3, #2
 800bf3e:	b2db      	uxtb	r3, r3
 800bf40:	2b00      	cmp	r3, #0
 800bf42:	d107      	bne.n	800bf54 <anim_ready_handler+0x28>
 800bf44:	687b      	ldr	r3, [r7, #4]
 800bf46:	f893 3020 	ldrb.w	r3, [r3, #32]
 800bf4a:	f003 0301 	and.w	r3, r3, #1
 800bf4e:	b2db      	uxtb	r3, r3
 800bf50:	2b00      	cmp	r3, #0
 800bf52:	d017      	beq.n	800bf84 <anim_ready_handler+0x58>
 800bf54:	687b      	ldr	r3, [r7, #4]
 800bf56:	f893 3020 	ldrb.w	r3, [r3, #32]
 800bf5a:	f003 0302 	and.w	r3, r3, #2
 800bf5e:	b2db      	uxtb	r3, r3
 800bf60:	2b00      	cmp	r3, #0
 800bf62:	d129      	bne.n	800bfb8 <anim_ready_handler+0x8c>
 800bf64:	687b      	ldr	r3, [r7, #4]
 800bf66:	f893 3020 	ldrb.w	r3, [r3, #32]
 800bf6a:	f003 0301 	and.w	r3, r3, #1
 800bf6e:	b2db      	uxtb	r3, r3
 800bf70:	2b00      	cmp	r3, #0
 800bf72:	d021      	beq.n	800bfb8 <anim_ready_handler+0x8c>
 800bf74:	687b      	ldr	r3, [r7, #4]
 800bf76:	f893 3020 	ldrb.w	r3, [r3, #32]
 800bf7a:	f003 0304 	and.w	r3, r3, #4
 800bf7e:	b2db      	uxtb	r3, r3
 800bf80:	2b00      	cmp	r3, #0
 800bf82:	d019      	beq.n	800bfb8 <anim_ready_handler+0x8c>

        /*Create copy from the animation and delete the animation from the list.
         * This way the `ready_cb` will see the animations like it's animation is ready deleted*/
        lv_anim_t a_tmp;
        memcpy(&a_tmp, a, sizeof(lv_anim_t));
 800bf84:	f107 0308 	add.w	r3, r7, #8
 800bf88:	2224      	movs	r2, #36	; 0x24
 800bf8a:	6879      	ldr	r1, [r7, #4]
 800bf8c:	4618      	mov	r0, r3
 800bf8e:	f007 fbdb 	bl	8013748 <memcpy>
        lv_ll_rem(&LV_GC_ROOT(_lv_anim_ll), a);
 800bf92:	6879      	ldr	r1, [r7, #4]
 800bf94:	4829      	ldr	r0, [pc, #164]	; (800c03c <anim_ready_handler+0x110>)
 800bf96:	f000 fc63 	bl	800c860 <lv_ll_rem>
        lv_mem_free(a);
 800bf9a:	6878      	ldr	r0, [r7, #4]
 800bf9c:	f000 fe68 	bl	800cc70 <lv_mem_free>
        anim_list_changed = true;
 800bfa0:	4b27      	ldr	r3, [pc, #156]	; (800c040 <anim_ready_handler+0x114>)
 800bfa2:	2201      	movs	r2, #1
 800bfa4:	701a      	strb	r2, [r3, #0]

        /* Call the callback function at the end*/
        if(a_tmp.ready_cb != NULL) a_tmp.ready_cb(&a_tmp);
 800bfa6:	697b      	ldr	r3, [r7, #20]
 800bfa8:	2b00      	cmp	r3, #0
 800bfaa:	d040      	beq.n	800c02e <anim_ready_handler+0x102>
 800bfac:	697b      	ldr	r3, [r7, #20]
 800bfae:	f107 0208 	add.w	r2, r7, #8
 800bfb2:	4610      	mov	r0, r2
 800bfb4:	4798      	blx	r3
    if((a->repeat == 0 && a->playback == 0) || (a->repeat == 0 && a->playback == 1 && a->playback_now == 1)) {
 800bfb6:	e03a      	b.n	800c02e <anim_ready_handler+0x102>
    }
    /*If the animation is not deleted then restart it*/
    else {
        a->act_time = -a->repeat_pause; /*Restart the animation*/
 800bfb8:	687b      	ldr	r3, [r7, #4]
 800bfba:	8bdb      	ldrh	r3, [r3, #30]
 800bfbc:	425b      	negs	r3, r3
 800bfbe:	b29b      	uxth	r3, r3
 800bfc0:	b21a      	sxth	r2, r3
 800bfc2:	687b      	ldr	r3, [r7, #4]
 800bfc4:	835a      	strh	r2, [r3, #26]
        /*Swap the start and end values in play back mode*/
        if(a->playback != 0) {
 800bfc6:	687b      	ldr	r3, [r7, #4]
 800bfc8:	f893 3020 	ldrb.w	r3, [r3, #32]
 800bfcc:	f003 0301 	and.w	r3, r3, #1
 800bfd0:	b2db      	uxtb	r3, r3
 800bfd2:	2b00      	cmp	r3, #0
 800bfd4:	d02c      	beq.n	800c030 <anim_ready_handler+0x104>
            /*If now turning back use the 'playback_pause*/
            if(a->playback_now == 0) a->act_time = -a->playback_pause;
 800bfd6:	687b      	ldr	r3, [r7, #4]
 800bfd8:	f893 3020 	ldrb.w	r3, [r3, #32]
 800bfdc:	f003 0304 	and.w	r3, r3, #4
 800bfe0:	b2db      	uxtb	r3, r3
 800bfe2:	2b00      	cmp	r3, #0
 800bfe4:	d106      	bne.n	800bff4 <anim_ready_handler+0xc8>
 800bfe6:	687b      	ldr	r3, [r7, #4]
 800bfe8:	8b9b      	ldrh	r3, [r3, #28]
 800bfea:	425b      	negs	r3, r3
 800bfec:	b29b      	uxth	r3, r3
 800bfee:	b21a      	sxth	r2, r3
 800bff0:	687b      	ldr	r3, [r7, #4]
 800bff2:	835a      	strh	r2, [r3, #26]

            /*Toggle the play back state*/
            a->playback_now = a->playback_now == 0 ? 1 : 0;
 800bff4:	687b      	ldr	r3, [r7, #4]
 800bff6:	f893 3020 	ldrb.w	r3, [r3, #32]
 800bffa:	f003 0304 	and.w	r3, r3, #4
 800bffe:	b2db      	uxtb	r3, r3
 800c000:	2b00      	cmp	r3, #0
 800c002:	bf0c      	ite	eq
 800c004:	2301      	moveq	r3, #1
 800c006:	2300      	movne	r3, #0
 800c008:	b2d9      	uxtb	r1, r3
 800c00a:	687a      	ldr	r2, [r7, #4]
 800c00c:	f892 3020 	ldrb.w	r3, [r2, #32]
 800c010:	f361 0382 	bfi	r3, r1, #2, #1
 800c014:	f882 3020 	strb.w	r3, [r2, #32]
            /*Swap the start and end values*/
            int32_t tmp;
            tmp      = a->start;
 800c018:	687b      	ldr	r3, [r7, #4]
 800c01a:	691b      	ldr	r3, [r3, #16]
 800c01c:	62fb      	str	r3, [r7, #44]	; 0x2c
            a->start = a->end;
 800c01e:	687b      	ldr	r3, [r7, #4]
 800c020:	695a      	ldr	r2, [r3, #20]
 800c022:	687b      	ldr	r3, [r7, #4]
 800c024:	611a      	str	r2, [r3, #16]
            a->end   = tmp;
 800c026:	687b      	ldr	r3, [r7, #4]
 800c028:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c02a:	615a      	str	r2, [r3, #20]
 800c02c:	e000      	b.n	800c030 <anim_ready_handler+0x104>
    if((a->repeat == 0 && a->playback == 0) || (a->repeat == 0 && a->playback == 1 && a->playback_now == 1)) {
 800c02e:	bf00      	nop
        }
    }

    return anim_list_changed;
 800c030:	4b03      	ldr	r3, [pc, #12]	; (800c040 <anim_ready_handler+0x114>)
 800c032:	781b      	ldrb	r3, [r3, #0]
}
 800c034:	4618      	mov	r0, r3
 800c036:	3730      	adds	r7, #48	; 0x30
 800c038:	46bd      	mov	sp, r7
 800c03a:	bd80      	pop	{r7, pc}
 800c03c:	20009988 	.word	0x20009988
 800c040:	200002b0 	.word	0x200002b0

0800c044 <lv_area_set>:
 * @param y1 top coordinate of the area
 * @param x2 right coordinate of the area
 * @param y2 bottom coordinate of the area
 */
void lv_area_set(lv_area_t * area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)
{
 800c044:	b480      	push	{r7}
 800c046:	b085      	sub	sp, #20
 800c048:	af00      	add	r7, sp, #0
 800c04a:	60f8      	str	r0, [r7, #12]
 800c04c:	4608      	mov	r0, r1
 800c04e:	4611      	mov	r1, r2
 800c050:	461a      	mov	r2, r3
 800c052:	4603      	mov	r3, r0
 800c054:	817b      	strh	r3, [r7, #10]
 800c056:	460b      	mov	r3, r1
 800c058:	813b      	strh	r3, [r7, #8]
 800c05a:	4613      	mov	r3, r2
 800c05c:	80fb      	strh	r3, [r7, #6]
    area_p->x1 = x1;
 800c05e:	68fb      	ldr	r3, [r7, #12]
 800c060:	897a      	ldrh	r2, [r7, #10]
 800c062:	801a      	strh	r2, [r3, #0]
    area_p->y1 = y1;
 800c064:	68fb      	ldr	r3, [r7, #12]
 800c066:	893a      	ldrh	r2, [r7, #8]
 800c068:	805a      	strh	r2, [r3, #2]
    area_p->x2 = x2;
 800c06a:	68fb      	ldr	r3, [r7, #12]
 800c06c:	88fa      	ldrh	r2, [r7, #6]
 800c06e:	809a      	strh	r2, [r3, #4]
    area_p->y2 = y2;
 800c070:	68fb      	ldr	r3, [r7, #12]
 800c072:	8b3a      	ldrh	r2, [r7, #24]
 800c074:	80da      	strh	r2, [r3, #6]
}
 800c076:	bf00      	nop
 800c078:	3714      	adds	r7, #20
 800c07a:	46bd      	mov	sp, r7
 800c07c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c080:	4770      	bx	lr

0800c082 <lv_area_get_size>:
 * Return with area of an area (x * y)
 * @param area_p pointer to an area
 * @return size of area
 */
uint32_t lv_area_get_size(const lv_area_t * area_p)
{
 800c082:	b480      	push	{r7}
 800c084:	b085      	sub	sp, #20
 800c086:	af00      	add	r7, sp, #0
 800c088:	6078      	str	r0, [r7, #4]
    uint32_t size;

    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);
 800c08a:	687b      	ldr	r3, [r7, #4]
 800c08c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800c090:	461a      	mov	r2, r3
 800c092:	687b      	ldr	r3, [r7, #4]
 800c094:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c098:	1ad3      	subs	r3, r2, r3
 800c09a:	3301      	adds	r3, #1
 800c09c:	461a      	mov	r2, r3
 800c09e:	687b      	ldr	r3, [r7, #4]
 800c0a0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800c0a4:	4619      	mov	r1, r3
 800c0a6:	687b      	ldr	r3, [r7, #4]
 800c0a8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800c0ac:	1acb      	subs	r3, r1, r3
 800c0ae:	3301      	adds	r3, #1
 800c0b0:	fb03 f302 	mul.w	r3, r3, r2
 800c0b4:	60fb      	str	r3, [r7, #12]

    return size;
 800c0b6:	68fb      	ldr	r3, [r7, #12]
}
 800c0b8:	4618      	mov	r0, r3
 800c0ba:	3714      	adds	r7, #20
 800c0bc:	46bd      	mov	sp, r7
 800c0be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c0c2:	4770      	bx	lr

0800c0c4 <lv_area_intersect>:
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 * @return false: the two area has NO common parts, res_p is invalid
 */
bool lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 800c0c4:	b480      	push	{r7}
 800c0c6:	b087      	sub	sp, #28
 800c0c8:	af00      	add	r7, sp, #0
 800c0ca:	60f8      	str	r0, [r7, #12]
 800c0cc:	60b9      	str	r1, [r7, #8]
 800c0ce:	607a      	str	r2, [r7, #4]
    /* Get the smaller area from 'a1_p' and 'a2_p' */
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
 800c0d0:	687b      	ldr	r3, [r7, #4]
 800c0d2:	f9b3 2000 	ldrsh.w	r2, [r3]
 800c0d6:	68bb      	ldr	r3, [r7, #8]
 800c0d8:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c0dc:	4293      	cmp	r3, r2
 800c0de:	bfb8      	it	lt
 800c0e0:	4613      	movlt	r3, r2
 800c0e2:	b21a      	sxth	r2, r3
 800c0e4:	68fb      	ldr	r3, [r7, #12]
 800c0e6:	801a      	strh	r2, [r3, #0]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
 800c0e8:	687b      	ldr	r3, [r7, #4]
 800c0ea:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800c0ee:	68bb      	ldr	r3, [r7, #8]
 800c0f0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800c0f4:	4293      	cmp	r3, r2
 800c0f6:	bfb8      	it	lt
 800c0f8:	4613      	movlt	r3, r2
 800c0fa:	b21a      	sxth	r2, r3
 800c0fc:	68fb      	ldr	r3, [r7, #12]
 800c0fe:	805a      	strh	r2, [r3, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
 800c100:	687b      	ldr	r3, [r7, #4]
 800c102:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 800c106:	68bb      	ldr	r3, [r7, #8]
 800c108:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800c10c:	4293      	cmp	r3, r2
 800c10e:	bfa8      	it	ge
 800c110:	4613      	movge	r3, r2
 800c112:	b21a      	sxth	r2, r3
 800c114:	68fb      	ldr	r3, [r7, #12]
 800c116:	809a      	strh	r2, [r3, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
 800c118:	687b      	ldr	r3, [r7, #4]
 800c11a:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 800c11e:	68bb      	ldr	r3, [r7, #8]
 800c120:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800c124:	4293      	cmp	r3, r2
 800c126:	bfa8      	it	ge
 800c128:	4613      	movge	r3, r2
 800c12a:	b21a      	sxth	r2, r3
 800c12c:	68fb      	ldr	r3, [r7, #12]
 800c12e:	80da      	strh	r2, [r3, #6]

    /*If x1 or y1 greater then x2 or y2 then the areas union is empty*/
    bool union_ok = true;
 800c130:	2301      	movs	r3, #1
 800c132:	75fb      	strb	r3, [r7, #23]
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
 800c134:	68fb      	ldr	r3, [r7, #12]
 800c136:	f9b3 2000 	ldrsh.w	r2, [r3]
 800c13a:	68fb      	ldr	r3, [r7, #12]
 800c13c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800c140:	429a      	cmp	r2, r3
 800c142:	dc07      	bgt.n	800c154 <lv_area_intersect+0x90>
 800c144:	68fb      	ldr	r3, [r7, #12]
 800c146:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800c14a:	68fb      	ldr	r3, [r7, #12]
 800c14c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800c150:	429a      	cmp	r2, r3
 800c152:	dd01      	ble.n	800c158 <lv_area_intersect+0x94>
        union_ok = false;
 800c154:	2300      	movs	r3, #0
 800c156:	75fb      	strb	r3, [r7, #23]
    }

    return union_ok;
 800c158:	7dfb      	ldrb	r3, [r7, #23]
}
 800c15a:	4618      	mov	r0, r3
 800c15c:	371c      	adds	r7, #28
 800c15e:	46bd      	mov	sp, r7
 800c160:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c164:	4770      	bx	lr

0800c166 <lv_area_join>:
 * @param res_p pointer to an area, the result will be stored here
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 */
void lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 800c166:	b480      	push	{r7}
 800c168:	b085      	sub	sp, #20
 800c16a:	af00      	add	r7, sp, #0
 800c16c:	60f8      	str	r0, [r7, #12]
 800c16e:	60b9      	str	r1, [r7, #8]
 800c170:	607a      	str	r2, [r7, #4]
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
 800c172:	687b      	ldr	r3, [r7, #4]
 800c174:	f9b3 2000 	ldrsh.w	r2, [r3]
 800c178:	68bb      	ldr	r3, [r7, #8]
 800c17a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c17e:	4293      	cmp	r3, r2
 800c180:	bfa8      	it	ge
 800c182:	4613      	movge	r3, r2
 800c184:	b21a      	sxth	r2, r3
 800c186:	68fb      	ldr	r3, [r7, #12]
 800c188:	801a      	strh	r2, [r3, #0]
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
 800c18a:	687b      	ldr	r3, [r7, #4]
 800c18c:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800c190:	68bb      	ldr	r3, [r7, #8]
 800c192:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800c196:	4293      	cmp	r3, r2
 800c198:	bfa8      	it	ge
 800c19a:	4613      	movge	r3, r2
 800c19c:	b21a      	sxth	r2, r3
 800c19e:	68fb      	ldr	r3, [r7, #12]
 800c1a0:	805a      	strh	r2, [r3, #2]
    a_res_p->x2 = LV_MATH_MAX(a1_p->x2, a2_p->x2);
 800c1a2:	687b      	ldr	r3, [r7, #4]
 800c1a4:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 800c1a8:	68bb      	ldr	r3, [r7, #8]
 800c1aa:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800c1ae:	4293      	cmp	r3, r2
 800c1b0:	bfb8      	it	lt
 800c1b2:	4613      	movlt	r3, r2
 800c1b4:	b21a      	sxth	r2, r3
 800c1b6:	68fb      	ldr	r3, [r7, #12]
 800c1b8:	809a      	strh	r2, [r3, #4]
    a_res_p->y2 = LV_MATH_MAX(a1_p->y2, a2_p->y2);
 800c1ba:	687b      	ldr	r3, [r7, #4]
 800c1bc:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 800c1c0:	68bb      	ldr	r3, [r7, #8]
 800c1c2:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800c1c6:	4293      	cmp	r3, r2
 800c1c8:	bfb8      	it	lt
 800c1ca:	4613      	movlt	r3, r2
 800c1cc:	b21a      	sxth	r2, r3
 800c1ce:	68fb      	ldr	r3, [r7, #12]
 800c1d0:	80da      	strh	r2, [r3, #6]
}
 800c1d2:	bf00      	nop
 800c1d4:	3714      	adds	r7, #20
 800c1d6:	46bd      	mov	sp, r7
 800c1d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c1dc:	4770      	bx	lr

0800c1de <lv_area_is_on>:
 * @param a1_p pointer to an area.
 * @param a2_p pointer to an other area
 * @return false: a1_p and a2_p has no common parts
 */
bool lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 800c1de:	b480      	push	{r7}
 800c1e0:	b083      	sub	sp, #12
 800c1e2:	af00      	add	r7, sp, #0
 800c1e4:	6078      	str	r0, [r7, #4]
 800c1e6:	6039      	str	r1, [r7, #0]
    if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {
 800c1e8:	687b      	ldr	r3, [r7, #4]
 800c1ea:	f9b3 2000 	ldrsh.w	r2, [r3]
 800c1ee:	683b      	ldr	r3, [r7, #0]
 800c1f0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800c1f4:	429a      	cmp	r2, r3
 800c1f6:	dc19      	bgt.n	800c22c <lv_area_is_on+0x4e>
 800c1f8:	687b      	ldr	r3, [r7, #4]
 800c1fa:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 800c1fe:	683b      	ldr	r3, [r7, #0]
 800c200:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c204:	429a      	cmp	r2, r3
 800c206:	db11      	blt.n	800c22c <lv_area_is_on+0x4e>
 800c208:	687b      	ldr	r3, [r7, #4]
 800c20a:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800c20e:	683b      	ldr	r3, [r7, #0]
 800c210:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800c214:	429a      	cmp	r2, r3
 800c216:	dc09      	bgt.n	800c22c <lv_area_is_on+0x4e>
 800c218:	687b      	ldr	r3, [r7, #4]
 800c21a:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 800c21e:	683b      	ldr	r3, [r7, #0]
 800c220:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800c224:	429a      	cmp	r2, r3
 800c226:	db01      	blt.n	800c22c <lv_area_is_on+0x4e>
        return true;
 800c228:	2301      	movs	r3, #1
 800c22a:	e000      	b.n	800c22e <lv_area_is_on+0x50>
    } else {
        return false;
 800c22c:	2300      	movs	r3, #0
    }
}
 800c22e:	4618      	mov	r0, r3
 800c230:	370c      	adds	r7, #12
 800c232:	46bd      	mov	sp, r7
 800c234:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c238:	4770      	bx	lr

0800c23a <lv_area_is_in>:
 * @param ain_p pointer to an area which could be in 'aholder_p'
 * @param aholder pointer to an area which could involve 'ain_p'
 * @return
 */
bool lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p)
{
 800c23a:	b480      	push	{r7}
 800c23c:	b085      	sub	sp, #20
 800c23e:	af00      	add	r7, sp, #0
 800c240:	6078      	str	r0, [r7, #4]
 800c242:	6039      	str	r1, [r7, #0]
    bool is_in = false;
 800c244:	2300      	movs	r3, #0
 800c246:	73fb      	strb	r3, [r7, #15]

    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
 800c248:	687b      	ldr	r3, [r7, #4]
 800c24a:	f9b3 2000 	ldrsh.w	r2, [r3]
 800c24e:	683b      	ldr	r3, [r7, #0]
 800c250:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c254:	429a      	cmp	r2, r3
 800c256:	db19      	blt.n	800c28c <lv_area_is_in+0x52>
 800c258:	687b      	ldr	r3, [r7, #4]
 800c25a:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800c25e:	683b      	ldr	r3, [r7, #0]
 800c260:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800c264:	429a      	cmp	r2, r3
 800c266:	db11      	blt.n	800c28c <lv_area_is_in+0x52>
 800c268:	687b      	ldr	r3, [r7, #4]
 800c26a:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 800c26e:	683b      	ldr	r3, [r7, #0]
 800c270:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800c274:	429a      	cmp	r2, r3
 800c276:	dc09      	bgt.n	800c28c <lv_area_is_in+0x52>
       ain_p->y2 <= aholder_p->y2) {
 800c278:	687b      	ldr	r3, [r7, #4]
 800c27a:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 800c27e:	683b      	ldr	r3, [r7, #0]
 800c280:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
 800c284:	429a      	cmp	r2, r3
 800c286:	dc01      	bgt.n	800c28c <lv_area_is_in+0x52>
        is_in = true;
 800c288:	2301      	movs	r3, #1
 800c28a:	73fb      	strb	r3, [r7, #15]
    }

    return is_in;
 800c28c:	7bfb      	ldrb	r3, [r7, #15]
}
 800c28e:	4618      	mov	r0, r3
 800c290:	3714      	adds	r7, #20
 800c292:	46bd      	mov	sp, r7
 800c294:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c298:	4770      	bx	lr

0800c29a <lv_circ_init>:
 * @param c pointer to a point. The coordinates will be calculated here
 * @param tmp point to a variable. It will store temporary data
 * @param radius radius of the circle
 */
void lv_circ_init(lv_point_t * c, lv_coord_t * tmp, lv_coord_t radius)
{
 800c29a:	b480      	push	{r7}
 800c29c:	b085      	sub	sp, #20
 800c29e:	af00      	add	r7, sp, #0
 800c2a0:	60f8      	str	r0, [r7, #12]
 800c2a2:	60b9      	str	r1, [r7, #8]
 800c2a4:	4613      	mov	r3, r2
 800c2a6:	80fb      	strh	r3, [r7, #6]
    c->x = radius;
 800c2a8:	68fb      	ldr	r3, [r7, #12]
 800c2aa:	88fa      	ldrh	r2, [r7, #6]
 800c2ac:	801a      	strh	r2, [r3, #0]
    c->y = 0;
 800c2ae:	68fb      	ldr	r3, [r7, #12]
 800c2b0:	2200      	movs	r2, #0
 800c2b2:	805a      	strh	r2, [r3, #2]
    *tmp = 1 - radius;
 800c2b4:	88fb      	ldrh	r3, [r7, #6]
 800c2b6:	f1c3 0301 	rsb	r3, r3, #1
 800c2ba:	b29b      	uxth	r3, r3
 800c2bc:	b21a      	sxth	r2, r3
 800c2be:	68bb      	ldr	r3, [r7, #8]
 800c2c0:	801a      	strh	r2, [r3, #0]
}
 800c2c2:	bf00      	nop
 800c2c4:	3714      	adds	r7, #20
 800c2c6:	46bd      	mov	sp, r7
 800c2c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2cc:	4770      	bx	lr

0800c2ce <lv_circ_cont>:
 * Test the circle drawing is ready or not
 * @param c same as in circ_init
 * @return true if the circle is not ready yet
 */
bool lv_circ_cont(lv_point_t * c)
{
 800c2ce:	b480      	push	{r7}
 800c2d0:	b083      	sub	sp, #12
 800c2d2:	af00      	add	r7, sp, #0
 800c2d4:	6078      	str	r0, [r7, #4]
    return c->y <= c->x ? true : false;
 800c2d6:	687b      	ldr	r3, [r7, #4]
 800c2d8:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800c2dc:	687b      	ldr	r3, [r7, #4]
 800c2de:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c2e2:	429a      	cmp	r2, r3
 800c2e4:	bfd4      	ite	le
 800c2e6:	2301      	movle	r3, #1
 800c2e8:	2300      	movgt	r3, #0
 800c2ea:	b2db      	uxtb	r3, r3
}
 800c2ec:	4618      	mov	r0, r3
 800c2ee:	370c      	adds	r7, #12
 800c2f0:	46bd      	mov	sp, r7
 800c2f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2f6:	4770      	bx	lr

0800c2f8 <lv_circ_next>:
 * Get the next point from the circle
 * @param c same as in circ_init. The next point stored here.
 * @param tmp same as in circ_init.
 */
void lv_circ_next(lv_point_t * c, lv_coord_t * tmp)
{
 800c2f8:	b480      	push	{r7}
 800c2fa:	b083      	sub	sp, #12
 800c2fc:	af00      	add	r7, sp, #0
 800c2fe:	6078      	str	r0, [r7, #4]
 800c300:	6039      	str	r1, [r7, #0]
    c->y++;
 800c302:	687b      	ldr	r3, [r7, #4]
 800c304:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800c308:	b29b      	uxth	r3, r3
 800c30a:	3301      	adds	r3, #1
 800c30c:	b29b      	uxth	r3, r3
 800c30e:	b21a      	sxth	r2, r3
 800c310:	687b      	ldr	r3, [r7, #4]
 800c312:	805a      	strh	r2, [r3, #2]

    if(*tmp <= 0) {
 800c314:	683b      	ldr	r3, [r7, #0]
 800c316:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c31a:	2b00      	cmp	r3, #0
 800c31c:	dc11      	bgt.n	800c342 <lv_circ_next+0x4a>
        (*tmp) += 2 * c->y + 1; /*Change in decision criterion for y -> y+1*/
 800c31e:	683b      	ldr	r3, [r7, #0]
 800c320:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c324:	b29a      	uxth	r2, r3
 800c326:	687b      	ldr	r3, [r7, #4]
 800c328:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800c32c:	b29b      	uxth	r3, r3
 800c32e:	005b      	lsls	r3, r3, #1
 800c330:	b29b      	uxth	r3, r3
 800c332:	4413      	add	r3, r2
 800c334:	b29b      	uxth	r3, r3
 800c336:	3301      	adds	r3, #1
 800c338:	b29b      	uxth	r3, r3
 800c33a:	b21a      	sxth	r2, r3
 800c33c:	683b      	ldr	r3, [r7, #0]
 800c33e:	801a      	strh	r2, [r3, #0]
    } else {
        c->x--;
        (*tmp) += 2 * (c->y - c->x) + 1; /*Change for y -> y+1, x -> x-1*/
    }
}
 800c340:	e01e      	b.n	800c380 <lv_circ_next+0x88>
        c->x--;
 800c342:	687b      	ldr	r3, [r7, #4]
 800c344:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c348:	b29b      	uxth	r3, r3
 800c34a:	3b01      	subs	r3, #1
 800c34c:	b29b      	uxth	r3, r3
 800c34e:	b21a      	sxth	r2, r3
 800c350:	687b      	ldr	r3, [r7, #4]
 800c352:	801a      	strh	r2, [r3, #0]
        (*tmp) += 2 * (c->y - c->x) + 1; /*Change for y -> y+1, x -> x-1*/
 800c354:	683b      	ldr	r3, [r7, #0]
 800c356:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c35a:	b29a      	uxth	r2, r3
 800c35c:	687b      	ldr	r3, [r7, #4]
 800c35e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800c362:	4619      	mov	r1, r3
 800c364:	687b      	ldr	r3, [r7, #4]
 800c366:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c36a:	1acb      	subs	r3, r1, r3
 800c36c:	b29b      	uxth	r3, r3
 800c36e:	005b      	lsls	r3, r3, #1
 800c370:	b29b      	uxth	r3, r3
 800c372:	4413      	add	r3, r2
 800c374:	b29b      	uxth	r3, r3
 800c376:	3301      	adds	r3, #1
 800c378:	b29b      	uxth	r3, r3
 800c37a:	b21a      	sxth	r2, r3
 800c37c:	683b      	ldr	r3, [r7, #0]
 800c37e:	801a      	strh	r2, [r3, #0]
}
 800c380:	bf00      	nop
 800c382:	370c      	adds	r7, #12
 800c384:	46bd      	mov	sp, r7
 800c386:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c38a:	4770      	bx	lr

0800c38c <lv_fs_init>:

/**
 * Initialize the File system interface
 */
void lv_fs_init(void)
{
 800c38c:	b580      	push	{r7, lr}
 800c38e:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_drv_ll), sizeof(lv_fs_drv_t));
 800c390:	2144      	movs	r1, #68	; 0x44
 800c392:	4802      	ldr	r0, [pc, #8]	; (800c39c <lv_fs_init+0x10>)
 800c394:	f000 f990 	bl	800c6b8 <lv_ll_init>
}
 800c398:	bf00      	nop
 800c39a:	bd80      	pop	{r7, pc}
 800c39c:	20009974 	.word	0x20009974

0800c3a0 <lv_fs_open>:
 * @param path path to the file beginning with the driver letter (e.g. S:/folder/file.txt)
 * @param mode read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR
 * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_open(lv_fs_file_t * file_p, const char * path, lv_fs_mode_t mode)
{
 800c3a0:	b590      	push	{r4, r7, lr}
 800c3a2:	b089      	sub	sp, #36	; 0x24
 800c3a4:	af00      	add	r7, sp, #0
 800c3a6:	60f8      	str	r0, [r7, #12]
 800c3a8:	60b9      	str	r1, [r7, #8]
 800c3aa:	4613      	mov	r3, r2
 800c3ac:	71fb      	strb	r3, [r7, #7]
    file_p->drv    = NULL;
 800c3ae:	68fb      	ldr	r3, [r7, #12]
 800c3b0:	2200      	movs	r2, #0
 800c3b2:	605a      	str	r2, [r3, #4]
    file_p->file_d = NULL;
 800c3b4:	68fb      	ldr	r3, [r7, #12]
 800c3b6:	2200      	movs	r2, #0
 800c3b8:	601a      	str	r2, [r3, #0]

    if(path == NULL) return LV_FS_RES_INV_PARAM;
 800c3ba:	68bb      	ldr	r3, [r7, #8]
 800c3bc:	2b00      	cmp	r3, #0
 800c3be:	d101      	bne.n	800c3c4 <lv_fs_open+0x24>
 800c3c0:	230b      	movs	r3, #11
 800c3c2:	e079      	b.n	800c4b8 <lv_fs_open+0x118>

    char letter = path[0];
 800c3c4:	68bb      	ldr	r3, [r7, #8]
 800c3c6:	781b      	ldrb	r3, [r3, #0]
 800c3c8:	77fb      	strb	r3, [r7, #31]

    file_p->drv = lv_fs_get_drv(letter);
 800c3ca:	7ffb      	ldrb	r3, [r7, #31]
 800c3cc:	4618      	mov	r0, r3
 800c3ce:	f000 f901 	bl	800c5d4 <lv_fs_get_drv>
 800c3d2:	4602      	mov	r2, r0
 800c3d4:	68fb      	ldr	r3, [r7, #12]
 800c3d6:	605a      	str	r2, [r3, #4]

    if(file_p->drv == NULL) {
 800c3d8:	68fb      	ldr	r3, [r7, #12]
 800c3da:	685b      	ldr	r3, [r3, #4]
 800c3dc:	2b00      	cmp	r3, #0
 800c3de:	d104      	bne.n	800c3ea <lv_fs_open+0x4a>
        file_p->file_d = NULL;
 800c3e0:	68fb      	ldr	r3, [r7, #12]
 800c3e2:	2200      	movs	r2, #0
 800c3e4:	601a      	str	r2, [r3, #0]
        return LV_FS_RES_NOT_EX;
 800c3e6:	2303      	movs	r3, #3
 800c3e8:	e066      	b.n	800c4b8 <lv_fs_open+0x118>
    }

    if(file_p->drv->ready_cb != NULL) {
 800c3ea:	68fb      	ldr	r3, [r7, #12]
 800c3ec:	685b      	ldr	r3, [r3, #4]
 800c3ee:	689b      	ldr	r3, [r3, #8]
 800c3f0:	2b00      	cmp	r3, #0
 800c3f2:	d014      	beq.n	800c41e <lv_fs_open+0x7e>
        if(file_p->drv->ready_cb(file_p->drv) == false) {
 800c3f4:	68fb      	ldr	r3, [r7, #12]
 800c3f6:	685b      	ldr	r3, [r3, #4]
 800c3f8:	689b      	ldr	r3, [r3, #8]
 800c3fa:	68fa      	ldr	r2, [r7, #12]
 800c3fc:	6852      	ldr	r2, [r2, #4]
 800c3fe:	4610      	mov	r0, r2
 800c400:	4798      	blx	r3
 800c402:	4603      	mov	r3, r0
 800c404:	f083 0301 	eor.w	r3, r3, #1
 800c408:	b2db      	uxtb	r3, r3
 800c40a:	2b00      	cmp	r3, #0
 800c40c:	d007      	beq.n	800c41e <lv_fs_open+0x7e>
            file_p->drv    = NULL;
 800c40e:	68fb      	ldr	r3, [r7, #12]
 800c410:	2200      	movs	r2, #0
 800c412:	605a      	str	r2, [r3, #4]
            file_p->file_d = NULL;
 800c414:	68fb      	ldr	r3, [r7, #12]
 800c416:	2200      	movs	r2, #0
 800c418:	601a      	str	r2, [r3, #0]
            return LV_FS_RES_HW_ERR;
 800c41a:	2301      	movs	r3, #1
 800c41c:	e04c      	b.n	800c4b8 <lv_fs_open+0x118>
        }
    }

    file_p->file_d = lv_mem_alloc(file_p->drv->file_size);
 800c41e:	68fb      	ldr	r3, [r7, #12]
 800c420:	685b      	ldr	r3, [r3, #4]
 800c422:	885b      	ldrh	r3, [r3, #2]
 800c424:	4618      	mov	r0, r3
 800c426:	f000 fbf1 	bl	800cc0c <lv_mem_alloc>
 800c42a:	4602      	mov	r2, r0
 800c42c:	68fb      	ldr	r3, [r7, #12]
 800c42e:	601a      	str	r2, [r3, #0]
    LV_ASSERT_MEM(file_p->file_d);
 800c430:	68fb      	ldr	r3, [r7, #12]
 800c432:	681b      	ldr	r3, [r3, #0]
 800c434:	4618      	mov	r0, r3
 800c436:	f7f3 fedf 	bl	80001f8 <lv_debug_check_null>
 800c43a:	4603      	mov	r3, r0
 800c43c:	f083 0301 	eor.w	r3, r3, #1
 800c440:	b2db      	uxtb	r3, r3
 800c442:	2b00      	cmp	r3, #0
 800c444:	d009      	beq.n	800c45a <lv_fs_open+0xba>
 800c446:	68fb      	ldr	r3, [r7, #12]
 800c448:	681b      	ldr	r3, [r3, #0]
 800c44a:	f04f 0400 	mov.w	r4, #0
 800c44e:	461a      	mov	r2, r3
 800c450:	4623      	mov	r3, r4
 800c452:	481b      	ldr	r0, [pc, #108]	; (800c4c0 <lv_fs_open+0x120>)
 800c454:	f7f3 fefa 	bl	800024c <lv_debug_log_error>
 800c458:	e7fe      	b.n	800c458 <lv_fs_open+0xb8>
    if(file_p->file_d == NULL) {
 800c45a:	68fb      	ldr	r3, [r7, #12]
 800c45c:	681b      	ldr	r3, [r3, #0]
 800c45e:	2b00      	cmp	r3, #0
 800c460:	d104      	bne.n	800c46c <lv_fs_open+0xcc>
        file_p->drv = NULL;
 800c462:	68fb      	ldr	r3, [r7, #12]
 800c464:	2200      	movs	r2, #0
 800c466:	605a      	str	r2, [r3, #4]
        return LV_FS_RES_OUT_OF_MEM; /* Out of memory */
 800c468:	230a      	movs	r3, #10
 800c46a:	e025      	b.n	800c4b8 <lv_fs_open+0x118>
    }

    if(file_p->drv->open_cb == NULL) {
 800c46c:	68fb      	ldr	r3, [r7, #12]
 800c46e:	685b      	ldr	r3, [r3, #4]
 800c470:	68db      	ldr	r3, [r3, #12]
 800c472:	2b00      	cmp	r3, #0
 800c474:	d101      	bne.n	800c47a <lv_fs_open+0xda>
        return LV_FS_RES_NOT_IMP;
 800c476:	2309      	movs	r3, #9
 800c478:	e01e      	b.n	800c4b8 <lv_fs_open+0x118>
    }

    const char * real_path = lv_fs_get_real_path(path);
 800c47a:	68b8      	ldr	r0, [r7, #8]
 800c47c:	f000 f8fa 	bl	800c674 <lv_fs_get_real_path>
 800c480:	61b8      	str	r0, [r7, #24]
    lv_fs_res_t res        = file_p->drv->open_cb(file_p->drv, file_p->file_d, real_path, mode);
 800c482:	68fb      	ldr	r3, [r7, #12]
 800c484:	685b      	ldr	r3, [r3, #4]
 800c486:	68dc      	ldr	r4, [r3, #12]
 800c488:	68fb      	ldr	r3, [r7, #12]
 800c48a:	6858      	ldr	r0, [r3, #4]
 800c48c:	68fb      	ldr	r3, [r7, #12]
 800c48e:	6819      	ldr	r1, [r3, #0]
 800c490:	79fb      	ldrb	r3, [r7, #7]
 800c492:	69ba      	ldr	r2, [r7, #24]
 800c494:	47a0      	blx	r4
 800c496:	4603      	mov	r3, r0
 800c498:	75fb      	strb	r3, [r7, #23]

    if(res != LV_FS_RES_OK) {
 800c49a:	7dfb      	ldrb	r3, [r7, #23]
 800c49c:	2b00      	cmp	r3, #0
 800c49e:	d00a      	beq.n	800c4b6 <lv_fs_open+0x116>
        lv_mem_free(file_p->file_d);
 800c4a0:	68fb      	ldr	r3, [r7, #12]
 800c4a2:	681b      	ldr	r3, [r3, #0]
 800c4a4:	4618      	mov	r0, r3
 800c4a6:	f000 fbe3 	bl	800cc70 <lv_mem_free>
        file_p->file_d = NULL;
 800c4aa:	68fb      	ldr	r3, [r7, #12]
 800c4ac:	2200      	movs	r2, #0
 800c4ae:	601a      	str	r2, [r3, #0]
        file_p->drv    = NULL;
 800c4b0:	68fb      	ldr	r3, [r7, #12]
 800c4b2:	2200      	movs	r2, #0
 800c4b4:	605a      	str	r2, [r3, #4]
    }

    return res;
 800c4b6:	7dfb      	ldrb	r3, [r7, #23]
}
 800c4b8:	4618      	mov	r0, r3
 800c4ba:	3724      	adds	r7, #36	; 0x24
 800c4bc:	46bd      	mov	sp, r7
 800c4be:	bd90      	pop	{r4, r7, pc}
 800c4c0:	08013888 	.word	0x08013888

0800c4c4 <lv_fs_close>:
 * Close an already opened file
 * @param file_p pointer to a lv_fs_file_t variable
 * @return  LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_close(lv_fs_file_t * file_p)
{
 800c4c4:	b580      	push	{r7, lr}
 800c4c6:	b084      	sub	sp, #16
 800c4c8:	af00      	add	r7, sp, #0
 800c4ca:	6078      	str	r0, [r7, #4]
    if(file_p->drv == NULL) {
 800c4cc:	687b      	ldr	r3, [r7, #4]
 800c4ce:	685b      	ldr	r3, [r3, #4]
 800c4d0:	2b00      	cmp	r3, #0
 800c4d2:	d101      	bne.n	800c4d8 <lv_fs_close+0x14>
        return LV_FS_RES_INV_PARAM;
 800c4d4:	230b      	movs	r3, #11
 800c4d6:	e020      	b.n	800c51a <lv_fs_close+0x56>
    }

    if(file_p->drv->close_cb == NULL) {
 800c4d8:	687b      	ldr	r3, [r7, #4]
 800c4da:	685b      	ldr	r3, [r3, #4]
 800c4dc:	691b      	ldr	r3, [r3, #16]
 800c4de:	2b00      	cmp	r3, #0
 800c4e0:	d101      	bne.n	800c4e6 <lv_fs_close+0x22>
        return LV_FS_RES_NOT_IMP;
 800c4e2:	2309      	movs	r3, #9
 800c4e4:	e019      	b.n	800c51a <lv_fs_close+0x56>
    }

    lv_fs_res_t res = file_p->drv->close_cb(file_p->drv, file_p->file_d);
 800c4e6:	687b      	ldr	r3, [r7, #4]
 800c4e8:	685b      	ldr	r3, [r3, #4]
 800c4ea:	691b      	ldr	r3, [r3, #16]
 800c4ec:	687a      	ldr	r2, [r7, #4]
 800c4ee:	6850      	ldr	r0, [r2, #4]
 800c4f0:	687a      	ldr	r2, [r7, #4]
 800c4f2:	6812      	ldr	r2, [r2, #0]
 800c4f4:	4611      	mov	r1, r2
 800c4f6:	4798      	blx	r3
 800c4f8:	4603      	mov	r3, r0
 800c4fa:	73fb      	strb	r3, [r7, #15]

    lv_mem_free(file_p->file_d); /*Clean up*/
 800c4fc:	687b      	ldr	r3, [r7, #4]
 800c4fe:	681b      	ldr	r3, [r3, #0]
 800c500:	4618      	mov	r0, r3
 800c502:	f000 fbb5 	bl	800cc70 <lv_mem_free>
    file_p->file_d = NULL;
 800c506:	687b      	ldr	r3, [r7, #4]
 800c508:	2200      	movs	r2, #0
 800c50a:	601a      	str	r2, [r3, #0]
    file_p->drv    = NULL;
 800c50c:	687b      	ldr	r3, [r7, #4]
 800c50e:	2200      	movs	r2, #0
 800c510:	605a      	str	r2, [r3, #4]
    file_p->file_d = NULL;
 800c512:	687b      	ldr	r3, [r7, #4]
 800c514:	2200      	movs	r2, #0
 800c516:	601a      	str	r2, [r3, #0]

    return res;
 800c518:	7bfb      	ldrb	r3, [r7, #15]
}
 800c51a:	4618      	mov	r0, r3
 800c51c:	3710      	adds	r7, #16
 800c51e:	46bd      	mov	sp, r7
 800c520:	bd80      	pop	{r7, pc}

0800c522 <lv_fs_read>:
 * @param btr Bytes To Read
 * @param br the number of real read bytes (Bytes Read). NULL if unused.
 * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_read(lv_fs_file_t * file_p, void * buf, uint32_t btr, uint32_t * br)
{
 800c522:	b590      	push	{r4, r7, lr}
 800c524:	b089      	sub	sp, #36	; 0x24
 800c526:	af02      	add	r7, sp, #8
 800c528:	60f8      	str	r0, [r7, #12]
 800c52a:	60b9      	str	r1, [r7, #8]
 800c52c:	607a      	str	r2, [r7, #4]
 800c52e:	603b      	str	r3, [r7, #0]
    if(br != NULL) *br = 0;
 800c530:	683b      	ldr	r3, [r7, #0]
 800c532:	2b00      	cmp	r3, #0
 800c534:	d002      	beq.n	800c53c <lv_fs_read+0x1a>
 800c536:	683b      	ldr	r3, [r7, #0]
 800c538:	2200      	movs	r2, #0
 800c53a:	601a      	str	r2, [r3, #0]
    if(file_p->drv == NULL) return LV_FS_RES_INV_PARAM;
 800c53c:	68fb      	ldr	r3, [r7, #12]
 800c53e:	685b      	ldr	r3, [r3, #4]
 800c540:	2b00      	cmp	r3, #0
 800c542:	d101      	bne.n	800c548 <lv_fs_read+0x26>
 800c544:	230b      	movs	r3, #11
 800c546:	e01e      	b.n	800c586 <lv_fs_read+0x64>
    if(file_p->drv->read_cb == NULL) return LV_FS_RES_NOT_IMP;
 800c548:	68fb      	ldr	r3, [r7, #12]
 800c54a:	685b      	ldr	r3, [r3, #4]
 800c54c:	699b      	ldr	r3, [r3, #24]
 800c54e:	2b00      	cmp	r3, #0
 800c550:	d101      	bne.n	800c556 <lv_fs_read+0x34>
 800c552:	2309      	movs	r3, #9
 800c554:	e017      	b.n	800c586 <lv_fs_read+0x64>

    uint32_t br_tmp = 0;
 800c556:	2300      	movs	r3, #0
 800c558:	613b      	str	r3, [r7, #16]
    lv_fs_res_t res = file_p->drv->read_cb(file_p->drv, file_p->file_d, buf, btr, &br_tmp);
 800c55a:	68fb      	ldr	r3, [r7, #12]
 800c55c:	685b      	ldr	r3, [r3, #4]
 800c55e:	699c      	ldr	r4, [r3, #24]
 800c560:	68fb      	ldr	r3, [r7, #12]
 800c562:	6858      	ldr	r0, [r3, #4]
 800c564:	68fb      	ldr	r3, [r7, #12]
 800c566:	6819      	ldr	r1, [r3, #0]
 800c568:	f107 0310 	add.w	r3, r7, #16
 800c56c:	9300      	str	r3, [sp, #0]
 800c56e:	687b      	ldr	r3, [r7, #4]
 800c570:	68ba      	ldr	r2, [r7, #8]
 800c572:	47a0      	blx	r4
 800c574:	4603      	mov	r3, r0
 800c576:	75fb      	strb	r3, [r7, #23]
    if(br != NULL) *br = br_tmp;
 800c578:	683b      	ldr	r3, [r7, #0]
 800c57a:	2b00      	cmp	r3, #0
 800c57c:	d002      	beq.n	800c584 <lv_fs_read+0x62>
 800c57e:	693a      	ldr	r2, [r7, #16]
 800c580:	683b      	ldr	r3, [r7, #0]
 800c582:	601a      	str	r2, [r3, #0]

    return res;
 800c584:	7dfb      	ldrb	r3, [r7, #23]
}
 800c586:	4618      	mov	r0, r3
 800c588:	371c      	adds	r7, #28
 800c58a:	46bd      	mov	sp, r7
 800c58c:	bd90      	pop	{r4, r7, pc}

0800c58e <lv_fs_seek>:
 * @param file_p pointer to a lv_fs_file_t variable
 * @param pos the new position expressed in bytes index (0: start of file)
 * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_seek(lv_fs_file_t * file_p, uint32_t pos)
{
 800c58e:	b580      	push	{r7, lr}
 800c590:	b084      	sub	sp, #16
 800c592:	af00      	add	r7, sp, #0
 800c594:	6078      	str	r0, [r7, #4]
 800c596:	6039      	str	r1, [r7, #0]
    if(file_p->drv == NULL) {
 800c598:	687b      	ldr	r3, [r7, #4]
 800c59a:	685b      	ldr	r3, [r3, #4]
 800c59c:	2b00      	cmp	r3, #0
 800c59e:	d101      	bne.n	800c5a4 <lv_fs_seek+0x16>
        return LV_FS_RES_INV_PARAM;
 800c5a0:	230b      	movs	r3, #11
 800c5a2:	e012      	b.n	800c5ca <lv_fs_seek+0x3c>
    }

    if(file_p->drv->seek_cb == NULL) {
 800c5a4:	687b      	ldr	r3, [r7, #4]
 800c5a6:	685b      	ldr	r3, [r3, #4]
 800c5a8:	6a1b      	ldr	r3, [r3, #32]
 800c5aa:	2b00      	cmp	r3, #0
 800c5ac:	d101      	bne.n	800c5b2 <lv_fs_seek+0x24>
        return LV_FS_RES_NOT_IMP;
 800c5ae:	2309      	movs	r3, #9
 800c5b0:	e00b      	b.n	800c5ca <lv_fs_seek+0x3c>
    }

    lv_fs_res_t res = file_p->drv->seek_cb(file_p->drv, file_p->file_d, pos);
 800c5b2:	687b      	ldr	r3, [r7, #4]
 800c5b4:	685b      	ldr	r3, [r3, #4]
 800c5b6:	6a1b      	ldr	r3, [r3, #32]
 800c5b8:	687a      	ldr	r2, [r7, #4]
 800c5ba:	6850      	ldr	r0, [r2, #4]
 800c5bc:	687a      	ldr	r2, [r7, #4]
 800c5be:	6811      	ldr	r1, [r2, #0]
 800c5c0:	683a      	ldr	r2, [r7, #0]
 800c5c2:	4798      	blx	r3
 800c5c4:	4603      	mov	r3, r0
 800c5c6:	73fb      	strb	r3, [r7, #15]

    return res;
 800c5c8:	7bfb      	ldrb	r3, [r7, #15]
}
 800c5ca:	4618      	mov	r0, r3
 800c5cc:	3710      	adds	r7, #16
 800c5ce:	46bd      	mov	sp, r7
 800c5d0:	bd80      	pop	{r7, pc}
	...

0800c5d4 <lv_fs_get_drv>:
 * Give a pointer to a driver from its letter
 * @param letter the driver letter
 * @return pointer to a driver or NULL if not found
 */
lv_fs_drv_t * lv_fs_get_drv(char letter)
{
 800c5d4:	b580      	push	{r7, lr}
 800c5d6:	b084      	sub	sp, #16
 800c5d8:	af00      	add	r7, sp, #0
 800c5da:	4603      	mov	r3, r0
 800c5dc:	71fb      	strb	r3, [r7, #7]
    lv_fs_drv_t * drv;

    LV_LL_READ(LV_GC_ROOT(_lv_drv_ll), drv)
 800c5de:	480c      	ldr	r0, [pc, #48]	; (800c610 <lv_fs_get_drv+0x3c>)
 800c5e0:	f000 f9ec 	bl	800c9bc <lv_ll_get_head>
 800c5e4:	60f8      	str	r0, [r7, #12]
 800c5e6:	e00b      	b.n	800c600 <lv_fs_get_drv+0x2c>
    {
        if(drv->letter == letter) {
 800c5e8:	68fb      	ldr	r3, [r7, #12]
 800c5ea:	781b      	ldrb	r3, [r3, #0]
 800c5ec:	79fa      	ldrb	r2, [r7, #7]
 800c5ee:	429a      	cmp	r2, r3
 800c5f0:	d101      	bne.n	800c5f6 <lv_fs_get_drv+0x22>
            return drv;
 800c5f2:	68fb      	ldr	r3, [r7, #12]
 800c5f4:	e008      	b.n	800c608 <lv_fs_get_drv+0x34>
    LV_LL_READ(LV_GC_ROOT(_lv_drv_ll), drv)
 800c5f6:	68f9      	ldr	r1, [r7, #12]
 800c5f8:	4805      	ldr	r0, [pc, #20]	; (800c610 <lv_fs_get_drv+0x3c>)
 800c5fa:	f000 fa05 	bl	800ca08 <lv_ll_get_next>
 800c5fe:	60f8      	str	r0, [r7, #12]
 800c600:	68fb      	ldr	r3, [r7, #12]
 800c602:	2b00      	cmp	r3, #0
 800c604:	d1f0      	bne.n	800c5e8 <lv_fs_get_drv+0x14>
        }
    }

    return NULL;
 800c606:	2300      	movs	r3, #0
}
 800c608:	4618      	mov	r0, r3
 800c60a:	3710      	adds	r7, #16
 800c60c:	46bd      	mov	sp, r7
 800c60e:	bd80      	pop	{r7, pc}
 800c610:	20009974 	.word	0x20009974

0800c614 <lv_fs_get_ext>:
 * Return with the extension of the filename
 * @param fn string with a filename
 * @return pointer to the beginning extension or empty string if no extension
 */
const char * lv_fs_get_ext(const char * fn)
{
 800c614:	b580      	push	{r7, lr}
 800c616:	b084      	sub	sp, #16
 800c618:	af00      	add	r7, sp, #0
 800c61a:	6078      	str	r0, [r7, #4]
    size_t i;
    for(i = strlen(fn); i > 0; i--) {
 800c61c:	6878      	ldr	r0, [r7, #4]
 800c61e:	f7f3 fde3 	bl	80001e8 <strlen>
 800c622:	60f8      	str	r0, [r7, #12]
 800c624:	e01b      	b.n	800c65e <lv_fs_get_ext+0x4a>
        if(fn[i] == '.') {
 800c626:	687a      	ldr	r2, [r7, #4]
 800c628:	68fb      	ldr	r3, [r7, #12]
 800c62a:	4413      	add	r3, r2
 800c62c:	781b      	ldrb	r3, [r3, #0]
 800c62e:	2b2e      	cmp	r3, #46	; 0x2e
 800c630:	d104      	bne.n	800c63c <lv_fs_get_ext+0x28>
            return &fn[i + 1];
 800c632:	68fb      	ldr	r3, [r7, #12]
 800c634:	3301      	adds	r3, #1
 800c636:	687a      	ldr	r2, [r7, #4]
 800c638:	4413      	add	r3, r2
 800c63a:	e014      	b.n	800c666 <lv_fs_get_ext+0x52>
        } else if(fn[i] == '/' || fn[i] == '\\') {
 800c63c:	687a      	ldr	r2, [r7, #4]
 800c63e:	68fb      	ldr	r3, [r7, #12]
 800c640:	4413      	add	r3, r2
 800c642:	781b      	ldrb	r3, [r3, #0]
 800c644:	2b2f      	cmp	r3, #47	; 0x2f
 800c646:	d005      	beq.n	800c654 <lv_fs_get_ext+0x40>
 800c648:	687a      	ldr	r2, [r7, #4]
 800c64a:	68fb      	ldr	r3, [r7, #12]
 800c64c:	4413      	add	r3, r2
 800c64e:	781b      	ldrb	r3, [r3, #0]
 800c650:	2b5c      	cmp	r3, #92	; 0x5c
 800c652:	d101      	bne.n	800c658 <lv_fs_get_ext+0x44>
            return ""; /*No extension if a '\' or '/' found*/
 800c654:	4b06      	ldr	r3, [pc, #24]	; (800c670 <lv_fs_get_ext+0x5c>)
 800c656:	e006      	b.n	800c666 <lv_fs_get_ext+0x52>
    for(i = strlen(fn); i > 0; i--) {
 800c658:	68fb      	ldr	r3, [r7, #12]
 800c65a:	3b01      	subs	r3, #1
 800c65c:	60fb      	str	r3, [r7, #12]
 800c65e:	68fb      	ldr	r3, [r7, #12]
 800c660:	2b00      	cmp	r3, #0
 800c662:	d1e0      	bne.n	800c626 <lv_fs_get_ext+0x12>
        }
    }

    return ""; /*Empty string if no '.' in the file name. */
 800c664:	4b02      	ldr	r3, [pc, #8]	; (800c670 <lv_fs_get_ext+0x5c>)
}
 800c666:	4618      	mov	r0, r3
 800c668:	3710      	adds	r7, #16
 800c66a:	46bd      	mov	sp, r7
 800c66c:	bd80      	pop	{r7, pc}
 800c66e:	bf00      	nop
 800c670:	08013898 	.word	0x08013898

0800c674 <lv_fs_get_real_path>:
 * Leave the driver letters and / or \ letters from beginning of the path
 * @param path path string (E.g. S:/folder/file.txt)
 * @return pointer to the beginning of the real path (E.g. folder/file.txt)
 */
static const char * lv_fs_get_real_path(const char * path)
{
 800c674:	b480      	push	{r7}
 800c676:	b083      	sub	sp, #12
 800c678:	af00      	add	r7, sp, #0
 800c67a:	6078      	str	r0, [r7, #4]
    /* Example path: "S:/folder/file.txt"
     * Leave the letter and the : / \ characters*/

    path++; /*Ignore the driver letter*/
 800c67c:	687b      	ldr	r3, [r7, #4]
 800c67e:	3301      	adds	r3, #1
 800c680:	607b      	str	r3, [r7, #4]

    while(*path != '\0') {
 800c682:	e00e      	b.n	800c6a2 <lv_fs_get_real_path+0x2e>
        if(*path == ':' || *path == '\\' || *path == '/') {
 800c684:	687b      	ldr	r3, [r7, #4]
 800c686:	781b      	ldrb	r3, [r3, #0]
 800c688:	2b3a      	cmp	r3, #58	; 0x3a
 800c68a:	d007      	beq.n	800c69c <lv_fs_get_real_path+0x28>
 800c68c:	687b      	ldr	r3, [r7, #4]
 800c68e:	781b      	ldrb	r3, [r3, #0]
 800c690:	2b5c      	cmp	r3, #92	; 0x5c
 800c692:	d003      	beq.n	800c69c <lv_fs_get_real_path+0x28>
 800c694:	687b      	ldr	r3, [r7, #4]
 800c696:	781b      	ldrb	r3, [r3, #0]
 800c698:	2b2f      	cmp	r3, #47	; 0x2f
 800c69a:	d106      	bne.n	800c6aa <lv_fs_get_real_path+0x36>
            path++;
 800c69c:	687b      	ldr	r3, [r7, #4]
 800c69e:	3301      	adds	r3, #1
 800c6a0:	607b      	str	r3, [r7, #4]
    while(*path != '\0') {
 800c6a2:	687b      	ldr	r3, [r7, #4]
 800c6a4:	781b      	ldrb	r3, [r3, #0]
 800c6a6:	2b00      	cmp	r3, #0
 800c6a8:	d1ec      	bne.n	800c684 <lv_fs_get_real_path+0x10>
        } else {
            break;
        }
    }

    return path;
 800c6aa:	687b      	ldr	r3, [r7, #4]
}
 800c6ac:	4618      	mov	r0, r3
 800c6ae:	370c      	adds	r7, #12
 800c6b0:	46bd      	mov	sp, r7
 800c6b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c6b6:	4770      	bx	lr

0800c6b8 <lv_ll_init>:
 * Initialize linked list
 * @param ll_dsc pointer to ll_dsc variable
 * @param node_size the size of 1 node in bytes
 */
void lv_ll_init(lv_ll_t * ll_p, uint32_t node_size)
{
 800c6b8:	b480      	push	{r7}
 800c6ba:	b083      	sub	sp, #12
 800c6bc:	af00      	add	r7, sp, #0
 800c6be:	6078      	str	r0, [r7, #4]
 800c6c0:	6039      	str	r1, [r7, #0]
    ll_p->head = NULL;
 800c6c2:	687b      	ldr	r3, [r7, #4]
 800c6c4:	2200      	movs	r2, #0
 800c6c6:	605a      	str	r2, [r3, #4]
    ll_p->tail = NULL;
 800c6c8:	687b      	ldr	r3, [r7, #4]
 800c6ca:	2200      	movs	r2, #0
 800c6cc:	609a      	str	r2, [r3, #8]
        node_size = node_size & (~0x7);
        node_size += 8;
    }
#else
    /*Round the size up to 4*/
    if(node_size & 0x3) {
 800c6ce:	683b      	ldr	r3, [r7, #0]
 800c6d0:	f003 0303 	and.w	r3, r3, #3
 800c6d4:	2b00      	cmp	r3, #0
 800c6d6:	d006      	beq.n	800c6e6 <lv_ll_init+0x2e>
        node_size = node_size & (~0x3);
 800c6d8:	683b      	ldr	r3, [r7, #0]
 800c6da:	f023 0303 	bic.w	r3, r3, #3
 800c6de:	603b      	str	r3, [r7, #0]
        node_size += 4;
 800c6e0:	683b      	ldr	r3, [r7, #0]
 800c6e2:	3304      	adds	r3, #4
 800c6e4:	603b      	str	r3, [r7, #0]
    }
#endif

    ll_p->n_size = node_size;
 800c6e6:	687b      	ldr	r3, [r7, #4]
 800c6e8:	683a      	ldr	r2, [r7, #0]
 800c6ea:	601a      	str	r2, [r3, #0]
}
 800c6ec:	bf00      	nop
 800c6ee:	370c      	adds	r7, #12
 800c6f0:	46bd      	mov	sp, r7
 800c6f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c6f6:	4770      	bx	lr

0800c6f8 <lv_ll_ins_head>:
 * Add a new head to a linked list
 * @param ll_p pointer to linked list
 * @return pointer to the new head
 */
void * lv_ll_ins_head(lv_ll_t * ll_p)
{
 800c6f8:	b580      	push	{r7, lr}
 800c6fa:	b084      	sub	sp, #16
 800c6fc:	af00      	add	r7, sp, #0
 800c6fe:	6078      	str	r0, [r7, #4]
    lv_ll_node_t * n_new;

    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 800c700:	687b      	ldr	r3, [r7, #4]
 800c702:	681b      	ldr	r3, [r3, #0]
 800c704:	3308      	adds	r3, #8
 800c706:	4618      	mov	r0, r3
 800c708:	f000 fa80 	bl	800cc0c <lv_mem_alloc>
 800c70c:	60f8      	str	r0, [r7, #12]

    if(n_new != NULL) {
 800c70e:	68fb      	ldr	r3, [r7, #12]
 800c710:	2b00      	cmp	r3, #0
 800c712:	d020      	beq.n	800c756 <lv_ll_ins_head+0x5e>
        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/
 800c714:	2200      	movs	r2, #0
 800c716:	68f9      	ldr	r1, [r7, #12]
 800c718:	6878      	ldr	r0, [r7, #4]
 800c71a:	f000 fa08 	bl	800cb2e <node_set_prev>
        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/
 800c71e:	687b      	ldr	r3, [r7, #4]
 800c720:	685b      	ldr	r3, [r3, #4]
 800c722:	461a      	mov	r2, r3
 800c724:	68f9      	ldr	r1, [r7, #12]
 800c726:	6878      	ldr	r0, [r7, #4]
 800c728:	f000 fa27 	bl	800cb7a <node_set_next>

        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/
 800c72c:	687b      	ldr	r3, [r7, #4]
 800c72e:	685b      	ldr	r3, [r3, #4]
 800c730:	2b00      	cmp	r3, #0
 800c732:	d006      	beq.n	800c742 <lv_ll_ins_head+0x4a>
            node_set_prev(ll_p, ll_p->head, n_new);
 800c734:	687b      	ldr	r3, [r7, #4]
 800c736:	685b      	ldr	r3, [r3, #4]
 800c738:	68fa      	ldr	r2, [r7, #12]
 800c73a:	4619      	mov	r1, r3
 800c73c:	6878      	ldr	r0, [r7, #4]
 800c73e:	f000 f9f6 	bl	800cb2e <node_set_prev>
        }

        ll_p->head = n_new;      /*Set the new head in the dsc.*/
 800c742:	687b      	ldr	r3, [r7, #4]
 800c744:	68fa      	ldr	r2, [r7, #12]
 800c746:	605a      	str	r2, [r3, #4]
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
 800c748:	687b      	ldr	r3, [r7, #4]
 800c74a:	689b      	ldr	r3, [r3, #8]
 800c74c:	2b00      	cmp	r3, #0
 800c74e:	d102      	bne.n	800c756 <lv_ll_ins_head+0x5e>
            ll_p->tail = n_new;
 800c750:	687b      	ldr	r3, [r7, #4]
 800c752:	68fa      	ldr	r2, [r7, #12]
 800c754:	609a      	str	r2, [r3, #8]
        }
    }

    return n_new;
 800c756:	68fb      	ldr	r3, [r7, #12]
}
 800c758:	4618      	mov	r0, r3
 800c75a:	3710      	adds	r7, #16
 800c75c:	46bd      	mov	sp, r7
 800c75e:	bd80      	pop	{r7, pc}

0800c760 <lv_ll_ins_prev>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the new head
 */
void * lv_ll_ins_prev(lv_ll_t * ll_p, void * n_act)
{
 800c760:	b580      	push	{r7, lr}
 800c762:	b084      	sub	sp, #16
 800c764:	af00      	add	r7, sp, #0
 800c766:	6078      	str	r0, [r7, #4]
 800c768:	6039      	str	r1, [r7, #0]
    lv_ll_node_t * n_new;
    lv_ll_node_t * n_prev;

    if(NULL == ll_p || NULL == n_act) return NULL;
 800c76a:	687b      	ldr	r3, [r7, #4]
 800c76c:	2b00      	cmp	r3, #0
 800c76e:	d002      	beq.n	800c776 <lv_ll_ins_prev+0x16>
 800c770:	683b      	ldr	r3, [r7, #0]
 800c772:	2b00      	cmp	r3, #0
 800c774:	d101      	bne.n	800c77a <lv_ll_ins_prev+0x1a>
 800c776:	2300      	movs	r3, #0
 800c778:	e035      	b.n	800c7e6 <lv_ll_ins_prev+0x86>

    if(lv_ll_get_head(ll_p) == n_act) {
 800c77a:	6878      	ldr	r0, [r7, #4]
 800c77c:	f000 f91e 	bl	800c9bc <lv_ll_get_head>
 800c780:	4602      	mov	r2, r0
 800c782:	683b      	ldr	r3, [r7, #0]
 800c784:	4293      	cmp	r3, r2
 800c786:	d108      	bne.n	800c79a <lv_ll_ins_prev+0x3a>
        n_new = lv_ll_ins_head(ll_p);
 800c788:	6878      	ldr	r0, [r7, #4]
 800c78a:	f7ff ffb5 	bl	800c6f8 <lv_ll_ins_head>
 800c78e:	60f8      	str	r0, [r7, #12]
        if(n_new == NULL) return NULL;
 800c790:	68fb      	ldr	r3, [r7, #12]
 800c792:	2b00      	cmp	r3, #0
 800c794:	d126      	bne.n	800c7e4 <lv_ll_ins_prev+0x84>
 800c796:	2300      	movs	r3, #0
 800c798:	e025      	b.n	800c7e6 <lv_ll_ins_prev+0x86>
    } else {
        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 800c79a:	687b      	ldr	r3, [r7, #4]
 800c79c:	681b      	ldr	r3, [r3, #0]
 800c79e:	3308      	adds	r3, #8
 800c7a0:	4618      	mov	r0, r3
 800c7a2:	f000 fa33 	bl	800cc0c <lv_mem_alloc>
 800c7a6:	60f8      	str	r0, [r7, #12]
        if(n_new == NULL) return NULL;
 800c7a8:	68fb      	ldr	r3, [r7, #12]
 800c7aa:	2b00      	cmp	r3, #0
 800c7ac:	d101      	bne.n	800c7b2 <lv_ll_ins_prev+0x52>
 800c7ae:	2300      	movs	r3, #0
 800c7b0:	e019      	b.n	800c7e6 <lv_ll_ins_prev+0x86>

        n_prev = lv_ll_get_prev(ll_p, n_act);
 800c7b2:	6839      	ldr	r1, [r7, #0]
 800c7b4:	6878      	ldr	r0, [r7, #4]
 800c7b6:	f000 f941 	bl	800ca3c <lv_ll_get_prev>
 800c7ba:	60b8      	str	r0, [r7, #8]
        node_set_next(ll_p, n_prev, n_new);
 800c7bc:	68fa      	ldr	r2, [r7, #12]
 800c7be:	68b9      	ldr	r1, [r7, #8]
 800c7c0:	6878      	ldr	r0, [r7, #4]
 800c7c2:	f000 f9da 	bl	800cb7a <node_set_next>
        node_set_prev(ll_p, n_new, n_prev);
 800c7c6:	68ba      	ldr	r2, [r7, #8]
 800c7c8:	68f9      	ldr	r1, [r7, #12]
 800c7ca:	6878      	ldr	r0, [r7, #4]
 800c7cc:	f000 f9af 	bl	800cb2e <node_set_prev>
        node_set_prev(ll_p, n_act, n_new);
 800c7d0:	68fa      	ldr	r2, [r7, #12]
 800c7d2:	6839      	ldr	r1, [r7, #0]
 800c7d4:	6878      	ldr	r0, [r7, #4]
 800c7d6:	f000 f9aa 	bl	800cb2e <node_set_prev>
        node_set_next(ll_p, n_new, n_act);
 800c7da:	683a      	ldr	r2, [r7, #0]
 800c7dc:	68f9      	ldr	r1, [r7, #12]
 800c7de:	6878      	ldr	r0, [r7, #4]
 800c7e0:	f000 f9cb 	bl	800cb7a <node_set_next>
    }

    return n_new;
 800c7e4:	68fb      	ldr	r3, [r7, #12]
}
 800c7e6:	4618      	mov	r0, r3
 800c7e8:	3710      	adds	r7, #16
 800c7ea:	46bd      	mov	sp, r7
 800c7ec:	bd80      	pop	{r7, pc}

0800c7ee <lv_ll_ins_tail>:
 * Add a new tail to a linked list
 * @param ll_p pointer to linked list
 * @return pointer to the new tail
 */
void * lv_ll_ins_tail(lv_ll_t * ll_p)
{
 800c7ee:	b580      	push	{r7, lr}
 800c7f0:	b084      	sub	sp, #16
 800c7f2:	af00      	add	r7, sp, #0
 800c7f4:	6078      	str	r0, [r7, #4]
    lv_ll_node_t * n_new;

    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 800c7f6:	687b      	ldr	r3, [r7, #4]
 800c7f8:	681b      	ldr	r3, [r3, #0]
 800c7fa:	3308      	adds	r3, #8
 800c7fc:	4618      	mov	r0, r3
 800c7fe:	f000 fa05 	bl	800cc0c <lv_mem_alloc>
 800c802:	60f8      	str	r0, [r7, #12]
    if(n_new == NULL) return NULL;
 800c804:	68fb      	ldr	r3, [r7, #12]
 800c806:	2b00      	cmp	r3, #0
 800c808:	d101      	bne.n	800c80e <lv_ll_ins_tail+0x20>
 800c80a:	2300      	movs	r3, #0
 800c80c:	e024      	b.n	800c858 <lv_ll_ins_tail+0x6a>

    if(n_new != NULL) {
 800c80e:	68fb      	ldr	r3, [r7, #12]
 800c810:	2b00      	cmp	r3, #0
 800c812:	d020      	beq.n	800c856 <lv_ll_ins_tail+0x68>
        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/
 800c814:	2200      	movs	r2, #0
 800c816:	68f9      	ldr	r1, [r7, #12]
 800c818:	6878      	ldr	r0, [r7, #4]
 800c81a:	f000 f9ae 	bl	800cb7a <node_set_next>
        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is tho old tail*/
 800c81e:	687b      	ldr	r3, [r7, #4]
 800c820:	689b      	ldr	r3, [r3, #8]
 800c822:	461a      	mov	r2, r3
 800c824:	68f9      	ldr	r1, [r7, #12]
 800c826:	6878      	ldr	r0, [r7, #4]
 800c828:	f000 f981 	bl	800cb2e <node_set_prev>
        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/
 800c82c:	687b      	ldr	r3, [r7, #4]
 800c82e:	689b      	ldr	r3, [r3, #8]
 800c830:	2b00      	cmp	r3, #0
 800c832:	d006      	beq.n	800c842 <lv_ll_ins_tail+0x54>
            node_set_next(ll_p, ll_p->tail, n_new);
 800c834:	687b      	ldr	r3, [r7, #4]
 800c836:	689b      	ldr	r3, [r3, #8]
 800c838:	68fa      	ldr	r2, [r7, #12]
 800c83a:	4619      	mov	r1, r3
 800c83c:	6878      	ldr	r0, [r7, #4]
 800c83e:	f000 f99c 	bl	800cb7a <node_set_next>
        }

        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/
 800c842:	687b      	ldr	r3, [r7, #4]
 800c844:	68fa      	ldr	r2, [r7, #12]
 800c846:	609a      	str	r2, [r3, #8]
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
 800c848:	687b      	ldr	r3, [r7, #4]
 800c84a:	685b      	ldr	r3, [r3, #4]
 800c84c:	2b00      	cmp	r3, #0
 800c84e:	d102      	bne.n	800c856 <lv_ll_ins_tail+0x68>
            ll_p->head = n_new;
 800c850:	687b      	ldr	r3, [r7, #4]
 800c852:	68fa      	ldr	r2, [r7, #12]
 800c854:	605a      	str	r2, [r3, #4]
        }
    }

    return n_new;
 800c856:	68fb      	ldr	r3, [r7, #12]
}
 800c858:	4618      	mov	r0, r3
 800c85a:	3710      	adds	r7, #16
 800c85c:	46bd      	mov	sp, r7
 800c85e:	bd80      	pop	{r7, pc}

0800c860 <lv_ll_rem>:
 * It does not free the the memory of node.
 * @param ll_p pointer to the linked list of 'node_p'
 * @param node_p pointer to node in 'll_p' linked list
 */
void lv_ll_rem(lv_ll_t * ll_p, void * node_p)
{
 800c860:	b580      	push	{r7, lr}
 800c862:	b084      	sub	sp, #16
 800c864:	af00      	add	r7, sp, #0
 800c866:	6078      	str	r0, [r7, #4]
 800c868:	6039      	str	r1, [r7, #0]
    if(lv_ll_get_head(ll_p) == node_p) {
 800c86a:	6878      	ldr	r0, [r7, #4]
 800c86c:	f000 f8a6 	bl	800c9bc <lv_ll_get_head>
 800c870:	4602      	mov	r2, r0
 800c872:	683b      	ldr	r3, [r7, #0]
 800c874:	4293      	cmp	r3, r2
 800c876:	d116      	bne.n	800c8a6 <lv_ll_rem+0x46>
        /*The new head will be the node after 'n_act'*/
        ll_p->head = lv_ll_get_next(ll_p, node_p);
 800c878:	6839      	ldr	r1, [r7, #0]
 800c87a:	6878      	ldr	r0, [r7, #4]
 800c87c:	f000 f8c4 	bl	800ca08 <lv_ll_get_next>
 800c880:	4602      	mov	r2, r0
 800c882:	687b      	ldr	r3, [r7, #4]
 800c884:	605a      	str	r2, [r3, #4]
        if(ll_p->head == NULL) {
 800c886:	687b      	ldr	r3, [r7, #4]
 800c888:	685b      	ldr	r3, [r3, #4]
 800c88a:	2b00      	cmp	r3, #0
 800c88c:	d103      	bne.n	800c896 <lv_ll_rem+0x36>
            ll_p->tail = NULL;
 800c88e:	687b      	ldr	r3, [r7, #4]
 800c890:	2200      	movs	r2, #0
 800c892:	609a      	str	r2, [r3, #8]
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);

        node_set_next(ll_p, n_prev, n_next);
        node_set_prev(ll_p, n_next, n_prev);
    }
}
 800c894:	e039      	b.n	800c90a <lv_ll_rem+0xaa>
            node_set_prev(ll_p, ll_p->head, NULL);
 800c896:	687b      	ldr	r3, [r7, #4]
 800c898:	685b      	ldr	r3, [r3, #4]
 800c89a:	2200      	movs	r2, #0
 800c89c:	4619      	mov	r1, r3
 800c89e:	6878      	ldr	r0, [r7, #4]
 800c8a0:	f000 f945 	bl	800cb2e <node_set_prev>
}
 800c8a4:	e031      	b.n	800c90a <lv_ll_rem+0xaa>
    } else if(lv_ll_get_tail(ll_p) == node_p) {
 800c8a6:	6878      	ldr	r0, [r7, #4]
 800c8a8:	f000 f89b 	bl	800c9e2 <lv_ll_get_tail>
 800c8ac:	4602      	mov	r2, r0
 800c8ae:	683b      	ldr	r3, [r7, #0]
 800c8b0:	4293      	cmp	r3, r2
 800c8b2:	d116      	bne.n	800c8e2 <lv_ll_rem+0x82>
        ll_p->tail = lv_ll_get_prev(ll_p, node_p);
 800c8b4:	6839      	ldr	r1, [r7, #0]
 800c8b6:	6878      	ldr	r0, [r7, #4]
 800c8b8:	f000 f8c0 	bl	800ca3c <lv_ll_get_prev>
 800c8bc:	4602      	mov	r2, r0
 800c8be:	687b      	ldr	r3, [r7, #4]
 800c8c0:	609a      	str	r2, [r3, #8]
        if(ll_p->tail == NULL) {
 800c8c2:	687b      	ldr	r3, [r7, #4]
 800c8c4:	689b      	ldr	r3, [r3, #8]
 800c8c6:	2b00      	cmp	r3, #0
 800c8c8:	d103      	bne.n	800c8d2 <lv_ll_rem+0x72>
            ll_p->head = NULL;
 800c8ca:	687b      	ldr	r3, [r7, #4]
 800c8cc:	2200      	movs	r2, #0
 800c8ce:	605a      	str	r2, [r3, #4]
}
 800c8d0:	e01b      	b.n	800c90a <lv_ll_rem+0xaa>
            node_set_next(ll_p, ll_p->tail, NULL);
 800c8d2:	687b      	ldr	r3, [r7, #4]
 800c8d4:	689b      	ldr	r3, [r3, #8]
 800c8d6:	2200      	movs	r2, #0
 800c8d8:	4619      	mov	r1, r3
 800c8da:	6878      	ldr	r0, [r7, #4]
 800c8dc:	f000 f94d 	bl	800cb7a <node_set_next>
}
 800c8e0:	e013      	b.n	800c90a <lv_ll_rem+0xaa>
        lv_ll_node_t * n_prev = lv_ll_get_prev(ll_p, node_p);
 800c8e2:	6839      	ldr	r1, [r7, #0]
 800c8e4:	6878      	ldr	r0, [r7, #4]
 800c8e6:	f000 f8a9 	bl	800ca3c <lv_ll_get_prev>
 800c8ea:	60f8      	str	r0, [r7, #12]
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
 800c8ec:	6839      	ldr	r1, [r7, #0]
 800c8ee:	6878      	ldr	r0, [r7, #4]
 800c8f0:	f000 f88a 	bl	800ca08 <lv_ll_get_next>
 800c8f4:	60b8      	str	r0, [r7, #8]
        node_set_next(ll_p, n_prev, n_next);
 800c8f6:	68ba      	ldr	r2, [r7, #8]
 800c8f8:	68f9      	ldr	r1, [r7, #12]
 800c8fa:	6878      	ldr	r0, [r7, #4]
 800c8fc:	f000 f93d 	bl	800cb7a <node_set_next>
        node_set_prev(ll_p, n_next, n_prev);
 800c900:	68fa      	ldr	r2, [r7, #12]
 800c902:	68b9      	ldr	r1, [r7, #8]
 800c904:	6878      	ldr	r0, [r7, #4]
 800c906:	f000 f912 	bl	800cb2e <node_set_prev>
}
 800c90a:	bf00      	nop
 800c90c:	3710      	adds	r7, #16
 800c90e:	46bd      	mov	sp, r7
 800c910:	bd80      	pop	{r7, pc}

0800c912 <lv_ll_chg_list>:
 * @param node pointer to a node
 * @param head true: be the head in the new list
 *             false be the head in the new list
 */
void lv_ll_chg_list(lv_ll_t * ll_ori_p, lv_ll_t * ll_new_p, void * node, bool head)
{
 800c912:	b580      	push	{r7, lr}
 800c914:	b084      	sub	sp, #16
 800c916:	af00      	add	r7, sp, #0
 800c918:	60f8      	str	r0, [r7, #12]
 800c91a:	60b9      	str	r1, [r7, #8]
 800c91c:	607a      	str	r2, [r7, #4]
 800c91e:	70fb      	strb	r3, [r7, #3]
    lv_ll_rem(ll_ori_p, node);
 800c920:	6879      	ldr	r1, [r7, #4]
 800c922:	68f8      	ldr	r0, [r7, #12]
 800c924:	f7ff ff9c 	bl	800c860 <lv_ll_rem>

    if(head) {
 800c928:	78fb      	ldrb	r3, [r7, #3]
 800c92a:	2b00      	cmp	r3, #0
 800c92c:	d021      	beq.n	800c972 <lv_ll_chg_list+0x60>
        /*Set node as head*/
        node_set_prev(ll_new_p, node, NULL);
 800c92e:	2200      	movs	r2, #0
 800c930:	6879      	ldr	r1, [r7, #4]
 800c932:	68b8      	ldr	r0, [r7, #8]
 800c934:	f000 f8fb 	bl	800cb2e <node_set_prev>
        node_set_next(ll_new_p, node, ll_new_p->head);
 800c938:	68bb      	ldr	r3, [r7, #8]
 800c93a:	685b      	ldr	r3, [r3, #4]
 800c93c:	461a      	mov	r2, r3
 800c93e:	6879      	ldr	r1, [r7, #4]
 800c940:	68b8      	ldr	r0, [r7, #8]
 800c942:	f000 f91a 	bl	800cb7a <node_set_next>

        if(ll_new_p->head != NULL) { /*If there is old head then before it goes the new*/
 800c946:	68bb      	ldr	r3, [r7, #8]
 800c948:	685b      	ldr	r3, [r3, #4]
 800c94a:	2b00      	cmp	r3, #0
 800c94c:	d006      	beq.n	800c95c <lv_ll_chg_list+0x4a>
            node_set_prev(ll_new_p, ll_new_p->head, node);
 800c94e:	68bb      	ldr	r3, [r7, #8]
 800c950:	685b      	ldr	r3, [r3, #4]
 800c952:	687a      	ldr	r2, [r7, #4]
 800c954:	4619      	mov	r1, r3
 800c956:	68b8      	ldr	r0, [r7, #8]
 800c958:	f000 f8e9 	bl	800cb2e <node_set_prev>
        }

        ll_new_p->head = node;       /*Set the new head in the dsc.*/
 800c95c:	68bb      	ldr	r3, [r7, #8]
 800c95e:	687a      	ldr	r2, [r7, #4]
 800c960:	605a      	str	r2, [r3, #4]
        if(ll_new_p->tail == NULL) { /*If there is no tail (first node) set the tail too*/
 800c962:	68bb      	ldr	r3, [r7, #8]
 800c964:	689b      	ldr	r3, [r3, #8]
 800c966:	2b00      	cmp	r3, #0
 800c968:	d124      	bne.n	800c9b4 <lv_ll_chg_list+0xa2>
            ll_new_p->tail = node;
 800c96a:	68bb      	ldr	r3, [r7, #8]
 800c96c:	687a      	ldr	r2, [r7, #4]
 800c96e:	609a      	str	r2, [r3, #8]
        ll_new_p->tail = node;       /*Set the new tail in the dsc.*/
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
            ll_new_p->head = node;
        }
    }
}
 800c970:	e020      	b.n	800c9b4 <lv_ll_chg_list+0xa2>
        node_set_prev(ll_new_p, node, ll_new_p->tail);
 800c972:	68bb      	ldr	r3, [r7, #8]
 800c974:	689b      	ldr	r3, [r3, #8]
 800c976:	461a      	mov	r2, r3
 800c978:	6879      	ldr	r1, [r7, #4]
 800c97a:	68b8      	ldr	r0, [r7, #8]
 800c97c:	f000 f8d7 	bl	800cb2e <node_set_prev>
        node_set_next(ll_new_p, node, NULL);
 800c980:	2200      	movs	r2, #0
 800c982:	6879      	ldr	r1, [r7, #4]
 800c984:	68b8      	ldr	r0, [r7, #8]
 800c986:	f000 f8f8 	bl	800cb7a <node_set_next>
        if(ll_new_p->tail != NULL) { /*If there is old tail then after it goes the new*/
 800c98a:	68bb      	ldr	r3, [r7, #8]
 800c98c:	689b      	ldr	r3, [r3, #8]
 800c98e:	2b00      	cmp	r3, #0
 800c990:	d006      	beq.n	800c9a0 <lv_ll_chg_list+0x8e>
            node_set_next(ll_new_p, ll_new_p->tail, node);
 800c992:	68bb      	ldr	r3, [r7, #8]
 800c994:	689b      	ldr	r3, [r3, #8]
 800c996:	687a      	ldr	r2, [r7, #4]
 800c998:	4619      	mov	r1, r3
 800c99a:	68b8      	ldr	r0, [r7, #8]
 800c99c:	f000 f8ed 	bl	800cb7a <node_set_next>
        ll_new_p->tail = node;       /*Set the new tail in the dsc.*/
 800c9a0:	68bb      	ldr	r3, [r7, #8]
 800c9a2:	687a      	ldr	r2, [r7, #4]
 800c9a4:	609a      	str	r2, [r3, #8]
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
 800c9a6:	68bb      	ldr	r3, [r7, #8]
 800c9a8:	685b      	ldr	r3, [r3, #4]
 800c9aa:	2b00      	cmp	r3, #0
 800c9ac:	d102      	bne.n	800c9b4 <lv_ll_chg_list+0xa2>
            ll_new_p->head = node;
 800c9ae:	68bb      	ldr	r3, [r7, #8]
 800c9b0:	687a      	ldr	r2, [r7, #4]
 800c9b2:	605a      	str	r2, [r3, #4]
}
 800c9b4:	bf00      	nop
 800c9b6:	3710      	adds	r7, #16
 800c9b8:	46bd      	mov	sp, r7
 800c9ba:	bd80      	pop	{r7, pc}

0800c9bc <lv_ll_get_head>:
 * Return with head node of the linked list
 * @param ll_p pointer to linked list
 * @return pointer to the head of 'll_p'
 */
void * lv_ll_get_head(const lv_ll_t * ll_p)
{
 800c9bc:	b480      	push	{r7}
 800c9be:	b085      	sub	sp, #20
 800c9c0:	af00      	add	r7, sp, #0
 800c9c2:	6078      	str	r0, [r7, #4]
    void * head = NULL;
 800c9c4:	2300      	movs	r3, #0
 800c9c6:	60fb      	str	r3, [r7, #12]

    if(ll_p != NULL) {
 800c9c8:	687b      	ldr	r3, [r7, #4]
 800c9ca:	2b00      	cmp	r3, #0
 800c9cc:	d002      	beq.n	800c9d4 <lv_ll_get_head+0x18>
        head = ll_p->head;
 800c9ce:	687b      	ldr	r3, [r7, #4]
 800c9d0:	685b      	ldr	r3, [r3, #4]
 800c9d2:	60fb      	str	r3, [r7, #12]
    }

    return head;
 800c9d4:	68fb      	ldr	r3, [r7, #12]
}
 800c9d6:	4618      	mov	r0, r3
 800c9d8:	3714      	adds	r7, #20
 800c9da:	46bd      	mov	sp, r7
 800c9dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c9e0:	4770      	bx	lr

0800c9e2 <lv_ll_get_tail>:
 * Return with tail node of the linked list
 * @param ll_p pointer to linked list
 * @return pointer to the head of 'll_p'
 */
void * lv_ll_get_tail(const lv_ll_t * ll_p)
{
 800c9e2:	b480      	push	{r7}
 800c9e4:	b085      	sub	sp, #20
 800c9e6:	af00      	add	r7, sp, #0
 800c9e8:	6078      	str	r0, [r7, #4]
    void * tail = NULL;
 800c9ea:	2300      	movs	r3, #0
 800c9ec:	60fb      	str	r3, [r7, #12]

    if(ll_p != NULL) {
 800c9ee:	687b      	ldr	r3, [r7, #4]
 800c9f0:	2b00      	cmp	r3, #0
 800c9f2:	d002      	beq.n	800c9fa <lv_ll_get_tail+0x18>
        tail = ll_p->tail;
 800c9f4:	687b      	ldr	r3, [r7, #4]
 800c9f6:	689b      	ldr	r3, [r3, #8]
 800c9f8:	60fb      	str	r3, [r7, #12]
    }

    return tail;
 800c9fa:	68fb      	ldr	r3, [r7, #12]
}
 800c9fc:	4618      	mov	r0, r3
 800c9fe:	3714      	adds	r7, #20
 800ca00:	46bd      	mov	sp, r7
 800ca02:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca06:	4770      	bx	lr

0800ca08 <lv_ll_get_next>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the next node
 */
void * lv_ll_get_next(const lv_ll_t * ll_p, const void * n_act)
{
 800ca08:	b480      	push	{r7}
 800ca0a:	b085      	sub	sp, #20
 800ca0c:	af00      	add	r7, sp, #0
 800ca0e:	6078      	str	r0, [r7, #4]
 800ca10:	6039      	str	r1, [r7, #0]
    void * next = NULL;
 800ca12:	2300      	movs	r3, #0
 800ca14:	60bb      	str	r3, [r7, #8]

    if(ll_p != NULL) {
 800ca16:	687b      	ldr	r3, [r7, #4]
 800ca18:	2b00      	cmp	r3, #0
 800ca1a:	d008      	beq.n	800ca2e <lv_ll_get_next+0x26>
        const lv_ll_node_t * n_act_d = n_act;
 800ca1c:	683b      	ldr	r3, [r7, #0]
 800ca1e:	60fb      	str	r3, [r7, #12]
        memcpy(&next, n_act_d + LL_NEXT_P_OFFSET(ll_p), sizeof(void *));
 800ca20:	687b      	ldr	r3, [r7, #4]
 800ca22:	681b      	ldr	r3, [r3, #0]
 800ca24:	3304      	adds	r3, #4
 800ca26:	68fa      	ldr	r2, [r7, #12]
 800ca28:	4413      	add	r3, r2
 800ca2a:	681b      	ldr	r3, [r3, #0]
 800ca2c:	60bb      	str	r3, [r7, #8]
    }

    return next;
 800ca2e:	68bb      	ldr	r3, [r7, #8]
}
 800ca30:	4618      	mov	r0, r3
 800ca32:	3714      	adds	r7, #20
 800ca34:	46bd      	mov	sp, r7
 800ca36:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca3a:	4770      	bx	lr

0800ca3c <lv_ll_get_prev>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the previous node
 */
void * lv_ll_get_prev(const lv_ll_t * ll_p, const void * n_act)
{
 800ca3c:	b480      	push	{r7}
 800ca3e:	b085      	sub	sp, #20
 800ca40:	af00      	add	r7, sp, #0
 800ca42:	6078      	str	r0, [r7, #4]
 800ca44:	6039      	str	r1, [r7, #0]
    void * prev = NULL;
 800ca46:	2300      	movs	r3, #0
 800ca48:	60bb      	str	r3, [r7, #8]

    if(ll_p != NULL) {
 800ca4a:	687b      	ldr	r3, [r7, #4]
 800ca4c:	2b00      	cmp	r3, #0
 800ca4e:	d007      	beq.n	800ca60 <lv_ll_get_prev+0x24>
        const lv_ll_node_t * n_act_d = n_act;
 800ca50:	683b      	ldr	r3, [r7, #0]
 800ca52:	60fb      	str	r3, [r7, #12]
        memcpy(&prev, n_act_d + LL_PREV_P_OFFSET(ll_p), sizeof(void *));
 800ca54:	687b      	ldr	r3, [r7, #4]
 800ca56:	681b      	ldr	r3, [r3, #0]
 800ca58:	68fa      	ldr	r2, [r7, #12]
 800ca5a:	4413      	add	r3, r2
 800ca5c:	681b      	ldr	r3, [r3, #0]
 800ca5e:	60bb      	str	r3, [r7, #8]
    }

    return prev;
 800ca60:	68bb      	ldr	r3, [r7, #8]
}
 800ca62:	4618      	mov	r0, r3
 800ca64:	3714      	adds	r7, #20
 800ca66:	46bd      	mov	sp, r7
 800ca68:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca6c:	4770      	bx	lr

0800ca6e <lv_ll_move_before>:
 * @param ll_p pointer to a linked list
 * @param n_act pointer to node to move
 * @param n_after pointer to a node which should be after `n_act`
 */
void lv_ll_move_before(lv_ll_t * ll_p, void * n_act, void * n_after)
{
 800ca6e:	b580      	push	{r7, lr}
 800ca70:	b086      	sub	sp, #24
 800ca72:	af00      	add	r7, sp, #0
 800ca74:	60f8      	str	r0, [r7, #12]
 800ca76:	60b9      	str	r1, [r7, #8]
 800ca78:	607a      	str	r2, [r7, #4]
    if(n_act == n_after) return; /*Can't move before itself*/
 800ca7a:	68ba      	ldr	r2, [r7, #8]
 800ca7c:	687b      	ldr	r3, [r7, #4]
 800ca7e:	429a      	cmp	r2, r3
 800ca80:	d035      	beq.n	800caee <lv_ll_move_before+0x80>

    void * n_before;
    if(n_after != NULL)
 800ca82:	687b      	ldr	r3, [r7, #4]
 800ca84:	2b00      	cmp	r3, #0
 800ca86:	d005      	beq.n	800ca94 <lv_ll_move_before+0x26>
        n_before = lv_ll_get_prev(ll_p, n_after);
 800ca88:	6879      	ldr	r1, [r7, #4]
 800ca8a:	68f8      	ldr	r0, [r7, #12]
 800ca8c:	f7ff ffd6 	bl	800ca3c <lv_ll_get_prev>
 800ca90:	6178      	str	r0, [r7, #20]
 800ca92:	e003      	b.n	800ca9c <lv_ll_move_before+0x2e>
    else
        n_before = lv_ll_get_tail(ll_p); /*if `n_after` is NULL `n_act` should be the new tail*/
 800ca94:	68f8      	ldr	r0, [r7, #12]
 800ca96:	f7ff ffa4 	bl	800c9e2 <lv_ll_get_tail>
 800ca9a:	6178      	str	r0, [r7, #20]

    if(n_act == n_before) return; /*Already before `n_after`*/
 800ca9c:	68ba      	ldr	r2, [r7, #8]
 800ca9e:	697b      	ldr	r3, [r7, #20]
 800caa0:	429a      	cmp	r2, r3
 800caa2:	d026      	beq.n	800caf2 <lv_ll_move_before+0x84>

    /*It's much easier to remove from the list and add again*/
    lv_ll_rem(ll_p, n_act);
 800caa4:	68b9      	ldr	r1, [r7, #8]
 800caa6:	68f8      	ldr	r0, [r7, #12]
 800caa8:	f7ff feda 	bl	800c860 <lv_ll_rem>

    /*Add again by setting the prev. and next nodes*/
    node_set_next(ll_p, n_before, n_act);
 800caac:	68ba      	ldr	r2, [r7, #8]
 800caae:	6979      	ldr	r1, [r7, #20]
 800cab0:	68f8      	ldr	r0, [r7, #12]
 800cab2:	f000 f862 	bl	800cb7a <node_set_next>
    node_set_prev(ll_p, n_act, n_before);
 800cab6:	697a      	ldr	r2, [r7, #20]
 800cab8:	68b9      	ldr	r1, [r7, #8]
 800caba:	68f8      	ldr	r0, [r7, #12]
 800cabc:	f000 f837 	bl	800cb2e <node_set_prev>
    node_set_prev(ll_p, n_after, n_act);
 800cac0:	68ba      	ldr	r2, [r7, #8]
 800cac2:	6879      	ldr	r1, [r7, #4]
 800cac4:	68f8      	ldr	r0, [r7, #12]
 800cac6:	f000 f832 	bl	800cb2e <node_set_prev>
    node_set_next(ll_p, n_act, n_after);
 800caca:	687a      	ldr	r2, [r7, #4]
 800cacc:	68b9      	ldr	r1, [r7, #8]
 800cace:	68f8      	ldr	r0, [r7, #12]
 800cad0:	f000 f853 	bl	800cb7a <node_set_next>

    /*If `n_act` was moved before NULL then it become the new tail*/
    if(n_after == NULL) ll_p->tail = n_act;
 800cad4:	687b      	ldr	r3, [r7, #4]
 800cad6:	2b00      	cmp	r3, #0
 800cad8:	d102      	bne.n	800cae0 <lv_ll_move_before+0x72>
 800cada:	68fb      	ldr	r3, [r7, #12]
 800cadc:	68ba      	ldr	r2, [r7, #8]
 800cade:	609a      	str	r2, [r3, #8]

    /*If `n_act` was moved before `NULL` then it's the new head*/
    if(n_before == NULL) ll_p->head = n_act;
 800cae0:	697b      	ldr	r3, [r7, #20]
 800cae2:	2b00      	cmp	r3, #0
 800cae4:	d106      	bne.n	800caf4 <lv_ll_move_before+0x86>
 800cae6:	68fb      	ldr	r3, [r7, #12]
 800cae8:	68ba      	ldr	r2, [r7, #8]
 800caea:	605a      	str	r2, [r3, #4]
 800caec:	e002      	b.n	800caf4 <lv_ll_move_before+0x86>
    if(n_act == n_after) return; /*Can't move before itself*/
 800caee:	bf00      	nop
 800caf0:	e000      	b.n	800caf4 <lv_ll_move_before+0x86>
    if(n_act == n_before) return; /*Already before `n_after`*/
 800caf2:	bf00      	nop
}
 800caf4:	3718      	adds	r7, #24
 800caf6:	46bd      	mov	sp, r7
 800caf8:	bd80      	pop	{r7, pc}

0800cafa <lv_ll_is_empty>:
 * Check if a linked list is empty
 * @param ll_p pointer to a linked list
 * @return true: the linked list is empty; false: not empty
 */
bool lv_ll_is_empty(lv_ll_t * ll_p)
{
 800cafa:	b480      	push	{r7}
 800cafc:	b083      	sub	sp, #12
 800cafe:	af00      	add	r7, sp, #0
 800cb00:	6078      	str	r0, [r7, #4]
    if(ll_p == NULL) return true;
 800cb02:	687b      	ldr	r3, [r7, #4]
 800cb04:	2b00      	cmp	r3, #0
 800cb06:	d101      	bne.n	800cb0c <lv_ll_is_empty+0x12>
 800cb08:	2301      	movs	r3, #1
 800cb0a:	e00a      	b.n	800cb22 <lv_ll_is_empty+0x28>

    if(ll_p->head == NULL && ll_p->tail == NULL) return true;
 800cb0c:	687b      	ldr	r3, [r7, #4]
 800cb0e:	685b      	ldr	r3, [r3, #4]
 800cb10:	2b00      	cmp	r3, #0
 800cb12:	d105      	bne.n	800cb20 <lv_ll_is_empty+0x26>
 800cb14:	687b      	ldr	r3, [r7, #4]
 800cb16:	689b      	ldr	r3, [r3, #8]
 800cb18:	2b00      	cmp	r3, #0
 800cb1a:	d101      	bne.n	800cb20 <lv_ll_is_empty+0x26>
 800cb1c:	2301      	movs	r3, #1
 800cb1e:	e000      	b.n	800cb22 <lv_ll_is_empty+0x28>

    return false;
 800cb20:	2300      	movs	r3, #0
}
 800cb22:	4618      	mov	r0, r3
 800cb24:	370c      	adds	r7, #12
 800cb26:	46bd      	mov	sp, r7
 800cb28:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb2c:	4770      	bx	lr

0800cb2e <node_set_prev>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which prev. node pointer should be set
 * @param prev pointer to a node which should be the previous node before 'act'
 */
static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)
{
 800cb2e:	b580      	push	{r7, lr}
 800cb30:	b086      	sub	sp, #24
 800cb32:	af00      	add	r7, sp, #0
 800cb34:	60f8      	str	r0, [r7, #12]
 800cb36:	60b9      	str	r1, [r7, #8]
 800cb38:	607a      	str	r2, [r7, #4]
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
 800cb3a:	68bb      	ldr	r3, [r7, #8]
 800cb3c:	2b00      	cmp	r3, #0
 800cb3e:	d018      	beq.n	800cb72 <node_set_prev+0x44>

    uint32_t node_p_size = sizeof(lv_ll_node_t *);
 800cb40:	2304      	movs	r3, #4
 800cb42:	617b      	str	r3, [r7, #20]
    if(prev)
 800cb44:	687b      	ldr	r3, [r7, #4]
 800cb46:	2b00      	cmp	r3, #0
 800cb48:	d009      	beq.n	800cb5e <node_set_prev+0x30>
        memcpy(act + LL_PREV_P_OFFSET(ll_p), &prev, node_p_size);
 800cb4a:	68fb      	ldr	r3, [r7, #12]
 800cb4c:	681b      	ldr	r3, [r3, #0]
 800cb4e:	68ba      	ldr	r2, [r7, #8]
 800cb50:	4413      	add	r3, r2
 800cb52:	1d39      	adds	r1, r7, #4
 800cb54:	697a      	ldr	r2, [r7, #20]
 800cb56:	4618      	mov	r0, r3
 800cb58:	f006 fdf6 	bl	8013748 <memcpy>
 800cb5c:	e00a      	b.n	800cb74 <node_set_prev+0x46>
    else
        memset(act + LL_PREV_P_OFFSET(ll_p), 0, node_p_size);
 800cb5e:	68fb      	ldr	r3, [r7, #12]
 800cb60:	681b      	ldr	r3, [r3, #0]
 800cb62:	68ba      	ldr	r2, [r7, #8]
 800cb64:	4413      	add	r3, r2
 800cb66:	697a      	ldr	r2, [r7, #20]
 800cb68:	2100      	movs	r1, #0
 800cb6a:	4618      	mov	r0, r3
 800cb6c:	f006 fdf7 	bl	801375e <memset>
 800cb70:	e000      	b.n	800cb74 <node_set_prev+0x46>
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
 800cb72:	bf00      	nop
}
 800cb74:	3718      	adds	r7, #24
 800cb76:	46bd      	mov	sp, r7
 800cb78:	bd80      	pop	{r7, pc}

0800cb7a <node_set_next>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
{
 800cb7a:	b580      	push	{r7, lr}
 800cb7c:	b086      	sub	sp, #24
 800cb7e:	af00      	add	r7, sp, #0
 800cb80:	60f8      	str	r0, [r7, #12]
 800cb82:	60b9      	str	r1, [r7, #8]
 800cb84:	607a      	str	r2, [r7, #4]
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
 800cb86:	68bb      	ldr	r3, [r7, #8]
 800cb88:	2b00      	cmp	r3, #0
 800cb8a:	d01a      	beq.n	800cbc2 <node_set_next+0x48>

    uint32_t node_p_size = sizeof(lv_ll_node_t *);
 800cb8c:	2304      	movs	r3, #4
 800cb8e:	617b      	str	r3, [r7, #20]
    if(next)
 800cb90:	687b      	ldr	r3, [r7, #4]
 800cb92:	2b00      	cmp	r3, #0
 800cb94:	d00a      	beq.n	800cbac <node_set_next+0x32>
        memcpy(act + LL_NEXT_P_OFFSET(ll_p), &next, node_p_size);
 800cb96:	68fb      	ldr	r3, [r7, #12]
 800cb98:	681b      	ldr	r3, [r3, #0]
 800cb9a:	3304      	adds	r3, #4
 800cb9c:	68ba      	ldr	r2, [r7, #8]
 800cb9e:	4413      	add	r3, r2
 800cba0:	1d39      	adds	r1, r7, #4
 800cba2:	697a      	ldr	r2, [r7, #20]
 800cba4:	4618      	mov	r0, r3
 800cba6:	f006 fdcf 	bl	8013748 <memcpy>
 800cbaa:	e00b      	b.n	800cbc4 <node_set_next+0x4a>
    else
        memset(act + LL_NEXT_P_OFFSET(ll_p), 0, node_p_size);
 800cbac:	68fb      	ldr	r3, [r7, #12]
 800cbae:	681b      	ldr	r3, [r3, #0]
 800cbb0:	3304      	adds	r3, #4
 800cbb2:	68ba      	ldr	r2, [r7, #8]
 800cbb4:	4413      	add	r3, r2
 800cbb6:	697a      	ldr	r2, [r7, #20]
 800cbb8:	2100      	movs	r1, #0
 800cbba:	4618      	mov	r0, r3
 800cbbc:	f006 fdcf 	bl	801375e <memset>
 800cbc0:	e000      	b.n	800cbc4 <node_set_next+0x4a>
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
 800cbc2:	bf00      	nop
}
 800cbc4:	3718      	adds	r7, #24
 800cbc6:	46bd      	mov	sp, r7
 800cbc8:	bd80      	pop	{r7, pc}
	...

0800cbcc <lv_mem_init>:

/**
 * Initiaiize the dyn_mem module (work memory and other variables)
 */
void lv_mem_init(void)
{
 800cbcc:	b480      	push	{r7}
 800cbce:	b083      	sub	sp, #12
 800cbd0:	af00      	add	r7, sp, #0
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
 800cbd2:	4b0c      	ldr	r3, [pc, #48]	; (800cc04 <lv_mem_init+0x38>)
 800cbd4:	4a0c      	ldr	r2, [pc, #48]	; (800cc08 <lv_mem_init+0x3c>)
 800cbd6:	601a      	str	r2, [r3, #0]
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
 800cbd8:	4b0a      	ldr	r3, [pc, #40]	; (800cc04 <lv_mem_init+0x38>)
 800cbda:	681b      	ldr	r3, [r3, #0]
 800cbdc:	607b      	str	r3, [r7, #4]
    full->header.s.used = 0;
 800cbde:	687a      	ldr	r2, [r7, #4]
 800cbe0:	7813      	ldrb	r3, [r2, #0]
 800cbe2:	f36f 0300 	bfc	r3, #0, #1
 800cbe6:	7013      	strb	r3, [r2, #0]
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
 800cbe8:	687a      	ldr	r2, [r7, #4]
 800cbea:	6813      	ldr	r3, [r2, #0]
 800cbec:	f647 71fc 	movw	r1, #32764	; 0x7ffc
 800cbf0:	f361 035f 	bfi	r3, r1, #1, #31
 800cbf4:	6013      	str	r3, [r2, #0]
#endif
}
 800cbf6:	bf00      	nop
 800cbf8:	370c      	adds	r7, #12
 800cbfa:	46bd      	mov	sp, r7
 800cbfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc00:	4770      	bx	lr
 800cc02:	bf00      	nop
 800cc04:	200002b4 	.word	0x200002b4
 800cc08:	200002bc 	.word	0x200002bc

0800cc0c <lv_mem_alloc>:
 * Allocate a memory dynamically
 * @param size size of the memory to allocate in bytes
 * @return pointer to the allocated memory
 */
void * lv_mem_alloc(size_t size)
{
 800cc0c:	b580      	push	{r7, lr}
 800cc0e:	b084      	sub	sp, #16
 800cc10:	af00      	add	r7, sp, #0
 800cc12:	6078      	str	r0, [r7, #4]
    if(size == 0) {
 800cc14:	687b      	ldr	r3, [r7, #4]
 800cc16:	2b00      	cmp	r3, #0
 800cc18:	d101      	bne.n	800cc1e <lv_mem_alloc+0x12>
        return &zero_mem;
 800cc1a:	4b14      	ldr	r3, [pc, #80]	; (800cc6c <lv_mem_alloc+0x60>)
 800cc1c:	e022      	b.n	800cc64 <lv_mem_alloc+0x58>
        size = size & (~0x7);
        size += 8;
    }
#else
    /*Round the size up to 4*/
    if(size & 0x3) {
 800cc1e:	687b      	ldr	r3, [r7, #4]
 800cc20:	f003 0303 	and.w	r3, r3, #3
 800cc24:	2b00      	cmp	r3, #0
 800cc26:	d006      	beq.n	800cc36 <lv_mem_alloc+0x2a>
        size = size & (~0x3);
 800cc28:	687b      	ldr	r3, [r7, #4]
 800cc2a:	f023 0303 	bic.w	r3, r3, #3
 800cc2e:	607b      	str	r3, [r7, #4]
        size += 4;
 800cc30:	687b      	ldr	r3, [r7, #4]
 800cc32:	3304      	adds	r3, #4
 800cc34:	607b      	str	r3, [r7, #4]
    }
#endif
    void * alloc = NULL;
 800cc36:	2300      	movs	r3, #0
 800cc38:	60fb      	str	r3, [r7, #12]

#if LV_MEM_CUSTOM == 0
    /*Use the built-in allocators*/
    lv_mem_ent_t * e = NULL;
 800cc3a:	2300      	movs	r3, #0
 800cc3c:	60bb      	str	r3, [r7, #8]

    /* Search for a appropriate entry*/
    do {
        /* Get the next entry*/
        e = ent_get_next(e);
 800cc3e:	68b8      	ldr	r0, [r7, #8]
 800cc40:	f000 f8c4 	bl	800cdcc <ent_get_next>
 800cc44:	60b8      	str	r0, [r7, #8]

        /*If there is next entry then try to allocate there*/
        if(e != NULL) {
 800cc46:	68bb      	ldr	r3, [r7, #8]
 800cc48:	2b00      	cmp	r3, #0
 800cc4a:	d004      	beq.n	800cc56 <lv_mem_alloc+0x4a>
            alloc = ent_alloc(e, size);
 800cc4c:	6879      	ldr	r1, [r7, #4]
 800cc4e:	68b8      	ldr	r0, [r7, #8]
 800cc50:	f000 f8e8 	bl	800ce24 <ent_alloc>
 800cc54:	60f8      	str	r0, [r7, #12]
        }
        /* End if there is not next entry OR the alloc. is successful*/
    } while(e != NULL && alloc == NULL);
 800cc56:	68bb      	ldr	r3, [r7, #8]
 800cc58:	2b00      	cmp	r3, #0
 800cc5a:	d002      	beq.n	800cc62 <lv_mem_alloc+0x56>
 800cc5c:	68fb      	ldr	r3, [r7, #12]
 800cc5e:	2b00      	cmp	r3, #0
 800cc60:	d0ed      	beq.n	800cc3e <lv_mem_alloc+0x32>
    if(alloc != NULL) memset(alloc, 0xaa, size);
#endif

    if(alloc == NULL) LV_LOG_WARN("Couldn't allocate memory");

    return alloc;
 800cc62:	68fb      	ldr	r3, [r7, #12]
}
 800cc64:	4618      	mov	r0, r3
 800cc66:	3710      	adds	r7, #16
 800cc68:	46bd      	mov	sp, r7
 800cc6a:	bd80      	pop	{r7, pc}
 800cc6c:	200002b8 	.word	0x200002b8

0800cc70 <lv_mem_free>:
/**
 * Free an allocated data
 * @param data pointer to an allocated memory
 */
void lv_mem_free(const void * data)
{
 800cc70:	b580      	push	{r7, lr}
 800cc72:	b084      	sub	sp, #16
 800cc74:	af00      	add	r7, sp, #0
 800cc76:	6078      	str	r0, [r7, #4]
    if(data == &zero_mem) return;
 800cc78:	687b      	ldr	r3, [r7, #4]
 800cc7a:	4a1e      	ldr	r2, [pc, #120]	; (800ccf4 <lv_mem_free+0x84>)
 800cc7c:	4293      	cmp	r3, r2
 800cc7e:	d030      	beq.n	800cce2 <lv_mem_free+0x72>
    if(data == NULL) return;
 800cc80:	687b      	ldr	r3, [r7, #4]
 800cc82:	2b00      	cmp	r3, #0
 800cc84:	d02f      	beq.n	800cce6 <lv_mem_free+0x76>
    memset((void *)data, 0xbb, lv_mem_get_size(data));
#endif

#if LV_ENABLE_GC == 0
    /*e points to the header*/
    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
 800cc86:	687b      	ldr	r3, [r7, #4]
 800cc88:	3b04      	subs	r3, #4
 800cc8a:	60bb      	str	r3, [r7, #8]
    e->header.s.used = 0;
 800cc8c:	68ba      	ldr	r2, [r7, #8]
 800cc8e:	7813      	ldrb	r3, [r2, #0]
 800cc90:	f36f 0300 	bfc	r3, #0, #1
 800cc94:	7013      	strb	r3, [r2, #0]
#if LV_MEM_CUSTOM == 0
#if LV_MEM_AUTO_DEFRAG
    /* Make a simple defrag.
     * Join the following free entries after this*/
    lv_mem_ent_t * e_next;
    e_next = ent_get_next(e);
 800cc96:	68b8      	ldr	r0, [r7, #8]
 800cc98:	f000 f898 	bl	800cdcc <ent_get_next>
 800cc9c:	60f8      	str	r0, [r7, #12]
    while(e_next != NULL) {
 800cc9e:	e01c      	b.n	800ccda <lv_mem_free+0x6a>
        if(e_next->header.s.used == 0) {
 800cca0:	68fb      	ldr	r3, [r7, #12]
 800cca2:	781b      	ldrb	r3, [r3, #0]
 800cca4:	f003 0301 	and.w	r3, r3, #1
 800cca8:	b2db      	uxtb	r3, r3
 800ccaa:	2b00      	cmp	r3, #0
 800ccac:	d11d      	bne.n	800ccea <lv_mem_free+0x7a>
            e->header.s.d_size += e_next->header.s.d_size + sizeof(e->header);
 800ccae:	68bb      	ldr	r3, [r7, #8]
 800ccb0:	681b      	ldr	r3, [r3, #0]
 800ccb2:	f3c3 035e 	ubfx	r3, r3, #1, #31
 800ccb6:	461a      	mov	r2, r3
 800ccb8:	68fb      	ldr	r3, [r7, #12]
 800ccba:	681b      	ldr	r3, [r3, #0]
 800ccbc:	f3c3 035e 	ubfx	r3, r3, #1, #31
 800ccc0:	4413      	add	r3, r2
 800ccc2:	3304      	adds	r3, #4
 800ccc4:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 800ccc8:	68ba      	ldr	r2, [r7, #8]
 800ccca:	6813      	ldr	r3, [r2, #0]
 800cccc:	f361 035f 	bfi	r3, r1, #1, #31
 800ccd0:	6013      	str	r3, [r2, #0]
        } else {
            break;
        }
        e_next = ent_get_next(e_next);
 800ccd2:	68f8      	ldr	r0, [r7, #12]
 800ccd4:	f000 f87a 	bl	800cdcc <ent_get_next>
 800ccd8:	60f8      	str	r0, [r7, #12]
    while(e_next != NULL) {
 800ccda:	68fb      	ldr	r3, [r7, #12]
 800ccdc:	2b00      	cmp	r3, #0
 800ccde:	d1df      	bne.n	800cca0 <lv_mem_free+0x30>
 800cce0:	e004      	b.n	800ccec <lv_mem_free+0x7c>
    if(data == &zero_mem) return;
 800cce2:	bf00      	nop
 800cce4:	e002      	b.n	800ccec <lv_mem_free+0x7c>
    if(data == NULL) return;
 800cce6:	bf00      	nop
 800cce8:	e000      	b.n	800ccec <lv_mem_free+0x7c>
            break;
 800ccea:	bf00      	nop
    LV_MEM_CUSTOM_FREE(e);
#else
    LV_MEM_CUSTOM_FREE((void *)data);
#endif /*LV_ENABLE_GC*/
#endif
}
 800ccec:	3710      	adds	r7, #16
 800ccee:	46bd      	mov	sp, r7
 800ccf0:	bd80      	pop	{r7, pc}
 800ccf2:	bf00      	nop
 800ccf4:	200002b8 	.word	0x200002b8

0800ccf8 <lv_mem_realloc>:
 */

#if LV_ENABLE_GC == 0

void * lv_mem_realloc(void * data_p, size_t new_size)
{
 800ccf8:	b580      	push	{r7, lr}
 800ccfa:	b086      	sub	sp, #24
 800ccfc:	af00      	add	r7, sp, #0
 800ccfe:	6078      	str	r0, [r7, #4]
 800cd00:	6039      	str	r1, [r7, #0]
    /*data_p could be previously freed pointer (in this case it is invalid)*/
    if(data_p != NULL) {
 800cd02:	687b      	ldr	r3, [r7, #4]
 800cd04:	2b00      	cmp	r3, #0
 800cd06:	d00b      	beq.n	800cd20 <lv_mem_realloc+0x28>
        lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data_p - sizeof(lv_mem_header_t));
 800cd08:	687b      	ldr	r3, [r7, #4]
 800cd0a:	3b04      	subs	r3, #4
 800cd0c:	617b      	str	r3, [r7, #20]
        if(e->header.s.used == 0) {
 800cd0e:	697b      	ldr	r3, [r7, #20]
 800cd10:	781b      	ldrb	r3, [r3, #0]
 800cd12:	f003 0301 	and.w	r3, r3, #1
 800cd16:	b2db      	uxtb	r3, r3
 800cd18:	2b00      	cmp	r3, #0
 800cd1a:	d101      	bne.n	800cd20 <lv_mem_realloc+0x28>
            data_p = NULL;
 800cd1c:	2300      	movs	r3, #0
 800cd1e:	607b      	str	r3, [r7, #4]
        }
    }

    uint32_t old_size = lv_mem_get_size(data_p);
 800cd20:	6878      	ldr	r0, [r7, #4]
 800cd22:	f000 f835 	bl	800cd90 <lv_mem_get_size>
 800cd26:	6138      	str	r0, [r7, #16]
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
 800cd28:	693a      	ldr	r2, [r7, #16]
 800cd2a:	683b      	ldr	r3, [r7, #0]
 800cd2c:	429a      	cmp	r2, r3
 800cd2e:	d101      	bne.n	800cd34 <lv_mem_realloc+0x3c>
 800cd30:	687b      	ldr	r3, [r7, #4]
 800cd32:	e028      	b.n	800cd86 <lv_mem_realloc+0x8e>

#if LV_MEM_CUSTOM == 0
    /* Truncate the memory if the new size is smaller. */
    if(new_size < old_size) {
 800cd34:	683a      	ldr	r2, [r7, #0]
 800cd36:	693b      	ldr	r3, [r7, #16]
 800cd38:	429a      	cmp	r2, r3
 800cd3a:	d209      	bcs.n	800cd50 <lv_mem_realloc+0x58>
        lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data_p - sizeof(lv_mem_header_t));
 800cd3c:	687b      	ldr	r3, [r7, #4]
 800cd3e:	3b04      	subs	r3, #4
 800cd40:	60bb      	str	r3, [r7, #8]
        ent_trunc(e, new_size);
 800cd42:	6839      	ldr	r1, [r7, #0]
 800cd44:	68b8      	ldr	r0, [r7, #8]
 800cd46:	f000 f894 	bl	800ce72 <ent_trunc>
        return &e->first_data;
 800cd4a:	68bb      	ldr	r3, [r7, #8]
 800cd4c:	3304      	adds	r3, #4
 800cd4e:	e01a      	b.n	800cd86 <lv_mem_realloc+0x8e>
    }
#endif

    void * new_p;
    new_p = lv_mem_alloc(new_size);
 800cd50:	6838      	ldr	r0, [r7, #0]
 800cd52:	f7ff ff5b 	bl	800cc0c <lv_mem_alloc>
 800cd56:	60f8      	str	r0, [r7, #12]

    if(new_p != NULL && data_p != NULL) {
 800cd58:	68fb      	ldr	r3, [r7, #12]
 800cd5a:	2b00      	cmp	r3, #0
 800cd5c:	d012      	beq.n	800cd84 <lv_mem_realloc+0x8c>
 800cd5e:	687b      	ldr	r3, [r7, #4]
 800cd60:	2b00      	cmp	r3, #0
 800cd62:	d00f      	beq.n	800cd84 <lv_mem_realloc+0x8c>
        /*Copy the old data to the new. Use the smaller size*/
        if(old_size != 0) {
 800cd64:	693b      	ldr	r3, [r7, #16]
 800cd66:	2b00      	cmp	r3, #0
 800cd68:	d00c      	beq.n	800cd84 <lv_mem_realloc+0x8c>
            memcpy(new_p, data_p, LV_MATH_MIN(new_size, old_size));
 800cd6a:	693a      	ldr	r2, [r7, #16]
 800cd6c:	683b      	ldr	r3, [r7, #0]
 800cd6e:	4293      	cmp	r3, r2
 800cd70:	bf28      	it	cs
 800cd72:	4613      	movcs	r3, r2
 800cd74:	461a      	mov	r2, r3
 800cd76:	6879      	ldr	r1, [r7, #4]
 800cd78:	68f8      	ldr	r0, [r7, #12]
 800cd7a:	f006 fce5 	bl	8013748 <memcpy>
            lv_mem_free(data_p);
 800cd7e:	6878      	ldr	r0, [r7, #4]
 800cd80:	f7ff ff76 	bl	800cc70 <lv_mem_free>
        }
    }

    if(new_p == NULL) LV_LOG_WARN("Couldn't allocate memory");

    return new_p;
 800cd84:	68fb      	ldr	r3, [r7, #12]
}
 800cd86:	4618      	mov	r0, r3
 800cd88:	3718      	adds	r7, #24
 800cd8a:	46bd      	mov	sp, r7
 800cd8c:	bd80      	pop	{r7, pc}
	...

0800cd90 <lv_mem_get_size>:
 */

#if LV_ENABLE_GC == 0

uint32_t lv_mem_get_size(const void * data)
{
 800cd90:	b480      	push	{r7}
 800cd92:	b085      	sub	sp, #20
 800cd94:	af00      	add	r7, sp, #0
 800cd96:	6078      	str	r0, [r7, #4]
    if(data == NULL) return 0;
 800cd98:	687b      	ldr	r3, [r7, #4]
 800cd9a:	2b00      	cmp	r3, #0
 800cd9c:	d101      	bne.n	800cda2 <lv_mem_get_size+0x12>
 800cd9e:	2300      	movs	r3, #0
 800cda0:	e00c      	b.n	800cdbc <lv_mem_get_size+0x2c>
    if(data == &zero_mem) return 0;
 800cda2:	687b      	ldr	r3, [r7, #4]
 800cda4:	4a08      	ldr	r2, [pc, #32]	; (800cdc8 <lv_mem_get_size+0x38>)
 800cda6:	4293      	cmp	r3, r2
 800cda8:	d101      	bne.n	800cdae <lv_mem_get_size+0x1e>
 800cdaa:	2300      	movs	r3, #0
 800cdac:	e006      	b.n	800cdbc <lv_mem_get_size+0x2c>

    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
 800cdae:	687b      	ldr	r3, [r7, #4]
 800cdb0:	3b04      	subs	r3, #4
 800cdb2:	60fb      	str	r3, [r7, #12]

    return e->header.s.d_size;
 800cdb4:	68fb      	ldr	r3, [r7, #12]
 800cdb6:	681b      	ldr	r3, [r3, #0]
 800cdb8:	f3c3 035e 	ubfx	r3, r3, #1, #31
}
 800cdbc:	4618      	mov	r0, r3
 800cdbe:	3714      	adds	r7, #20
 800cdc0:	46bd      	mov	sp, r7
 800cdc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdc6:	4770      	bx	lr
 800cdc8:	200002b8 	.word	0x200002b8

0800cdcc <ent_get_next>:
 * Give the next entry after 'act_e'
 * @param act_e pointer to an entry
 * @return pointer to an entry after 'act_e'
 */
static lv_mem_ent_t * ent_get_next(lv_mem_ent_t * act_e)
{
 800cdcc:	b480      	push	{r7}
 800cdce:	b085      	sub	sp, #20
 800cdd0:	af00      	add	r7, sp, #0
 800cdd2:	6078      	str	r0, [r7, #4]
    lv_mem_ent_t * next_e = NULL;
 800cdd4:	2300      	movs	r3, #0
 800cdd6:	60fb      	str	r3, [r7, #12]

    if(act_e == NULL) { /*NULL means: get the first entry*/
 800cdd8:	687b      	ldr	r3, [r7, #4]
 800cdda:	2b00      	cmp	r3, #0
 800cddc:	d103      	bne.n	800cde6 <ent_get_next+0x1a>
        next_e = (lv_mem_ent_t *)work_mem;
 800cdde:	4b10      	ldr	r3, [pc, #64]	; (800ce20 <ent_get_next+0x54>)
 800cde0:	681b      	ldr	r3, [r3, #0]
 800cde2:	60fb      	str	r3, [r7, #12]
 800cde4:	e014      	b.n	800ce10 <ent_get_next+0x44>
    } else { /*Get the next entry */
        uint8_t * data = &act_e->first_data;
 800cde6:	687b      	ldr	r3, [r7, #4]
 800cde8:	3304      	adds	r3, #4
 800cdea:	60bb      	str	r3, [r7, #8]
        next_e         = (lv_mem_ent_t *)&data[act_e->header.s.d_size];
 800cdec:	687b      	ldr	r3, [r7, #4]
 800cdee:	681b      	ldr	r3, [r3, #0]
 800cdf0:	f3c3 035e 	ubfx	r3, r3, #1, #31
 800cdf4:	461a      	mov	r2, r3
 800cdf6:	68bb      	ldr	r3, [r7, #8]
 800cdf8:	4413      	add	r3, r2
 800cdfa:	60fb      	str	r3, [r7, #12]

        if(&next_e->first_data >= &work_mem[LV_MEM_SIZE]) next_e = NULL;
 800cdfc:	68fb      	ldr	r3, [r7, #12]
 800cdfe:	1d1a      	adds	r2, r3, #4
 800ce00:	4b07      	ldr	r3, [pc, #28]	; (800ce20 <ent_get_next+0x54>)
 800ce02:	681b      	ldr	r3, [r3, #0]
 800ce04:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 800ce08:	429a      	cmp	r2, r3
 800ce0a:	d301      	bcc.n	800ce10 <ent_get_next+0x44>
 800ce0c:	2300      	movs	r3, #0
 800ce0e:	60fb      	str	r3, [r7, #12]
    }

    return next_e;
 800ce10:	68fb      	ldr	r3, [r7, #12]
}
 800ce12:	4618      	mov	r0, r3
 800ce14:	3714      	adds	r7, #20
 800ce16:	46bd      	mov	sp, r7
 800ce18:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce1c:	4770      	bx	lr
 800ce1e:	bf00      	nop
 800ce20:	200002b4 	.word	0x200002b4

0800ce24 <ent_alloc>:
 * @param e try to allocate to this entry
 * @param size size of the new memory in bytes
 * @return pointer to the allocated memory or NULL if not enough memory in the entry
 */
static void * ent_alloc(lv_mem_ent_t * e, size_t size)
{
 800ce24:	b580      	push	{r7, lr}
 800ce26:	b084      	sub	sp, #16
 800ce28:	af00      	add	r7, sp, #0
 800ce2a:	6078      	str	r0, [r7, #4]
 800ce2c:	6039      	str	r1, [r7, #0]
    void * alloc = NULL;
 800ce2e:	2300      	movs	r3, #0
 800ce30:	60fb      	str	r3, [r7, #12]

    /*If the memory is free and big enough then use it */
    if(e->header.s.used == 0 && e->header.s.d_size >= size) {
 800ce32:	687b      	ldr	r3, [r7, #4]
 800ce34:	781b      	ldrb	r3, [r3, #0]
 800ce36:	f003 0301 	and.w	r3, r3, #1
 800ce3a:	b2db      	uxtb	r3, r3
 800ce3c:	2b00      	cmp	r3, #0
 800ce3e:	d113      	bne.n	800ce68 <ent_alloc+0x44>
 800ce40:	687b      	ldr	r3, [r7, #4]
 800ce42:	681b      	ldr	r3, [r3, #0]
 800ce44:	f3c3 035e 	ubfx	r3, r3, #1, #31
 800ce48:	461a      	mov	r2, r3
 800ce4a:	683b      	ldr	r3, [r7, #0]
 800ce4c:	4293      	cmp	r3, r2
 800ce4e:	d80b      	bhi.n	800ce68 <ent_alloc+0x44>
        /*Truncate the entry to the desired size */
        ent_trunc(e, size),
 800ce50:	6839      	ldr	r1, [r7, #0]
 800ce52:	6878      	ldr	r0, [r7, #4]
 800ce54:	f000 f80d 	bl	800ce72 <ent_trunc>

            e->header.s.used = 1;
 800ce58:	687a      	ldr	r2, [r7, #4]
 800ce5a:	7813      	ldrb	r3, [r2, #0]
 800ce5c:	f043 0301 	orr.w	r3, r3, #1
 800ce60:	7013      	strb	r3, [r2, #0]

        /*Save the allocated data*/
        alloc = &e->first_data;
 800ce62:	687b      	ldr	r3, [r7, #4]
 800ce64:	3304      	adds	r3, #4
 800ce66:	60fb      	str	r3, [r7, #12]
    }

    return alloc;
 800ce68:	68fb      	ldr	r3, [r7, #12]
}
 800ce6a:	4618      	mov	r0, r3
 800ce6c:	3710      	adds	r7, #16
 800ce6e:	46bd      	mov	sp, r7
 800ce70:	bd80      	pop	{r7, pc}

0800ce72 <ent_trunc>:
 * Truncate the data of entry to the given size
 * @param e Pointer to an entry
 * @param size new size in bytes
 */
static void ent_trunc(lv_mem_ent_t * e, size_t size)
{
 800ce72:	b480      	push	{r7}
 800ce74:	b085      	sub	sp, #20
 800ce76:	af00      	add	r7, sp, #0
 800ce78:	6078      	str	r0, [r7, #4]
 800ce7a:	6039      	str	r1, [r7, #0]
        size = size & (~0x7);
        size += 8;
    }
#else
    /*Round the size up to 4*/
    if(size & 0x3) {
 800ce7c:	683b      	ldr	r3, [r7, #0]
 800ce7e:	f003 0303 	and.w	r3, r3, #3
 800ce82:	2b00      	cmp	r3, #0
 800ce84:	d006      	beq.n	800ce94 <ent_trunc+0x22>
        size = size & (~0x3);
 800ce86:	683b      	ldr	r3, [r7, #0]
 800ce88:	f023 0303 	bic.w	r3, r3, #3
 800ce8c:	603b      	str	r3, [r7, #0]
        size += 4;
 800ce8e:	683b      	ldr	r3, [r7, #0]
 800ce90:	3304      	adds	r3, #4
 800ce92:	603b      	str	r3, [r7, #0]
    }
#endif

    /*Don't let empty space only for a header without data*/
    if(e->header.s.d_size == size + sizeof(lv_mem_header_t)) {
 800ce94:	687b      	ldr	r3, [r7, #4]
 800ce96:	681b      	ldr	r3, [r3, #0]
 800ce98:	f3c3 035e 	ubfx	r3, r3, #1, #31
 800ce9c:	461a      	mov	r2, r3
 800ce9e:	683b      	ldr	r3, [r7, #0]
 800cea0:	3304      	adds	r3, #4
 800cea2:	429a      	cmp	r2, r3
 800cea4:	d104      	bne.n	800ceb0 <ent_trunc+0x3e>
        size = e->header.s.d_size;
 800cea6:	687b      	ldr	r3, [r7, #4]
 800cea8:	681b      	ldr	r3, [r3, #0]
 800ceaa:	f3c3 035e 	ubfx	r3, r3, #1, #31
 800ceae:	603b      	str	r3, [r7, #0]
    }

    /* Create the new entry after the current if there is space for it */
    if(e->header.s.d_size != size) {
 800ceb0:	687b      	ldr	r3, [r7, #4]
 800ceb2:	681b      	ldr	r3, [r3, #0]
 800ceb4:	f3c3 035e 	ubfx	r3, r3, #1, #31
 800ceb8:	461a      	mov	r2, r3
 800ceba:	683b      	ldr	r3, [r7, #0]
 800cebc:	4293      	cmp	r3, r2
 800cebe:	d01a      	beq.n	800cef6 <ent_trunc+0x84>
        uint8_t * e_data             = &e->first_data;
 800cec0:	687b      	ldr	r3, [r7, #4]
 800cec2:	3304      	adds	r3, #4
 800cec4:	60fb      	str	r3, [r7, #12]
        lv_mem_ent_t * after_new_e   = (lv_mem_ent_t *)&e_data[size];
 800cec6:	68fa      	ldr	r2, [r7, #12]
 800cec8:	683b      	ldr	r3, [r7, #0]
 800ceca:	4413      	add	r3, r2
 800cecc:	60bb      	str	r3, [r7, #8]
        after_new_e->header.s.used   = 0;
 800cece:	68ba      	ldr	r2, [r7, #8]
 800ced0:	7813      	ldrb	r3, [r2, #0]
 800ced2:	f36f 0300 	bfc	r3, #0, #1
 800ced6:	7013      	strb	r3, [r2, #0]
        after_new_e->header.s.d_size = (uint32_t)e->header.s.d_size - size - sizeof(lv_mem_header_t);
 800ced8:	687b      	ldr	r3, [r7, #4]
 800ceda:	681b      	ldr	r3, [r3, #0]
 800cedc:	f3c3 035e 	ubfx	r3, r3, #1, #31
 800cee0:	461a      	mov	r2, r3
 800cee2:	683b      	ldr	r3, [r7, #0]
 800cee4:	1ad3      	subs	r3, r2, r3
 800cee6:	3b04      	subs	r3, #4
 800cee8:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 800ceec:	68ba      	ldr	r2, [r7, #8]
 800ceee:	6813      	ldr	r3, [r2, #0]
 800cef0:	f361 035f 	bfi	r3, r1, #1, #31
 800cef4:	6013      	str	r3, [r2, #0]
    }

    /* Set the new size for the original entry */
    e->header.s.d_size = (uint32_t)size;
 800cef6:	683b      	ldr	r3, [r7, #0]
 800cef8:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 800cefc:	687a      	ldr	r2, [r7, #4]
 800cefe:	6813      	ldr	r3, [r2, #0]
 800cf00:	f361 035f 	bfi	r3, r1, #1, #31
 800cf04:	6013      	str	r3, [r2, #0]
}
 800cf06:	bf00      	nop
 800cf08:	3714      	adds	r7, #20
 800cf0a:	46bd      	mov	sp, r7
 800cf0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf10:	4770      	bx	lr
	...

0800cf14 <lv_task_core_init>:

/**
 * Init the lv_task module
 */
void lv_task_core_init(void)
{
 800cf14:	b580      	push	{r7, lr}
 800cf16:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_task_ll), sizeof(lv_task_t));
 800cf18:	2114      	movs	r1, #20
 800cf1a:	4804      	ldr	r0, [pc, #16]	; (800cf2c <lv_task_core_init+0x18>)
 800cf1c:	f7ff fbcc 	bl	800c6b8 <lv_ll_init>

    /*Initially enable the lv_task handling*/
    lv_task_enable(true);
 800cf20:	2001      	movs	r0, #1
 800cf22:	f000 fa7b 	bl	800d41c <lv_task_enable>
}
 800cf26:	bf00      	nop
 800cf28:	bd80      	pop	{r7, pc}
 800cf2a:	bf00      	nop
 800cf2c:	20009940 	.word	0x20009940

0800cf30 <lv_task_handler>:

/**
 * Call it  periodically to handle lv_tasks.
 */
LV_ATTRIBUTE_TASK_HANDLER void lv_task_handler(void)
{
 800cf30:	b580      	push	{r7, lr}
 800cf32:	b084      	sub	sp, #16
 800cf34:	af00      	add	r7, sp, #0
    LV_LOG_TRACE("lv_task_handler started");

    /*Avoid concurrent running of the task handler*/
    static bool already_running = false;
    if(already_running) return;
 800cf36:	4b79      	ldr	r3, [pc, #484]	; (800d11c <lv_task_handler+0x1ec>)
 800cf38:	781b      	ldrb	r3, [r3, #0]
 800cf3a:	2b00      	cmp	r3, #0
 800cf3c:	f040 80ea 	bne.w	800d114 <lv_task_handler+0x1e4>
    already_running = true;
 800cf40:	4b76      	ldr	r3, [pc, #472]	; (800d11c <lv_task_handler+0x1ec>)
 800cf42:	2201      	movs	r2, #1
 800cf44:	701a      	strb	r2, [r3, #0]

    static uint32_t idle_period_start = 0;
    static uint32_t handler_start     = 0;
    static uint32_t busy_time         = 0;

    if(lv_task_run == false) {
 800cf46:	4b76      	ldr	r3, [pc, #472]	; (800d120 <lv_task_handler+0x1f0>)
 800cf48:	781b      	ldrb	r3, [r3, #0]
 800cf4a:	f083 0301 	eor.w	r3, r3, #1
 800cf4e:	b2db      	uxtb	r3, r3
 800cf50:	2b00      	cmp	r3, #0
 800cf52:	d003      	beq.n	800cf5c <lv_task_handler+0x2c>
        already_running = false; /*Release mutex*/
 800cf54:	4b71      	ldr	r3, [pc, #452]	; (800d11c <lv_task_handler+0x1ec>)
 800cf56:	2200      	movs	r2, #0
 800cf58:	701a      	strb	r2, [r3, #0]
        return;
 800cf5a:	e0dc      	b.n	800d116 <lv_task_handler+0x1e6>
    }

    handler_start = lv_tick_get();
 800cf5c:	f7fe fe1c 	bl	800bb98 <lv_tick_get>
 800cf60:	4602      	mov	r2, r0
 800cf62:	4b70      	ldr	r3, [pc, #448]	; (800d124 <lv_task_handler+0x1f4>)
 800cf64:	601a      	str	r2, [r3, #0]

    /* Run all task from the highest to the lowest priority
     * If a lower priority task is executed check task again from the highest priority
     * but on the priority of executed tasks don't run tasks before the executed*/
    lv_task_t * task_interrupter = NULL;
 800cf66:	2300      	movs	r3, #0
 800cf68:	60fb      	str	r3, [r7, #12]
    lv_task_t * next;
    bool end_flag;
    do {
        end_flag                 = true;
 800cf6a:	2301      	movs	r3, #1
 800cf6c:	72fb      	strb	r3, [r7, #11]
        task_deleted             = false;
 800cf6e:	4b6e      	ldr	r3, [pc, #440]	; (800d128 <lv_task_handler+0x1f8>)
 800cf70:	2200      	movs	r2, #0
 800cf72:	701a      	strb	r2, [r3, #0]
        task_created             = false;
 800cf74:	4b6d      	ldr	r3, [pc, #436]	; (800d12c <lv_task_handler+0x1fc>)
 800cf76:	2200      	movs	r2, #0
 800cf78:	701a      	strb	r2, [r3, #0]
        LV_GC_ROOT(_lv_task_act) = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 800cf7a:	486d      	ldr	r0, [pc, #436]	; (800d130 <lv_task_handler+0x200>)
 800cf7c:	f7ff fd1e 	bl	800c9bc <lv_ll_get_head>
 800cf80:	4602      	mov	r2, r0
 800cf82:	4b6c      	ldr	r3, [pc, #432]	; (800d134 <lv_task_handler+0x204>)
 800cf84:	601a      	str	r2, [r3, #0]
        while(LV_GC_ROOT(_lv_task_act)) {
 800cf86:	e07d      	b.n	800d084 <lv_task_handler+0x154>
            /* The task might be deleted if it runs only once ('once = 1')
             * So get next element until the current is surely valid*/
            next = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
 800cf88:	4b6a      	ldr	r3, [pc, #424]	; (800d134 <lv_task_handler+0x204>)
 800cf8a:	681b      	ldr	r3, [r3, #0]
 800cf8c:	4619      	mov	r1, r3
 800cf8e:	4868      	ldr	r0, [pc, #416]	; (800d130 <lv_task_handler+0x200>)
 800cf90:	f7ff fd3a 	bl	800ca08 <lv_ll_get_next>
 800cf94:	6078      	str	r0, [r7, #4]

            /*We reach priority of the turned off task. There is nothing more to do.*/
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_OFF) {
 800cf96:	4b67      	ldr	r3, [pc, #412]	; (800d134 <lv_task_handler+0x204>)
 800cf98:	681b      	ldr	r3, [r3, #0]
 800cf9a:	7c1b      	ldrb	r3, [r3, #16]
 800cf9c:	f003 0307 	and.w	r3, r3, #7
 800cfa0:	b2db      	uxtb	r3, r3
 800cfa2:	2b00      	cmp	r3, #0
 800cfa4:	d074      	beq.n	800d090 <lv_task_handler+0x160>
                break;
            }

            /*Here is the interrupter task. Don't execute it again.*/
            if(LV_GC_ROOT(_lv_task_act) == task_interrupter) {
 800cfa6:	4b63      	ldr	r3, [pc, #396]	; (800d134 <lv_task_handler+0x204>)
 800cfa8:	681b      	ldr	r3, [r3, #0]
 800cfaa:	68fa      	ldr	r2, [r7, #12]
 800cfac:	429a      	cmp	r2, r3
 800cfae:	d105      	bne.n	800cfbc <lv_task_handler+0x8c>
                task_interrupter = NULL; /*From this point only task after the interrupter comes, so
 800cfb0:	2300      	movs	r3, #0
 800cfb2:	60fb      	str	r3, [r7, #12]
                                            the interrupter is not interesting anymore*/
                LV_GC_ROOT(_lv_task_act) = next;
 800cfb4:	4a5f      	ldr	r2, [pc, #380]	; (800d134 <lv_task_handler+0x204>)
 800cfb6:	687b      	ldr	r3, [r7, #4]
 800cfb8:	6013      	str	r3, [r2, #0]
                continue; /*Load the next task*/
 800cfba:	e063      	b.n	800d084 <lv_task_handler+0x154>
            }

            /*Just try to run the tasks with highest priority.*/
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_HIGHEST) {
 800cfbc:	4b5d      	ldr	r3, [pc, #372]	; (800d134 <lv_task_handler+0x204>)
 800cfbe:	681b      	ldr	r3, [r3, #0]
 800cfc0:	7c1b      	ldrb	r3, [r3, #16]
 800cfc2:	f003 0307 	and.w	r3, r3, #7
 800cfc6:	b2db      	uxtb	r3, r3
 800cfc8:	2b05      	cmp	r3, #5
 800cfca:	d105      	bne.n	800cfd8 <lv_task_handler+0xa8>
                lv_task_exec(LV_GC_ROOT(_lv_task_act));
 800cfcc:	4b59      	ldr	r3, [pc, #356]	; (800d134 <lv_task_handler+0x204>)
 800cfce:	681b      	ldr	r3, [r3, #0]
 800cfd0:	4618      	mov	r0, r3
 800cfd2:	f000 fa33 	bl	800d43c <lv_task_exec>
 800cfd6:	e047      	b.n	800d068 <lv_task_handler+0x138>
            }
            /*Tasks with higher priority than the interrupted shall be run in every case*/
            else if(task_interrupter) {
 800cfd8:	68fb      	ldr	r3, [r7, #12]
 800cfda:	2b00      	cmp	r3, #0
 800cfdc:	d028      	beq.n	800d030 <lv_task_handler+0x100>
                if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio > task_interrupter->prio) {
 800cfde:	4b55      	ldr	r3, [pc, #340]	; (800d134 <lv_task_handler+0x204>)
 800cfe0:	681b      	ldr	r3, [r3, #0]
 800cfe2:	7c1b      	ldrb	r3, [r3, #16]
 800cfe4:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800cfe8:	b2da      	uxtb	r2, r3
 800cfea:	68fb      	ldr	r3, [r7, #12]
 800cfec:	7c1b      	ldrb	r3, [r3, #16]
 800cfee:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800cff2:	b2db      	uxtb	r3, r3
 800cff4:	429a      	cmp	r2, r3
 800cff6:	d937      	bls.n	800d068 <lv_task_handler+0x138>
                    if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
 800cff8:	4b4e      	ldr	r3, [pc, #312]	; (800d134 <lv_task_handler+0x204>)
 800cffa:	681b      	ldr	r3, [r3, #0]
 800cffc:	4618      	mov	r0, r3
 800cffe:	f000 fa1d 	bl	800d43c <lv_task_exec>
 800d002:	4603      	mov	r3, r0
 800d004:	2b00      	cmp	r3, #0
 800d006:	d02f      	beq.n	800d068 <lv_task_handler+0x138>
                        if(!task_created && !task_deleted) {
 800d008:	4b48      	ldr	r3, [pc, #288]	; (800d12c <lv_task_handler+0x1fc>)
 800d00a:	781b      	ldrb	r3, [r3, #0]
 800d00c:	f083 0301 	eor.w	r3, r3, #1
 800d010:	b2db      	uxtb	r3, r3
 800d012:	2b00      	cmp	r3, #0
 800d014:	d028      	beq.n	800d068 <lv_task_handler+0x138>
 800d016:	4b44      	ldr	r3, [pc, #272]	; (800d128 <lv_task_handler+0x1f8>)
 800d018:	781b      	ldrb	r3, [r3, #0]
 800d01a:	f083 0301 	eor.w	r3, r3, #1
 800d01e:	b2db      	uxtb	r3, r3
 800d020:	2b00      	cmp	r3, #0
 800d022:	d021      	beq.n	800d068 <lv_task_handler+0x138>
                            /*Check all tasks again from the highest priority */
                            task_interrupter = LV_GC_ROOT(_lv_task_act);
 800d024:	4b43      	ldr	r3, [pc, #268]	; (800d134 <lv_task_handler+0x204>)
 800d026:	681b      	ldr	r3, [r3, #0]
 800d028:	60fb      	str	r3, [r7, #12]
                            end_flag = false;
 800d02a:	2300      	movs	r3, #0
 800d02c:	72fb      	strb	r3, [r7, #11]
                            break;
 800d02e:	e030      	b.n	800d092 <lv_task_handler+0x162>
                }
            }
            /* It is no interrupter task or we already reached it earlier.
             * Just run the remaining tasks*/
            else {
                if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
 800d030:	4b40      	ldr	r3, [pc, #256]	; (800d134 <lv_task_handler+0x204>)
 800d032:	681b      	ldr	r3, [r3, #0]
 800d034:	4618      	mov	r0, r3
 800d036:	f000 fa01 	bl	800d43c <lv_task_exec>
 800d03a:	4603      	mov	r3, r0
 800d03c:	2b00      	cmp	r3, #0
 800d03e:	d013      	beq.n	800d068 <lv_task_handler+0x138>
                    if(!task_created && !task_deleted) {
 800d040:	4b3a      	ldr	r3, [pc, #232]	; (800d12c <lv_task_handler+0x1fc>)
 800d042:	781b      	ldrb	r3, [r3, #0]
 800d044:	f083 0301 	eor.w	r3, r3, #1
 800d048:	b2db      	uxtb	r3, r3
 800d04a:	2b00      	cmp	r3, #0
 800d04c:	d00c      	beq.n	800d068 <lv_task_handler+0x138>
 800d04e:	4b36      	ldr	r3, [pc, #216]	; (800d128 <lv_task_handler+0x1f8>)
 800d050:	781b      	ldrb	r3, [r3, #0]
 800d052:	f083 0301 	eor.w	r3, r3, #1
 800d056:	b2db      	uxtb	r3, r3
 800d058:	2b00      	cmp	r3, #0
 800d05a:	d005      	beq.n	800d068 <lv_task_handler+0x138>
                        task_interrupter = LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
 800d05c:	4b35      	ldr	r3, [pc, #212]	; (800d134 <lv_task_handler+0x204>)
 800d05e:	681b      	ldr	r3, [r3, #0]
 800d060:	60fb      	str	r3, [r7, #12]
                        end_flag         = false;
 800d062:	2300      	movs	r3, #0
 800d064:	72fb      	strb	r3, [r7, #11]
                        break;
 800d066:	e014      	b.n	800d092 <lv_task_handler+0x162>
                    }
                }
            }

            /*If a task was created or deleted then this or the next item might be corrupted*/
            if(task_created || task_deleted) {
 800d068:	4b30      	ldr	r3, [pc, #192]	; (800d12c <lv_task_handler+0x1fc>)
 800d06a:	781b      	ldrb	r3, [r3, #0]
 800d06c:	2b00      	cmp	r3, #0
 800d06e:	d103      	bne.n	800d078 <lv_task_handler+0x148>
 800d070:	4b2d      	ldr	r3, [pc, #180]	; (800d128 <lv_task_handler+0x1f8>)
 800d072:	781b      	ldrb	r3, [r3, #0]
 800d074:	2b00      	cmp	r3, #0
 800d076:	d002      	beq.n	800d07e <lv_task_handler+0x14e>
                task_interrupter = NULL;
 800d078:	2300      	movs	r3, #0
 800d07a:	60fb      	str	r3, [r7, #12]
                break;
 800d07c:	e009      	b.n	800d092 <lv_task_handler+0x162>
            }

            LV_GC_ROOT(_lv_task_act) = next; /*Load the next task*/
 800d07e:	4a2d      	ldr	r2, [pc, #180]	; (800d134 <lv_task_handler+0x204>)
 800d080:	687b      	ldr	r3, [r7, #4]
 800d082:	6013      	str	r3, [r2, #0]
        while(LV_GC_ROOT(_lv_task_act)) {
 800d084:	4b2b      	ldr	r3, [pc, #172]	; (800d134 <lv_task_handler+0x204>)
 800d086:	681b      	ldr	r3, [r3, #0]
 800d088:	2b00      	cmp	r3, #0
 800d08a:	f47f af7d 	bne.w	800cf88 <lv_task_handler+0x58>
 800d08e:	e000      	b.n	800d092 <lv_task_handler+0x162>
                break;
 800d090:	bf00      	nop
        }
    } while(!end_flag);
 800d092:	7afb      	ldrb	r3, [r7, #11]
 800d094:	f083 0301 	eor.w	r3, r3, #1
 800d098:	b2db      	uxtb	r3, r3
 800d09a:	2b00      	cmp	r3, #0
 800d09c:	f47f af65 	bne.w	800cf6a <lv_task_handler+0x3a>

    busy_time += lv_tick_elaps(handler_start);
 800d0a0:	4b20      	ldr	r3, [pc, #128]	; (800d124 <lv_task_handler+0x1f4>)
 800d0a2:	681b      	ldr	r3, [r3, #0]
 800d0a4:	4618      	mov	r0, r3
 800d0a6:	f7fe fd91 	bl	800bbcc <lv_tick_elaps>
 800d0aa:	4602      	mov	r2, r0
 800d0ac:	4b22      	ldr	r3, [pc, #136]	; (800d138 <lv_task_handler+0x208>)
 800d0ae:	681b      	ldr	r3, [r3, #0]
 800d0b0:	4413      	add	r3, r2
 800d0b2:	4a21      	ldr	r2, [pc, #132]	; (800d138 <lv_task_handler+0x208>)
 800d0b4:	6013      	str	r3, [r2, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
 800d0b6:	4b21      	ldr	r3, [pc, #132]	; (800d13c <lv_task_handler+0x20c>)
 800d0b8:	681b      	ldr	r3, [r3, #0]
 800d0ba:	4618      	mov	r0, r3
 800d0bc:	f7fe fd86 	bl	800bbcc <lv_tick_elaps>
 800d0c0:	6038      	str	r0, [r7, #0]
    if(idle_period_time >= IDLE_MEAS_PERIOD) {
 800d0c2:	683b      	ldr	r3, [r7, #0]
 800d0c4:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 800d0c8:	d320      	bcc.n	800d10c <lv_task_handler+0x1dc>

        idle_last         = (uint32_t)((uint32_t)busy_time * 100) / IDLE_MEAS_PERIOD; /*Calculate the busy percentage*/
 800d0ca:	4b1b      	ldr	r3, [pc, #108]	; (800d138 <lv_task_handler+0x208>)
 800d0cc:	681b      	ldr	r3, [r3, #0]
 800d0ce:	2264      	movs	r2, #100	; 0x64
 800d0d0:	fb02 f303 	mul.w	r3, r2, r3
 800d0d4:	4a1a      	ldr	r2, [pc, #104]	; (800d140 <lv_task_handler+0x210>)
 800d0d6:	fba2 2303 	umull	r2, r3, r2, r3
 800d0da:	095b      	lsrs	r3, r3, #5
 800d0dc:	b2da      	uxtb	r2, r3
 800d0de:	4b19      	ldr	r3, [pc, #100]	; (800d144 <lv_task_handler+0x214>)
 800d0e0:	701a      	strb	r2, [r3, #0]
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last;                    /*But we need idle time*/
 800d0e2:	4b18      	ldr	r3, [pc, #96]	; (800d144 <lv_task_handler+0x214>)
 800d0e4:	781b      	ldrb	r3, [r3, #0]
 800d0e6:	2b64      	cmp	r3, #100	; 0x64
 800d0e8:	d805      	bhi.n	800d0f6 <lv_task_handler+0x1c6>
 800d0ea:	4b16      	ldr	r3, [pc, #88]	; (800d144 <lv_task_handler+0x214>)
 800d0ec:	781b      	ldrb	r3, [r3, #0]
 800d0ee:	f1c3 0364 	rsb	r3, r3, #100	; 0x64
 800d0f2:	b2db      	uxtb	r3, r3
 800d0f4:	e000      	b.n	800d0f8 <lv_task_handler+0x1c8>
 800d0f6:	2300      	movs	r3, #0
 800d0f8:	4a12      	ldr	r2, [pc, #72]	; (800d144 <lv_task_handler+0x214>)
 800d0fa:	7013      	strb	r3, [r2, #0]
        busy_time         = 0;
 800d0fc:	4b0e      	ldr	r3, [pc, #56]	; (800d138 <lv_task_handler+0x208>)
 800d0fe:	2200      	movs	r2, #0
 800d100:	601a      	str	r2, [r3, #0]
        idle_period_start = lv_tick_get();
 800d102:	f7fe fd49 	bl	800bb98 <lv_tick_get>
 800d106:	4602      	mov	r2, r0
 800d108:	4b0c      	ldr	r3, [pc, #48]	; (800d13c <lv_task_handler+0x20c>)
 800d10a:	601a      	str	r2, [r3, #0]
    }

    already_running = false; /*Release the mutex*/
 800d10c:	4b03      	ldr	r3, [pc, #12]	; (800d11c <lv_task_handler+0x1ec>)
 800d10e:	2200      	movs	r2, #0
 800d110:	701a      	strb	r2, [r3, #0]
 800d112:	e000      	b.n	800d116 <lv_task_handler+0x1e6>
    if(already_running) return;
 800d114:	bf00      	nop

    LV_LOG_TRACE("lv_task_handler ready");
}
 800d116:	3710      	adds	r7, #16
 800d118:	46bd      	mov	sp, r7
 800d11a:	bd80      	pop	{r7, pc}
 800d11c:	200082c0 	.word	0x200082c0
 800d120:	200082bc 	.word	0x200082bc
 800d124:	200082c4 	.word	0x200082c4
 800d128:	200082be 	.word	0x200082be
 800d12c:	200082bf 	.word	0x200082bf
 800d130:	20009940 	.word	0x20009940
 800d134:	20009980 	.word	0x20009980
 800d138:	200082c8 	.word	0x200082c8
 800d13c:	200082cc 	.word	0x200082cc
 800d140:	10624dd3 	.word	0x10624dd3
 800d144:	200082bd 	.word	0x200082bd

0800d148 <lv_task_create_basic>:
 * Create an "empty" task. It needs to initialzed with at least
 * `lv_task_set_cb` and `lv_task_set_period`
 * @return pointer to the craeted task
 */
lv_task_t * lv_task_create_basic(void)
{
 800d148:	b590      	push	{r4, r7, lr}
 800d14a:	b083      	sub	sp, #12
 800d14c:	af00      	add	r7, sp, #0
    lv_task_t * new_task = NULL;
 800d14e:	2300      	movs	r3, #0
 800d150:	607b      	str	r3, [r7, #4]
    lv_task_t * tmp;

    /*Create task lists in order of priority from high to low*/
    tmp = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 800d152:	4847      	ldr	r0, [pc, #284]	; (800d270 <lv_task_create_basic+0x128>)
 800d154:	f7ff fc32 	bl	800c9bc <lv_ll_get_head>
 800d158:	6038      	str	r0, [r7, #0]

    /*It's the first task*/
    if(NULL == tmp) {
 800d15a:	683b      	ldr	r3, [r7, #0]
 800d15c:	2b00      	cmp	r3, #0
 800d15e:	d11a      	bne.n	800d196 <lv_task_create_basic+0x4e>
        new_task = lv_ll_ins_head(&LV_GC_ROOT(_lv_task_ll));
 800d160:	4843      	ldr	r0, [pc, #268]	; (800d270 <lv_task_create_basic+0x128>)
 800d162:	f7ff fac9 	bl	800c6f8 <lv_ll_ins_head>
 800d166:	6078      	str	r0, [r7, #4]
        LV_ASSERT_MEM(new_task);
 800d168:	6878      	ldr	r0, [r7, #4]
 800d16a:	f7f3 f845 	bl	80001f8 <lv_debug_check_null>
 800d16e:	4603      	mov	r3, r0
 800d170:	f083 0301 	eor.w	r3, r3, #1
 800d174:	b2db      	uxtb	r3, r3
 800d176:	2b00      	cmp	r3, #0
 800d178:	d008      	beq.n	800d18c <lv_task_create_basic+0x44>
 800d17a:	687b      	ldr	r3, [r7, #4]
 800d17c:	f04f 0400 	mov.w	r4, #0
 800d180:	461a      	mov	r2, r3
 800d182:	4623      	mov	r3, r4
 800d184:	483b      	ldr	r0, [pc, #236]	; (800d274 <lv_task_create_basic+0x12c>)
 800d186:	f7f3 f861 	bl	800024c <lv_debug_log_error>
 800d18a:	e7fe      	b.n	800d18a <lv_task_create_basic+0x42>
        if(new_task == NULL) return NULL;
 800d18c:	687b      	ldr	r3, [r7, #4]
 800d18e:	2b00      	cmp	r3, #0
 800d190:	d14c      	bne.n	800d22c <lv_task_create_basic+0xe4>
 800d192:	2300      	movs	r3, #0
 800d194:	e068      	b.n	800d268 <lv_task_create_basic+0x120>
    }
    /*Insert the new task to proper place according to its priority*/
    else {
        do {
            if(tmp->prio <= DEF_PRIO) {
 800d196:	683b      	ldr	r3, [r7, #0]
 800d198:	7c1b      	ldrb	r3, [r3, #16]
 800d19a:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800d19e:	b2db      	uxtb	r3, r3
 800d1a0:	2b03      	cmp	r3, #3
 800d1a2:	d81b      	bhi.n	800d1dc <lv_task_create_basic+0x94>
                new_task = lv_ll_ins_prev(&LV_GC_ROOT(_lv_task_ll), tmp);
 800d1a4:	6839      	ldr	r1, [r7, #0]
 800d1a6:	4832      	ldr	r0, [pc, #200]	; (800d270 <lv_task_create_basic+0x128>)
 800d1a8:	f7ff fada 	bl	800c760 <lv_ll_ins_prev>
 800d1ac:	6078      	str	r0, [r7, #4]
                LV_ASSERT_MEM(new_task);
 800d1ae:	6878      	ldr	r0, [r7, #4]
 800d1b0:	f7f3 f822 	bl	80001f8 <lv_debug_check_null>
 800d1b4:	4603      	mov	r3, r0
 800d1b6:	f083 0301 	eor.w	r3, r3, #1
 800d1ba:	b2db      	uxtb	r3, r3
 800d1bc:	2b00      	cmp	r3, #0
 800d1be:	d008      	beq.n	800d1d2 <lv_task_create_basic+0x8a>
 800d1c0:	687b      	ldr	r3, [r7, #4]
 800d1c2:	f04f 0400 	mov.w	r4, #0
 800d1c6:	461a      	mov	r2, r3
 800d1c8:	4623      	mov	r3, r4
 800d1ca:	482a      	ldr	r0, [pc, #168]	; (800d274 <lv_task_create_basic+0x12c>)
 800d1cc:	f7f3 f83e 	bl	800024c <lv_debug_log_error>
 800d1d0:	e7fe      	b.n	800d1d0 <lv_task_create_basic+0x88>
                if(new_task == NULL) return NULL;
 800d1d2:	687b      	ldr	r3, [r7, #4]
 800d1d4:	2b00      	cmp	r3, #0
 800d1d6:	d10a      	bne.n	800d1ee <lv_task_create_basic+0xa6>
 800d1d8:	2300      	movs	r3, #0
 800d1da:	e045      	b.n	800d268 <lv_task_create_basic+0x120>
                break;
            }
            tmp = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
 800d1dc:	6839      	ldr	r1, [r7, #0]
 800d1de:	4824      	ldr	r0, [pc, #144]	; (800d270 <lv_task_create_basic+0x128>)
 800d1e0:	f7ff fc12 	bl	800ca08 <lv_ll_get_next>
 800d1e4:	6038      	str	r0, [r7, #0]
        } while(tmp != NULL);
 800d1e6:	683b      	ldr	r3, [r7, #0]
 800d1e8:	2b00      	cmp	r3, #0
 800d1ea:	d1d4      	bne.n	800d196 <lv_task_create_basic+0x4e>
 800d1ec:	e000      	b.n	800d1f0 <lv_task_create_basic+0xa8>
                break;
 800d1ee:	bf00      	nop

        /*Only too high priority tasks were found. Add the task to the end*/
        if(tmp == NULL) {
 800d1f0:	683b      	ldr	r3, [r7, #0]
 800d1f2:	2b00      	cmp	r3, #0
 800d1f4:	d11a      	bne.n	800d22c <lv_task_create_basic+0xe4>
            new_task = lv_ll_ins_tail(&LV_GC_ROOT(_lv_task_ll));
 800d1f6:	481e      	ldr	r0, [pc, #120]	; (800d270 <lv_task_create_basic+0x128>)
 800d1f8:	f7ff faf9 	bl	800c7ee <lv_ll_ins_tail>
 800d1fc:	6078      	str	r0, [r7, #4]
            LV_ASSERT_MEM(new_task);
 800d1fe:	6878      	ldr	r0, [r7, #4]
 800d200:	f7f2 fffa 	bl	80001f8 <lv_debug_check_null>
 800d204:	4603      	mov	r3, r0
 800d206:	f083 0301 	eor.w	r3, r3, #1
 800d20a:	b2db      	uxtb	r3, r3
 800d20c:	2b00      	cmp	r3, #0
 800d20e:	d008      	beq.n	800d222 <lv_task_create_basic+0xda>
 800d210:	687b      	ldr	r3, [r7, #4]
 800d212:	f04f 0400 	mov.w	r4, #0
 800d216:	461a      	mov	r2, r3
 800d218:	4623      	mov	r3, r4
 800d21a:	4816      	ldr	r0, [pc, #88]	; (800d274 <lv_task_create_basic+0x12c>)
 800d21c:	f7f3 f816 	bl	800024c <lv_debug_log_error>
 800d220:	e7fe      	b.n	800d220 <lv_task_create_basic+0xd8>
            if(new_task == NULL) return NULL;
 800d222:	687b      	ldr	r3, [r7, #4]
 800d224:	2b00      	cmp	r3, #0
 800d226:	d101      	bne.n	800d22c <lv_task_create_basic+0xe4>
 800d228:	2300      	movs	r3, #0
 800d22a:	e01d      	b.n	800d268 <lv_task_create_basic+0x120>
        }
    }

    new_task->period  = DEF_PERIOD;
 800d22c:	687b      	ldr	r3, [r7, #4]
 800d22e:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 800d232:	601a      	str	r2, [r3, #0]
    new_task->task_cb = NULL;
 800d234:	687b      	ldr	r3, [r7, #4]
 800d236:	2200      	movs	r2, #0
 800d238:	609a      	str	r2, [r3, #8]
    new_task->prio    = DEF_PRIO;
 800d23a:	687a      	ldr	r2, [r7, #4]
 800d23c:	7c13      	ldrb	r3, [r2, #16]
 800d23e:	2103      	movs	r1, #3
 800d240:	f361 0302 	bfi	r3, r1, #0, #3
 800d244:	7413      	strb	r3, [r2, #16]

    new_task->once     = 0;
 800d246:	687a      	ldr	r2, [r7, #4]
 800d248:	7c13      	ldrb	r3, [r2, #16]
 800d24a:	f36f 03c3 	bfc	r3, #3, #1
 800d24e:	7413      	strb	r3, [r2, #16]
    new_task->last_run = lv_tick_get();
 800d250:	f7fe fca2 	bl	800bb98 <lv_tick_get>
 800d254:	4602      	mov	r2, r0
 800d256:	687b      	ldr	r3, [r7, #4]
 800d258:	605a      	str	r2, [r3, #4]

    new_task->user_data = NULL;
 800d25a:	687b      	ldr	r3, [r7, #4]
 800d25c:	2200      	movs	r2, #0
 800d25e:	60da      	str	r2, [r3, #12]

    task_created = true;
 800d260:	4b05      	ldr	r3, [pc, #20]	; (800d278 <lv_task_create_basic+0x130>)
 800d262:	2201      	movs	r2, #1
 800d264:	701a      	strb	r2, [r3, #0]

    return new_task;
 800d266:	687b      	ldr	r3, [r7, #4]
}
 800d268:	4618      	mov	r0, r3
 800d26a:	370c      	adds	r7, #12
 800d26c:	46bd      	mov	sp, r7
 800d26e:	bd90      	pop	{r4, r7, pc}
 800d270:	20009940 	.word	0x20009940
 800d274:	0801389c 	.word	0x0801389c
 800d278:	200082bf 	.word	0x200082bf

0800d27c <lv_task_create>:
 * @param prio priority of the task (LV_TASK_PRIO_OFF means the task is stopped)
 * @param user_data custom parameter
 * @return pointer to the new task
 */
lv_task_t * lv_task_create(lv_task_cb_t task_cb, uint32_t period, lv_task_prio_t prio, void * user_data)
{
 800d27c:	b590      	push	{r4, r7, lr}
 800d27e:	b087      	sub	sp, #28
 800d280:	af00      	add	r7, sp, #0
 800d282:	60f8      	str	r0, [r7, #12]
 800d284:	60b9      	str	r1, [r7, #8]
 800d286:	603b      	str	r3, [r7, #0]
 800d288:	4613      	mov	r3, r2
 800d28a:	71fb      	strb	r3, [r7, #7]
    lv_task_t * new_task = lv_task_create_basic();
 800d28c:	f7ff ff5c 	bl	800d148 <lv_task_create_basic>
 800d290:	6178      	str	r0, [r7, #20]
    LV_ASSERT_MEM(new_task);
 800d292:	6978      	ldr	r0, [r7, #20]
 800d294:	f7f2 ffb0 	bl	80001f8 <lv_debug_check_null>
 800d298:	4603      	mov	r3, r0
 800d29a:	f083 0301 	eor.w	r3, r3, #1
 800d29e:	b2db      	uxtb	r3, r3
 800d2a0:	2b00      	cmp	r3, #0
 800d2a2:	d008      	beq.n	800d2b6 <lv_task_create+0x3a>
 800d2a4:	697b      	ldr	r3, [r7, #20]
 800d2a6:	f04f 0400 	mov.w	r4, #0
 800d2aa:	461a      	mov	r2, r3
 800d2ac:	4623      	mov	r3, r4
 800d2ae:	480f      	ldr	r0, [pc, #60]	; (800d2ec <lv_task_create+0x70>)
 800d2b0:	f7f2 ffcc 	bl	800024c <lv_debug_log_error>
 800d2b4:	e7fe      	b.n	800d2b4 <lv_task_create+0x38>
    if(new_task == NULL) return NULL;
 800d2b6:	697b      	ldr	r3, [r7, #20]
 800d2b8:	2b00      	cmp	r3, #0
 800d2ba:	d101      	bne.n	800d2c0 <lv_task_create+0x44>
 800d2bc:	2300      	movs	r3, #0
 800d2be:	e010      	b.n	800d2e2 <lv_task_create+0x66>

    lv_task_set_cb(new_task, task_cb);
 800d2c0:	68f9      	ldr	r1, [r7, #12]
 800d2c2:	6978      	ldr	r0, [r7, #20]
 800d2c4:	f000 f814 	bl	800d2f0 <lv_task_set_cb>
    lv_task_set_period(new_task, period);
 800d2c8:	68b9      	ldr	r1, [r7, #8]
 800d2ca:	6978      	ldr	r0, [r7, #20]
 800d2cc:	f000 f886 	bl	800d3dc <lv_task_set_period>
    lv_task_set_prio(new_task, prio);
 800d2d0:	79fb      	ldrb	r3, [r7, #7]
 800d2d2:	4619      	mov	r1, r3
 800d2d4:	6978      	ldr	r0, [r7, #20]
 800d2d6:	f000 f837 	bl	800d348 <lv_task_set_prio>
    new_task->user_data = user_data;
 800d2da:	697b      	ldr	r3, [r7, #20]
 800d2dc:	683a      	ldr	r2, [r7, #0]
 800d2de:	60da      	str	r2, [r3, #12]

    return new_task;
 800d2e0:	697b      	ldr	r3, [r7, #20]
}
 800d2e2:	4618      	mov	r0, r3
 800d2e4:	371c      	adds	r7, #28
 800d2e6:	46bd      	mov	sp, r7
 800d2e8:	bd90      	pop	{r4, r7, pc}
 800d2ea:	bf00      	nop
 800d2ec:	0801389c 	.word	0x0801389c

0800d2f0 <lv_task_set_cb>:
 * Set the callback the task (the function to call periodically)
 * @param task pointer to a task
 * @param task_cb teh function to call periodically
 */
void lv_task_set_cb(lv_task_t * task, lv_task_cb_t task_cb)
{
 800d2f0:	b480      	push	{r7}
 800d2f2:	b083      	sub	sp, #12
 800d2f4:	af00      	add	r7, sp, #0
 800d2f6:	6078      	str	r0, [r7, #4]
 800d2f8:	6039      	str	r1, [r7, #0]
    task->task_cb = task_cb;
 800d2fa:	687b      	ldr	r3, [r7, #4]
 800d2fc:	683a      	ldr	r2, [r7, #0]
 800d2fe:	609a      	str	r2, [r3, #8]
}
 800d300:	bf00      	nop
 800d302:	370c      	adds	r7, #12
 800d304:	46bd      	mov	sp, r7
 800d306:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d30a:	4770      	bx	lr

0800d30c <lv_task_del>:
/**
 * Delete a lv_task
 * @param task pointer to task created by task
 */
void lv_task_del(lv_task_t * task)
{
 800d30c:	b580      	push	{r7, lr}
 800d30e:	b082      	sub	sp, #8
 800d310:	af00      	add	r7, sp, #0
 800d312:	6078      	str	r0, [r7, #4]
    lv_ll_rem(&LV_GC_ROOT(_lv_task_ll), task);
 800d314:	6879      	ldr	r1, [r7, #4]
 800d316:	4809      	ldr	r0, [pc, #36]	; (800d33c <lv_task_del+0x30>)
 800d318:	f7ff faa2 	bl	800c860 <lv_ll_rem>

    lv_mem_free(task);
 800d31c:	6878      	ldr	r0, [r7, #4]
 800d31e:	f7ff fca7 	bl	800cc70 <lv_mem_free>

    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
 800d322:	4b07      	ldr	r3, [pc, #28]	; (800d340 <lv_task_del+0x34>)
 800d324:	681b      	ldr	r3, [r3, #0]
 800d326:	687a      	ldr	r2, [r7, #4]
 800d328:	429a      	cmp	r2, r3
 800d32a:	d102      	bne.n	800d332 <lv_task_del+0x26>
 800d32c:	4b05      	ldr	r3, [pc, #20]	; (800d344 <lv_task_del+0x38>)
 800d32e:	2201      	movs	r2, #1
 800d330:	701a      	strb	r2, [r3, #0]
}
 800d332:	bf00      	nop
 800d334:	3708      	adds	r7, #8
 800d336:	46bd      	mov	sp, r7
 800d338:	bd80      	pop	{r7, pc}
 800d33a:	bf00      	nop
 800d33c:	20009940 	.word	0x20009940
 800d340:	20009980 	.word	0x20009980
 800d344:	200082be 	.word	0x200082be

0800d348 <lv_task_set_prio>:
 * Set new priority for a lv_task
 * @param task pointer to a lv_task
 * @param prio the new priority
 */
void lv_task_set_prio(lv_task_t * task, lv_task_prio_t prio)
{
 800d348:	b580      	push	{r7, lr}
 800d34a:	b084      	sub	sp, #16
 800d34c:	af00      	add	r7, sp, #0
 800d34e:	6078      	str	r0, [r7, #4]
 800d350:	460b      	mov	r3, r1
 800d352:	70fb      	strb	r3, [r7, #3]
    if(task->prio == prio) return;
 800d354:	687b      	ldr	r3, [r7, #4]
 800d356:	7c1b      	ldrb	r3, [r3, #16]
 800d358:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800d35c:	b2db      	uxtb	r3, r3
 800d35e:	461a      	mov	r2, r3
 800d360:	78fb      	ldrb	r3, [r7, #3]
 800d362:	429a      	cmp	r2, r3
 800d364:	d033      	beq.n	800d3ce <lv_task_set_prio+0x86>

    /*Find the tasks with new priority*/
    lv_task_t * i;
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
 800d366:	481c      	ldr	r0, [pc, #112]	; (800d3d8 <lv_task_set_prio+0x90>)
 800d368:	f7ff fb28 	bl	800c9bc <lv_ll_get_head>
 800d36c:	60f8      	str	r0, [r7, #12]
 800d36e:	e017      	b.n	800d3a0 <lv_task_set_prio+0x58>
    {
        if(i->prio <= prio) {
 800d370:	68fb      	ldr	r3, [r7, #12]
 800d372:	7c1b      	ldrb	r3, [r3, #16]
 800d374:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800d378:	b2db      	uxtb	r3, r3
 800d37a:	461a      	mov	r2, r3
 800d37c:	78fb      	ldrb	r3, [r7, #3]
 800d37e:	429a      	cmp	r2, r3
 800d380:	dc09      	bgt.n	800d396 <lv_task_set_prio+0x4e>
            if(i != task) lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, i);
 800d382:	68fa      	ldr	r2, [r7, #12]
 800d384:	687b      	ldr	r3, [r7, #4]
 800d386:	429a      	cmp	r2, r3
 800d388:	d00e      	beq.n	800d3a8 <lv_task_set_prio+0x60>
 800d38a:	68fa      	ldr	r2, [r7, #12]
 800d38c:	6879      	ldr	r1, [r7, #4]
 800d38e:	4812      	ldr	r0, [pc, #72]	; (800d3d8 <lv_task_set_prio+0x90>)
 800d390:	f7ff fb6d 	bl	800ca6e <lv_ll_move_before>
            break;
 800d394:	e008      	b.n	800d3a8 <lv_task_set_prio+0x60>
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
 800d396:	68f9      	ldr	r1, [r7, #12]
 800d398:	480f      	ldr	r0, [pc, #60]	; (800d3d8 <lv_task_set_prio+0x90>)
 800d39a:	f7ff fb35 	bl	800ca08 <lv_ll_get_next>
 800d39e:	60f8      	str	r0, [r7, #12]
 800d3a0:	68fb      	ldr	r3, [r7, #12]
 800d3a2:	2b00      	cmp	r3, #0
 800d3a4:	d1e4      	bne.n	800d370 <lv_task_set_prio+0x28>
 800d3a6:	e000      	b.n	800d3aa <lv_task_set_prio+0x62>
            break;
 800d3a8:	bf00      	nop
        }
    }

    /*There was no such a low priority so far then add the node to the tail*/
    if(i == NULL) {
 800d3aa:	68fb      	ldr	r3, [r7, #12]
 800d3ac:	2b00      	cmp	r3, #0
 800d3ae:	d104      	bne.n	800d3ba <lv_task_set_prio+0x72>
        lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, NULL);
 800d3b0:	2200      	movs	r2, #0
 800d3b2:	6879      	ldr	r1, [r7, #4]
 800d3b4:	4808      	ldr	r0, [pc, #32]	; (800d3d8 <lv_task_set_prio+0x90>)
 800d3b6:	f7ff fb5a 	bl	800ca6e <lv_ll_move_before>
    }

    task->prio = prio;
 800d3ba:	78fb      	ldrb	r3, [r7, #3]
 800d3bc:	f003 0307 	and.w	r3, r3, #7
 800d3c0:	b2d9      	uxtb	r1, r3
 800d3c2:	687a      	ldr	r2, [r7, #4]
 800d3c4:	7c13      	ldrb	r3, [r2, #16]
 800d3c6:	f361 0302 	bfi	r3, r1, #0, #3
 800d3ca:	7413      	strb	r3, [r2, #16]
 800d3cc:	e000      	b.n	800d3d0 <lv_task_set_prio+0x88>
    if(task->prio == prio) return;
 800d3ce:	bf00      	nop
}
 800d3d0:	3710      	adds	r7, #16
 800d3d2:	46bd      	mov	sp, r7
 800d3d4:	bd80      	pop	{r7, pc}
 800d3d6:	bf00      	nop
 800d3d8:	20009940 	.word	0x20009940

0800d3dc <lv_task_set_period>:
 * Set new period for a lv_task
 * @param task pointer to a lv_task
 * @param period the new period
 */
void lv_task_set_period(lv_task_t * task, uint32_t period)
{
 800d3dc:	b480      	push	{r7}
 800d3de:	b083      	sub	sp, #12
 800d3e0:	af00      	add	r7, sp, #0
 800d3e2:	6078      	str	r0, [r7, #4]
 800d3e4:	6039      	str	r1, [r7, #0]
    task->period = period;
 800d3e6:	687b      	ldr	r3, [r7, #4]
 800d3e8:	683a      	ldr	r2, [r7, #0]
 800d3ea:	601a      	str	r2, [r3, #0]
}
 800d3ec:	bf00      	nop
 800d3ee:	370c      	adds	r7, #12
 800d3f0:	46bd      	mov	sp, r7
 800d3f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d3f6:	4770      	bx	lr

0800d3f8 <lv_task_ready>:
/**
 * Make a lv_task ready. It will not wait its period.
 * @param task pointer to a lv_task.
 */
void lv_task_ready(lv_task_t * task)
{
 800d3f8:	b580      	push	{r7, lr}
 800d3fa:	b082      	sub	sp, #8
 800d3fc:	af00      	add	r7, sp, #0
 800d3fe:	6078      	str	r0, [r7, #4]
    task->last_run = lv_tick_get() - task->period - 1;
 800d400:	f7fe fbca 	bl	800bb98 <lv_tick_get>
 800d404:	4602      	mov	r2, r0
 800d406:	687b      	ldr	r3, [r7, #4]
 800d408:	681b      	ldr	r3, [r3, #0]
 800d40a:	1ad3      	subs	r3, r2, r3
 800d40c:	1e5a      	subs	r2, r3, #1
 800d40e:	687b      	ldr	r3, [r7, #4]
 800d410:	605a      	str	r2, [r3, #4]
}
 800d412:	bf00      	nop
 800d414:	3708      	adds	r7, #8
 800d416:	46bd      	mov	sp, r7
 800d418:	bd80      	pop	{r7, pc}
	...

0800d41c <lv_task_enable>:
/**
 * Enable or disable the whole lv_task handling
 * @param en: true: lv_task handling is running, false: lv_task handling is suspended
 */
void lv_task_enable(bool en)
{
 800d41c:	b480      	push	{r7}
 800d41e:	b083      	sub	sp, #12
 800d420:	af00      	add	r7, sp, #0
 800d422:	4603      	mov	r3, r0
 800d424:	71fb      	strb	r3, [r7, #7]
    lv_task_run = en;
 800d426:	4a04      	ldr	r2, [pc, #16]	; (800d438 <lv_task_enable+0x1c>)
 800d428:	79fb      	ldrb	r3, [r7, #7]
 800d42a:	7013      	strb	r3, [r2, #0]
}
 800d42c:	bf00      	nop
 800d42e:	370c      	adds	r7, #12
 800d430:	46bd      	mov	sp, r7
 800d432:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d436:	4770      	bx	lr
 800d438:	200082bc 	.word	0x200082bc

0800d43c <lv_task_exec>:
 * Execute task if its the priority is appropriate
 * @param task pointer to lv_task
 * @return true: execute, false: not executed
 */
static bool lv_task_exec(lv_task_t * task)
{
 800d43c:	b580      	push	{r7, lr}
 800d43e:	b084      	sub	sp, #16
 800d440:	af00      	add	r7, sp, #0
 800d442:	6078      	str	r0, [r7, #4]
    bool exec = false;
 800d444:	2300      	movs	r3, #0
 800d446:	73fb      	strb	r3, [r7, #15]

    /*Execute if at least 'period' time elapsed*/
    uint32_t elp = lv_tick_elaps(task->last_run);
 800d448:	687b      	ldr	r3, [r7, #4]
 800d44a:	685b      	ldr	r3, [r3, #4]
 800d44c:	4618      	mov	r0, r3
 800d44e:	f7fe fbbd 	bl	800bbcc <lv_tick_elaps>
 800d452:	60b8      	str	r0, [r7, #8]
    if(elp >= task->period) {
 800d454:	687b      	ldr	r3, [r7, #4]
 800d456:	681b      	ldr	r3, [r3, #0]
 800d458:	68ba      	ldr	r2, [r7, #8]
 800d45a:	429a      	cmp	r2, r3
 800d45c:	d325      	bcc.n	800d4aa <lv_task_exec+0x6e>
        task->last_run = lv_tick_get();
 800d45e:	f7fe fb9b 	bl	800bb98 <lv_tick_get>
 800d462:	4602      	mov	r2, r0
 800d464:	687b      	ldr	r3, [r7, #4]
 800d466:	605a      	str	r2, [r3, #4]
        task_deleted   = false;
 800d468:	4b12      	ldr	r3, [pc, #72]	; (800d4b4 <lv_task_exec+0x78>)
 800d46a:	2200      	movs	r2, #0
 800d46c:	701a      	strb	r2, [r3, #0]
        task_created   = false;
 800d46e:	4b12      	ldr	r3, [pc, #72]	; (800d4b8 <lv_task_exec+0x7c>)
 800d470:	2200      	movs	r2, #0
 800d472:	701a      	strb	r2, [r3, #0]
        if(task->task_cb) task->task_cb(task);
 800d474:	687b      	ldr	r3, [r7, #4]
 800d476:	689b      	ldr	r3, [r3, #8]
 800d478:	2b00      	cmp	r3, #0
 800d47a:	d003      	beq.n	800d484 <lv_task_exec+0x48>
 800d47c:	687b      	ldr	r3, [r7, #4]
 800d47e:	689b      	ldr	r3, [r3, #8]
 800d480:	6878      	ldr	r0, [r7, #4]
 800d482:	4798      	blx	r3

        /*Delete if it was a one shot lv_task*/
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
 800d484:	4b0b      	ldr	r3, [pc, #44]	; (800d4b4 <lv_task_exec+0x78>)
 800d486:	781b      	ldrb	r3, [r3, #0]
 800d488:	f083 0301 	eor.w	r3, r3, #1
 800d48c:	b2db      	uxtb	r3, r3
 800d48e:	2b00      	cmp	r3, #0
 800d490:	d009      	beq.n	800d4a6 <lv_task_exec+0x6a>
            if(task->once != 0) {
 800d492:	687b      	ldr	r3, [r7, #4]
 800d494:	7c1b      	ldrb	r3, [r3, #16]
 800d496:	f003 0308 	and.w	r3, r3, #8
 800d49a:	b2db      	uxtb	r3, r3
 800d49c:	2b00      	cmp	r3, #0
 800d49e:	d002      	beq.n	800d4a6 <lv_task_exec+0x6a>
                lv_task_del(task);
 800d4a0:	6878      	ldr	r0, [r7, #4]
 800d4a2:	f7ff ff33 	bl	800d30c <lv_task_del>
            }
        }
        exec = true;
 800d4a6:	2301      	movs	r3, #1
 800d4a8:	73fb      	strb	r3, [r7, #15]
    }

    return exec;
 800d4aa:	7bfb      	ldrb	r3, [r7, #15]
}
 800d4ac:	4618      	mov	r0, r3
 800d4ae:	3710      	adds	r7, #16
 800d4b0:	46bd      	mov	sp, r7
 800d4b2:	bd80      	pop	{r7, pc}
 800d4b4:	200082be 	.word	0x200082be
 800d4b8:	200082bf 	.word	0x200082bf

0800d4bc <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
 800d4bc:	b480      	push	{r7}
 800d4be:	b083      	sub	sp, #12
 800d4c0:	af00      	add	r7, sp, #0
 800d4c2:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 800d4c4:	687b      	ldr	r3, [r7, #4]
 800d4c6:	7a1b      	ldrb	r3, [r3, #8]
}
 800d4c8:	4618      	mov	r0, r3
 800d4ca:	370c      	adds	r7, #12
 800d4cc:	46bd      	mov	sp, r7
 800d4ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d4d2:	4770      	bx	lr

0800d4d4 <lv_txt_get_size>:
 * @param max_width max with of the text (break the lines to fit this size) Set CORD_MAX to avoid
 * line breaks
 */
void lv_txt_get_size(lv_point_t * size_res, const char * text, const lv_font_t * font, lv_coord_t letter_space,
                     lv_coord_t line_space, lv_coord_t max_width, lv_txt_flag_t flag)
{
 800d4d4:	b580      	push	{r7, lr}
 800d4d6:	b08a      	sub	sp, #40	; 0x28
 800d4d8:	af02      	add	r7, sp, #8
 800d4da:	60f8      	str	r0, [r7, #12]
 800d4dc:	60b9      	str	r1, [r7, #8]
 800d4de:	607a      	str	r2, [r7, #4]
 800d4e0:	807b      	strh	r3, [r7, #2]
    size_res->x = 0;
 800d4e2:	68fb      	ldr	r3, [r7, #12]
 800d4e4:	2200      	movs	r2, #0
 800d4e6:	801a      	strh	r2, [r3, #0]
    size_res->y = 0;
 800d4e8:	68fb      	ldr	r3, [r7, #12]
 800d4ea:	2200      	movs	r2, #0
 800d4ec:	805a      	strh	r2, [r3, #2]

    if(text == NULL) return;
 800d4ee:	68bb      	ldr	r3, [r7, #8]
 800d4f0:	2b00      	cmp	r3, #0
 800d4f2:	f000 80a6 	beq.w	800d642 <lv_txt_get_size+0x16e>
    if(font == NULL) return;
 800d4f6:	687b      	ldr	r3, [r7, #4]
 800d4f8:	2b00      	cmp	r3, #0
 800d4fa:	f000 80a4 	beq.w	800d646 <lv_txt_get_size+0x172>

    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 800d4fe:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800d502:	f003 0302 	and.w	r3, r3, #2
 800d506:	2b00      	cmp	r3, #0
 800d508:	d002      	beq.n	800d510 <lv_txt_get_size+0x3c>
 800d50a:	f647 4318 	movw	r3, #31768	; 0x7c18
 800d50e:	85bb      	strh	r3, [r7, #44]	; 0x2c

    uint32_t line_start     = 0;
 800d510:	2300      	movs	r3, #0
 800d512:	61fb      	str	r3, [r7, #28]
    uint32_t new_line_start = 0;
 800d514:	2300      	movs	r3, #0
 800d516:	61bb      	str	r3, [r7, #24]
    lv_coord_t act_line_length;
    uint8_t letter_height = lv_font_get_line_height(font);
 800d518:	6878      	ldr	r0, [r7, #4]
 800d51a:	f7ff ffcf 	bl	800d4bc <lv_font_get_line_height>
 800d51e:	4603      	mov	r3, r0
 800d520:	75fb      	strb	r3, [r7, #23]

    /*Calc. the height and longest line*/
    while(text[line_start] != '\0') {
 800d522:	e054      	b.n	800d5ce <lv_txt_get_size+0xfa>
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
 800d524:	68ba      	ldr	r2, [r7, #8]
 800d526:	69fb      	ldr	r3, [r7, #28]
 800d528:	18d0      	adds	r0, r2, r3
 800d52a:	f9b7 102c 	ldrsh.w	r1, [r7, #44]	; 0x2c
 800d52e:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 800d532:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800d536:	9300      	str	r3, [sp, #0]
 800d538:	460b      	mov	r3, r1
 800d53a:	6879      	ldr	r1, [r7, #4]
 800d53c:	f000 f99a 	bl	800d874 <lv_txt_get_next_line>
 800d540:	4603      	mov	r3, r0
 800d542:	461a      	mov	r2, r3
 800d544:	69bb      	ldr	r3, [r7, #24]
 800d546:	4413      	add	r3, r2
 800d548:	61bb      	str	r3, [r7, #24]

        if ((unsigned long)size_res->y + (unsigned long)letter_height + (unsigned long)line_space > LV_MAX_OF(lv_coord_t)) {
 800d54a:	68fb      	ldr	r3, [r7, #12]
 800d54c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800d550:	461a      	mov	r2, r3
 800d552:	7dfb      	ldrb	r3, [r7, #23]
 800d554:	441a      	add	r2, r3
 800d556:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 800d55a:	4413      	add	r3, r2
 800d55c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800d560:	d273      	bcs.n	800d64a <lv_txt_get_size+0x176>
            LV_LOG_WARN("lv_txt_get_size: integer overflow while calculating text height");
            return;
        } else {
            size_res->y += letter_height;
 800d562:	68fb      	ldr	r3, [r7, #12]
 800d564:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800d568:	b29a      	uxth	r2, r3
 800d56a:	7dfb      	ldrb	r3, [r7, #23]
 800d56c:	b29b      	uxth	r3, r3
 800d56e:	4413      	add	r3, r2
 800d570:	b29b      	uxth	r3, r3
 800d572:	b21a      	sxth	r2, r3
 800d574:	68fb      	ldr	r3, [r7, #12]
 800d576:	805a      	strh	r2, [r3, #2]
            size_res->y += line_space;
 800d578:	68fb      	ldr	r3, [r7, #12]
 800d57a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800d57e:	b29a      	uxth	r2, r3
 800d580:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800d582:	4413      	add	r3, r2
 800d584:	b29b      	uxth	r3, r3
 800d586:	b21a      	sxth	r2, r3
 800d588:	68fb      	ldr	r3, [r7, #12]
 800d58a:	805a      	strh	r2, [r3, #2]
        }

        /*Calculate the the longest line*/
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
 800d58c:	68ba      	ldr	r2, [r7, #8]
 800d58e:	69fb      	ldr	r3, [r7, #28]
 800d590:	18d0      	adds	r0, r2, r3
 800d592:	69bb      	ldr	r3, [r7, #24]
 800d594:	b29a      	uxth	r2, r3
 800d596:	69fb      	ldr	r3, [r7, #28]
 800d598:	b29b      	uxth	r3, r3
 800d59a:	1ad3      	subs	r3, r2, r3
 800d59c:	b299      	uxth	r1, r3
 800d59e:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 800d5a2:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800d5a6:	9300      	str	r3, [sp, #0]
 800d5a8:	4613      	mov	r3, r2
 800d5aa:	687a      	ldr	r2, [r7, #4]
 800d5ac:	f000 f9f4 	bl	800d998 <lv_txt_get_width>
 800d5b0:	4603      	mov	r3, r0
 800d5b2:	82bb      	strh	r3, [r7, #20]

        size_res->x = LV_MATH_MAX(act_line_length, size_res->x);
 800d5b4:	68fb      	ldr	r3, [r7, #12]
 800d5b6:	f9b3 3000 	ldrsh.w	r3, [r3]
 800d5ba:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 800d5be:	4293      	cmp	r3, r2
 800d5c0:	bfb8      	it	lt
 800d5c2:	4613      	movlt	r3, r2
 800d5c4:	b21a      	sxth	r2, r3
 800d5c6:	68fb      	ldr	r3, [r7, #12]
 800d5c8:	801a      	strh	r2, [r3, #0]
        line_start  = new_line_start;
 800d5ca:	69bb      	ldr	r3, [r7, #24]
 800d5cc:	61fb      	str	r3, [r7, #28]
    while(text[line_start] != '\0') {
 800d5ce:	68ba      	ldr	r2, [r7, #8]
 800d5d0:	69fb      	ldr	r3, [r7, #28]
 800d5d2:	4413      	add	r3, r2
 800d5d4:	781b      	ldrb	r3, [r3, #0]
 800d5d6:	2b00      	cmp	r3, #0
 800d5d8:	d1a4      	bne.n	800d524 <lv_txt_get_size+0x50>
    }

    /*Make the text one line taller if the last character is '\n' or '\r'*/
    if((line_start != 0) && (text[line_start - 1] == '\n' || text[line_start - 1] == '\r')) {
 800d5da:	69fb      	ldr	r3, [r7, #28]
 800d5dc:	2b00      	cmp	r3, #0
 800d5de:	d01b      	beq.n	800d618 <lv_txt_get_size+0x144>
 800d5e0:	69fb      	ldr	r3, [r7, #28]
 800d5e2:	3b01      	subs	r3, #1
 800d5e4:	68ba      	ldr	r2, [r7, #8]
 800d5e6:	4413      	add	r3, r2
 800d5e8:	781b      	ldrb	r3, [r3, #0]
 800d5ea:	2b0a      	cmp	r3, #10
 800d5ec:	d006      	beq.n	800d5fc <lv_txt_get_size+0x128>
 800d5ee:	69fb      	ldr	r3, [r7, #28]
 800d5f0:	3b01      	subs	r3, #1
 800d5f2:	68ba      	ldr	r2, [r7, #8]
 800d5f4:	4413      	add	r3, r2
 800d5f6:	781b      	ldrb	r3, [r3, #0]
 800d5f8:	2b0d      	cmp	r3, #13
 800d5fa:	d10d      	bne.n	800d618 <lv_txt_get_size+0x144>
        size_res->y += letter_height + line_space;
 800d5fc:	68fb      	ldr	r3, [r7, #12]
 800d5fe:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800d602:	b29a      	uxth	r2, r3
 800d604:	7dfb      	ldrb	r3, [r7, #23]
 800d606:	b299      	uxth	r1, r3
 800d608:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800d60a:	440b      	add	r3, r1
 800d60c:	b29b      	uxth	r3, r3
 800d60e:	4413      	add	r3, r2
 800d610:	b29b      	uxth	r3, r3
 800d612:	b21a      	sxth	r2, r3
 800d614:	68fb      	ldr	r3, [r7, #12]
 800d616:	805a      	strh	r2, [r3, #2]
    }

    /*Correction with the last line space or set the height manually if the text is empty*/
    if(size_res->y == 0)
 800d618:	68fb      	ldr	r3, [r7, #12]
 800d61a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800d61e:	2b00      	cmp	r3, #0
 800d620:	d104      	bne.n	800d62c <lv_txt_get_size+0x158>
        size_res->y = letter_height;
 800d622:	7dfb      	ldrb	r3, [r7, #23]
 800d624:	b21a      	sxth	r2, r3
 800d626:	68fb      	ldr	r3, [r7, #12]
 800d628:	805a      	strh	r2, [r3, #2]
 800d62a:	e00f      	b.n	800d64c <lv_txt_get_size+0x178>
    else
        size_res->y -= line_space;
 800d62c:	68fb      	ldr	r3, [r7, #12]
 800d62e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800d632:	b29a      	uxth	r2, r3
 800d634:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800d636:	1ad3      	subs	r3, r2, r3
 800d638:	b29b      	uxth	r3, r3
 800d63a:	b21a      	sxth	r2, r3
 800d63c:	68fb      	ldr	r3, [r7, #12]
 800d63e:	805a      	strh	r2, [r3, #2]
 800d640:	e004      	b.n	800d64c <lv_txt_get_size+0x178>
    if(text == NULL) return;
 800d642:	bf00      	nop
 800d644:	e002      	b.n	800d64c <lv_txt_get_size+0x178>
    if(font == NULL) return;
 800d646:	bf00      	nop
 800d648:	e000      	b.n	800d64c <lv_txt_get_size+0x178>
            return;
 800d64a:	bf00      	nop
}
 800d64c:	3720      	adds	r7, #32
 800d64e:	46bd      	mov	sp, r7
 800d650:	bd80      	pop	{r7, pc}
	...

0800d654 <lv_txt_get_next_word>:
 * @return the index of the first char of the next word (in byte index not letter index. With UTF-8 they are different)
 */
static uint16_t lv_txt_get_next_word(const char * txt, const lv_font_t * font,
                              lv_coord_t letter_space, lv_coord_t max_width,
                              lv_txt_flag_t flag, uint32_t *word_w_ptr, lv_txt_cmd_state_t * cmd_state, bool force)
{
 800d654:	b580      	push	{r7, lr}
 800d656:	b090      	sub	sp, #64	; 0x40
 800d658:	af00      	add	r7, sp, #0
 800d65a:	60f8      	str	r0, [r7, #12]
 800d65c:	60b9      	str	r1, [r7, #8]
 800d65e:	4611      	mov	r1, r2
 800d660:	461a      	mov	r2, r3
 800d662:	460b      	mov	r3, r1
 800d664:	80fb      	strh	r3, [r7, #6]
 800d666:	4613      	mov	r3, r2
 800d668:	80bb      	strh	r3, [r7, #4]
    if(txt == NULL || txt[0] == '\0') return 0;
 800d66a:	68fb      	ldr	r3, [r7, #12]
 800d66c:	2b00      	cmp	r3, #0
 800d66e:	d003      	beq.n	800d678 <lv_txt_get_next_word+0x24>
 800d670:	68fb      	ldr	r3, [r7, #12]
 800d672:	781b      	ldrb	r3, [r3, #0]
 800d674:	2b00      	cmp	r3, #0
 800d676:	d101      	bne.n	800d67c <lv_txt_get_next_word+0x28>
 800d678:	2300      	movs	r3, #0
 800d67a:	e0f3      	b.n	800d864 <lv_txt_get_next_word+0x210>
    if(font == NULL) return 0;
 800d67c:	68bb      	ldr	r3, [r7, #8]
 800d67e:	2b00      	cmp	r3, #0
 800d680:	d101      	bne.n	800d686 <lv_txt_get_next_word+0x32>
 800d682:	2300      	movs	r3, #0
 800d684:	e0ee      	b.n	800d864 <lv_txt_get_next_word+0x210>

    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 800d686:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 800d68a:	f003 0302 	and.w	r3, r3, #2
 800d68e:	2b00      	cmp	r3, #0
 800d690:	d002      	beq.n	800d698 <lv_txt_get_next_word+0x44>
 800d692:	f647 4318 	movw	r3, #31768	; 0x7c18
 800d696:	80bb      	strh	r3, [r7, #4]

    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
 800d698:	2300      	movs	r3, #0
 800d69a:	61fb      	str	r3, [r7, #28]
 800d69c:	2300      	movs	r3, #0
 800d69e:	61bb      	str	r3, [r7, #24]
 800d6a0:	2300      	movs	r3, #0
 800d6a2:	617b      	str	r3, [r7, #20]
    uint32_t letter = 0;      /* Letter at i */
 800d6a4:	2300      	movs	r3, #0
 800d6a6:	63fb      	str	r3, [r7, #60]	; 0x3c
    uint32_t letter_next = 0; /* Letter at i_next */
 800d6a8:	2300      	movs	r3, #0
 800d6aa:	63bb      	str	r3, [r7, #56]	; 0x38
    lv_coord_t letter_w;
    lv_coord_t cur_w = 0;  /* Pixel Width of transversed string */
 800d6ac:	2300      	movs	r3, #0
 800d6ae:	86fb      	strh	r3, [r7, #54]	; 0x36
    uint32_t word_len = 0;   /* Number of characters in the transversed word */
 800d6b0:	2300      	movs	r3, #0
 800d6b2:	633b      	str	r3, [r7, #48]	; 0x30
    uint32_t break_index = NO_BREAK_FOUND; /* only used for "long" words */
 800d6b4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800d6b8:	62fb      	str	r3, [r7, #44]	; 0x2c
    uint32_t break_letter_count = 0; /* Number of characters up to the long word break point */
 800d6ba:	2300      	movs	r3, #0
 800d6bc:	62bb      	str	r3, [r7, #40]	; 0x28

    letter = lv_txt_encoded_next(txt, &i_next);
 800d6be:	4b6b      	ldr	r3, [pc, #428]	; (800d86c <lv_txt_get_next_word+0x218>)
 800d6c0:	681b      	ldr	r3, [r3, #0]
 800d6c2:	f107 0218 	add.w	r2, r7, #24
 800d6c6:	4611      	mov	r1, r2
 800d6c8:	68f8      	ldr	r0, [r7, #12]
 800d6ca:	4798      	blx	r3
 800d6cc:	63f8      	str	r0, [r7, #60]	; 0x3c
    i_next_next = i_next;
 800d6ce:	69bb      	ldr	r3, [r7, #24]
 800d6d0:	617b      	str	r3, [r7, #20]

    /* Obtain the full word, regardless if it fits or not in max_width */
    while(txt[i] != '\0') {
 800d6d2:	e074      	b.n	800d7be <lv_txt_get_next_word+0x16a>
        letter_next = lv_txt_encoded_next(txt, &i_next_next);
 800d6d4:	4b65      	ldr	r3, [pc, #404]	; (800d86c <lv_txt_get_next_word+0x218>)
 800d6d6:	681b      	ldr	r3, [r3, #0]
 800d6d8:	f107 0214 	add.w	r2, r7, #20
 800d6dc:	4611      	mov	r1, r2
 800d6de:	68f8      	ldr	r0, [r7, #12]
 800d6e0:	4798      	blx	r3
 800d6e2:	63b8      	str	r0, [r7, #56]	; 0x38
        word_len++;
 800d6e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d6e6:	3301      	adds	r3, #1
 800d6e8:	633b      	str	r3, [r7, #48]	; 0x30

        /*Handle the recolor command*/
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 800d6ea:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 800d6ee:	f003 0301 	and.w	r3, r3, #1
 800d6f2:	2b00      	cmp	r3, #0
 800d6f4:	d00d      	beq.n	800d712 <lv_txt_get_next_word+0xbe>
            if(lv_txt_is_cmd(cmd_state, letter) != false) {
 800d6f6:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800d6f8:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800d6fa:	f000 f9b7 	bl	800da6c <lv_txt_is_cmd>
 800d6fe:	4603      	mov	r3, r0
 800d700:	2b00      	cmp	r3, #0
 800d702:	d006      	beq.n	800d712 <lv_txt_get_next_word+0xbe>
                i = i_next;
 800d704:	69bb      	ldr	r3, [r7, #24]
 800d706:	61fb      	str	r3, [r7, #28]
                i_next = i_next_next;
 800d708:	697b      	ldr	r3, [r7, #20]
 800d70a:	61bb      	str	r3, [r7, #24]
                letter = letter_next;
 800d70c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d70e:	63fb      	str	r3, [r7, #60]	; 0x3c
                continue;   /*Skip the letter is it is part of a command*/
 800d710:	e055      	b.n	800d7be <lv_txt_get_next_word+0x16a>
            }
        }

        letter_w = lv_font_get_glyph_width(font, letter, letter_next);
 800d712:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800d714:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800d716:	68b8      	ldr	r0, [r7, #8]
 800d718:	f7fd fa5c 	bl	800abd4 <lv_font_get_glyph_width>
 800d71c:	4603      	mov	r3, r0
 800d71e:	847b      	strh	r3, [r7, #34]	; 0x22
        cur_w += letter_w;
 800d720:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 800d722:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d724:	4413      	add	r3, r2
 800d726:	b29b      	uxth	r3, r3
 800d728:	86fb      	strh	r3, [r7, #54]	; 0x36

        if(letter_w > 0) {
 800d72a:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 800d72e:	2b00      	cmp	r3, #0
 800d730:	dd04      	ble.n	800d73c <lv_txt_get_next_word+0xe8>
            cur_w += letter_space;
 800d732:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 800d734:	88fb      	ldrh	r3, [r7, #6]
 800d736:	4413      	add	r3, r2
 800d738:	b29b      	uxth	r3, r3
 800d73a:	86fb      	strh	r3, [r7, #54]	; 0x36
        }

        /* Test if this character fits within max_width */
        if(break_index == NO_BREAK_FOUND && (cur_w - letter_space) > max_width) {
 800d73c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d73e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800d742:	d10d      	bne.n	800d760 <lv_txt_get_next_word+0x10c>
 800d744:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 800d748:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800d74c:	1ad2      	subs	r2, r2, r3
 800d74e:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 800d752:	429a      	cmp	r2, r3
 800d754:	dd04      	ble.n	800d760 <lv_txt_get_next_word+0x10c>
            break_index = i; 
 800d756:	69fb      	ldr	r3, [r7, #28]
 800d758:	62fb      	str	r3, [r7, #44]	; 0x2c
            break_letter_count = word_len - 1;
 800d75a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d75c:	3b01      	subs	r3, #1
 800d75e:	62bb      	str	r3, [r7, #40]	; 0x28
            /* break_index is now pointing at the character that doesn't fit */
        }

        /*Check for new line chars and breakchars*/
        if(letter == '\n' || letter == '\r' || is_break_char(letter)) {
 800d760:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d762:	2b0a      	cmp	r3, #10
 800d764:	d008      	beq.n	800d778 <lv_txt_get_next_word+0x124>
 800d766:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d768:	2b0d      	cmp	r3, #13
 800d76a:	d005      	beq.n	800d778 <lv_txt_get_next_word+0x124>
 800d76c:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800d76e:	f000 fba5 	bl	800debc <is_break_char>
 800d772:	4603      	mov	r3, r0
 800d774:	2b00      	cmp	r3, #0
 800d776:	d011      	beq.n	800d79c <lv_txt_get_next_word+0x148>
            /* Update the output width on the first character if it fits.
             * Must do this here incase first letter is a break character. */
            if(i == 0 && break_index == NO_BREAK_FOUND && word_w_ptr != NULL) *word_w_ptr = cur_w;
 800d778:	69fb      	ldr	r3, [r7, #28]
 800d77a:	2b00      	cmp	r3, #0
 800d77c:	d10a      	bne.n	800d794 <lv_txt_get_next_word+0x140>
 800d77e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d780:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800d784:	d106      	bne.n	800d794 <lv_txt_get_next_word+0x140>
 800d786:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d788:	2b00      	cmp	r3, #0
 800d78a:	d003      	beq.n	800d794 <lv_txt_get_next_word+0x140>
 800d78c:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 800d790:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d792:	601a      	str	r2, [r3, #0]
            word_len--;
 800d794:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d796:	3b01      	subs	r3, #1
 800d798:	633b      	str	r3, [r7, #48]	; 0x30
            break;
 800d79a:	e016      	b.n	800d7ca <lv_txt_get_next_word+0x176>
        }

        /* Update the output width */
        if( word_w_ptr != NULL && break_index == NO_BREAK_FOUND ) *word_w_ptr = cur_w;
 800d79c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d79e:	2b00      	cmp	r3, #0
 800d7a0:	d007      	beq.n	800d7b2 <lv_txt_get_next_word+0x15e>
 800d7a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d7a4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800d7a8:	d103      	bne.n	800d7b2 <lv_txt_get_next_word+0x15e>
 800d7aa:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 800d7ae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d7b0:	601a      	str	r2, [r3, #0]


        i = i_next;
 800d7b2:	69bb      	ldr	r3, [r7, #24]
 800d7b4:	61fb      	str	r3, [r7, #28]
        i_next = i_next_next;
 800d7b6:	697b      	ldr	r3, [r7, #20]
 800d7b8:	61bb      	str	r3, [r7, #24]
        letter = letter_next;
 800d7ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d7bc:	63fb      	str	r3, [r7, #60]	; 0x3c
    while(txt[i] != '\0') {
 800d7be:	69fb      	ldr	r3, [r7, #28]
 800d7c0:	68fa      	ldr	r2, [r7, #12]
 800d7c2:	4413      	add	r3, r2
 800d7c4:	781b      	ldrb	r3, [r3, #0]
 800d7c6:	2b00      	cmp	r3, #0
 800d7c8:	d184      	bne.n	800d6d4 <lv_txt_get_next_word+0x80>
    }

    /* Entire Word fits in the provided space */
    if( break_index == NO_BREAK_FOUND ) {
 800d7ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d7cc:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800d7d0:	d10d      	bne.n	800d7ee <lv_txt_get_next_word+0x19a>
        if( word_len == 0 || (letter == '\r' && letter_next == '\n') ) i = i_next;
 800d7d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d7d4:	2b00      	cmp	r3, #0
 800d7d6:	d005      	beq.n	800d7e4 <lv_txt_get_next_word+0x190>
 800d7d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d7da:	2b0d      	cmp	r3, #13
 800d7dc:	d104      	bne.n	800d7e8 <lv_txt_get_next_word+0x194>
 800d7de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d7e0:	2b0a      	cmp	r3, #10
 800d7e2:	d101      	bne.n	800d7e8 <lv_txt_get_next_word+0x194>
 800d7e4:	69bb      	ldr	r3, [r7, #24]
 800d7e6:	61fb      	str	r3, [r7, #28]
        return i;
 800d7e8:	69fb      	ldr	r3, [r7, #28]
 800d7ea:	b29b      	uxth	r3, r3
 800d7ec:	e03a      	b.n	800d864 <lv_txt_get_next_word+0x210>
    }

#if LV_TXT_LINE_BREAK_LONG_LEN > 0
    /* Word doesn't fit in provided space, but isn't "long" */
    if(word_len < LV_TXT_LINE_BREAK_LONG_LEN) {
 800d7ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d7f0:	2b0b      	cmp	r3, #11
 800d7f2:	d80e      	bhi.n	800d812 <lv_txt_get_next_word+0x1be>
        if( force ) return break_index;
 800d7f4:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 800d7f8:	2b00      	cmp	r3, #0
 800d7fa:	d002      	beq.n	800d802 <lv_txt_get_next_word+0x1ae>
 800d7fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d7fe:	b29b      	uxth	r3, r3
 800d800:	e030      	b.n	800d864 <lv_txt_get_next_word+0x210>
        if(word_w_ptr != NULL) *word_w_ptr = 0; /* Return no word */
 800d802:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d804:	2b00      	cmp	r3, #0
 800d806:	d002      	beq.n	800d80e <lv_txt_get_next_word+0x1ba>
 800d808:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d80a:	2200      	movs	r2, #0
 800d80c:	601a      	str	r2, [r3, #0]
        return 0;
 800d80e:	2300      	movs	r3, #0
 800d810:	e028      	b.n	800d864 <lv_txt_get_next_word+0x210>
    }

    /* Word is "long," but insufficient amounts can fit in provided space */
    if(break_letter_count < LV_TXT_LINE_BREAK_LONG_PRE_MIN_LEN) {
 800d812:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d814:	2b02      	cmp	r3, #2
 800d816:	d80e      	bhi.n	800d836 <lv_txt_get_next_word+0x1e2>
        if( force ) return break_index;
 800d818:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 800d81c:	2b00      	cmp	r3, #0
 800d81e:	d002      	beq.n	800d826 <lv_txt_get_next_word+0x1d2>
 800d820:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d822:	b29b      	uxth	r3, r3
 800d824:	e01e      	b.n	800d864 <lv_txt_get_next_word+0x210>
        if(word_w_ptr != NULL) *word_w_ptr = 0;
 800d826:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d828:	2b00      	cmp	r3, #0
 800d82a:	d002      	beq.n	800d832 <lv_txt_get_next_word+0x1de>
 800d82c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d82e:	2200      	movs	r2, #0
 800d830:	601a      	str	r2, [r3, #0]
        return 0;
 800d832:	2300      	movs	r3, #0
 800d834:	e016      	b.n	800d864 <lv_txt_get_next_word+0x210>
    }

    /* Word is a "long", but letters may need to be better distributed */
    {
        i = break_index;
 800d836:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d838:	61fb      	str	r3, [r7, #28]
        int32_t n_move = LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN - (word_len - break_letter_count);
 800d83a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d83c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d83e:	1ad3      	subs	r3, r2, r3
 800d840:	3303      	adds	r3, #3
 800d842:	627b      	str	r3, [r7, #36]	; 0x24
        /* Move pointer "i" backwards */
        for(;n_move>0; n_move--){
 800d844:	e009      	b.n	800d85a <lv_txt_get_next_word+0x206>
            lv_txt_encoded_prev(txt, &i);
 800d846:	4b0a      	ldr	r3, [pc, #40]	; (800d870 <lv_txt_get_next_word+0x21c>)
 800d848:	681b      	ldr	r3, [r3, #0]
 800d84a:	f107 021c 	add.w	r2, r7, #28
 800d84e:	4611      	mov	r1, r2
 800d850:	68f8      	ldr	r0, [r7, #12]
 800d852:	4798      	blx	r3
        for(;n_move>0; n_move--){
 800d854:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d856:	3b01      	subs	r3, #1
 800d858:	627b      	str	r3, [r7, #36]	; 0x24
 800d85a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d85c:	2b00      	cmp	r3, #0
 800d85e:	dcf2      	bgt.n	800d846 <lv_txt_get_next_word+0x1f2>
            // TODO: it would be appropriate to update the returned word width here
            // However, in current usage, this doesn't impact anything.
        }
    }
    return i;
 800d860:	69fb      	ldr	r3, [r7, #28]
 800d862:	b29b      	uxth	r3, r3
    if( force ) return break_index;
    if(word_w_ptr != NULL) *word_w_ptr = 0; /* Return no word */
    (void) break_letter_count;
    return 0;
#endif
}
 800d864:	4618      	mov	r0, r3
 800d866:	3740      	adds	r7, #64	; 0x40
 800d868:	46bd      	mov	sp, r7
 800d86a:	bd80      	pop	{r7, pc}
 800d86c:	20000054 	.word	0x20000054
 800d870:	20000058 	.word	0x20000058

0800d874 <lv_txt_get_next_line>:
 * @param flags settings for the text from 'txt_flag_type' enum
 * @return the index of the first char of the new line (in byte index not letter index. With UTF-8 they are different)
 */
uint16_t lv_txt_get_next_line(const char * txt, const lv_font_t * font,
                              lv_coord_t letter_space, lv_coord_t max_width, lv_txt_flag_t flag)
{
 800d874:	b580      	push	{r7, lr}
 800d876:	b08c      	sub	sp, #48	; 0x30
 800d878:	af04      	add	r7, sp, #16
 800d87a:	60f8      	str	r0, [r7, #12]
 800d87c:	60b9      	str	r1, [r7, #8]
 800d87e:	4611      	mov	r1, r2
 800d880:	461a      	mov	r2, r3
 800d882:	460b      	mov	r3, r1
 800d884:	80fb      	strh	r3, [r7, #6]
 800d886:	4613      	mov	r3, r2
 800d888:	80bb      	strh	r3, [r7, #4]
    if(txt == NULL) return 0;
 800d88a:	68fb      	ldr	r3, [r7, #12]
 800d88c:	2b00      	cmp	r3, #0
 800d88e:	d101      	bne.n	800d894 <lv_txt_get_next_line+0x20>
 800d890:	2300      	movs	r3, #0
 800d892:	e07a      	b.n	800d98a <lv_txt_get_next_line+0x116>
    if(font == NULL) return 0;
 800d894:	68bb      	ldr	r3, [r7, #8]
 800d896:	2b00      	cmp	r3, #0
 800d898:	d101      	bne.n	800d89e <lv_txt_get_next_line+0x2a>
 800d89a:	2300      	movs	r3, #0
 800d89c:	e075      	b.n	800d98a <lv_txt_get_next_line+0x116>

    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 800d89e:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800d8a2:	f003 0302 	and.w	r3, r3, #2
 800d8a6:	2b00      	cmp	r3, #0
 800d8a8:	d002      	beq.n	800d8b0 <lv_txt_get_next_line+0x3c>
 800d8aa:	f647 4318 	movw	r3, #31768	; 0x7c18
 800d8ae:	80bb      	strh	r3, [r7, #4]
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 800d8b0:	2300      	movs	r3, #0
 800d8b2:	76fb      	strb	r3, [r7, #27]
    uint32_t i = 0;                                        /* Iterating index into txt */
 800d8b4:	2300      	movs	r3, #0
 800d8b6:	617b      	str	r3, [r7, #20]

    while(txt[i] != '\0' && max_width > 0) {
 800d8b8:	e04f      	b.n	800d95a <lv_txt_get_next_line+0xe6>
        uint32_t word_w = 0;
 800d8ba:	2300      	movs	r3, #0
 800d8bc:	613b      	str	r3, [r7, #16]
        uint32_t advance = lv_txt_get_next_word(&txt[i], font, letter_space, max_width, flag, &word_w, &cmd_state, i==0);
 800d8be:	697b      	ldr	r3, [r7, #20]
 800d8c0:	68fa      	ldr	r2, [r7, #12]
 800d8c2:	18d0      	adds	r0, r2, r3
 800d8c4:	697b      	ldr	r3, [r7, #20]
 800d8c6:	2b00      	cmp	r3, #0
 800d8c8:	bf0c      	ite	eq
 800d8ca:	2301      	moveq	r3, #1
 800d8cc:	2300      	movne	r3, #0
 800d8ce:	b2db      	uxtb	r3, r3
 800d8d0:	f9b7 1004 	ldrsh.w	r1, [r7, #4]
 800d8d4:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 800d8d8:	9303      	str	r3, [sp, #12]
 800d8da:	f107 031b 	add.w	r3, r7, #27
 800d8de:	9302      	str	r3, [sp, #8]
 800d8e0:	f107 0310 	add.w	r3, r7, #16
 800d8e4:	9301      	str	r3, [sp, #4]
 800d8e6:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800d8ea:	9300      	str	r3, [sp, #0]
 800d8ec:	460b      	mov	r3, r1
 800d8ee:	68b9      	ldr	r1, [r7, #8]
 800d8f0:	f7ff feb0 	bl	800d654 <lv_txt_get_next_word>
 800d8f4:	4603      	mov	r3, r0
 800d8f6:	61fb      	str	r3, [r7, #28]
        max_width -= word_w;
 800d8f8:	88ba      	ldrh	r2, [r7, #4]
 800d8fa:	693b      	ldr	r3, [r7, #16]
 800d8fc:	b29b      	uxth	r3, r3
 800d8fe:	1ad3      	subs	r3, r2, r3
 800d900:	b29b      	uxth	r3, r3
 800d902:	80bb      	strh	r3, [r7, #4]

        if( advance == 0 ){
 800d904:	69fb      	ldr	r3, [r7, #28]
 800d906:	2b00      	cmp	r3, #0
 800d908:	d10a      	bne.n	800d920 <lv_txt_get_next_line+0xac>
            if(i == 0) lv_txt_encoded_next(txt, &i); // prevent inf loops
 800d90a:	697b      	ldr	r3, [r7, #20]
 800d90c:	2b00      	cmp	r3, #0
 800d90e:	d12f      	bne.n	800d970 <lv_txt_get_next_line+0xfc>
 800d910:	4b20      	ldr	r3, [pc, #128]	; (800d994 <lv_txt_get_next_line+0x120>)
 800d912:	681b      	ldr	r3, [r3, #0]
 800d914:	f107 0214 	add.w	r2, r7, #20
 800d918:	4611      	mov	r1, r2
 800d91a:	68f8      	ldr	r0, [r7, #12]
 800d91c:	4798      	blx	r3
            break;
 800d91e:	e027      	b.n	800d970 <lv_txt_get_next_line+0xfc>
        }

        i += advance;
 800d920:	697a      	ldr	r2, [r7, #20]
 800d922:	69fb      	ldr	r3, [r7, #28]
 800d924:	4413      	add	r3, r2
 800d926:	617b      	str	r3, [r7, #20]

        if(txt[0] == '\n' || txt[0] == '\r') break;
 800d928:	68fb      	ldr	r3, [r7, #12]
 800d92a:	781b      	ldrb	r3, [r3, #0]
 800d92c:	2b0a      	cmp	r3, #10
 800d92e:	d01f      	beq.n	800d970 <lv_txt_get_next_line+0xfc>
 800d930:	68fb      	ldr	r3, [r7, #12]
 800d932:	781b      	ldrb	r3, [r3, #0]
 800d934:	2b0d      	cmp	r3, #13
 800d936:	d01b      	beq.n	800d970 <lv_txt_get_next_line+0xfc>

        if(txt[i] == '\n' || txt[i] == '\r'){
 800d938:	697b      	ldr	r3, [r7, #20]
 800d93a:	68fa      	ldr	r2, [r7, #12]
 800d93c:	4413      	add	r3, r2
 800d93e:	781b      	ldrb	r3, [r3, #0]
 800d940:	2b0a      	cmp	r3, #10
 800d942:	d005      	beq.n	800d950 <lv_txt_get_next_line+0xdc>
 800d944:	697b      	ldr	r3, [r7, #20]
 800d946:	68fa      	ldr	r2, [r7, #12]
 800d948:	4413      	add	r3, r2
 800d94a:	781b      	ldrb	r3, [r3, #0]
 800d94c:	2b0d      	cmp	r3, #13
 800d94e:	d104      	bne.n	800d95a <lv_txt_get_next_line+0xe6>
            i++;  /* Include the following newline in the current line */
 800d950:	697b      	ldr	r3, [r7, #20]
 800d952:	3301      	adds	r3, #1
 800d954:	617b      	str	r3, [r7, #20]
            break;
 800d956:	bf00      	nop
 800d958:	e00b      	b.n	800d972 <lv_txt_get_next_line+0xfe>
    while(txt[i] != '\0' && max_width > 0) {
 800d95a:	697b      	ldr	r3, [r7, #20]
 800d95c:	68fa      	ldr	r2, [r7, #12]
 800d95e:	4413      	add	r3, r2
 800d960:	781b      	ldrb	r3, [r3, #0]
 800d962:	2b00      	cmp	r3, #0
 800d964:	d005      	beq.n	800d972 <lv_txt_get_next_line+0xfe>
 800d966:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 800d96a:	2b00      	cmp	r3, #0
 800d96c:	dca5      	bgt.n	800d8ba <lv_txt_get_next_line+0x46>
 800d96e:	e000      	b.n	800d972 <lv_txt_get_next_line+0xfe>
            break;
 800d970:	bf00      	nop
        }

    }

    /* Always step at least one to avoid infinite loops */
    if(i == 0) {
 800d972:	697b      	ldr	r3, [r7, #20]
 800d974:	2b00      	cmp	r3, #0
 800d976:	d106      	bne.n	800d986 <lv_txt_get_next_line+0x112>
        lv_txt_encoded_next(txt, &i);
 800d978:	4b06      	ldr	r3, [pc, #24]	; (800d994 <lv_txt_get_next_line+0x120>)
 800d97a:	681b      	ldr	r3, [r3, #0]
 800d97c:	f107 0214 	add.w	r2, r7, #20
 800d980:	4611      	mov	r1, r2
 800d982:	68f8      	ldr	r0, [r7, #12]
 800d984:	4798      	blx	r3
    }

    return i;
 800d986:	697b      	ldr	r3, [r7, #20]
 800d988:	b29b      	uxth	r3, r3
}
 800d98a:	4618      	mov	r0, r3
 800d98c:	3720      	adds	r7, #32
 800d98e:	46bd      	mov	sp, r7
 800d990:	bd80      	pop	{r7, pc}
 800d992:	bf00      	nop
 800d994:	20000054 	.word	0x20000054

0800d998 <lv_txt_get_width>:
 * @param flags settings for the text from 'txt_flag_t' enum
 * @return length of a char_num long text
 */
lv_coord_t lv_txt_get_width(const char * txt, uint16_t length, const lv_font_t * font, lv_coord_t letter_space,
                            lv_txt_flag_t flag)
{
 800d998:	b580      	push	{r7, lr}
 800d99a:	b08a      	sub	sp, #40	; 0x28
 800d99c:	af00      	add	r7, sp, #0
 800d99e:	60f8      	str	r0, [r7, #12]
 800d9a0:	607a      	str	r2, [r7, #4]
 800d9a2:	461a      	mov	r2, r3
 800d9a4:	460b      	mov	r3, r1
 800d9a6:	817b      	strh	r3, [r7, #10]
 800d9a8:	4613      	mov	r3, r2
 800d9aa:	813b      	strh	r3, [r7, #8]
    if(txt == NULL) return 0;
 800d9ac:	68fb      	ldr	r3, [r7, #12]
 800d9ae:	2b00      	cmp	r3, #0
 800d9b0:	d101      	bne.n	800d9b6 <lv_txt_get_width+0x1e>
 800d9b2:	2300      	movs	r3, #0
 800d9b4:	e053      	b.n	800da5e <lv_txt_get_width+0xc6>
    if(font == NULL) return 0;
 800d9b6:	687b      	ldr	r3, [r7, #4]
 800d9b8:	2b00      	cmp	r3, #0
 800d9ba:	d101      	bne.n	800d9c0 <lv_txt_get_width+0x28>
 800d9bc:	2300      	movs	r3, #0
 800d9be:	e04e      	b.n	800da5e <lv_txt_get_width+0xc6>

    uint32_t i                   = 0;
 800d9c0:	2300      	movs	r3, #0
 800d9c2:	617b      	str	r3, [r7, #20]
    lv_coord_t width             = 0;
 800d9c4:	2300      	movs	r3, #0
 800d9c6:	84fb      	strh	r3, [r7, #38]	; 0x26
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 800d9c8:	2300      	movs	r3, #0
 800d9ca:	74fb      	strb	r3, [r7, #19]
    uint32_t letter;
    uint32_t letter_next;

    if(length != 0) {
 800d9cc:	897b      	ldrh	r3, [r7, #10]
 800d9ce:	2b00      	cmp	r3, #0
 800d9d0:	d043      	beq.n	800da5a <lv_txt_get_width+0xc2>
        while(i < length) {
 800d9d2:	e035      	b.n	800da40 <lv_txt_get_width+0xa8>
            letter      = lv_txt_encoded_next(txt, &i);
 800d9d4:	4b24      	ldr	r3, [pc, #144]	; (800da68 <lv_txt_get_width+0xd0>)
 800d9d6:	681b      	ldr	r3, [r3, #0]
 800d9d8:	f107 0214 	add.w	r2, r7, #20
 800d9dc:	4611      	mov	r1, r2
 800d9de:	68f8      	ldr	r0, [r7, #12]
 800d9e0:	4798      	blx	r3
 800d9e2:	6238      	str	r0, [r7, #32]
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
 800d9e4:	4b20      	ldr	r3, [pc, #128]	; (800da68 <lv_txt_get_width+0xd0>)
 800d9e6:	681b      	ldr	r3, [r3, #0]
 800d9e8:	697a      	ldr	r2, [r7, #20]
 800d9ea:	68f9      	ldr	r1, [r7, #12]
 800d9ec:	440a      	add	r2, r1
 800d9ee:	2100      	movs	r1, #0
 800d9f0:	4610      	mov	r0, r2
 800d9f2:	4798      	blx	r3
 800d9f4:	61f8      	str	r0, [r7, #28]
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 800d9f6:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800d9fa:	f003 0301 	and.w	r3, r3, #1
 800d9fe:	2b00      	cmp	r3, #0
 800da00:	d009      	beq.n	800da16 <lv_txt_get_width+0x7e>
                if(lv_txt_is_cmd(&cmd_state, letter) != false) {
 800da02:	f107 0313 	add.w	r3, r7, #19
 800da06:	6a39      	ldr	r1, [r7, #32]
 800da08:	4618      	mov	r0, r3
 800da0a:	f000 f82f 	bl	800da6c <lv_txt_is_cmd>
 800da0e:	4603      	mov	r3, r0
 800da10:	2b00      	cmp	r3, #0
 800da12:	d000      	beq.n	800da16 <lv_txt_get_width+0x7e>
                    continue;
 800da14:	e014      	b.n	800da40 <lv_txt_get_width+0xa8>
                }
            }

            lv_coord_t char_width = lv_font_get_glyph_width(font, letter, letter_next);
 800da16:	69fa      	ldr	r2, [r7, #28]
 800da18:	6a39      	ldr	r1, [r7, #32]
 800da1a:	6878      	ldr	r0, [r7, #4]
 800da1c:	f7fd f8da 	bl	800abd4 <lv_font_get_glyph_width>
 800da20:	4603      	mov	r3, r0
 800da22:	837b      	strh	r3, [r7, #26]
            if(char_width > 0) {
 800da24:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800da28:	2b00      	cmp	r3, #0
 800da2a:	dd09      	ble.n	800da40 <lv_txt_get_width+0xa8>
                width += char_width;
 800da2c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800da2e:	8b7b      	ldrh	r3, [r7, #26]
 800da30:	4413      	add	r3, r2
 800da32:	b29b      	uxth	r3, r3
 800da34:	84fb      	strh	r3, [r7, #38]	; 0x26
                width += letter_space;
 800da36:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800da38:	893b      	ldrh	r3, [r7, #8]
 800da3a:	4413      	add	r3, r2
 800da3c:	b29b      	uxth	r3, r3
 800da3e:	84fb      	strh	r3, [r7, #38]	; 0x26
        while(i < length) {
 800da40:	897a      	ldrh	r2, [r7, #10]
 800da42:	697b      	ldr	r3, [r7, #20]
 800da44:	429a      	cmp	r2, r3
 800da46:	d8c5      	bhi.n	800d9d4 <lv_txt_get_width+0x3c>
            }
        }

        if(width > 0) {
 800da48:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 800da4c:	2b00      	cmp	r3, #0
 800da4e:	dd04      	ble.n	800da5a <lv_txt_get_width+0xc2>
            width -= letter_space; /*Trim the last letter space. Important if the text is center
 800da50:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800da52:	893b      	ldrh	r3, [r7, #8]
 800da54:	1ad3      	subs	r3, r2, r3
 800da56:	b29b      	uxth	r3, r3
 800da58:	84fb      	strh	r3, [r7, #38]	; 0x26
                                      aligned */
        }
    }

    return width;
 800da5a:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
}
 800da5e:	4618      	mov	r0, r3
 800da60:	3728      	adds	r7, #40	; 0x28
 800da62:	46bd      	mov	sp, r7
 800da64:	bd80      	pop	{r7, pc}
 800da66:	bf00      	nop
 800da68:	20000054 	.word	0x20000054

0800da6c <lv_txt_is_cmd>:
 * @param c the current character
 * @return true: the character is part of a command and should not be written,
 *         false: the character should be written
 */
bool lv_txt_is_cmd(lv_txt_cmd_state_t * state, uint32_t c)
{
 800da6c:	b480      	push	{r7}
 800da6e:	b085      	sub	sp, #20
 800da70:	af00      	add	r7, sp, #0
 800da72:	6078      	str	r0, [r7, #4]
 800da74:	6039      	str	r1, [r7, #0]
    bool ret = false;
 800da76:	2300      	movs	r3, #0
 800da78:	73fb      	strb	r3, [r7, #15]

    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
 800da7a:	2323      	movs	r3, #35	; 0x23
 800da7c:	461a      	mov	r2, r3
 800da7e:	683b      	ldr	r3, [r7, #0]
 800da80:	4293      	cmp	r3, r2
 800da82:	d11a      	bne.n	800daba <lv_txt_is_cmd+0x4e>
        if(*state == LV_TXT_CMD_STATE_WAIT) { /*Start char*/
 800da84:	687b      	ldr	r3, [r7, #4]
 800da86:	781b      	ldrb	r3, [r3, #0]
 800da88:	2b00      	cmp	r3, #0
 800da8a:	d105      	bne.n	800da98 <lv_txt_is_cmd+0x2c>
            *state = LV_TXT_CMD_STATE_PAR;
 800da8c:	687b      	ldr	r3, [r7, #4]
 800da8e:	2201      	movs	r2, #1
 800da90:	701a      	strb	r2, [r3, #0]
            ret    = true;
 800da92:	2301      	movs	r3, #1
 800da94:	73fb      	strb	r3, [r7, #15]
 800da96:	e010      	b.n	800daba <lv_txt_is_cmd+0x4e>
        }
        /*Other start char in parameter is escaped cmd. char */
        else if(*state == LV_TXT_CMD_STATE_PAR) {
 800da98:	687b      	ldr	r3, [r7, #4]
 800da9a:	781b      	ldrb	r3, [r3, #0]
 800da9c:	2b01      	cmp	r3, #1
 800da9e:	d103      	bne.n	800daa8 <lv_txt_is_cmd+0x3c>
            *state = LV_TXT_CMD_STATE_WAIT;
 800daa0:	687b      	ldr	r3, [r7, #4]
 800daa2:	2200      	movs	r2, #0
 800daa4:	701a      	strb	r2, [r3, #0]
 800daa6:	e008      	b.n	800daba <lv_txt_is_cmd+0x4e>
        }
        /*Command end */
        else if(*state == LV_TXT_CMD_STATE_IN) {
 800daa8:	687b      	ldr	r3, [r7, #4]
 800daaa:	781b      	ldrb	r3, [r3, #0]
 800daac:	2b02      	cmp	r3, #2
 800daae:	d104      	bne.n	800daba <lv_txt_is_cmd+0x4e>
            *state = LV_TXT_CMD_STATE_WAIT;
 800dab0:	687b      	ldr	r3, [r7, #4]
 800dab2:	2200      	movs	r2, #0
 800dab4:	701a      	strb	r2, [r3, #0]
            ret    = true;
 800dab6:	2301      	movs	r3, #1
 800dab8:	73fb      	strb	r3, [r7, #15]
        }
    }

    /*Skip the color parameter and wait the space after it*/
    if(*state == LV_TXT_CMD_STATE_PAR) {
 800daba:	687b      	ldr	r3, [r7, #4]
 800dabc:	781b      	ldrb	r3, [r3, #0]
 800dabe:	2b01      	cmp	r3, #1
 800dac0:	d107      	bne.n	800dad2 <lv_txt_is_cmd+0x66>
        if(c == ' ') {
 800dac2:	683b      	ldr	r3, [r7, #0]
 800dac4:	2b20      	cmp	r3, #32
 800dac6:	d102      	bne.n	800dace <lv_txt_is_cmd+0x62>
            *state = LV_TXT_CMD_STATE_IN; /*After the parameter the text is in the command*/
 800dac8:	687b      	ldr	r3, [r7, #4]
 800daca:	2202      	movs	r2, #2
 800dacc:	701a      	strb	r2, [r3, #0]
        }
        ret = true;
 800dace:	2301      	movs	r3, #1
 800dad0:	73fb      	strb	r3, [r7, #15]
    }

    return ret;
 800dad2:	7bfb      	ldrb	r3, [r7, #15]
}
 800dad4:	4618      	mov	r0, r3
 800dad6:	3714      	adds	r7, #20
 800dad8:	46bd      	mov	sp, r7
 800dada:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dade:	4770      	bx	lr

0800dae0 <lv_txt_utf8_size>:
 * Give the size of an UTF-8 coded character
 * @param str pointer to a character in a string
 * @return length of the UTF-8 character (1,2,3 or 4). O on invalid code
 */
static uint8_t lv_txt_utf8_size(const char * str)
{
 800dae0:	b480      	push	{r7}
 800dae2:	b083      	sub	sp, #12
 800dae4:	af00      	add	r7, sp, #0
 800dae6:	6078      	str	r0, [r7, #4]
    if((str[0] & 0x80) == 0)
 800dae8:	687b      	ldr	r3, [r7, #4]
 800daea:	781b      	ldrb	r3, [r3, #0]
 800daec:	b25b      	sxtb	r3, r3
 800daee:	2b00      	cmp	r3, #0
 800daf0:	db01      	blt.n	800daf6 <lv_txt_utf8_size+0x16>
        return 1;
 800daf2:	2301      	movs	r3, #1
 800daf4:	e018      	b.n	800db28 <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xE0) == 0xC0)
 800daf6:	687b      	ldr	r3, [r7, #4]
 800daf8:	781b      	ldrb	r3, [r3, #0]
 800dafa:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 800dafe:	2bc0      	cmp	r3, #192	; 0xc0
 800db00:	d101      	bne.n	800db06 <lv_txt_utf8_size+0x26>
        return 2;
 800db02:	2302      	movs	r3, #2
 800db04:	e010      	b.n	800db28 <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xF0) == 0xE0)
 800db06:	687b      	ldr	r3, [r7, #4]
 800db08:	781b      	ldrb	r3, [r3, #0]
 800db0a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800db0e:	2be0      	cmp	r3, #224	; 0xe0
 800db10:	d101      	bne.n	800db16 <lv_txt_utf8_size+0x36>
        return 3;
 800db12:	2303      	movs	r3, #3
 800db14:	e008      	b.n	800db28 <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xF8) == 0xF0)
 800db16:	687b      	ldr	r3, [r7, #4]
 800db18:	781b      	ldrb	r3, [r3, #0]
 800db1a:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
 800db1e:	2bf0      	cmp	r3, #240	; 0xf0
 800db20:	d101      	bne.n	800db26 <lv_txt_utf8_size+0x46>
        return 4;
 800db22:	2304      	movs	r3, #4
 800db24:	e000      	b.n	800db28 <lv_txt_utf8_size+0x48>
    return 0; /*If the char was invalid tell it's 1 byte long*/
 800db26:	2300      	movs	r3, #0
}
 800db28:	4618      	mov	r0, r3
 800db2a:	370c      	adds	r7, #12
 800db2c:	46bd      	mov	sp, r7
 800db2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db32:	4770      	bx	lr

0800db34 <lv_txt_utf8_next>:
 *          After call it will point to the next UTF-8 char in 'txt'.
 *          NULL to use txt[0] as index
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_txt_utf8_next(const char * txt, uint32_t * i)
{
 800db34:	b480      	push	{r7}
 800db36:	b085      	sub	sp, #20
 800db38:	af00      	add	r7, sp, #0
 800db3a:	6078      	str	r0, [r7, #4]
 800db3c:	6039      	str	r1, [r7, #0]
     * 00000000 00000000 00000yyy yyxxxxxx -> 110yyyyy 10xxxxxx
     * 00000000 00000000 zzzzyyyy yyxxxxxx -> 1110zzzz 10yyyyyy 10xxxxxx
     * 00000000 000wwwzz zzzzyyyy yyxxxxxx -> 11110www 10zzzzzz 10yyyyyy 10xxxxxx
     * */

    uint32_t result = 0;
 800db3e:	2300      	movs	r3, #0
 800db40:	60fb      	str	r3, [r7, #12]

    /*Dummy 'i' pointer is required*/
    uint32_t i_tmp = 0;
 800db42:	2300      	movs	r3, #0
 800db44:	60bb      	str	r3, [r7, #8]
    if(i == NULL) i = &i_tmp;
 800db46:	683b      	ldr	r3, [r7, #0]
 800db48:	2b00      	cmp	r3, #0
 800db4a:	d102      	bne.n	800db52 <lv_txt_utf8_next+0x1e>
 800db4c:	f107 0308 	add.w	r3, r7, #8
 800db50:	603b      	str	r3, [r7, #0]

    /*Normal ASCII*/
    if((txt[*i] & 0x80) == 0) {
 800db52:	683b      	ldr	r3, [r7, #0]
 800db54:	681b      	ldr	r3, [r3, #0]
 800db56:	687a      	ldr	r2, [r7, #4]
 800db58:	4413      	add	r3, r2
 800db5a:	781b      	ldrb	r3, [r3, #0]
 800db5c:	b25b      	sxtb	r3, r3
 800db5e:	2b00      	cmp	r3, #0
 800db60:	db0b      	blt.n	800db7a <lv_txt_utf8_next+0x46>
        result = txt[*i];
 800db62:	683b      	ldr	r3, [r7, #0]
 800db64:	681b      	ldr	r3, [r3, #0]
 800db66:	687a      	ldr	r2, [r7, #4]
 800db68:	4413      	add	r3, r2
 800db6a:	781b      	ldrb	r3, [r3, #0]
 800db6c:	60fb      	str	r3, [r7, #12]
        (*i)++;
 800db6e:	683b      	ldr	r3, [r7, #0]
 800db70:	681b      	ldr	r3, [r3, #0]
 800db72:	1c5a      	adds	r2, r3, #1
 800db74:	683b      	ldr	r3, [r7, #0]
 800db76:	601a      	str	r2, [r3, #0]
 800db78:	e0ea      	b.n	800dd50 <lv_txt_utf8_next+0x21c>
    }
    /*Real UTF-8 decode*/
    else {
        /*2 bytes UTF-8 code*/
        if((txt[*i] & 0xE0) == 0xC0) {
 800db7a:	683b      	ldr	r3, [r7, #0]
 800db7c:	681b      	ldr	r3, [r3, #0]
 800db7e:	687a      	ldr	r2, [r7, #4]
 800db80:	4413      	add	r3, r2
 800db82:	781b      	ldrb	r3, [r3, #0]
 800db84:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 800db88:	2bc0      	cmp	r3, #192	; 0xc0
 800db8a:	d128      	bne.n	800dbde <lv_txt_utf8_next+0xaa>
            result = (uint32_t)(txt[*i] & 0x1F) << 6;
 800db8c:	683b      	ldr	r3, [r7, #0]
 800db8e:	681b      	ldr	r3, [r3, #0]
 800db90:	687a      	ldr	r2, [r7, #4]
 800db92:	4413      	add	r3, r2
 800db94:	781b      	ldrb	r3, [r3, #0]
 800db96:	019b      	lsls	r3, r3, #6
 800db98:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 800db9c:	60fb      	str	r3, [r7, #12]
            (*i)++;
 800db9e:	683b      	ldr	r3, [r7, #0]
 800dba0:	681b      	ldr	r3, [r3, #0]
 800dba2:	1c5a      	adds	r2, r3, #1
 800dba4:	683b      	ldr	r3, [r7, #0]
 800dba6:	601a      	str	r2, [r3, #0]
            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 800dba8:	683b      	ldr	r3, [r7, #0]
 800dbaa:	681b      	ldr	r3, [r3, #0]
 800dbac:	687a      	ldr	r2, [r7, #4]
 800dbae:	4413      	add	r3, r2
 800dbb0:	781b      	ldrb	r3, [r3, #0]
 800dbb2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800dbb6:	2b80      	cmp	r3, #128	; 0x80
 800dbb8:	d001      	beq.n	800dbbe <lv_txt_utf8_next+0x8a>
 800dbba:	2300      	movs	r3, #0
 800dbbc:	e0c9      	b.n	800dd52 <lv_txt_utf8_next+0x21e>
            result += (txt[*i] & 0x3F);
 800dbbe:	683b      	ldr	r3, [r7, #0]
 800dbc0:	681b      	ldr	r3, [r3, #0]
 800dbc2:	687a      	ldr	r2, [r7, #4]
 800dbc4:	4413      	add	r3, r2
 800dbc6:	781b      	ldrb	r3, [r3, #0]
 800dbc8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800dbcc:	68fa      	ldr	r2, [r7, #12]
 800dbce:	4413      	add	r3, r2
 800dbd0:	60fb      	str	r3, [r7, #12]
            (*i)++;
 800dbd2:	683b      	ldr	r3, [r7, #0]
 800dbd4:	681b      	ldr	r3, [r3, #0]
 800dbd6:	1c5a      	adds	r2, r3, #1
 800dbd8:	683b      	ldr	r3, [r7, #0]
 800dbda:	601a      	str	r2, [r3, #0]
 800dbdc:	e0b8      	b.n	800dd50 <lv_txt_utf8_next+0x21c>
        }
        /*3 bytes UTF-8 code*/
        else if((txt[*i] & 0xF0) == 0xE0) {
 800dbde:	683b      	ldr	r3, [r7, #0]
 800dbe0:	681b      	ldr	r3, [r3, #0]
 800dbe2:	687a      	ldr	r2, [r7, #4]
 800dbe4:	4413      	add	r3, r2
 800dbe6:	781b      	ldrb	r3, [r3, #0]
 800dbe8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800dbec:	2be0      	cmp	r3, #224	; 0xe0
 800dbee:	d142      	bne.n	800dc76 <lv_txt_utf8_next+0x142>
            result = (uint32_t)(txt[*i] & 0x0F) << 12;
 800dbf0:	683b      	ldr	r3, [r7, #0]
 800dbf2:	681b      	ldr	r3, [r3, #0]
 800dbf4:	687a      	ldr	r2, [r7, #4]
 800dbf6:	4413      	add	r3, r2
 800dbf8:	781b      	ldrb	r3, [r3, #0]
 800dbfa:	031b      	lsls	r3, r3, #12
 800dbfc:	b29b      	uxth	r3, r3
 800dbfe:	60fb      	str	r3, [r7, #12]
            (*i)++;
 800dc00:	683b      	ldr	r3, [r7, #0]
 800dc02:	681b      	ldr	r3, [r3, #0]
 800dc04:	1c5a      	adds	r2, r3, #1
 800dc06:	683b      	ldr	r3, [r7, #0]
 800dc08:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 800dc0a:	683b      	ldr	r3, [r7, #0]
 800dc0c:	681b      	ldr	r3, [r3, #0]
 800dc0e:	687a      	ldr	r2, [r7, #4]
 800dc10:	4413      	add	r3, r2
 800dc12:	781b      	ldrb	r3, [r3, #0]
 800dc14:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800dc18:	2b80      	cmp	r3, #128	; 0x80
 800dc1a:	d001      	beq.n	800dc20 <lv_txt_utf8_next+0xec>
 800dc1c:	2300      	movs	r3, #0
 800dc1e:	e098      	b.n	800dd52 <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
 800dc20:	683b      	ldr	r3, [r7, #0]
 800dc22:	681b      	ldr	r3, [r3, #0]
 800dc24:	687a      	ldr	r2, [r7, #4]
 800dc26:	4413      	add	r3, r2
 800dc28:	781b      	ldrb	r3, [r3, #0]
 800dc2a:	019b      	lsls	r3, r3, #6
 800dc2c:	f403 637c 	and.w	r3, r3, #4032	; 0xfc0
 800dc30:	68fa      	ldr	r2, [r7, #12]
 800dc32:	4413      	add	r3, r2
 800dc34:	60fb      	str	r3, [r7, #12]
            (*i)++;
 800dc36:	683b      	ldr	r3, [r7, #0]
 800dc38:	681b      	ldr	r3, [r3, #0]
 800dc3a:	1c5a      	adds	r2, r3, #1
 800dc3c:	683b      	ldr	r3, [r7, #0]
 800dc3e:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 800dc40:	683b      	ldr	r3, [r7, #0]
 800dc42:	681b      	ldr	r3, [r3, #0]
 800dc44:	687a      	ldr	r2, [r7, #4]
 800dc46:	4413      	add	r3, r2
 800dc48:	781b      	ldrb	r3, [r3, #0]
 800dc4a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800dc4e:	2b80      	cmp	r3, #128	; 0x80
 800dc50:	d001      	beq.n	800dc56 <lv_txt_utf8_next+0x122>
 800dc52:	2300      	movs	r3, #0
 800dc54:	e07d      	b.n	800dd52 <lv_txt_utf8_next+0x21e>
            result += (txt[*i] & 0x3F);
 800dc56:	683b      	ldr	r3, [r7, #0]
 800dc58:	681b      	ldr	r3, [r3, #0]
 800dc5a:	687a      	ldr	r2, [r7, #4]
 800dc5c:	4413      	add	r3, r2
 800dc5e:	781b      	ldrb	r3, [r3, #0]
 800dc60:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800dc64:	68fa      	ldr	r2, [r7, #12]
 800dc66:	4413      	add	r3, r2
 800dc68:	60fb      	str	r3, [r7, #12]
            (*i)++;
 800dc6a:	683b      	ldr	r3, [r7, #0]
 800dc6c:	681b      	ldr	r3, [r3, #0]
 800dc6e:	1c5a      	adds	r2, r3, #1
 800dc70:	683b      	ldr	r3, [r7, #0]
 800dc72:	601a      	str	r2, [r3, #0]
 800dc74:	e06c      	b.n	800dd50 <lv_txt_utf8_next+0x21c>
        }
        /*4 bytes UTF-8 code*/
        else if((txt[*i] & 0xF8) == 0xF0) {
 800dc76:	683b      	ldr	r3, [r7, #0]
 800dc78:	681b      	ldr	r3, [r3, #0]
 800dc7a:	687a      	ldr	r2, [r7, #4]
 800dc7c:	4413      	add	r3, r2
 800dc7e:	781b      	ldrb	r3, [r3, #0]
 800dc80:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
 800dc84:	2bf0      	cmp	r3, #240	; 0xf0
 800dc86:	d15e      	bne.n	800dd46 <lv_txt_utf8_next+0x212>
            result = (uint32_t)(txt[*i] & 0x07) << 18;
 800dc88:	683b      	ldr	r3, [r7, #0]
 800dc8a:	681b      	ldr	r3, [r3, #0]
 800dc8c:	687a      	ldr	r2, [r7, #4]
 800dc8e:	4413      	add	r3, r2
 800dc90:	781b      	ldrb	r3, [r3, #0]
 800dc92:	049b      	lsls	r3, r3, #18
 800dc94:	f403 13e0 	and.w	r3, r3, #1835008	; 0x1c0000
 800dc98:	60fb      	str	r3, [r7, #12]
            (*i)++;
 800dc9a:	683b      	ldr	r3, [r7, #0]
 800dc9c:	681b      	ldr	r3, [r3, #0]
 800dc9e:	1c5a      	adds	r2, r3, #1
 800dca0:	683b      	ldr	r3, [r7, #0]
 800dca2:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 800dca4:	683b      	ldr	r3, [r7, #0]
 800dca6:	681b      	ldr	r3, [r3, #0]
 800dca8:	687a      	ldr	r2, [r7, #4]
 800dcaa:	4413      	add	r3, r2
 800dcac:	781b      	ldrb	r3, [r3, #0]
 800dcae:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800dcb2:	2b80      	cmp	r3, #128	; 0x80
 800dcb4:	d001      	beq.n	800dcba <lv_txt_utf8_next+0x186>
 800dcb6:	2300      	movs	r3, #0
 800dcb8:	e04b      	b.n	800dd52 <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 12;
 800dcba:	683b      	ldr	r3, [r7, #0]
 800dcbc:	681b      	ldr	r3, [r3, #0]
 800dcbe:	687a      	ldr	r2, [r7, #4]
 800dcc0:	4413      	add	r3, r2
 800dcc2:	781b      	ldrb	r3, [r3, #0]
 800dcc4:	031b      	lsls	r3, r3, #12
 800dcc6:	f403 337c 	and.w	r3, r3, #258048	; 0x3f000
 800dcca:	68fa      	ldr	r2, [r7, #12]
 800dccc:	4413      	add	r3, r2
 800dcce:	60fb      	str	r3, [r7, #12]
            (*i)++;
 800dcd0:	683b      	ldr	r3, [r7, #0]
 800dcd2:	681b      	ldr	r3, [r3, #0]
 800dcd4:	1c5a      	adds	r2, r3, #1
 800dcd6:	683b      	ldr	r3, [r7, #0]
 800dcd8:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 800dcda:	683b      	ldr	r3, [r7, #0]
 800dcdc:	681b      	ldr	r3, [r3, #0]
 800dcde:	687a      	ldr	r2, [r7, #4]
 800dce0:	4413      	add	r3, r2
 800dce2:	781b      	ldrb	r3, [r3, #0]
 800dce4:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800dce8:	2b80      	cmp	r3, #128	; 0x80
 800dcea:	d001      	beq.n	800dcf0 <lv_txt_utf8_next+0x1bc>
 800dcec:	2300      	movs	r3, #0
 800dcee:	e030      	b.n	800dd52 <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
 800dcf0:	683b      	ldr	r3, [r7, #0]
 800dcf2:	681b      	ldr	r3, [r3, #0]
 800dcf4:	687a      	ldr	r2, [r7, #4]
 800dcf6:	4413      	add	r3, r2
 800dcf8:	781b      	ldrb	r3, [r3, #0]
 800dcfa:	019b      	lsls	r3, r3, #6
 800dcfc:	f403 637c 	and.w	r3, r3, #4032	; 0xfc0
 800dd00:	68fa      	ldr	r2, [r7, #12]
 800dd02:	4413      	add	r3, r2
 800dd04:	60fb      	str	r3, [r7, #12]
            (*i)++;
 800dd06:	683b      	ldr	r3, [r7, #0]
 800dd08:	681b      	ldr	r3, [r3, #0]
 800dd0a:	1c5a      	adds	r2, r3, #1
 800dd0c:	683b      	ldr	r3, [r7, #0]
 800dd0e:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 800dd10:	683b      	ldr	r3, [r7, #0]
 800dd12:	681b      	ldr	r3, [r3, #0]
 800dd14:	687a      	ldr	r2, [r7, #4]
 800dd16:	4413      	add	r3, r2
 800dd18:	781b      	ldrb	r3, [r3, #0]
 800dd1a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800dd1e:	2b80      	cmp	r3, #128	; 0x80
 800dd20:	d001      	beq.n	800dd26 <lv_txt_utf8_next+0x1f2>
 800dd22:	2300      	movs	r3, #0
 800dd24:	e015      	b.n	800dd52 <lv_txt_utf8_next+0x21e>
            result += txt[*i] & 0x3F;
 800dd26:	683b      	ldr	r3, [r7, #0]
 800dd28:	681b      	ldr	r3, [r3, #0]
 800dd2a:	687a      	ldr	r2, [r7, #4]
 800dd2c:	4413      	add	r3, r2
 800dd2e:	781b      	ldrb	r3, [r3, #0]
 800dd30:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800dd34:	68fa      	ldr	r2, [r7, #12]
 800dd36:	4413      	add	r3, r2
 800dd38:	60fb      	str	r3, [r7, #12]
            (*i)++;
 800dd3a:	683b      	ldr	r3, [r7, #0]
 800dd3c:	681b      	ldr	r3, [r3, #0]
 800dd3e:	1c5a      	adds	r2, r3, #1
 800dd40:	683b      	ldr	r3, [r7, #0]
 800dd42:	601a      	str	r2, [r3, #0]
 800dd44:	e004      	b.n	800dd50 <lv_txt_utf8_next+0x21c>
        } else {
            (*i)++; /*Not UTF-8 char. Go the next.*/
 800dd46:	683b      	ldr	r3, [r7, #0]
 800dd48:	681b      	ldr	r3, [r3, #0]
 800dd4a:	1c5a      	adds	r2, r3, #1
 800dd4c:	683b      	ldr	r3, [r7, #0]
 800dd4e:	601a      	str	r2, [r3, #0]
        }
    }
    return result;
 800dd50:	68fb      	ldr	r3, [r7, #12]
}
 800dd52:	4618      	mov	r0, r3
 800dd54:	3714      	adds	r7, #20
 800dd56:	46bd      	mov	sp, r7
 800dd58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd5c:	4770      	bx	lr
	...

0800dd60 <lv_txt_utf8_prev>:
 * @param i start byte index in 'txt' where to start. After the call it will point to the previous
 * UTF-8 char in 'txt'.
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_txt_utf8_prev(const char * txt, uint32_t * i)
{
 800dd60:	b580      	push	{r7, lr}
 800dd62:	b086      	sub	sp, #24
 800dd64:	af00      	add	r7, sp, #0
 800dd66:	6078      	str	r0, [r7, #4]
 800dd68:	6039      	str	r1, [r7, #0]
    uint8_t c_size;
    uint8_t cnt = 0;
 800dd6a:	2300      	movs	r3, #0
 800dd6c:	75fb      	strb	r3, [r7, #23]

    /*Try to find a !0 long UTF-8 char by stepping one character back*/
    (*i)--;
 800dd6e:	683b      	ldr	r3, [r7, #0]
 800dd70:	681b      	ldr	r3, [r3, #0]
 800dd72:	1e5a      	subs	r2, r3, #1
 800dd74:	683b      	ldr	r3, [r7, #0]
 800dd76:	601a      	str	r2, [r3, #0]
    do {
        if(cnt >= 4) return 0; /*No UTF-8 char found before the initial*/
 800dd78:	7dfb      	ldrb	r3, [r7, #23]
 800dd7a:	2b03      	cmp	r3, #3
 800dd7c:	d901      	bls.n	800dd82 <lv_txt_utf8_prev+0x22>
 800dd7e:	2300      	movs	r3, #0
 800dd80:	e02a      	b.n	800ddd8 <lv_txt_utf8_prev+0x78>

        c_size = lv_txt_encoded_size(&txt[*i]);
 800dd82:	4b17      	ldr	r3, [pc, #92]	; (800dde0 <lv_txt_utf8_prev+0x80>)
 800dd84:	681b      	ldr	r3, [r3, #0]
 800dd86:	683a      	ldr	r2, [r7, #0]
 800dd88:	6812      	ldr	r2, [r2, #0]
 800dd8a:	6879      	ldr	r1, [r7, #4]
 800dd8c:	440a      	add	r2, r1
 800dd8e:	4610      	mov	r0, r2
 800dd90:	4798      	blx	r3
 800dd92:	4603      	mov	r3, r0
 800dd94:	75bb      	strb	r3, [r7, #22]
        if(c_size == 0) {
 800dd96:	7dbb      	ldrb	r3, [r7, #22]
 800dd98:	2b00      	cmp	r3, #0
 800dd9a:	d10b      	bne.n	800ddb4 <lv_txt_utf8_prev+0x54>
            if(*i != 0)
 800dd9c:	683b      	ldr	r3, [r7, #0]
 800dd9e:	681b      	ldr	r3, [r3, #0]
 800dda0:	2b00      	cmp	r3, #0
 800dda2:	d005      	beq.n	800ddb0 <lv_txt_utf8_prev+0x50>
                (*i)--;
 800dda4:	683b      	ldr	r3, [r7, #0]
 800dda6:	681b      	ldr	r3, [r3, #0]
 800dda8:	1e5a      	subs	r2, r3, #1
 800ddaa:	683b      	ldr	r3, [r7, #0]
 800ddac:	601a      	str	r2, [r3, #0]
 800ddae:	e001      	b.n	800ddb4 <lv_txt_utf8_prev+0x54>
            else
                return 0;
 800ddb0:	2300      	movs	r3, #0
 800ddb2:	e011      	b.n	800ddd8 <lv_txt_utf8_prev+0x78>
        }
        cnt++;
 800ddb4:	7dfb      	ldrb	r3, [r7, #23]
 800ddb6:	3301      	adds	r3, #1
 800ddb8:	75fb      	strb	r3, [r7, #23]
    } while(c_size == 0);
 800ddba:	7dbb      	ldrb	r3, [r7, #22]
 800ddbc:	2b00      	cmp	r3, #0
 800ddbe:	d0db      	beq.n	800dd78 <lv_txt_utf8_prev+0x18>

    uint32_t i_tmp  = *i;
 800ddc0:	683b      	ldr	r3, [r7, #0]
 800ddc2:	681b      	ldr	r3, [r3, #0]
 800ddc4:	60fb      	str	r3, [r7, #12]
    uint32_t letter = lv_txt_encoded_next(txt, &i_tmp); /*Character found, get it*/
 800ddc6:	4b07      	ldr	r3, [pc, #28]	; (800dde4 <lv_txt_utf8_prev+0x84>)
 800ddc8:	681b      	ldr	r3, [r3, #0]
 800ddca:	f107 020c 	add.w	r2, r7, #12
 800ddce:	4611      	mov	r1, r2
 800ddd0:	6878      	ldr	r0, [r7, #4]
 800ddd2:	4798      	blx	r3
 800ddd4:	6138      	str	r0, [r7, #16]

    return letter;
 800ddd6:	693b      	ldr	r3, [r7, #16]
}
 800ddd8:	4618      	mov	r0, r3
 800ddda:	3718      	adds	r7, #24
 800dddc:	46bd      	mov	sp, r7
 800ddde:	bd80      	pop	{r7, pc}
 800dde0:	20000050 	.word	0x20000050
 800dde4:	20000054 	.word	0x20000054

0800dde8 <lv_txt_utf8_get_byte_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param utf8_id character index
 * @return byte index of the 'utf8_id'th letter
 */
static uint32_t lv_txt_utf8_get_byte_id(const char * txt, uint32_t utf8_id)
{
 800dde8:	b580      	push	{r7, lr}
 800ddea:	b086      	sub	sp, #24
 800ddec:	af00      	add	r7, sp, #0
 800ddee:	6078      	str	r0, [r7, #4]
 800ddf0:	6039      	str	r1, [r7, #0]
    uint32_t i;
    uint32_t byte_cnt = 0;
 800ddf2:	2300      	movs	r3, #0
 800ddf4:	613b      	str	r3, [r7, #16]
    for(i = 0; i < utf8_id; i++) {
 800ddf6:	2300      	movs	r3, #0
 800ddf8:	617b      	str	r3, [r7, #20]
 800ddfa:	e014      	b.n	800de26 <lv_txt_utf8_get_byte_id+0x3e>
        uint8_t c_size = lv_txt_encoded_size(&txt[byte_cnt]);
 800ddfc:	4b0e      	ldr	r3, [pc, #56]	; (800de38 <lv_txt_utf8_get_byte_id+0x50>)
 800ddfe:	681b      	ldr	r3, [r3, #0]
 800de00:	6879      	ldr	r1, [r7, #4]
 800de02:	693a      	ldr	r2, [r7, #16]
 800de04:	440a      	add	r2, r1
 800de06:	4610      	mov	r0, r2
 800de08:	4798      	blx	r3
 800de0a:	4603      	mov	r3, r0
 800de0c:	73fb      	strb	r3, [r7, #15]
        byte_cnt += c_size > 0 ? c_size : 1;
 800de0e:	7bfb      	ldrb	r3, [r7, #15]
 800de10:	2b00      	cmp	r3, #0
 800de12:	d001      	beq.n	800de18 <lv_txt_utf8_get_byte_id+0x30>
 800de14:	7bfb      	ldrb	r3, [r7, #15]
 800de16:	e000      	b.n	800de1a <lv_txt_utf8_get_byte_id+0x32>
 800de18:	2301      	movs	r3, #1
 800de1a:	693a      	ldr	r2, [r7, #16]
 800de1c:	4413      	add	r3, r2
 800de1e:	613b      	str	r3, [r7, #16]
    for(i = 0; i < utf8_id; i++) {
 800de20:	697b      	ldr	r3, [r7, #20]
 800de22:	3301      	adds	r3, #1
 800de24:	617b      	str	r3, [r7, #20]
 800de26:	697a      	ldr	r2, [r7, #20]
 800de28:	683b      	ldr	r3, [r7, #0]
 800de2a:	429a      	cmp	r2, r3
 800de2c:	d3e6      	bcc.n	800ddfc <lv_txt_utf8_get_byte_id+0x14>
    }

    return byte_cnt;
 800de2e:	693b      	ldr	r3, [r7, #16]
}
 800de30:	4618      	mov	r0, r3
 800de32:	3718      	adds	r7, #24
 800de34:	46bd      	mov	sp, r7
 800de36:	bd80      	pop	{r7, pc}
 800de38:	20000050 	.word	0x20000050

0800de3c <lv_txt_utf8_get_char_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param byte_id byte index
 * @return character index of the letter at 'byte_id'th position
 */
static uint32_t lv_txt_utf8_get_char_id(const char * txt, uint32_t byte_id)
{
 800de3c:	b580      	push	{r7, lr}
 800de3e:	b084      	sub	sp, #16
 800de40:	af00      	add	r7, sp, #0
 800de42:	6078      	str	r0, [r7, #4]
 800de44:	6039      	str	r1, [r7, #0]
    uint32_t i        = 0;
 800de46:	2300      	movs	r3, #0
 800de48:	60bb      	str	r3, [r7, #8]
    uint32_t char_cnt = 0;
 800de4a:	2300      	movs	r3, #0
 800de4c:	60fb      	str	r3, [r7, #12]

    while(i < byte_id) {
 800de4e:	e009      	b.n	800de64 <lv_txt_utf8_get_char_id+0x28>
        lv_txt_encoded_next(txt, &i); /*'i' points to the next letter so use the prev. value*/
 800de50:	4b09      	ldr	r3, [pc, #36]	; (800de78 <lv_txt_utf8_get_char_id+0x3c>)
 800de52:	681b      	ldr	r3, [r3, #0]
 800de54:	f107 0208 	add.w	r2, r7, #8
 800de58:	4611      	mov	r1, r2
 800de5a:	6878      	ldr	r0, [r7, #4]
 800de5c:	4798      	blx	r3
        char_cnt++;
 800de5e:	68fb      	ldr	r3, [r7, #12]
 800de60:	3301      	adds	r3, #1
 800de62:	60fb      	str	r3, [r7, #12]
    while(i < byte_id) {
 800de64:	68bb      	ldr	r3, [r7, #8]
 800de66:	683a      	ldr	r2, [r7, #0]
 800de68:	429a      	cmp	r2, r3
 800de6a:	d8f1      	bhi.n	800de50 <lv_txt_utf8_get_char_id+0x14>
    }

    return char_cnt;
 800de6c:	68fb      	ldr	r3, [r7, #12]
}
 800de6e:	4618      	mov	r0, r3
 800de70:	3710      	adds	r7, #16
 800de72:	46bd      	mov	sp, r7
 800de74:	bd80      	pop	{r7, pc}
 800de76:	bf00      	nop
 800de78:	20000054 	.word	0x20000054

0800de7c <lv_txt_utf8_get_length>:
 * E.g.: "ÁBC" is 3 characters (but 4 bytes)
 * @param txt a '\0' terminated char string
 * @return number of characters
 */
static uint32_t lv_txt_utf8_get_length(const char * txt)
{
 800de7c:	b580      	push	{r7, lr}
 800de7e:	b084      	sub	sp, #16
 800de80:	af00      	add	r7, sp, #0
 800de82:	6078      	str	r0, [r7, #4]
    uint32_t len = 0;
 800de84:	2300      	movs	r3, #0
 800de86:	60fb      	str	r3, [r7, #12]
    uint32_t i   = 0;
 800de88:	2300      	movs	r3, #0
 800de8a:	60bb      	str	r3, [r7, #8]

    while(txt[i] != '\0') {
 800de8c:	e009      	b.n	800dea2 <lv_txt_utf8_get_length+0x26>
        lv_txt_encoded_next(txt, &i);
 800de8e:	4b0a      	ldr	r3, [pc, #40]	; (800deb8 <lv_txt_utf8_get_length+0x3c>)
 800de90:	681b      	ldr	r3, [r3, #0]
 800de92:	f107 0208 	add.w	r2, r7, #8
 800de96:	4611      	mov	r1, r2
 800de98:	6878      	ldr	r0, [r7, #4]
 800de9a:	4798      	blx	r3
        len++;
 800de9c:	68fb      	ldr	r3, [r7, #12]
 800de9e:	3301      	adds	r3, #1
 800dea0:	60fb      	str	r3, [r7, #12]
    while(txt[i] != '\0') {
 800dea2:	68bb      	ldr	r3, [r7, #8]
 800dea4:	687a      	ldr	r2, [r7, #4]
 800dea6:	4413      	add	r3, r2
 800dea8:	781b      	ldrb	r3, [r3, #0]
 800deaa:	2b00      	cmp	r3, #0
 800deac:	d1ef      	bne.n	800de8e <lv_txt_utf8_get_length+0x12>
    }

    return len;
 800deae:	68fb      	ldr	r3, [r7, #12]
}
 800deb0:	4618      	mov	r0, r3
 800deb2:	3710      	adds	r7, #16
 800deb4:	46bd      	mov	sp, r7
 800deb6:	bd80      	pop	{r7, pc}
 800deb8:	20000054 	.word	0x20000054

0800debc <is_break_char>:
 * Test if char is break char or not (a text can broken here or not)
 * @param letter a letter
 * @return false: 'letter' is not break char
 */
static inline bool is_break_char(uint32_t letter)
{
 800debc:	b480      	push	{r7}
 800debe:	b085      	sub	sp, #20
 800dec0:	af00      	add	r7, sp, #0
 800dec2:	6078      	str	r0, [r7, #4]
    uint8_t i;
    bool ret = false;
 800dec4:	2300      	movs	r3, #0
 800dec6:	73bb      	strb	r3, [r7, #14]

    /*Compare the letter to TXT_BREAK_CHARS*/
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
 800dec8:	2300      	movs	r3, #0
 800deca:	73fb      	strb	r3, [r7, #15]
 800decc:	e00c      	b.n	800dee8 <is_break_char+0x2c>
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
 800dece:	7bfb      	ldrb	r3, [r7, #15]
 800ded0:	4a0b      	ldr	r2, [pc, #44]	; (800df00 <is_break_char+0x44>)
 800ded2:	5cd3      	ldrb	r3, [r2, r3]
 800ded4:	461a      	mov	r2, r3
 800ded6:	687b      	ldr	r3, [r7, #4]
 800ded8:	4293      	cmp	r3, r2
 800deda:	d102      	bne.n	800dee2 <is_break_char+0x26>
            ret = true; /*If match then it is break char*/
 800dedc:	2301      	movs	r3, #1
 800dede:	73bb      	strb	r3, [r7, #14]
            break;
 800dee0:	e007      	b.n	800def2 <is_break_char+0x36>
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
 800dee2:	7bfb      	ldrb	r3, [r7, #15]
 800dee4:	3301      	adds	r3, #1
 800dee6:	73fb      	strb	r3, [r7, #15]
 800dee8:	7bfb      	ldrb	r3, [r7, #15]
 800deea:	4a05      	ldr	r2, [pc, #20]	; (800df00 <is_break_char+0x44>)
 800deec:	5cd3      	ldrb	r3, [r2, r3]
 800deee:	2b00      	cmp	r3, #0
 800def0:	d1ed      	bne.n	800dece <is_break_char+0x12>
        }
    }

    return ret;
 800def2:	7bbb      	ldrb	r3, [r7, #14]
}
 800def4:	4618      	mov	r0, r3
 800def6:	3714      	adds	r7, #20
 800def8:	46bd      	mov	sp, r7
 800defa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800defe:	4770      	bx	lr
 800df00:	080138ac 	.word	0x080138ac

0800df04 <lv_utils_bsearch>:
 *
 * @return a pointer to a matching item, or NULL if none exists.
 */
void * lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,
                        int32_t (*cmp)(const void * pRef, const void * pElement))
{
 800df04:	b580      	push	{r7, lr}
 800df06:	b086      	sub	sp, #24
 800df08:	af00      	add	r7, sp, #0
 800df0a:	60f8      	str	r0, [r7, #12]
 800df0c:	60b9      	str	r1, [r7, #8]
 800df0e:	607a      	str	r2, [r7, #4]
 800df10:	603b      	str	r3, [r7, #0]
    const char * middle;
    int32_t c;

    for(middle = base; n != 0;) {
 800df12:	68bb      	ldr	r3, [r7, #8]
 800df14:	617b      	str	r3, [r7, #20]
 800df16:	e02d      	b.n	800df74 <lv_utils_bsearch+0x70>
        middle += (n / 2) * size;
 800df18:	687b      	ldr	r3, [r7, #4]
 800df1a:	085b      	lsrs	r3, r3, #1
 800df1c:	683a      	ldr	r2, [r7, #0]
 800df1e:	fb02 f303 	mul.w	r3, r2, r3
 800df22:	697a      	ldr	r2, [r7, #20]
 800df24:	4413      	add	r3, r2
 800df26:	617b      	str	r3, [r7, #20]
        if((c = (*cmp)(key, middle)) > 0) {
 800df28:	6a3b      	ldr	r3, [r7, #32]
 800df2a:	6979      	ldr	r1, [r7, #20]
 800df2c:	68f8      	ldr	r0, [r7, #12]
 800df2e:	4798      	blx	r3
 800df30:	6138      	str	r0, [r7, #16]
 800df32:	693b      	ldr	r3, [r7, #16]
 800df34:	2b00      	cmp	r3, #0
 800df36:	dd12      	ble.n	800df5e <lv_utils_bsearch+0x5a>
            n    = (n / 2) - ((n & 1) == 0);
 800df38:	687b      	ldr	r3, [r7, #4]
 800df3a:	085b      	lsrs	r3, r3, #1
 800df3c:	687a      	ldr	r2, [r7, #4]
 800df3e:	f002 0201 	and.w	r2, r2, #1
 800df42:	2a00      	cmp	r2, #0
 800df44:	bf0c      	ite	eq
 800df46:	2201      	moveq	r2, #1
 800df48:	2200      	movne	r2, #0
 800df4a:	b2d2      	uxtb	r2, r2
 800df4c:	1a9b      	subs	r3, r3, r2
 800df4e:	607b      	str	r3, [r7, #4]
            base = (middle += size);
 800df50:	697a      	ldr	r2, [r7, #20]
 800df52:	683b      	ldr	r3, [r7, #0]
 800df54:	4413      	add	r3, r2
 800df56:	617b      	str	r3, [r7, #20]
 800df58:	697b      	ldr	r3, [r7, #20]
 800df5a:	60bb      	str	r3, [r7, #8]
 800df5c:	e00a      	b.n	800df74 <lv_utils_bsearch+0x70>
        } else if(c < 0) {
 800df5e:	693b      	ldr	r3, [r7, #16]
 800df60:	2b00      	cmp	r3, #0
 800df62:	da05      	bge.n	800df70 <lv_utils_bsearch+0x6c>
            n /= 2;
 800df64:	687b      	ldr	r3, [r7, #4]
 800df66:	085b      	lsrs	r3, r3, #1
 800df68:	607b      	str	r3, [r7, #4]
            middle = base;
 800df6a:	68bb      	ldr	r3, [r7, #8]
 800df6c:	617b      	str	r3, [r7, #20]
 800df6e:	e001      	b.n	800df74 <lv_utils_bsearch+0x70>
        } else {
            return (char *)middle;
 800df70:	697b      	ldr	r3, [r7, #20]
 800df72:	e003      	b.n	800df7c <lv_utils_bsearch+0x78>
    for(middle = base; n != 0;) {
 800df74:	687b      	ldr	r3, [r7, #4]
 800df76:	2b00      	cmp	r3, #0
 800df78:	d1ce      	bne.n	800df18 <lv_utils_bsearch+0x14>
        }
    }
    return NULL;
 800df7a:	2300      	movs	r3, #0
}
 800df7c:	4618      	mov	r0, r3
 800df7e:	3718      	adds	r7, #24
 800df80:	46bd      	mov	sp, r7
 800df82:	bd80      	pop	{r7, pc}

0800df84 <lv_btn_set_layout>:
 * Set the layout on a button
 * @param btn pointer to a button object
 * @param layout a layout from 'lv_cont_layout_t'
 */
static inline void lv_btn_set_layout(lv_obj_t * btn, lv_layout_t layout)
{
 800df84:	b580      	push	{r7, lr}
 800df86:	b082      	sub	sp, #8
 800df88:	af00      	add	r7, sp, #0
 800df8a:	6078      	str	r0, [r7, #4]
 800df8c:	460b      	mov	r3, r1
 800df8e:	70fb      	strb	r3, [r7, #3]
    lv_cont_set_layout(btn, layout);
 800df90:	78fb      	ldrb	r3, [r7, #3]
 800df92:	4619      	mov	r1, r3
 800df94:	6878      	ldr	r0, [r7, #4]
 800df96:	f000 fc4b 	bl	800e830 <lv_cont_set_layout>
}
 800df9a:	bf00      	nop
 800df9c:	3708      	adds	r7, #8
 800df9e:	46bd      	mov	sp, r7
 800dfa0:	bd80      	pop	{r7, pc}
	...

0800dfa4 <lv_btn_create>:
 * @param par pointer to an object, it will be the parent of the new button
 * @param copy pointer to a button object, if not NULL then the new object will be copied from it
 * @return pointer to the created button
 */
lv_obj_t * lv_btn_create(lv_obj_t * par, const lv_obj_t * copy)
{
 800dfa4:	b590      	push	{r4, r7, lr}
 800dfa6:	b087      	sub	sp, #28
 800dfa8:	af00      	add	r7, sp, #0
 800dfaa:	6078      	str	r0, [r7, #4]
 800dfac:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("button create started");

    lv_obj_t * new_btn;

    new_btn = lv_cont_create(par, copy);
 800dfae:	6839      	ldr	r1, [r7, #0]
 800dfb0:	6878      	ldr	r0, [r7, #4]
 800dfb2:	f000 fb75 	bl	800e6a0 <lv_cont_create>
 800dfb6:	6178      	str	r0, [r7, #20]
    LV_ASSERT_MEM(new_btn);
 800dfb8:	6978      	ldr	r0, [r7, #20]
 800dfba:	f7f2 f91d 	bl	80001f8 <lv_debug_check_null>
 800dfbe:	4603      	mov	r3, r0
 800dfc0:	f083 0301 	eor.w	r3, r3, #1
 800dfc4:	b2db      	uxtb	r3, r3
 800dfc6:	2b00      	cmp	r3, #0
 800dfc8:	d008      	beq.n	800dfdc <lv_btn_create+0x38>
 800dfca:	697b      	ldr	r3, [r7, #20]
 800dfcc:	f04f 0400 	mov.w	r4, #0
 800dfd0:	461a      	mov	r2, r3
 800dfd2:	4623      	mov	r3, r4
 800dfd4:	4860      	ldr	r0, [pc, #384]	; (800e158 <lv_btn_create+0x1b4>)
 800dfd6:	f7f2 f939 	bl	800024c <lv_debug_log_error>
 800dfda:	e7fe      	b.n	800dfda <lv_btn_create+0x36>
    if(new_btn == NULL) return NULL;
 800dfdc:	697b      	ldr	r3, [r7, #20]
 800dfde:	2b00      	cmp	r3, #0
 800dfe0:	d101      	bne.n	800dfe6 <lv_btn_create+0x42>
 800dfe2:	2300      	movs	r3, #0
 800dfe4:	e0b3      	b.n	800e14e <lv_btn_create+0x1aa>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_btn);
 800dfe6:	4b5d      	ldr	r3, [pc, #372]	; (800e15c <lv_btn_create+0x1b8>)
 800dfe8:	681b      	ldr	r3, [r3, #0]
 800dfea:	2b00      	cmp	r3, #0
 800dfec:	d105      	bne.n	800dffa <lv_btn_create+0x56>
 800dfee:	6978      	ldr	r0, [r7, #20]
 800dff0:	f7f4 fcac 	bl	800294c <lv_obj_get_signal_cb>
 800dff4:	4602      	mov	r2, r0
 800dff6:	4b59      	ldr	r3, [pc, #356]	; (800e15c <lv_btn_create+0x1b8>)
 800dff8:	601a      	str	r2, [r3, #0]
    if(ancestor_design == NULL) ancestor_design = lv_obj_get_design_cb(new_btn);
 800dffa:	4b59      	ldr	r3, [pc, #356]	; (800e160 <lv_btn_create+0x1bc>)
 800dffc:	681b      	ldr	r3, [r3, #0]
 800dffe:	2b00      	cmp	r3, #0
 800e000:	d105      	bne.n	800e00e <lv_btn_create+0x6a>
 800e002:	6978      	ldr	r0, [r7, #20]
 800e004:	f7f4 fcc0 	bl	8002988 <lv_obj_get_design_cb>
 800e008:	4602      	mov	r2, r0
 800e00a:	4b55      	ldr	r3, [pc, #340]	; (800e160 <lv_btn_create+0x1bc>)
 800e00c:	601a      	str	r2, [r3, #0]

    /*Allocate the extended data*/
    lv_btn_ext_t * ext = lv_obj_allocate_ext_attr(new_btn, sizeof(lv_btn_ext_t));
 800e00e:	211c      	movs	r1, #28
 800e010:	6978      	ldr	r0, [r7, #20]
 800e012:	f7f4 f95d 	bl	80022d0 <lv_obj_allocate_ext_attr>
 800e016:	6138      	str	r0, [r7, #16]
    LV_ASSERT_MEM(ext);
 800e018:	6938      	ldr	r0, [r7, #16]
 800e01a:	f7f2 f8ed 	bl	80001f8 <lv_debug_check_null>
 800e01e:	4603      	mov	r3, r0
 800e020:	f083 0301 	eor.w	r3, r3, #1
 800e024:	b2db      	uxtb	r3, r3
 800e026:	2b00      	cmp	r3, #0
 800e028:	d008      	beq.n	800e03c <lv_btn_create+0x98>
 800e02a:	693b      	ldr	r3, [r7, #16]
 800e02c:	f04f 0400 	mov.w	r4, #0
 800e030:	461a      	mov	r2, r3
 800e032:	4623      	mov	r3, r4
 800e034:	4848      	ldr	r0, [pc, #288]	; (800e158 <lv_btn_create+0x1b4>)
 800e036:	f7f2 f909 	bl	800024c <lv_debug_log_error>
 800e03a:	e7fe      	b.n	800e03a <lv_btn_create+0x96>
    if(ext == NULL) return NULL;
 800e03c:	693b      	ldr	r3, [r7, #16]
 800e03e:	2b00      	cmp	r3, #0
 800e040:	d101      	bne.n	800e046 <lv_btn_create+0xa2>
 800e042:	2300      	movs	r3, #0
 800e044:	e083      	b.n	800e14e <lv_btn_create+0x1aa>

    ext->state = LV_BTN_STATE_REL;
 800e046:	693a      	ldr	r2, [r7, #16]
 800e048:	7e13      	ldrb	r3, [r2, #24]
 800e04a:	f36f 0302 	bfc	r3, #0, #3
 800e04e:	7613      	strb	r3, [r2, #24]

    ext->styles[LV_BTN_STATE_REL]     = &lv_style_btn_rel;
 800e050:	693b      	ldr	r3, [r7, #16]
 800e052:	4a44      	ldr	r2, [pc, #272]	; (800e164 <lv_btn_create+0x1c0>)
 800e054:	605a      	str	r2, [r3, #4]
    ext->styles[LV_BTN_STATE_PR]      = &lv_style_btn_pr;
 800e056:	693b      	ldr	r3, [r7, #16]
 800e058:	4a43      	ldr	r2, [pc, #268]	; (800e168 <lv_btn_create+0x1c4>)
 800e05a:	609a      	str	r2, [r3, #8]
    ext->styles[LV_BTN_STATE_TGL_REL] = &lv_style_btn_tgl_rel;
 800e05c:	693b      	ldr	r3, [r7, #16]
 800e05e:	4a43      	ldr	r2, [pc, #268]	; (800e16c <lv_btn_create+0x1c8>)
 800e060:	60da      	str	r2, [r3, #12]
    ext->styles[LV_BTN_STATE_TGL_PR]  = &lv_style_btn_tgl_pr;
 800e062:	693b      	ldr	r3, [r7, #16]
 800e064:	4a42      	ldr	r2, [pc, #264]	; (800e170 <lv_btn_create+0x1cc>)
 800e066:	611a      	str	r2, [r3, #16]
    ext->styles[LV_BTN_STATE_INA]     = &lv_style_btn_ina;
 800e068:	693b      	ldr	r3, [r7, #16]
 800e06a:	4a42      	ldr	r2, [pc, #264]	; (800e174 <lv_btn_create+0x1d0>)
 800e06c:	615a      	str	r2, [r3, #20]

    ext->toggle = 0;
 800e06e:	693a      	ldr	r2, [r7, #16]
 800e070:	7e13      	ldrb	r3, [r2, #24]
 800e072:	f36f 03c3 	bfc	r3, #3, #1
 800e076:	7613      	strb	r3, [r2, #24]
    ext->ink_in_time   = 0;
    ext->ink_wait_time = 0;
    ext->ink_out_time  = 0;
#endif

    lv_obj_set_signal_cb(new_btn, lv_btn_signal);
 800e078:	493f      	ldr	r1, [pc, #252]	; (800e178 <lv_btn_create+0x1d4>)
 800e07a:	6978      	ldr	r0, [r7, #20]
 800e07c:	f7f4 f8e8 	bl	8002250 <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(new_btn, lv_btn_design);
 800e080:	493e      	ldr	r1, [pc, #248]	; (800e17c <lv_btn_create+0x1d8>)
 800e082:	6978      	ldr	r0, [r7, #20]
 800e084:	f7f4 f904 	bl	8002290 <lv_obj_set_design_cb>

    /*If no copy do the basic initialization*/
    if(copy == NULL) {
 800e088:	683b      	ldr	r3, [r7, #0]
 800e08a:	2b00      	cmp	r3, #0
 800e08c:	d13b      	bne.n	800e106 <lv_btn_create+0x162>
        /*Set layout if the button is not a screen*/
        if(par != NULL) {
 800e08e:	687b      	ldr	r3, [r7, #4]
 800e090:	2b00      	cmp	r3, #0
 800e092:	d003      	beq.n	800e09c <lv_btn_create+0xf8>
            lv_btn_set_layout(new_btn, LV_LAYOUT_CENTER);
 800e094:	2101      	movs	r1, #1
 800e096:	6978      	ldr	r0, [r7, #20]
 800e098:	f7ff ff74 	bl	800df84 <lv_btn_set_layout>
        }

        lv_obj_set_click(new_btn, true); /*Be sure the button is clickable*/
 800e09c:	2101      	movs	r1, #1
 800e09e:	6978      	ldr	r0, [r7, #20]
 800e0a0:	f7f3 ffae 	bl	8002000 <lv_obj_set_click>

        /*Set the default styles*/
        lv_theme_t * th = lv_theme_get_current();
 800e0a4:	f002 ffd8 	bl	8011058 <lv_theme_get_current>
 800e0a8:	60b8      	str	r0, [r7, #8]
        if(th) {
 800e0aa:	68bb      	ldr	r3, [r7, #8]
 800e0ac:	2b00      	cmp	r3, #0
 800e0ae:	d023      	beq.n	800e0f8 <lv_btn_create+0x154>
            lv_btn_set_style(new_btn, LV_BTN_STYLE_REL, th->style.btn.rel);
 800e0b0:	68bb      	ldr	r3, [r7, #8]
 800e0b2:	691b      	ldr	r3, [r3, #16]
 800e0b4:	461a      	mov	r2, r3
 800e0b6:	2100      	movs	r1, #0
 800e0b8:	6978      	ldr	r0, [r7, #20]
 800e0ba:	f000 f89f 	bl	800e1fc <lv_btn_set_style>
            lv_btn_set_style(new_btn, LV_BTN_STYLE_PR, th->style.btn.pr);
 800e0be:	68bb      	ldr	r3, [r7, #8]
 800e0c0:	695b      	ldr	r3, [r3, #20]
 800e0c2:	461a      	mov	r2, r3
 800e0c4:	2101      	movs	r1, #1
 800e0c6:	6978      	ldr	r0, [r7, #20]
 800e0c8:	f000 f898 	bl	800e1fc <lv_btn_set_style>
            lv_btn_set_style(new_btn, LV_BTN_STYLE_TGL_REL, th->style.btn.tgl_rel);
 800e0cc:	68bb      	ldr	r3, [r7, #8]
 800e0ce:	699b      	ldr	r3, [r3, #24]
 800e0d0:	461a      	mov	r2, r3
 800e0d2:	2102      	movs	r1, #2
 800e0d4:	6978      	ldr	r0, [r7, #20]
 800e0d6:	f000 f891 	bl	800e1fc <lv_btn_set_style>
            lv_btn_set_style(new_btn, LV_BTN_STYLE_TGL_PR, th->style.btn.tgl_pr);
 800e0da:	68bb      	ldr	r3, [r7, #8]
 800e0dc:	69db      	ldr	r3, [r3, #28]
 800e0de:	461a      	mov	r2, r3
 800e0e0:	2103      	movs	r1, #3
 800e0e2:	6978      	ldr	r0, [r7, #20]
 800e0e4:	f000 f88a 	bl	800e1fc <lv_btn_set_style>
            lv_btn_set_style(new_btn, LV_BTN_STYLE_INA, th->style.btn.ina);
 800e0e8:	68bb      	ldr	r3, [r7, #8]
 800e0ea:	6a1b      	ldr	r3, [r3, #32]
 800e0ec:	461a      	mov	r2, r3
 800e0ee:	2104      	movs	r1, #4
 800e0f0:	6978      	ldr	r0, [r7, #20]
 800e0f2:	f000 f883 	bl	800e1fc <lv_btn_set_style>
 800e0f6:	e029      	b.n	800e14c <lv_btn_create+0x1a8>
        } else {
            lv_obj_set_style(new_btn, ext->styles[LV_BTN_STATE_REL]);
 800e0f8:	693b      	ldr	r3, [r7, #16]
 800e0fa:	685b      	ldr	r3, [r3, #4]
 800e0fc:	4619      	mov	r1, r3
 800e0fe:	6978      	ldr	r0, [r7, #20]
 800e100:	f7f3 ff1c 	bl	8001f3c <lv_obj_set_style>
 800e104:	e022      	b.n	800e14c <lv_btn_create+0x1a8>
        }
    }
    /*Copy 'copy'*/
    else {
        lv_btn_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 800e106:	6838      	ldr	r0, [r7, #0]
 800e108:	f7f4 fc5c 	bl	80029c4 <lv_obj_get_ext_attr>
 800e10c:	60f8      	str	r0, [r7, #12]
        ext->state              = copy_ext->state;
 800e10e:	68fb      	ldr	r3, [r7, #12]
 800e110:	7e1b      	ldrb	r3, [r3, #24]
 800e112:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800e116:	b2d9      	uxtb	r1, r3
 800e118:	693a      	ldr	r2, [r7, #16]
 800e11a:	7e13      	ldrb	r3, [r2, #24]
 800e11c:	f361 0302 	bfi	r3, r1, #0, #3
 800e120:	7613      	strb	r3, [r2, #24]
        ext->toggle             = copy_ext->toggle;
 800e122:	68fb      	ldr	r3, [r7, #12]
 800e124:	7e1b      	ldrb	r3, [r3, #24]
 800e126:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800e12a:	b2d9      	uxtb	r1, r3
 800e12c:	693a      	ldr	r2, [r7, #16]
 800e12e:	7e13      	ldrb	r3, [r2, #24]
 800e130:	f361 03c3 	bfi	r3, r1, #3, #1
 800e134:	7613      	strb	r3, [r2, #24]
#if LV_USE_ANIMATION && LV_BTN_INK_EFFECT
        ext->ink_in_time   = copy_ext->ink_in_time;
        ext->ink_wait_time = copy_ext->ink_wait_time;
        ext->ink_out_time  = copy_ext->ink_out_time;
#endif
        memcpy((void*) ext->styles, copy_ext->styles, sizeof(ext->styles));
 800e136:	693b      	ldr	r3, [r7, #16]
 800e138:	1d18      	adds	r0, r3, #4
 800e13a:	68fb      	ldr	r3, [r7, #12]
 800e13c:	3304      	adds	r3, #4
 800e13e:	2214      	movs	r2, #20
 800e140:	4619      	mov	r1, r3
 800e142:	f005 fb01 	bl	8013748 <memcpy>

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_btn);
 800e146:	6978      	ldr	r0, [r7, #20]
 800e148:	f7f3 ff32 	bl	8001fb0 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("button created");

    return new_btn;
 800e14c:	697b      	ldr	r3, [r7, #20]
}
 800e14e:	4618      	mov	r0, r3
 800e150:	371c      	adds	r7, #28
 800e152:	46bd      	mov	sp, r7
 800e154:	bd90      	pop	{r4, r7, pc}
 800e156:	bf00      	nop
 800e158:	080138b4 	.word	0x080138b4
 800e15c:	200082d0 	.word	0x200082d0
 800e160:	200082d4 	.word	0x200082d4
 800e164:	20009680 	.word	0x20009680
 800e168:	200096c0 	.word	0x200096c0
 800e16c:	20009840 	.word	0x20009840
 800e170:	200098c0 	.word	0x200098c0
 800e174:	20009780 	.word	0x20009780
 800e178:	0800e34d 	.word	0x0800e34d
 800e17c:	0800e301 	.word	0x0800e301

0800e180 <lv_btn_set_state>:
 * Set the state of the button
 * @param btn pointer to a button object
 * @param state the new state of the button (from lv_btn_state_t enum)
 */
void lv_btn_set_state(lv_obj_t * btn, lv_btn_state_t state)
{
 800e180:	b590      	push	{r4, r7, lr}
 800e182:	b085      	sub	sp, #20
 800e184:	af00      	add	r7, sp, #0
 800e186:	6078      	str	r0, [r7, #4]
 800e188:	460b      	mov	r3, r1
 800e18a:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(btn, LV_OBJX_NAME);
 800e18c:	6878      	ldr	r0, [r7, #4]
 800e18e:	f7f2 f833 	bl	80001f8 <lv_debug_check_null>
 800e192:	4603      	mov	r3, r0
 800e194:	f083 0301 	eor.w	r3, r3, #1
 800e198:	b2db      	uxtb	r3, r3
 800e19a:	2b00      	cmp	r3, #0
 800e19c:	d008      	beq.n	800e1b0 <lv_btn_set_state+0x30>
 800e19e:	687b      	ldr	r3, [r7, #4]
 800e1a0:	f04f 0400 	mov.w	r4, #0
 800e1a4:	461a      	mov	r2, r3
 800e1a6:	4623      	mov	r3, r4
 800e1a8:	4813      	ldr	r0, [pc, #76]	; (800e1f8 <lv_btn_set_state+0x78>)
 800e1aa:	f7f2 f84f 	bl	800024c <lv_debug_log_error>
 800e1ae:	e7fe      	b.n	800e1ae <lv_btn_set_state+0x2e>

    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
 800e1b0:	6878      	ldr	r0, [r7, #4]
 800e1b2:	f7f4 fc07 	bl	80029c4 <lv_obj_get_ext_attr>
 800e1b6:	60f8      	str	r0, [r7, #12]
    if(ext->state != state) {
 800e1b8:	68fb      	ldr	r3, [r7, #12]
 800e1ba:	7e1b      	ldrb	r3, [r3, #24]
 800e1bc:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800e1c0:	b2db      	uxtb	r3, r3
 800e1c2:	461a      	mov	r2, r3
 800e1c4:	78fb      	ldrb	r3, [r7, #3]
 800e1c6:	429a      	cmp	r2, r3
 800e1c8:	d011      	beq.n	800e1ee <lv_btn_set_state+0x6e>
        ext->state = state;
 800e1ca:	78fb      	ldrb	r3, [r7, #3]
 800e1cc:	f003 0307 	and.w	r3, r3, #7
 800e1d0:	b2d9      	uxtb	r1, r3
 800e1d2:	68fa      	ldr	r2, [r7, #12]
 800e1d4:	7e13      	ldrb	r3, [r2, #24]
 800e1d6:	f361 0302 	bfi	r3, r1, #0, #3
 800e1da:	7613      	strb	r3, [r2, #24]
        lv_obj_set_style(btn, ext->styles[state]);
 800e1dc:	78fb      	ldrb	r3, [r7, #3]
 800e1de:	68fa      	ldr	r2, [r7, #12]
 800e1e0:	009b      	lsls	r3, r3, #2
 800e1e2:	4413      	add	r3, r2
 800e1e4:	685b      	ldr	r3, [r3, #4]
 800e1e6:	4619      	mov	r1, r3
 800e1e8:	6878      	ldr	r0, [r7, #4]
 800e1ea:	f7f3 fea7 	bl	8001f3c <lv_obj_set_style>
    }
}
 800e1ee:	bf00      	nop
 800e1f0:	3714      	adds	r7, #20
 800e1f2:	46bd      	mov	sp, r7
 800e1f4:	bd90      	pop	{r4, r7, pc}
 800e1f6:	bf00      	nop
 800e1f8:	080138c4 	.word	0x080138c4

0800e1fc <lv_btn_set_style>:
 * @param btn pointer to a button object
 * @param type which style should be set
 * @param style pointer to a style
 */
void lv_btn_set_style(lv_obj_t * btn, lv_btn_style_t type, const lv_style_t * style)
{
 800e1fc:	b590      	push	{r4, r7, lr}
 800e1fe:	b087      	sub	sp, #28
 800e200:	af00      	add	r7, sp, #0
 800e202:	60f8      	str	r0, [r7, #12]
 800e204:	460b      	mov	r3, r1
 800e206:	607a      	str	r2, [r7, #4]
 800e208:	72fb      	strb	r3, [r7, #11]
    LV_ASSERT_OBJ(btn, LV_OBJX_NAME);
 800e20a:	68f8      	ldr	r0, [r7, #12]
 800e20c:	f7f1 fff4 	bl	80001f8 <lv_debug_check_null>
 800e210:	4603      	mov	r3, r0
 800e212:	f083 0301 	eor.w	r3, r3, #1
 800e216:	b2db      	uxtb	r3, r3
 800e218:	2b00      	cmp	r3, #0
 800e21a:	d008      	beq.n	800e22e <lv_btn_set_style+0x32>
 800e21c:	68fb      	ldr	r3, [r7, #12]
 800e21e:	f04f 0400 	mov.w	r4, #0
 800e222:	461a      	mov	r2, r3
 800e224:	4623      	mov	r3, r4
 800e226:	481f      	ldr	r0, [pc, #124]	; (800e2a4 <lv_btn_set_style+0xa8>)
 800e228:	f7f2 f810 	bl	800024c <lv_debug_log_error>
 800e22c:	e7fe      	b.n	800e22c <lv_btn_set_style+0x30>

    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
 800e22e:	68f8      	ldr	r0, [r7, #12]
 800e230:	f7f4 fbc8 	bl	80029c4 <lv_obj_get_ext_attr>
 800e234:	6178      	str	r0, [r7, #20]

    switch(type) {
 800e236:	7afb      	ldrb	r3, [r7, #11]
 800e238:	2b04      	cmp	r3, #4
 800e23a:	d821      	bhi.n	800e280 <lv_btn_set_style+0x84>
 800e23c:	a201      	add	r2, pc, #4	; (adr r2, 800e244 <lv_btn_set_style+0x48>)
 800e23e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e242:	bf00      	nop
 800e244:	0800e259 	.word	0x0800e259
 800e248:	0800e261 	.word	0x0800e261
 800e24c:	0800e269 	.word	0x0800e269
 800e250:	0800e271 	.word	0x0800e271
 800e254:	0800e279 	.word	0x0800e279
        case LV_BTN_STYLE_REL: ext->styles[LV_BTN_STATE_REL] = style; break;
 800e258:	697b      	ldr	r3, [r7, #20]
 800e25a:	687a      	ldr	r2, [r7, #4]
 800e25c:	605a      	str	r2, [r3, #4]
 800e25e:	e00f      	b.n	800e280 <lv_btn_set_style+0x84>
        case LV_BTN_STYLE_PR: ext->styles[LV_BTN_STATE_PR] = style; break;
 800e260:	697b      	ldr	r3, [r7, #20]
 800e262:	687a      	ldr	r2, [r7, #4]
 800e264:	609a      	str	r2, [r3, #8]
 800e266:	e00b      	b.n	800e280 <lv_btn_set_style+0x84>
        case LV_BTN_STYLE_TGL_REL: ext->styles[LV_BTN_STATE_TGL_REL] = style; break;
 800e268:	697b      	ldr	r3, [r7, #20]
 800e26a:	687a      	ldr	r2, [r7, #4]
 800e26c:	60da      	str	r2, [r3, #12]
 800e26e:	e007      	b.n	800e280 <lv_btn_set_style+0x84>
        case LV_BTN_STYLE_TGL_PR: ext->styles[LV_BTN_STATE_TGL_PR] = style; break;
 800e270:	697b      	ldr	r3, [r7, #20]
 800e272:	687a      	ldr	r2, [r7, #4]
 800e274:	611a      	str	r2, [r3, #16]
 800e276:	e003      	b.n	800e280 <lv_btn_set_style+0x84>
        case LV_BTN_STYLE_INA: ext->styles[LV_BTN_STATE_INA] = style; break;
 800e278:	697b      	ldr	r3, [r7, #20]
 800e27a:	687a      	ldr	r2, [r7, #4]
 800e27c:	615a      	str	r2, [r3, #20]
 800e27e:	bf00      	nop
    }

    /*Refresh the object with the new style*/
    lv_obj_set_style(btn, ext->styles[ext->state]);
 800e280:	697b      	ldr	r3, [r7, #20]
 800e282:	7e1b      	ldrb	r3, [r3, #24]
 800e284:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800e288:	b2db      	uxtb	r3, r3
 800e28a:	697a      	ldr	r2, [r7, #20]
 800e28c:	009b      	lsls	r3, r3, #2
 800e28e:	4413      	add	r3, r2
 800e290:	685b      	ldr	r3, [r3, #4]
 800e292:	4619      	mov	r1, r3
 800e294:	68f8      	ldr	r0, [r7, #12]
 800e296:	f7f3 fe51 	bl	8001f3c <lv_obj_set_style>
}
 800e29a:	bf00      	nop
 800e29c:	371c      	adds	r7, #28
 800e29e:	46bd      	mov	sp, r7
 800e2a0:	bd90      	pop	{r4, r7, pc}
 800e2a2:	bf00      	nop
 800e2a4:	080138c4 	.word	0x080138c4

0800e2a8 <lv_btn_get_toggle>:
 * Get the toggle enable attribute of the button
 * @param btn pointer to a button object
 * @return true: toggle enabled, false: disabled
 */
bool lv_btn_get_toggle(const lv_obj_t * btn)
{
 800e2a8:	b590      	push	{r4, r7, lr}
 800e2aa:	b085      	sub	sp, #20
 800e2ac:	af00      	add	r7, sp, #0
 800e2ae:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(btn, LV_OBJX_NAME);
 800e2b0:	6878      	ldr	r0, [r7, #4]
 800e2b2:	f7f1 ffa1 	bl	80001f8 <lv_debug_check_null>
 800e2b6:	4603      	mov	r3, r0
 800e2b8:	f083 0301 	eor.w	r3, r3, #1
 800e2bc:	b2db      	uxtb	r3, r3
 800e2be:	2b00      	cmp	r3, #0
 800e2c0:	d008      	beq.n	800e2d4 <lv_btn_get_toggle+0x2c>
 800e2c2:	687b      	ldr	r3, [r7, #4]
 800e2c4:	f04f 0400 	mov.w	r4, #0
 800e2c8:	461a      	mov	r2, r3
 800e2ca:	4623      	mov	r3, r4
 800e2cc:	480b      	ldr	r0, [pc, #44]	; (800e2fc <lv_btn_get_toggle+0x54>)
 800e2ce:	f7f1 ffbd 	bl	800024c <lv_debug_log_error>
 800e2d2:	e7fe      	b.n	800e2d2 <lv_btn_get_toggle+0x2a>

    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
 800e2d4:	6878      	ldr	r0, [r7, #4]
 800e2d6:	f7f4 fb75 	bl	80029c4 <lv_obj_get_ext_attr>
 800e2da:	60f8      	str	r0, [r7, #12]

    return ext->toggle != 0 ? true : false;
 800e2dc:	68fb      	ldr	r3, [r7, #12]
 800e2de:	7e1b      	ldrb	r3, [r3, #24]
 800e2e0:	08db      	lsrs	r3, r3, #3
 800e2e2:	b2db      	uxtb	r3, r3
 800e2e4:	f003 0301 	and.w	r3, r3, #1
 800e2e8:	2b00      	cmp	r3, #0
 800e2ea:	bf14      	ite	ne
 800e2ec:	2301      	movne	r3, #1
 800e2ee:	2300      	moveq	r3, #0
 800e2f0:	b2db      	uxtb	r3, r3
}
 800e2f2:	4618      	mov	r0, r3
 800e2f4:	3714      	adds	r7, #20
 800e2f6:	46bd      	mov	sp, r7
 800e2f8:	bd90      	pop	{r4, r7, pc}
 800e2fa:	bf00      	nop
 800e2fc:	080138c4 	.word	0x080138c4

0800e300 <lv_btn_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_btn_design(lv_obj_t * btn, const lv_area_t * mask, lv_design_mode_t mode)
{
 800e300:	b580      	push	{r7, lr}
 800e302:	b084      	sub	sp, #16
 800e304:	af00      	add	r7, sp, #0
 800e306:	60f8      	str	r0, [r7, #12]
 800e308:	60b9      	str	r1, [r7, #8]
 800e30a:	4613      	mov	r3, r2
 800e30c:	71fb      	strb	r3, [r7, #7]
    if(mode == LV_DESIGN_COVER_CHK) {
 800e30e:	79fb      	ldrb	r3, [r7, #7]
 800e310:	2b02      	cmp	r3, #2
 800e312:	d101      	bne.n	800e318 <lv_btn_design+0x18>
        return false;
 800e314:	2300      	movs	r3, #0
 800e316:	e013      	b.n	800e340 <lv_btn_design+0x40>
    } else if(mode == LV_DESIGN_DRAW_MAIN) {
 800e318:	79fb      	ldrb	r3, [r7, #7]
 800e31a:	2b00      	cmp	r3, #0
 800e31c:	d106      	bne.n	800e32c <lv_btn_design+0x2c>
                lv_style_mix(ext->styles[ink_bg_state], ext->styles[ink_top_state], &res, ink_act_value);
                lv_draw_rect(&btn->coords, mask, &res, opa_scale);
            }
        }
#else
        ancestor_design(btn, mask, mode);
 800e31e:	4b0a      	ldr	r3, [pc, #40]	; (800e348 <lv_btn_design+0x48>)
 800e320:	681b      	ldr	r3, [r3, #0]
 800e322:	79fa      	ldrb	r2, [r7, #7]
 800e324:	68b9      	ldr	r1, [r7, #8]
 800e326:	68f8      	ldr	r0, [r7, #12]
 800e328:	4798      	blx	r3
 800e32a:	e008      	b.n	800e33e <lv_btn_design+0x3e>
#endif
    } else if(mode == LV_DESIGN_DRAW_POST) {
 800e32c:	79fb      	ldrb	r3, [r7, #7]
 800e32e:	2b01      	cmp	r3, #1
 800e330:	d105      	bne.n	800e33e <lv_btn_design+0x3e>
        ancestor_design(btn, mask, mode);
 800e332:	4b05      	ldr	r3, [pc, #20]	; (800e348 <lv_btn_design+0x48>)
 800e334:	681b      	ldr	r3, [r3, #0]
 800e336:	79fa      	ldrb	r2, [r7, #7]
 800e338:	68b9      	ldr	r1, [r7, #8]
 800e33a:	68f8      	ldr	r0, [r7, #12]
 800e33c:	4798      	blx	r3
    }

    return true;
 800e33e:	2301      	movs	r3, #1
}
 800e340:	4618      	mov	r0, r3
 800e342:	3710      	adds	r7, #16
 800e344:	46bd      	mov	sp, r7
 800e346:	bd80      	pop	{r7, pc}
 800e348:	200082d4 	.word	0x200082d4

0800e34c <lv_btn_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_btn_signal(lv_obj_t * btn, lv_signal_t sign, void * param)
{
 800e34c:	b580      	push	{r7, lr}
 800e34e:	b08a      	sub	sp, #40	; 0x28
 800e350:	af00      	add	r7, sp, #0
 800e352:	60f8      	str	r0, [r7, #12]
 800e354:	460b      	mov	r3, r1
 800e356:	607a      	str	r2, [r7, #4]
 800e358:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(btn, sign, param);
 800e35a:	4ba9      	ldr	r3, [pc, #676]	; (800e600 <lv_btn_signal+0x2b4>)
 800e35c:	681b      	ldr	r3, [r3, #0]
 800e35e:	7af9      	ldrb	r1, [r7, #11]
 800e360:	687a      	ldr	r2, [r7, #4]
 800e362:	68f8      	ldr	r0, [r7, #12]
 800e364:	4798      	blx	r3
 800e366:	4603      	mov	r3, r0
 800e368:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    if(res != LV_RES_OK) return res;
 800e36c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800e370:	2b01      	cmp	r3, #1
 800e372:	d002      	beq.n	800e37a <lv_btn_signal+0x2e>
 800e374:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800e378:	e13e      	b.n	800e5f8 <lv_btn_signal+0x2ac>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
 800e37a:	7afb      	ldrb	r3, [r7, #11]
 800e37c:	2b07      	cmp	r3, #7
 800e37e:	d105      	bne.n	800e38c <lv_btn_signal+0x40>
 800e380:	49a0      	ldr	r1, [pc, #640]	; (800e604 <lv_btn_signal+0x2b8>)
 800e382:	6878      	ldr	r0, [r7, #4]
 800e384:	f7f4 fb86 	bl	8002a94 <lv_obj_handle_get_type_signal>
 800e388:	4603      	mov	r3, r0
 800e38a:	e135      	b.n	800e5f8 <lv_btn_signal+0x2ac>

    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
 800e38c:	68f8      	ldr	r0, [r7, #12]
 800e38e:	f7f4 fb19 	bl	80029c4 <lv_obj_get_ext_attr>
 800e392:	6238      	str	r0, [r7, #32]
    bool tgl           = lv_btn_get_toggle(btn);
 800e394:	68f8      	ldr	r0, [r7, #12]
 800e396:	f7ff ff87 	bl	800e2a8 <lv_btn_get_toggle>
 800e39a:	4603      	mov	r3, r0
 800e39c:	77fb      	strb	r3, [r7, #31]

    if(sign == LV_SIGNAL_PRESSED) {
 800e39e:	7afb      	ldrb	r3, [r7, #11]
 800e3a0:	2b08      	cmp	r3, #8
 800e3a2:	d118      	bne.n	800e3d6 <lv_btn_signal+0x8a>
        /*Refresh the state*/
        if(ext->state == LV_BTN_STATE_REL) {
 800e3a4:	6a3b      	ldr	r3, [r7, #32]
 800e3a6:	7e1b      	ldrb	r3, [r3, #24]
 800e3a8:	f003 0307 	and.w	r3, r3, #7
 800e3ac:	b2db      	uxtb	r3, r3
 800e3ae:	2b00      	cmp	r3, #0
 800e3b0:	d104      	bne.n	800e3bc <lv_btn_signal+0x70>
            lv_btn_set_state(btn, LV_BTN_STATE_PR);
 800e3b2:	2101      	movs	r1, #1
 800e3b4:	68f8      	ldr	r0, [r7, #12]
 800e3b6:	f7ff fee3 	bl	800e180 <lv_btn_set_state>
 800e3ba:	e11b      	b.n	800e5f4 <lv_btn_signal+0x2a8>
#if LV_USE_ANIMATION && LV_BTN_INK_EFFECT
            ink_bg_state  = LV_BTN_STATE_REL;
            ink_top_state = LV_BTN_STATE_PR;
#endif
        } else if(ext->state == LV_BTN_STATE_TGL_REL) {
 800e3bc:	6a3b      	ldr	r3, [r7, #32]
 800e3be:	7e1b      	ldrb	r3, [r3, #24]
 800e3c0:	f003 0307 	and.w	r3, r3, #7
 800e3c4:	b2db      	uxtb	r3, r3
 800e3c6:	2b02      	cmp	r3, #2
 800e3c8:	f040 8114 	bne.w	800e5f4 <lv_btn_signal+0x2a8>
            lv_btn_set_state(btn, LV_BTN_STATE_TGL_PR);
 800e3cc:	2103      	movs	r1, #3
 800e3ce:	68f8      	ldr	r0, [r7, #12]
 800e3d0:	f7ff fed6 	bl	800e180 <lv_btn_set_state>
 800e3d4:	e10e      	b.n	800e5f4 <lv_btn_signal+0x2a8>
            a.repeat         = 0;
            a.repeat_pause   = 0;
            lv_anim_create(&a);
        }
#endif
    } else if(sign == LV_SIGNAL_PRESS_LOST) {
 800e3d6:	7afb      	ldrb	r3, [r7, #11]
 800e3d8:	2b0a      	cmp	r3, #10
 800e3da:	d118      	bne.n	800e40e <lv_btn_signal+0xc2>
        /*Refresh the state*/
        if(ext->state == LV_BTN_STATE_PR)
 800e3dc:	6a3b      	ldr	r3, [r7, #32]
 800e3de:	7e1b      	ldrb	r3, [r3, #24]
 800e3e0:	f003 0307 	and.w	r3, r3, #7
 800e3e4:	b2db      	uxtb	r3, r3
 800e3e6:	2b01      	cmp	r3, #1
 800e3e8:	d104      	bne.n	800e3f4 <lv_btn_signal+0xa8>
            lv_btn_set_state(btn, LV_BTN_STATE_REL);
 800e3ea:	2100      	movs	r1, #0
 800e3ec:	68f8      	ldr	r0, [r7, #12]
 800e3ee:	f7ff fec7 	bl	800e180 <lv_btn_set_state>
 800e3f2:	e0ff      	b.n	800e5f4 <lv_btn_signal+0x2a8>
        else if(ext->state == LV_BTN_STATE_TGL_PR)
 800e3f4:	6a3b      	ldr	r3, [r7, #32]
 800e3f6:	7e1b      	ldrb	r3, [r3, #24]
 800e3f8:	f003 0307 	and.w	r3, r3, #7
 800e3fc:	b2db      	uxtb	r3, r3
 800e3fe:	2b03      	cmp	r3, #3
 800e400:	f040 80f8 	bne.w	800e5f4 <lv_btn_signal+0x2a8>
            lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 800e404:	2102      	movs	r1, #2
 800e406:	68f8      	ldr	r0, [r7, #12]
 800e408:	f7ff feba 	bl	800e180 <lv_btn_set_state>
 800e40c:	e0f2      	b.n	800e5f4 <lv_btn_signal+0x2a8>
    } else if(sign == LV_SIGNAL_PRESSING) {
 800e40e:	7afb      	ldrb	r3, [r7, #11]
 800e410:	2b09      	cmp	r3, #9
 800e412:	d11f      	bne.n	800e454 <lv_btn_signal+0x108>
        /*When the button begins to drag revert pressed states to released*/
        if(lv_indev_is_dragging(param) != false) {
 800e414:	6878      	ldr	r0, [r7, #4]
 800e416:	f7f2 fa1d 	bl	8000854 <lv_indev_is_dragging>
 800e41a:	4603      	mov	r3, r0
 800e41c:	2b00      	cmp	r3, #0
 800e41e:	f000 80e9 	beq.w	800e5f4 <lv_btn_signal+0x2a8>
            if(ext->state == LV_BTN_STATE_PR)
 800e422:	6a3b      	ldr	r3, [r7, #32]
 800e424:	7e1b      	ldrb	r3, [r3, #24]
 800e426:	f003 0307 	and.w	r3, r3, #7
 800e42a:	b2db      	uxtb	r3, r3
 800e42c:	2b01      	cmp	r3, #1
 800e42e:	d104      	bne.n	800e43a <lv_btn_signal+0xee>
                lv_btn_set_state(btn, LV_BTN_STATE_REL);
 800e430:	2100      	movs	r1, #0
 800e432:	68f8      	ldr	r0, [r7, #12]
 800e434:	f7ff fea4 	bl	800e180 <lv_btn_set_state>
 800e438:	e0dc      	b.n	800e5f4 <lv_btn_signal+0x2a8>
            else if(ext->state == LV_BTN_STATE_TGL_PR)
 800e43a:	6a3b      	ldr	r3, [r7, #32]
 800e43c:	7e1b      	ldrb	r3, [r3, #24]
 800e43e:	f003 0307 	and.w	r3, r3, #7
 800e442:	b2db      	uxtb	r3, r3
 800e444:	2b03      	cmp	r3, #3
 800e446:	f040 80d5 	bne.w	800e5f4 <lv_btn_signal+0x2a8>
                lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 800e44a:	2102      	movs	r1, #2
 800e44c:	68f8      	ldr	r0, [r7, #12]
 800e44e:	f7ff fe97 	bl	800e180 <lv_btn_set_state>
 800e452:	e0cf      	b.n	800e5f4 <lv_btn_signal+0x2a8>
        }
    } else if(sign == LV_SIGNAL_RELEASED) {
 800e454:	7afb      	ldrb	r3, [r7, #11]
 800e456:	2b0b      	cmp	r3, #11
 800e458:	d17f      	bne.n	800e55a <lv_btn_signal+0x20e>
        /*If not dragged and it was not long press action then
         *change state and run the action*/
        if(lv_indev_is_dragging(param) == false) {
 800e45a:	6878      	ldr	r0, [r7, #4]
 800e45c:	f7f2 f9fa 	bl	8000854 <lv_indev_is_dragging>
 800e460:	4603      	mov	r3, r0
 800e462:	f083 0301 	eor.w	r3, r3, #1
 800e466:	b2db      	uxtb	r3, r3
 800e468:	2b00      	cmp	r3, #0
 800e46a:	d05e      	beq.n	800e52a <lv_btn_signal+0x1de>
            uint32_t toggled = 0;
 800e46c:	2300      	movs	r3, #0
 800e46e:	61bb      	str	r3, [r7, #24]
            if(ext->state == LV_BTN_STATE_PR && tgl == false) {
 800e470:	6a3b      	ldr	r3, [r7, #32]
 800e472:	7e1b      	ldrb	r3, [r3, #24]
 800e474:	f003 0307 	and.w	r3, r3, #7
 800e478:	b2db      	uxtb	r3, r3
 800e47a:	2b01      	cmp	r3, #1
 800e47c:	d10c      	bne.n	800e498 <lv_btn_signal+0x14c>
 800e47e:	7ffb      	ldrb	r3, [r7, #31]
 800e480:	f083 0301 	eor.w	r3, r3, #1
 800e484:	b2db      	uxtb	r3, r3
 800e486:	2b00      	cmp	r3, #0
 800e488:	d006      	beq.n	800e498 <lv_btn_signal+0x14c>
                lv_btn_set_state(btn, LV_BTN_STATE_REL);
 800e48a:	2100      	movs	r1, #0
 800e48c:	68f8      	ldr	r0, [r7, #12]
 800e48e:	f7ff fe77 	bl	800e180 <lv_btn_set_state>
                toggled = 0;
 800e492:	2300      	movs	r3, #0
 800e494:	61bb      	str	r3, [r7, #24]
 800e496:	e034      	b.n	800e502 <lv_btn_signal+0x1b6>
            } else if(ext->state == LV_BTN_STATE_TGL_PR && tgl == false) {
 800e498:	6a3b      	ldr	r3, [r7, #32]
 800e49a:	7e1b      	ldrb	r3, [r3, #24]
 800e49c:	f003 0307 	and.w	r3, r3, #7
 800e4a0:	b2db      	uxtb	r3, r3
 800e4a2:	2b03      	cmp	r3, #3
 800e4a4:	d10c      	bne.n	800e4c0 <lv_btn_signal+0x174>
 800e4a6:	7ffb      	ldrb	r3, [r7, #31]
 800e4a8:	f083 0301 	eor.w	r3, r3, #1
 800e4ac:	b2db      	uxtb	r3, r3
 800e4ae:	2b00      	cmp	r3, #0
 800e4b0:	d006      	beq.n	800e4c0 <lv_btn_signal+0x174>
                lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 800e4b2:	2102      	movs	r1, #2
 800e4b4:	68f8      	ldr	r0, [r7, #12]
 800e4b6:	f7ff fe63 	bl	800e180 <lv_btn_set_state>
                toggled = 1;
 800e4ba:	2301      	movs	r3, #1
 800e4bc:	61bb      	str	r3, [r7, #24]
 800e4be:	e020      	b.n	800e502 <lv_btn_signal+0x1b6>
            } else if(ext->state == LV_BTN_STATE_PR && tgl == true) {
 800e4c0:	6a3b      	ldr	r3, [r7, #32]
 800e4c2:	7e1b      	ldrb	r3, [r3, #24]
 800e4c4:	f003 0307 	and.w	r3, r3, #7
 800e4c8:	b2db      	uxtb	r3, r3
 800e4ca:	2b01      	cmp	r3, #1
 800e4cc:	d109      	bne.n	800e4e2 <lv_btn_signal+0x196>
 800e4ce:	7ffb      	ldrb	r3, [r7, #31]
 800e4d0:	2b00      	cmp	r3, #0
 800e4d2:	d006      	beq.n	800e4e2 <lv_btn_signal+0x196>
                lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 800e4d4:	2102      	movs	r1, #2
 800e4d6:	68f8      	ldr	r0, [r7, #12]
 800e4d8:	f7ff fe52 	bl	800e180 <lv_btn_set_state>
                toggled = 1;
 800e4dc:	2301      	movs	r3, #1
 800e4de:	61bb      	str	r3, [r7, #24]
 800e4e0:	e00f      	b.n	800e502 <lv_btn_signal+0x1b6>
            } else if(ext->state == LV_BTN_STATE_TGL_PR && tgl == true) {
 800e4e2:	6a3b      	ldr	r3, [r7, #32]
 800e4e4:	7e1b      	ldrb	r3, [r3, #24]
 800e4e6:	f003 0307 	and.w	r3, r3, #7
 800e4ea:	b2db      	uxtb	r3, r3
 800e4ec:	2b03      	cmp	r3, #3
 800e4ee:	d108      	bne.n	800e502 <lv_btn_signal+0x1b6>
 800e4f0:	7ffb      	ldrb	r3, [r7, #31]
 800e4f2:	2b00      	cmp	r3, #0
 800e4f4:	d005      	beq.n	800e502 <lv_btn_signal+0x1b6>
                lv_btn_set_state(btn, LV_BTN_STATE_REL);
 800e4f6:	2100      	movs	r1, #0
 800e4f8:	68f8      	ldr	r0, [r7, #12]
 800e4fa:	f7ff fe41 	bl	800e180 <lv_btn_set_state>
                toggled = 0;
 800e4fe:	2300      	movs	r3, #0
 800e500:	61bb      	str	r3, [r7, #24]
            }

            if(tgl) {
 800e502:	7ffb      	ldrb	r3, [r7, #31]
 800e504:	2b00      	cmp	r3, #0
 800e506:	d075      	beq.n	800e5f4 <lv_btn_signal+0x2a8>
                res = lv_event_send(btn, LV_EVENT_VALUE_CHANGED, &toggled);
 800e508:	f107 0318 	add.w	r3, r7, #24
 800e50c:	461a      	mov	r2, r3
 800e50e:	210e      	movs	r1, #14
 800e510:	68f8      	ldr	r0, [r7, #12]
 800e512:	f7f3 fded 	bl	80020f0 <lv_event_send>
 800e516:	4603      	mov	r3, r0
 800e518:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                if(res != LV_RES_OK) return res;
 800e51c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800e520:	2b01      	cmp	r3, #1
 800e522:	d067      	beq.n	800e5f4 <lv_btn_signal+0x2a8>
 800e524:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800e528:	e066      	b.n	800e5f8 <lv_btn_signal+0x2ac>
            }

        } else { /*If dragged change back the state*/
            if(ext->state == LV_BTN_STATE_PR) {
 800e52a:	6a3b      	ldr	r3, [r7, #32]
 800e52c:	7e1b      	ldrb	r3, [r3, #24]
 800e52e:	f003 0307 	and.w	r3, r3, #7
 800e532:	b2db      	uxtb	r3, r3
 800e534:	2b01      	cmp	r3, #1
 800e536:	d104      	bne.n	800e542 <lv_btn_signal+0x1f6>
                lv_btn_set_state(btn, LV_BTN_STATE_REL);
 800e538:	2100      	movs	r1, #0
 800e53a:	68f8      	ldr	r0, [r7, #12]
 800e53c:	f7ff fe20 	bl	800e180 <lv_btn_set_state>
 800e540:	e058      	b.n	800e5f4 <lv_btn_signal+0x2a8>
            } else if(ext->state == LV_BTN_STATE_TGL_PR) {
 800e542:	6a3b      	ldr	r3, [r7, #32]
 800e544:	7e1b      	ldrb	r3, [r3, #24]
 800e546:	f003 0307 	and.w	r3, r3, #7
 800e54a:	b2db      	uxtb	r3, r3
 800e54c:	2b03      	cmp	r3, #3
 800e54e:	d151      	bne.n	800e5f4 <lv_btn_signal+0x2a8>
                lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 800e550:	2102      	movs	r1, #2
 800e552:	68f8      	ldr	r0, [r7, #12]
 800e554:	f7ff fe14 	bl	800e180 <lv_btn_set_state>
 800e558:	e04c      	b.n	800e5f4 <lv_btn_signal+0x2a8>
            a.repeat         = 0;
            a.repeat_pause   = 0;
            lv_anim_create(&a);
        }
#endif
    } else if(sign == LV_SIGNAL_CONTROL) {
 800e55a:	7afb      	ldrb	r3, [r7, #11]
 800e55c:	2b12      	cmp	r3, #18
 800e55e:	d149      	bne.n	800e5f4 <lv_btn_signal+0x2a8>
        char c = *((char *)param);
 800e560:	687b      	ldr	r3, [r7, #4]
 800e562:	781b      	ldrb	r3, [r3, #0]
 800e564:	77bb      	strb	r3, [r7, #30]
        if(c == LV_KEY_RIGHT || c == LV_KEY_UP) {
 800e566:	7fbb      	ldrb	r3, [r7, #30]
 800e568:	2b13      	cmp	r3, #19
 800e56a:	d002      	beq.n	800e572 <lv_btn_signal+0x226>
 800e56c:	7fbb      	ldrb	r3, [r7, #30]
 800e56e:	2b11      	cmp	r3, #17
 800e570:	d11c      	bne.n	800e5ac <lv_btn_signal+0x260>
            if(lv_btn_get_toggle(btn)) {
 800e572:	68f8      	ldr	r0, [r7, #12]
 800e574:	f7ff fe98 	bl	800e2a8 <lv_btn_get_toggle>
 800e578:	4603      	mov	r3, r0
 800e57a:	2b00      	cmp	r3, #0
 800e57c:	d039      	beq.n	800e5f2 <lv_btn_signal+0x2a6>
                lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 800e57e:	2102      	movs	r1, #2
 800e580:	68f8      	ldr	r0, [r7, #12]
 800e582:	f7ff fdfd 	bl	800e180 <lv_btn_set_state>

                uint32_t state = 1;
 800e586:	2301      	movs	r3, #1
 800e588:	617b      	str	r3, [r7, #20]
                res            = lv_event_send(btn, LV_EVENT_VALUE_CHANGED, &state);
 800e58a:	f107 0314 	add.w	r3, r7, #20
 800e58e:	461a      	mov	r2, r3
 800e590:	210e      	movs	r1, #14
 800e592:	68f8      	ldr	r0, [r7, #12]
 800e594:	f7f3 fdac 	bl	80020f0 <lv_event_send>
 800e598:	4603      	mov	r3, r0
 800e59a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                if(res != LV_RES_OK) return res;
 800e59e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800e5a2:	2b01      	cmp	r3, #1
 800e5a4:	d025      	beq.n	800e5f2 <lv_btn_signal+0x2a6>
 800e5a6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800e5aa:	e025      	b.n	800e5f8 <lv_btn_signal+0x2ac>
            }

        } else if(c == LV_KEY_LEFT || c == LV_KEY_DOWN) {
 800e5ac:	7fbb      	ldrb	r3, [r7, #30]
 800e5ae:	2b14      	cmp	r3, #20
 800e5b0:	d002      	beq.n	800e5b8 <lv_btn_signal+0x26c>
 800e5b2:	7fbb      	ldrb	r3, [r7, #30]
 800e5b4:	2b12      	cmp	r3, #18
 800e5b6:	d11d      	bne.n	800e5f4 <lv_btn_signal+0x2a8>
            if(lv_btn_get_toggle(btn)) {
 800e5b8:	68f8      	ldr	r0, [r7, #12]
 800e5ba:	f7ff fe75 	bl	800e2a8 <lv_btn_get_toggle>
 800e5be:	4603      	mov	r3, r0
 800e5c0:	2b00      	cmp	r3, #0
 800e5c2:	d017      	beq.n	800e5f4 <lv_btn_signal+0x2a8>
                lv_btn_set_state(btn, LV_BTN_STATE_REL);
 800e5c4:	2100      	movs	r1, #0
 800e5c6:	68f8      	ldr	r0, [r7, #12]
 800e5c8:	f7ff fdda 	bl	800e180 <lv_btn_set_state>

                uint32_t state = 0;
 800e5cc:	2300      	movs	r3, #0
 800e5ce:	613b      	str	r3, [r7, #16]
                res            = lv_event_send(btn, LV_EVENT_VALUE_CHANGED, &state);
 800e5d0:	f107 0310 	add.w	r3, r7, #16
 800e5d4:	461a      	mov	r2, r3
 800e5d6:	210e      	movs	r1, #14
 800e5d8:	68f8      	ldr	r0, [r7, #12]
 800e5da:	f7f3 fd89 	bl	80020f0 <lv_event_send>
 800e5de:	4603      	mov	r3, r0
 800e5e0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                if(res != LV_RES_OK) return res;
 800e5e4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800e5e8:	2b01      	cmp	r3, #1
 800e5ea:	d003      	beq.n	800e5f4 <lv_btn_signal+0x2a8>
 800e5ec:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800e5f0:	e002      	b.n	800e5f8 <lv_btn_signal+0x2ac>
            if(lv_btn_get_toggle(btn)) {
 800e5f2:	bf00      	nop
            ink_obj = NULL;
        }
#endif
    }

    return res;
 800e5f4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 800e5f8:	4618      	mov	r0, r3
 800e5fa:	3728      	adds	r7, #40	; 0x28
 800e5fc:	46bd      	mov	sp, r7
 800e5fe:	bd80      	pop	{r7, pc}
 800e600:	200082d0 	.word	0x200082d0
 800e604:	080138d4 	.word	0x080138d4

0800e608 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 800e608:	b580      	push	{r7, lr}
 800e60a:	b082      	sub	sp, #8
 800e60c:	af00      	add	r7, sp, #0
 800e60e:	6078      	str	r0, [r7, #4]
 800e610:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 800e612:	2208      	movs	r2, #8
 800e614:	6839      	ldr	r1, [r7, #0]
 800e616:	6878      	ldr	r0, [r7, #4]
 800e618:	f005 f896 	bl	8013748 <memcpy>
}
 800e61c:	bf00      	nop
 800e61e:	3708      	adds	r7, #8
 800e620:	46bd      	mov	sp, r7
 800e622:	bd80      	pop	{r7, pc}

0800e624 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 800e624:	b480      	push	{r7}
 800e626:	b083      	sub	sp, #12
 800e628:	af00      	add	r7, sp, #0
 800e62a:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 800e62c:	687b      	ldr	r3, [r7, #4]
 800e62e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800e632:	b29a      	uxth	r2, r3
 800e634:	687b      	ldr	r3, [r7, #4]
 800e636:	f9b3 3000 	ldrsh.w	r3, [r3]
 800e63a:	b29b      	uxth	r3, r3
 800e63c:	1ad3      	subs	r3, r2, r3
 800e63e:	b29b      	uxth	r3, r3
 800e640:	3301      	adds	r3, #1
 800e642:	b29b      	uxth	r3, r3
 800e644:	b21b      	sxth	r3, r3
}
 800e646:	4618      	mov	r0, r3
 800e648:	370c      	adds	r7, #12
 800e64a:	46bd      	mov	sp, r7
 800e64c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e650:	4770      	bx	lr

0800e652 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 800e652:	b480      	push	{r7}
 800e654:	b083      	sub	sp, #12
 800e656:	af00      	add	r7, sp, #0
 800e658:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 800e65a:	687b      	ldr	r3, [r7, #4]
 800e65c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800e660:	b29a      	uxth	r2, r3
 800e662:	687b      	ldr	r3, [r7, #4]
 800e664:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800e668:	b29b      	uxth	r3, r3
 800e66a:	1ad3      	subs	r3, r2, r3
 800e66c:	b29b      	uxth	r3, r3
 800e66e:	3301      	adds	r3, #1
 800e670:	b29b      	uxth	r3, r3
 800e672:	b21b      	sxth	r3, r3
}
 800e674:	4618      	mov	r0, r3
 800e676:	370c      	adds	r7, #12
 800e678:	46bd      	mov	sp, r7
 800e67a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e67e:	4770      	bx	lr

0800e680 <lv_cont_set_style>:
 * @param cont pointer to a container object
 * @param type which style should be set (can be only `LV_CONT_STYLE_MAIN`)
 * @param style pointer to the new style
 */
static inline void lv_cont_set_style(lv_obj_t * cont, lv_cont_style_t type, const lv_style_t * style)
{
 800e680:	b580      	push	{r7, lr}
 800e682:	b084      	sub	sp, #16
 800e684:	af00      	add	r7, sp, #0
 800e686:	60f8      	str	r0, [r7, #12]
 800e688:	460b      	mov	r3, r1
 800e68a:	607a      	str	r2, [r7, #4]
 800e68c:	72fb      	strb	r3, [r7, #11]
    (void)type; /*Unused*/
    lv_obj_set_style(cont, style);
 800e68e:	6879      	ldr	r1, [r7, #4]
 800e690:	68f8      	ldr	r0, [r7, #12]
 800e692:	f7f3 fc53 	bl	8001f3c <lv_obj_set_style>
}
 800e696:	bf00      	nop
 800e698:	3710      	adds	r7, #16
 800e69a:	46bd      	mov	sp, r7
 800e69c:	bd80      	pop	{r7, pc}
	...

0800e6a0 <lv_cont_create>:
 * @param par pointer to an object, it will be the parent of the new container
 * @param copy pointer to a container object, if not NULL then the new object will be copied from it
 * @return pointer to the created container
 */
lv_obj_t * lv_cont_create(lv_obj_t * par, const lv_obj_t * copy)
{
 800e6a0:	b590      	push	{r4, r7, lr}
 800e6a2:	b087      	sub	sp, #28
 800e6a4:	af00      	add	r7, sp, #0
 800e6a6:	6078      	str	r0, [r7, #4]
 800e6a8:	6039      	str	r1, [r7, #0]

    LV_LOG_TRACE("container create started");

    /*Create a basic object*/
    lv_obj_t * new_cont = lv_obj_create(par, copy);
 800e6aa:	6839      	ldr	r1, [r7, #0]
 800e6ac:	6878      	ldr	r0, [r7, #4]
 800e6ae:	f7f2 f961 	bl	8000974 <lv_obj_create>
 800e6b2:	6178      	str	r0, [r7, #20]
    LV_ASSERT_MEM(new_cont);
 800e6b4:	6978      	ldr	r0, [r7, #20]
 800e6b6:	f7f1 fd9f 	bl	80001f8 <lv_debug_check_null>
 800e6ba:	4603      	mov	r3, r0
 800e6bc:	f083 0301 	eor.w	r3, r3, #1
 800e6c0:	b2db      	uxtb	r3, r3
 800e6c2:	2b00      	cmp	r3, #0
 800e6c4:	d008      	beq.n	800e6d8 <lv_cont_create+0x38>
 800e6c6:	697b      	ldr	r3, [r7, #20]
 800e6c8:	f04f 0400 	mov.w	r4, #0
 800e6cc:	461a      	mov	r2, r3
 800e6ce:	4623      	mov	r3, r4
 800e6d0:	4853      	ldr	r0, [pc, #332]	; (800e820 <lv_cont_create+0x180>)
 800e6d2:	f7f1 fdbb 	bl	800024c <lv_debug_log_error>
 800e6d6:	e7fe      	b.n	800e6d6 <lv_cont_create+0x36>
    if(new_cont == NULL) return NULL;
 800e6d8:	697b      	ldr	r3, [r7, #20]
 800e6da:	2b00      	cmp	r3, #0
 800e6dc:	d101      	bne.n	800e6e2 <lv_cont_create+0x42>
 800e6de:	2300      	movs	r3, #0
 800e6e0:	e099      	b.n	800e816 <lv_cont_create+0x176>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_cont);
 800e6e2:	4b50      	ldr	r3, [pc, #320]	; (800e824 <lv_cont_create+0x184>)
 800e6e4:	681b      	ldr	r3, [r3, #0]
 800e6e6:	2b00      	cmp	r3, #0
 800e6e8:	d105      	bne.n	800e6f6 <lv_cont_create+0x56>
 800e6ea:	6978      	ldr	r0, [r7, #20]
 800e6ec:	f7f4 f92e 	bl	800294c <lv_obj_get_signal_cb>
 800e6f0:	4602      	mov	r2, r0
 800e6f2:	4b4c      	ldr	r3, [pc, #304]	; (800e824 <lv_cont_create+0x184>)
 800e6f4:	601a      	str	r2, [r3, #0]

    lv_obj_allocate_ext_attr(new_cont, sizeof(lv_cont_ext_t));
 800e6f6:	2102      	movs	r1, #2
 800e6f8:	6978      	ldr	r0, [r7, #20]
 800e6fa:	f7f3 fde9 	bl	80022d0 <lv_obj_allocate_ext_attr>
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(new_cont);
 800e6fe:	6978      	ldr	r0, [r7, #20]
 800e700:	f7f4 f960 	bl	80029c4 <lv_obj_get_ext_attr>
 800e704:	6138      	str	r0, [r7, #16]
    if(ext == NULL) return NULL;
 800e706:	693b      	ldr	r3, [r7, #16]
 800e708:	2b00      	cmp	r3, #0
 800e70a:	d101      	bne.n	800e710 <lv_cont_create+0x70>
 800e70c:	2300      	movs	r3, #0
 800e70e:	e082      	b.n	800e816 <lv_cont_create+0x176>

    LV_ASSERT_MEM(ext);
 800e710:	6938      	ldr	r0, [r7, #16]
 800e712:	f7f1 fd71 	bl	80001f8 <lv_debug_check_null>
 800e716:	4603      	mov	r3, r0
 800e718:	f083 0301 	eor.w	r3, r3, #1
 800e71c:	b2db      	uxtb	r3, r3
 800e71e:	2b00      	cmp	r3, #0
 800e720:	d008      	beq.n	800e734 <lv_cont_create+0x94>
 800e722:	693b      	ldr	r3, [r7, #16]
 800e724:	f04f 0400 	mov.w	r4, #0
 800e728:	461a      	mov	r2, r3
 800e72a:	4623      	mov	r3, r4
 800e72c:	483c      	ldr	r0, [pc, #240]	; (800e820 <lv_cont_create+0x180>)
 800e72e:	f7f1 fd8d 	bl	800024c <lv_debug_log_error>
 800e732:	e7fe      	b.n	800e732 <lv_cont_create+0x92>
    ext->fit_left   = LV_FIT_NONE;
 800e734:	693a      	ldr	r2, [r7, #16]
 800e736:	7813      	ldrb	r3, [r2, #0]
 800e738:	f36f 1305 	bfc	r3, #4, #2
 800e73c:	7013      	strb	r3, [r2, #0]
    ext->fit_right  = LV_FIT_NONE;
 800e73e:	693a      	ldr	r2, [r7, #16]
 800e740:	7813      	ldrb	r3, [r2, #0]
 800e742:	f36f 1387 	bfc	r3, #6, #2
 800e746:	7013      	strb	r3, [r2, #0]
    ext->fit_top    = LV_FIT_NONE;
 800e748:	693a      	ldr	r2, [r7, #16]
 800e74a:	7853      	ldrb	r3, [r2, #1]
 800e74c:	f36f 0301 	bfc	r3, #0, #2
 800e750:	7053      	strb	r3, [r2, #1]
    ext->fit_bottom = LV_FIT_NONE;
 800e752:	693a      	ldr	r2, [r7, #16]
 800e754:	7853      	ldrb	r3, [r2, #1]
 800e756:	f36f 0383 	bfc	r3, #2, #2
 800e75a:	7053      	strb	r3, [r2, #1]
    ext->layout     = LV_LAYOUT_OFF;
 800e75c:	693a      	ldr	r2, [r7, #16]
 800e75e:	7813      	ldrb	r3, [r2, #0]
 800e760:	f36f 0303 	bfc	r3, #0, #4
 800e764:	7013      	strb	r3, [r2, #0]

    lv_obj_set_signal_cb(new_cont, lv_cont_signal);
 800e766:	4930      	ldr	r1, [pc, #192]	; (800e828 <lv_cont_create+0x188>)
 800e768:	6978      	ldr	r0, [r7, #20]
 800e76a:	f7f3 fd71 	bl	8002250 <lv_obj_set_signal_cb>

    /*Init the new container*/
    if(copy == NULL) {
 800e76e:	683b      	ldr	r3, [r7, #0]
 800e770:	2b00      	cmp	r3, #0
 800e772:	d116      	bne.n	800e7a2 <lv_cont_create+0x102>
        /*Set the default styles if it's not screen*/
        if(par != NULL) {
 800e774:	687b      	ldr	r3, [r7, #4]
 800e776:	2b00      	cmp	r3, #0
 800e778:	d04c      	beq.n	800e814 <lv_cont_create+0x174>
            lv_theme_t * th = lv_theme_get_current();
 800e77a:	f002 fc6d 	bl	8011058 <lv_theme_get_current>
 800e77e:	60b8      	str	r0, [r7, #8]
            if(th) {
 800e780:	68bb      	ldr	r3, [r7, #8]
 800e782:	2b00      	cmp	r3, #0
 800e784:	d007      	beq.n	800e796 <lv_cont_create+0xf6>
                lv_cont_set_style(new_cont, LV_CONT_STYLE_MAIN, th->style.cont);
 800e786:	68bb      	ldr	r3, [r7, #8]
 800e788:	68db      	ldr	r3, [r3, #12]
 800e78a:	461a      	mov	r2, r3
 800e78c:	2100      	movs	r1, #0
 800e78e:	6978      	ldr	r0, [r7, #20]
 800e790:	f7ff ff76 	bl	800e680 <lv_cont_set_style>
 800e794:	e03e      	b.n	800e814 <lv_cont_create+0x174>
            } else {
                lv_cont_set_style(new_cont, LV_CONT_STYLE_MAIN, &lv_style_pretty);
 800e796:	4a25      	ldr	r2, [pc, #148]	; (800e82c <lv_cont_create+0x18c>)
 800e798:	2100      	movs	r1, #0
 800e79a:	6978      	ldr	r0, [r7, #20]
 800e79c:	f7ff ff70 	bl	800e680 <lv_cont_set_style>
 800e7a0:	e038      	b.n	800e814 <lv_cont_create+0x174>
            }
        }
    }
    /*Copy an existing object*/
    else {
        lv_cont_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 800e7a2:	6838      	ldr	r0, [r7, #0]
 800e7a4:	f7f4 f90e 	bl	80029c4 <lv_obj_get_ext_attr>
 800e7a8:	60f8      	str	r0, [r7, #12]
        ext->fit_left            = copy_ext->fit_left;
 800e7aa:	68fb      	ldr	r3, [r7, #12]
 800e7ac:	781b      	ldrb	r3, [r3, #0]
 800e7ae:	f3c3 1301 	ubfx	r3, r3, #4, #2
 800e7b2:	b2d9      	uxtb	r1, r3
 800e7b4:	693a      	ldr	r2, [r7, #16]
 800e7b6:	7813      	ldrb	r3, [r2, #0]
 800e7b8:	f361 1305 	bfi	r3, r1, #4, #2
 800e7bc:	7013      	strb	r3, [r2, #0]
        ext->fit_right           = copy_ext->fit_right;
 800e7be:	68fb      	ldr	r3, [r7, #12]
 800e7c0:	781b      	ldrb	r3, [r3, #0]
 800e7c2:	f3c3 1381 	ubfx	r3, r3, #6, #2
 800e7c6:	b2d9      	uxtb	r1, r3
 800e7c8:	693a      	ldr	r2, [r7, #16]
 800e7ca:	7813      	ldrb	r3, [r2, #0]
 800e7cc:	f361 1387 	bfi	r3, r1, #6, #2
 800e7d0:	7013      	strb	r3, [r2, #0]
        ext->fit_top             = copy_ext->fit_top;
 800e7d2:	68fb      	ldr	r3, [r7, #12]
 800e7d4:	785b      	ldrb	r3, [r3, #1]
 800e7d6:	f3c3 0301 	ubfx	r3, r3, #0, #2
 800e7da:	b2d9      	uxtb	r1, r3
 800e7dc:	693a      	ldr	r2, [r7, #16]
 800e7de:	7853      	ldrb	r3, [r2, #1]
 800e7e0:	f361 0301 	bfi	r3, r1, #0, #2
 800e7e4:	7053      	strb	r3, [r2, #1]
        ext->fit_bottom          = copy_ext->fit_bottom;
 800e7e6:	68fb      	ldr	r3, [r7, #12]
 800e7e8:	785b      	ldrb	r3, [r3, #1]
 800e7ea:	f3c3 0381 	ubfx	r3, r3, #2, #2
 800e7ee:	b2d9      	uxtb	r1, r3
 800e7f0:	693a      	ldr	r2, [r7, #16]
 800e7f2:	7853      	ldrb	r3, [r2, #1]
 800e7f4:	f361 0383 	bfi	r3, r1, #2, #2
 800e7f8:	7053      	strb	r3, [r2, #1]
        ext->layout              = copy_ext->layout;
 800e7fa:	68fb      	ldr	r3, [r7, #12]
 800e7fc:	781b      	ldrb	r3, [r3, #0]
 800e7fe:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800e802:	b2d9      	uxtb	r1, r3
 800e804:	693a      	ldr	r2, [r7, #16]
 800e806:	7813      	ldrb	r3, [r2, #0]
 800e808:	f361 0303 	bfi	r3, r1, #0, #4
 800e80c:	7013      	strb	r3, [r2, #0]

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_cont);
 800e80e:	6978      	ldr	r0, [r7, #20]
 800e810:	f7f3 fbce 	bl	8001fb0 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("container created");

    return new_cont;
 800e814:	697b      	ldr	r3, [r7, #20]
}
 800e816:	4618      	mov	r0, r3
 800e818:	371c      	adds	r7, #28
 800e81a:	46bd      	mov	sp, r7
 800e81c:	bd90      	pop	{r4, r7, pc}
 800e81e:	bf00      	nop
 800e820:	080138dc 	.word	0x080138dc
 800e824:	200082d8 	.word	0x200082d8
 800e828:	0800e8f5 	.word	0x0800e8f5
 800e82c:	20009700 	.word	0x20009700

0800e830 <lv_cont_set_layout>:
 * Set a layout on a container
 * @param cont pointer to a container object
 * @param layout a layout from 'lv_cont_layout_t'
 */
void lv_cont_set_layout(lv_obj_t * cont, lv_layout_t layout)
{
 800e830:	b590      	push	{r4, r7, lr}
 800e832:	b085      	sub	sp, #20
 800e834:	af00      	add	r7, sp, #0
 800e836:	6078      	str	r0, [r7, #4]
 800e838:	460b      	mov	r3, r1
 800e83a:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(cont, LV_OBJX_NAME);
 800e83c:	6878      	ldr	r0, [r7, #4]
 800e83e:	f7f1 fcdb 	bl	80001f8 <lv_debug_check_null>
 800e842:	4603      	mov	r3, r0
 800e844:	f083 0301 	eor.w	r3, r3, #1
 800e848:	b2db      	uxtb	r3, r3
 800e84a:	2b00      	cmp	r3, #0
 800e84c:	d008      	beq.n	800e860 <lv_cont_set_layout+0x30>
 800e84e:	687b      	ldr	r3, [r7, #4]
 800e850:	f04f 0400 	mov.w	r4, #0
 800e854:	461a      	mov	r2, r3
 800e856:	4623      	mov	r3, r4
 800e858:	4812      	ldr	r0, [pc, #72]	; (800e8a4 <lv_cont_set_layout+0x74>)
 800e85a:	f7f1 fcf7 	bl	800024c <lv_debug_log_error>
 800e85e:	e7fe      	b.n	800e85e <lv_cont_set_layout+0x2e>

    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 800e860:	6878      	ldr	r0, [r7, #4]
 800e862:	f7f4 f8af 	bl	80029c4 <lv_obj_get_ext_attr>
 800e866:	60f8      	str	r0, [r7, #12]
    if(ext->layout == layout) return;
 800e868:	68fb      	ldr	r3, [r7, #12]
 800e86a:	781b      	ldrb	r3, [r3, #0]
 800e86c:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800e870:	b2db      	uxtb	r3, r3
 800e872:	461a      	mov	r2, r3
 800e874:	78fb      	ldrb	r3, [r7, #3]
 800e876:	429a      	cmp	r2, r3
 800e878:	d00f      	beq.n	800e89a <lv_cont_set_layout+0x6a>

    ext->layout = layout;
 800e87a:	78fb      	ldrb	r3, [r7, #3]
 800e87c:	f003 030f 	and.w	r3, r3, #15
 800e880:	b2d9      	uxtb	r1, r3
 800e882:	68fa      	ldr	r2, [r7, #12]
 800e884:	7813      	ldrb	r3, [r2, #0]
 800e886:	f361 0303 	bfi	r3, r1, #0, #4
 800e88a:	7013      	strb	r3, [r2, #0]

    /*Send a signal to refresh the layout*/
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
 800e88c:	687b      	ldr	r3, [r7, #4]
 800e88e:	69db      	ldr	r3, [r3, #28]
 800e890:	2200      	movs	r2, #0
 800e892:	2101      	movs	r1, #1
 800e894:	6878      	ldr	r0, [r7, #4]
 800e896:	4798      	blx	r3
 800e898:	e000      	b.n	800e89c <lv_cont_set_layout+0x6c>
    if(ext->layout == layout) return;
 800e89a:	bf00      	nop
}
 800e89c:	3714      	adds	r7, #20
 800e89e:	46bd      	mov	sp, r7
 800e8a0:	bd90      	pop	{r4, r7, pc}
 800e8a2:	bf00      	nop
 800e8a4:	080138ec 	.word	0x080138ec

0800e8a8 <lv_cont_get_layout>:
 * Get the layout of a container
 * @param cont pointer to container object
 * @return the layout from 'lv_cont_layout_t'
 */
lv_layout_t lv_cont_get_layout(const lv_obj_t * cont)
{
 800e8a8:	b590      	push	{r4, r7, lr}
 800e8aa:	b085      	sub	sp, #20
 800e8ac:	af00      	add	r7, sp, #0
 800e8ae:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(cont, LV_OBJX_NAME);
 800e8b0:	6878      	ldr	r0, [r7, #4]
 800e8b2:	f7f1 fca1 	bl	80001f8 <lv_debug_check_null>
 800e8b6:	4603      	mov	r3, r0
 800e8b8:	f083 0301 	eor.w	r3, r3, #1
 800e8bc:	b2db      	uxtb	r3, r3
 800e8be:	2b00      	cmp	r3, #0
 800e8c0:	d008      	beq.n	800e8d4 <lv_cont_get_layout+0x2c>
 800e8c2:	687b      	ldr	r3, [r7, #4]
 800e8c4:	f04f 0400 	mov.w	r4, #0
 800e8c8:	461a      	mov	r2, r3
 800e8ca:	4623      	mov	r3, r4
 800e8cc:	4808      	ldr	r0, [pc, #32]	; (800e8f0 <lv_cont_get_layout+0x48>)
 800e8ce:	f7f1 fcbd 	bl	800024c <lv_debug_log_error>
 800e8d2:	e7fe      	b.n	800e8d2 <lv_cont_get_layout+0x2a>

    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 800e8d4:	6878      	ldr	r0, [r7, #4]
 800e8d6:	f7f4 f875 	bl	80029c4 <lv_obj_get_ext_attr>
 800e8da:	60f8      	str	r0, [r7, #12]
    return ext->layout;
 800e8dc:	68fb      	ldr	r3, [r7, #12]
 800e8de:	781b      	ldrb	r3, [r3, #0]
 800e8e0:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800e8e4:	b2db      	uxtb	r3, r3
}
 800e8e6:	4618      	mov	r0, r3
 800e8e8:	3714      	adds	r7, #20
 800e8ea:	46bd      	mov	sp, r7
 800e8ec:	bd90      	pop	{r4, r7, pc}
 800e8ee:	bf00      	nop
 800e8f0:	080138ec 	.word	0x080138ec

0800e8f4 <lv_cont_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_cont_signal(lv_obj_t * cont, lv_signal_t sign, void * param)
{
 800e8f4:	b590      	push	{r4, r7, lr}
 800e8f6:	b087      	sub	sp, #28
 800e8f8:	af00      	add	r7, sp, #0
 800e8fa:	60f8      	str	r0, [r7, #12]
 800e8fc:	460b      	mov	r3, r1
 800e8fe:	607a      	str	r2, [r7, #4]
 800e900:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(cont, sign, param);
 800e902:	4b2a      	ldr	r3, [pc, #168]	; (800e9ac <lv_cont_signal+0xb8>)
 800e904:	681b      	ldr	r3, [r3, #0]
 800e906:	7af9      	ldrb	r1, [r7, #11]
 800e908:	687a      	ldr	r2, [r7, #4]
 800e90a:	68f8      	ldr	r0, [r7, #12]
 800e90c:	4798      	blx	r3
 800e90e:	4603      	mov	r3, r0
 800e910:	75fb      	strb	r3, [r7, #23]
    if(res != LV_RES_OK) return res;
 800e912:	7dfb      	ldrb	r3, [r7, #23]
 800e914:	2b01      	cmp	r3, #1
 800e916:	d001      	beq.n	800e91c <lv_cont_signal+0x28>
 800e918:	7dfb      	ldrb	r3, [r7, #23]
 800e91a:	e043      	b.n	800e9a4 <lv_cont_signal+0xb0>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
 800e91c:	7afb      	ldrb	r3, [r7, #11]
 800e91e:	2b07      	cmp	r3, #7
 800e920:	d105      	bne.n	800e92e <lv_cont_signal+0x3a>
 800e922:	4923      	ldr	r1, [pc, #140]	; (800e9b0 <lv_cont_signal+0xbc>)
 800e924:	6878      	ldr	r0, [r7, #4]
 800e926:	f7f4 f8b5 	bl	8002a94 <lv_obj_handle_get_type_signal>
 800e92a:	4603      	mov	r3, r0
 800e92c:	e03a      	b.n	800e9a4 <lv_cont_signal+0xb0>

    if(sign == LV_SIGNAL_STYLE_CHG) { /*Recalculate the padding if the style changed*/
 800e92e:	7afb      	ldrb	r3, [r7, #11]
 800e930:	2b04      	cmp	r3, #4
 800e932:	d106      	bne.n	800e942 <lv_cont_signal+0x4e>
        lv_cont_refr_layout(cont);
 800e934:	68f8      	ldr	r0, [r7, #12]
 800e936:	f000 f83d 	bl	800e9b4 <lv_cont_refr_layout>
        lv_cont_refr_autofit(cont);
 800e93a:	68f8      	ldr	r0, [r7, #12]
 800e93c:	f000 fc9d 	bl	800f27a <lv_cont_refr_autofit>
 800e940:	e02f      	b.n	800e9a2 <lv_cont_signal+0xae>
    } else if(sign == LV_SIGNAL_CHILD_CHG) {
 800e942:	7afb      	ldrb	r3, [r7, #11]
 800e944:	2b01      	cmp	r3, #1
 800e946:	d106      	bne.n	800e956 <lv_cont_signal+0x62>
        lv_cont_refr_layout(cont);
 800e948:	68f8      	ldr	r0, [r7, #12]
 800e94a:	f000 f833 	bl	800e9b4 <lv_cont_refr_layout>
        lv_cont_refr_autofit(cont);
 800e94e:	68f8      	ldr	r0, [r7, #12]
 800e950:	f000 fc93 	bl	800f27a <lv_cont_refr_autofit>
 800e954:	e025      	b.n	800e9a2 <lv_cont_signal+0xae>
    } else if(sign == LV_SIGNAL_CORD_CHG) {
 800e956:	7afb      	ldrb	r3, [r7, #11]
 800e958:	2b02      	cmp	r3, #2
 800e95a:	d11c      	bne.n	800e996 <lv_cont_signal+0xa2>
        if(lv_obj_get_width(cont) != lv_area_get_width(param) || lv_obj_get_height(cont) != lv_area_get_height(param)) {
 800e95c:	68f8      	ldr	r0, [r7, #12]
 800e95e:	f7f3 fe5b 	bl	8002618 <lv_obj_get_width>
 800e962:	4603      	mov	r3, r0
 800e964:	461c      	mov	r4, r3
 800e966:	6878      	ldr	r0, [r7, #4]
 800e968:	f7ff fe5c 	bl	800e624 <lv_area_get_width>
 800e96c:	4603      	mov	r3, r0
 800e96e:	429c      	cmp	r4, r3
 800e970:	d10a      	bne.n	800e988 <lv_cont_signal+0x94>
 800e972:	68f8      	ldr	r0, [r7, #12]
 800e974:	f7f3 fe72 	bl	800265c <lv_obj_get_height>
 800e978:	4603      	mov	r3, r0
 800e97a:	461c      	mov	r4, r3
 800e97c:	6878      	ldr	r0, [r7, #4]
 800e97e:	f7ff fe68 	bl	800e652 <lv_area_get_height>
 800e982:	4603      	mov	r3, r0
 800e984:	429c      	cmp	r4, r3
 800e986:	d00c      	beq.n	800e9a2 <lv_cont_signal+0xae>
            lv_cont_refr_layout(cont);
 800e988:	68f8      	ldr	r0, [r7, #12]
 800e98a:	f000 f813 	bl	800e9b4 <lv_cont_refr_layout>
            lv_cont_refr_autofit(cont);
 800e98e:	68f8      	ldr	r0, [r7, #12]
 800e990:	f000 fc73 	bl	800f27a <lv_cont_refr_autofit>
 800e994:	e005      	b.n	800e9a2 <lv_cont_signal+0xae>
        }
    } else if(sign == LV_SIGNAL_PARENT_SIZE_CHG) {
 800e996:	7afb      	ldrb	r3, [r7, #11]
 800e998:	2b03      	cmp	r3, #3
 800e99a:	d102      	bne.n	800e9a2 <lv_cont_signal+0xae>
        /*FLOOD and FILL fit needs to be refreshed if the parent size has changed*/
        lv_cont_refr_autofit(cont);
 800e99c:	68f8      	ldr	r0, [r7, #12]
 800e99e:	f000 fc6c 	bl	800f27a <lv_cont_refr_autofit>

    }

    return res;
 800e9a2:	7dfb      	ldrb	r3, [r7, #23]
}
 800e9a4:	4618      	mov	r0, r3
 800e9a6:	371c      	adds	r7, #28
 800e9a8:	46bd      	mov	sp, r7
 800e9aa:	bd90      	pop	{r4, r7, pc}
 800e9ac:	200082d8 	.word	0x200082d8
 800e9b0:	080138fc 	.word	0x080138fc

0800e9b4 <lv_cont_refr_layout>:
/**
 * Refresh the layout of a container
 * @param cont pointer to an object which layout should be refreshed
 */
static void lv_cont_refr_layout(lv_obj_t * cont)
{
 800e9b4:	b580      	push	{r7, lr}
 800e9b6:	b084      	sub	sp, #16
 800e9b8:	af00      	add	r7, sp, #0
 800e9ba:	6078      	str	r0, [r7, #4]
    lv_layout_t type = lv_cont_get_layout(cont);
 800e9bc:	6878      	ldr	r0, [r7, #4]
 800e9be:	f7ff ff73 	bl	800e8a8 <lv_cont_get_layout>
 800e9c2:	4603      	mov	r3, r0
 800e9c4:	73fb      	strb	r3, [r7, #15]

    /*'cont' has to be at least 1 child*/
    if(lv_obj_get_child(cont, NULL) == NULL) return;
 800e9c6:	2100      	movs	r1, #0
 800e9c8:	6878      	ldr	r0, [r7, #4]
 800e9ca:	f7f3 fd67 	bl	800249c <lv_obj_get_child>
 800e9ce:	4603      	mov	r3, r0
 800e9d0:	2b00      	cmp	r3, #0
 800e9d2:	d031      	beq.n	800ea38 <lv_cont_refr_layout+0x84>

    if(type == LV_LAYOUT_OFF) return;
 800e9d4:	7bfb      	ldrb	r3, [r7, #15]
 800e9d6:	2b00      	cmp	r3, #0
 800e9d8:	d030      	beq.n	800ea3c <lv_cont_refr_layout+0x88>

    if(type == LV_LAYOUT_CENTER) {
 800e9da:	7bfb      	ldrb	r3, [r7, #15]
 800e9dc:	2b01      	cmp	r3, #1
 800e9de:	d103      	bne.n	800e9e8 <lv_cont_refr_layout+0x34>
        lv_cont_layout_center(cont);
 800e9e0:	6878      	ldr	r0, [r7, #4]
 800e9e2:	f000 f94c 	bl	800ec7e <lv_cont_layout_center>
 800e9e6:	e02a      	b.n	800ea3e <lv_cont_refr_layout+0x8a>
    } else if(type == LV_LAYOUT_COL_L || type == LV_LAYOUT_COL_M || type == LV_LAYOUT_COL_R) {
 800e9e8:	7bfb      	ldrb	r3, [r7, #15]
 800e9ea:	2b02      	cmp	r3, #2
 800e9ec:	d005      	beq.n	800e9fa <lv_cont_refr_layout+0x46>
 800e9ee:	7bfb      	ldrb	r3, [r7, #15]
 800e9f0:	2b03      	cmp	r3, #3
 800e9f2:	d002      	beq.n	800e9fa <lv_cont_refr_layout+0x46>
 800e9f4:	7bfb      	ldrb	r3, [r7, #15]
 800e9f6:	2b04      	cmp	r3, #4
 800e9f8:	d103      	bne.n	800ea02 <lv_cont_refr_layout+0x4e>
        lv_cont_layout_col(cont);
 800e9fa:	6878      	ldr	r0, [r7, #4]
 800e9fc:	f000 f822 	bl	800ea44 <lv_cont_layout_col>
 800ea00:	e01d      	b.n	800ea3e <lv_cont_refr_layout+0x8a>
    } else if(type == LV_LAYOUT_ROW_T || type == LV_LAYOUT_ROW_M || type == LV_LAYOUT_ROW_B) {
 800ea02:	7bfb      	ldrb	r3, [r7, #15]
 800ea04:	2b05      	cmp	r3, #5
 800ea06:	d005      	beq.n	800ea14 <lv_cont_refr_layout+0x60>
 800ea08:	7bfb      	ldrb	r3, [r7, #15]
 800ea0a:	2b06      	cmp	r3, #6
 800ea0c:	d002      	beq.n	800ea14 <lv_cont_refr_layout+0x60>
 800ea0e:	7bfb      	ldrb	r3, [r7, #15]
 800ea10:	2b07      	cmp	r3, #7
 800ea12:	d103      	bne.n	800ea1c <lv_cont_refr_layout+0x68>
        lv_cont_layout_row(cont);
 800ea14:	6878      	ldr	r0, [r7, #4]
 800ea16:	f000 f88b 	bl	800eb30 <lv_cont_layout_row>
 800ea1a:	e010      	b.n	800ea3e <lv_cont_refr_layout+0x8a>
    } else if(type == LV_LAYOUT_PRETTY) {
 800ea1c:	7bfb      	ldrb	r3, [r7, #15]
 800ea1e:	2b08      	cmp	r3, #8
 800ea20:	d103      	bne.n	800ea2a <lv_cont_refr_layout+0x76>
        lv_cont_layout_pretty(cont);
 800ea22:	6878      	ldr	r0, [r7, #4]
 800ea24:	f000 f9cc 	bl	800edc0 <lv_cont_layout_pretty>
 800ea28:	e009      	b.n	800ea3e <lv_cont_refr_layout+0x8a>
    } else if(type == LV_LAYOUT_GRID) {
 800ea2a:	7bfb      	ldrb	r3, [r7, #15]
 800ea2c:	2b09      	cmp	r3, #9
 800ea2e:	d106      	bne.n	800ea3e <lv_cont_refr_layout+0x8a>
        lv_cont_layout_grid(cont);
 800ea30:	6878      	ldr	r0, [r7, #4]
 800ea32:	f000 fb65 	bl	800f100 <lv_cont_layout_grid>
 800ea36:	e002      	b.n	800ea3e <lv_cont_refr_layout+0x8a>
    if(lv_obj_get_child(cont, NULL) == NULL) return;
 800ea38:	bf00      	nop
 800ea3a:	e000      	b.n	800ea3e <lv_cont_refr_layout+0x8a>
    if(type == LV_LAYOUT_OFF) return;
 800ea3c:	bf00      	nop
    }
}
 800ea3e:	3710      	adds	r7, #16
 800ea40:	46bd      	mov	sp, r7
 800ea42:	bd80      	pop	{r7, pc}

0800ea44 <lv_cont_layout_col>:
/**
 * Handle column type layouts
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_col(lv_obj_t * cont)
{
 800ea44:	b580      	push	{r7, lr}
 800ea46:	b088      	sub	sp, #32
 800ea48:	af02      	add	r7, sp, #8
 800ea4a:	6078      	str	r0, [r7, #4]
    lv_layout_t type = lv_cont_get_layout(cont);
 800ea4c:	6878      	ldr	r0, [r7, #4]
 800ea4e:	f7ff ff2b 	bl	800e8a8 <lv_cont_get_layout>
 800ea52:	4603      	mov	r3, r0
 800ea54:	737b      	strb	r3, [r7, #13]
    lv_obj_t * child;

    /*Adjust margin and get the alignment type*/
    lv_align_t align;
    const lv_style_t * style = lv_obj_get_style(cont);
 800ea56:	6878      	ldr	r0, [r7, #4]
 800ea58:	f7f3 fe7a 	bl	8002750 <lv_obj_get_style>
 800ea5c:	60b8      	str	r0, [r7, #8]
    lv_coord_t hpad_corr;

    switch(type) {
 800ea5e:	7b7b      	ldrb	r3, [r7, #13]
 800ea60:	2b03      	cmp	r3, #3
 800ea62:	d009      	beq.n	800ea78 <lv_cont_layout_col+0x34>
 800ea64:	2b04      	cmp	r3, #4
 800ea66:	d00c      	beq.n	800ea82 <lv_cont_layout_col+0x3e>
 800ea68:	2b02      	cmp	r3, #2
 800ea6a:	d114      	bne.n	800ea96 <lv_cont_layout_col+0x52>
        case LV_LAYOUT_COL_L:
            hpad_corr = style->body.padding.left;
 800ea6c:	68bb      	ldr	r3, [r7, #8]
 800ea6e:	8b5b      	ldrh	r3, [r3, #26]
 800ea70:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_TOP_LEFT;
 800ea72:	2301      	movs	r3, #1
 800ea74:	74fb      	strb	r3, [r7, #19]
            break;
 800ea76:	e013      	b.n	800eaa0 <lv_cont_layout_col+0x5c>
        case LV_LAYOUT_COL_M:
            hpad_corr = 0;
 800ea78:	2300      	movs	r3, #0
 800ea7a:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_TOP_MID;
 800ea7c:	2302      	movs	r3, #2
 800ea7e:	74fb      	strb	r3, [r7, #19]
            break;
 800ea80:	e00e      	b.n	800eaa0 <lv_cont_layout_col+0x5c>
        case LV_LAYOUT_COL_R:
            hpad_corr = -style->body.padding.right;
 800ea82:	68bb      	ldr	r3, [r7, #8]
 800ea84:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 800ea88:	b29b      	uxth	r3, r3
 800ea8a:	425b      	negs	r3, r3
 800ea8c:	b29b      	uxth	r3, r3
 800ea8e:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_TOP_RIGHT;
 800ea90:	2303      	movs	r3, #3
 800ea92:	74fb      	strb	r3, [r7, #19]
            break;
 800ea94:	e004      	b.n	800eaa0 <lv_cont_layout_col+0x5c>
        default:
            hpad_corr = 0;
 800ea96:	2300      	movs	r3, #0
 800ea98:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_TOP_LEFT;
 800ea9a:	2301      	movs	r3, #1
 800ea9c:	74fb      	strb	r3, [r7, #19]
            break;
 800ea9e:	bf00      	nop
    }

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_set_protect(cont, LV_PROTECT_CHILD_CHG);
 800eaa0:	2101      	movs	r1, #1
 800eaa2:	6878      	ldr	r0, [r7, #4]
 800eaa4:	f7f3 fad2 	bl	800204c <lv_obj_set_protect>
    /* Align the children */
    lv_coord_t last_cord = style->body.padding.top;
 800eaa8:	68bb      	ldr	r3, [r7, #8]
 800eaaa:	8adb      	ldrh	r3, [r3, #22]
 800eaac:	81fb      	strh	r3, [r7, #14]
    LV_LL_READ_BACK(cont->child_ll, child)
 800eaae:	687b      	ldr	r3, [r7, #4]
 800eab0:	3304      	adds	r3, #4
 800eab2:	4618      	mov	r0, r3
 800eab4:	f7fd ff95 	bl	800c9e2 <lv_ll_get_tail>
 800eab8:	6178      	str	r0, [r7, #20]
 800eaba:	e02e      	b.n	800eb1a <lv_cont_layout_col+0xd6>
    {
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 800eabc:	6978      	ldr	r0, [r7, #20]
 800eabe:	f7f3 feb3 	bl	8002828 <lv_obj_get_hidden>
 800eac2:	4603      	mov	r3, r0
 800eac4:	2b00      	cmp	r3, #0
 800eac6:	d120      	bne.n	800eb0a <lv_cont_layout_col+0xc6>
 800eac8:	2104      	movs	r1, #4
 800eaca:	6978      	ldr	r0, [r7, #20]
 800eacc:	f7f3 ff14 	bl	80028f8 <lv_obj_is_protected>
 800ead0:	4603      	mov	r3, r0
 800ead2:	2b00      	cmp	r3, #0
 800ead4:	d119      	bne.n	800eb0a <lv_cont_layout_col+0xc6>

        lv_obj_align(child, cont, align, hpad_corr, last_cord);
 800ead6:	f9b7 1010 	ldrsh.w	r1, [r7, #16]
 800eada:	7cfa      	ldrb	r2, [r7, #19]
 800eadc:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800eae0:	9300      	str	r3, [sp, #0]
 800eae2:	460b      	mov	r3, r1
 800eae4:	6879      	ldr	r1, [r7, #4]
 800eae6:	6978      	ldr	r0, [r7, #20]
 800eae8:	f7f2 fd22 	bl	8001530 <lv_obj_align>
        last_cord += lv_obj_get_height(child) + style->body.padding.inner;
 800eaec:	6978      	ldr	r0, [r7, #20]
 800eaee:	f7f3 fdb5 	bl	800265c <lv_obj_get_height>
 800eaf2:	4603      	mov	r3, r0
 800eaf4:	461a      	mov	r2, r3
 800eaf6:	68bb      	ldr	r3, [r7, #8]
 800eaf8:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 800eafc:	4413      	add	r3, r2
 800eafe:	b29a      	uxth	r2, r3
 800eb00:	89fb      	ldrh	r3, [r7, #14]
 800eb02:	4413      	add	r3, r2
 800eb04:	b29b      	uxth	r3, r3
 800eb06:	81fb      	strh	r3, [r7, #14]
 800eb08:	e000      	b.n	800eb0c <lv_cont_layout_col+0xc8>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 800eb0a:	bf00      	nop
    LV_LL_READ_BACK(cont->child_ll, child)
 800eb0c:	687b      	ldr	r3, [r7, #4]
 800eb0e:	3304      	adds	r3, #4
 800eb10:	6979      	ldr	r1, [r7, #20]
 800eb12:	4618      	mov	r0, r3
 800eb14:	f7fd ff92 	bl	800ca3c <lv_ll_get_prev>
 800eb18:	6178      	str	r0, [r7, #20]
 800eb1a:	697b      	ldr	r3, [r7, #20]
 800eb1c:	2b00      	cmp	r3, #0
 800eb1e:	d1cd      	bne.n	800eabc <lv_cont_layout_col+0x78>
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 800eb20:	2101      	movs	r1, #1
 800eb22:	6878      	ldr	r0, [r7, #4]
 800eb24:	f7f3 faba 	bl	800209c <lv_obj_clear_protect>
}
 800eb28:	bf00      	nop
 800eb2a:	3718      	adds	r7, #24
 800eb2c:	46bd      	mov	sp, r7
 800eb2e:	bd80      	pop	{r7, pc}

0800eb30 <lv_cont_layout_row>:
/**
 * Handle row type layouts
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_row(lv_obj_t * cont)
{
 800eb30:	b580      	push	{r7, lr}
 800eb32:	b08a      	sub	sp, #40	; 0x28
 800eb34:	af02      	add	r7, sp, #8
 800eb36:	6078      	str	r0, [r7, #4]
    lv_layout_t type = lv_cont_get_layout(cont);
 800eb38:	6878      	ldr	r0, [r7, #4]
 800eb3a:	f7ff feb5 	bl	800e8a8 <lv_cont_get_layout>
 800eb3e:	4603      	mov	r3, r0
 800eb40:	757b      	strb	r3, [r7, #21]
    lv_obj_t * child;

    /*Adjust margin and get the alignment type*/
    lv_align_t align;
    const lv_style_t * style = lv_obj_get_style(cont);
 800eb42:	6878      	ldr	r0, [r7, #4]
 800eb44:	f7f3 fe04 	bl	8002750 <lv_obj_get_style>
 800eb48:	6138      	str	r0, [r7, #16]
    lv_coord_t vpad_corr;
    lv_bidi_dir_t base_dir = lv_obj_get_base_dir(cont);
 800eb4a:	6878      	ldr	r0, [r7, #4]
 800eb4c:	f7f3 fe94 	bl	8002878 <lv_obj_get_base_dir>
 800eb50:	4603      	mov	r3, r0
 800eb52:	73fb      	strb	r3, [r7, #15]
    switch(type) {
 800eb54:	7d7b      	ldrb	r3, [r7, #21]
 800eb56:	2b06      	cmp	r3, #6
 800eb58:	d00e      	beq.n	800eb78 <lv_cont_layout_row+0x48>
 800eb5a:	2b07      	cmp	r3, #7
 800eb5c:	d016      	beq.n	800eb8c <lv_cont_layout_row+0x5c>
 800eb5e:	2b05      	cmp	r3, #5
 800eb60:	d123      	bne.n	800ebaa <lv_cont_layout_row+0x7a>
        case LV_LAYOUT_ROW_T:
            vpad_corr = style->body.padding.top;
 800eb62:	693b      	ldr	r3, [r7, #16]
 800eb64:	8adb      	ldrh	r3, [r3, #22]
 800eb66:	833b      	strh	r3, [r7, #24]
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_TOP_RIGHT : LV_ALIGN_IN_TOP_LEFT;
 800eb68:	7bfb      	ldrb	r3, [r7, #15]
 800eb6a:	2b01      	cmp	r3, #1
 800eb6c:	d101      	bne.n	800eb72 <lv_cont_layout_row+0x42>
 800eb6e:	2303      	movs	r3, #3
 800eb70:	e000      	b.n	800eb74 <lv_cont_layout_row+0x44>
 800eb72:	2301      	movs	r3, #1
 800eb74:	76fb      	strb	r3, [r7, #27]
            break;
 800eb76:	e022      	b.n	800ebbe <lv_cont_layout_row+0x8e>
        case LV_LAYOUT_ROW_M:
            vpad_corr = 0;
 800eb78:	2300      	movs	r3, #0
 800eb7a:	833b      	strh	r3, [r7, #24]
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_RIGHT_MID: LV_ALIGN_IN_LEFT_MID;
 800eb7c:	7bfb      	ldrb	r3, [r7, #15]
 800eb7e:	2b01      	cmp	r3, #1
 800eb80:	d101      	bne.n	800eb86 <lv_cont_layout_row+0x56>
 800eb82:	2308      	movs	r3, #8
 800eb84:	e000      	b.n	800eb88 <lv_cont_layout_row+0x58>
 800eb86:	2307      	movs	r3, #7
 800eb88:	76fb      	strb	r3, [r7, #27]
            break;
 800eb8a:	e018      	b.n	800ebbe <lv_cont_layout_row+0x8e>
        case LV_LAYOUT_ROW_B:
            vpad_corr = -style->body.padding.bottom;
 800eb8c:	693b      	ldr	r3, [r7, #16]
 800eb8e:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 800eb92:	b29b      	uxth	r3, r3
 800eb94:	425b      	negs	r3, r3
 800eb96:	b29b      	uxth	r3, r3
 800eb98:	833b      	strh	r3, [r7, #24]
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_BOTTOM_RIGHT: LV_ALIGN_IN_BOTTOM_LEFT;
 800eb9a:	7bfb      	ldrb	r3, [r7, #15]
 800eb9c:	2b01      	cmp	r3, #1
 800eb9e:	d101      	bne.n	800eba4 <lv_cont_layout_row+0x74>
 800eba0:	2306      	movs	r3, #6
 800eba2:	e000      	b.n	800eba6 <lv_cont_layout_row+0x76>
 800eba4:	2304      	movs	r3, #4
 800eba6:	76fb      	strb	r3, [r7, #27]
            break;
 800eba8:	e009      	b.n	800ebbe <lv_cont_layout_row+0x8e>
        default:
            vpad_corr = 0;
 800ebaa:	2300      	movs	r3, #0
 800ebac:	833b      	strh	r3, [r7, #24]
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_TOP_RIGHT : LV_ALIGN_IN_TOP_LEFT;
 800ebae:	7bfb      	ldrb	r3, [r7, #15]
 800ebb0:	2b01      	cmp	r3, #1
 800ebb2:	d101      	bne.n	800ebb8 <lv_cont_layout_row+0x88>
 800ebb4:	2303      	movs	r3, #3
 800ebb6:	e000      	b.n	800ebba <lv_cont_layout_row+0x8a>
 800ebb8:	2301      	movs	r3, #1
 800ebba:	76fb      	strb	r3, [r7, #27]
            break;
 800ebbc:	bf00      	nop
    }

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_set_protect(cont, LV_PROTECT_CHILD_CHG);
 800ebbe:	2101      	movs	r1, #1
 800ebc0:	6878      	ldr	r0, [r7, #4]
 800ebc2:	f7f3 fa43 	bl	800204c <lv_obj_set_protect>

    /* Align the children */
    lv_coord_t last_cord;
    if(base_dir == LV_BIDI_DIR_RTL) last_cord = style->body.padding.right;
 800ebc6:	7bfb      	ldrb	r3, [r7, #15]
 800ebc8:	2b01      	cmp	r3, #1
 800ebca:	d103      	bne.n	800ebd4 <lv_cont_layout_row+0xa4>
 800ebcc:	693b      	ldr	r3, [r7, #16]
 800ebce:	8b9b      	ldrh	r3, [r3, #28]
 800ebd0:	82fb      	strh	r3, [r7, #22]
 800ebd2:	e002      	b.n	800ebda <lv_cont_layout_row+0xaa>
    else last_cord = style->body.padding.left;
 800ebd4:	693b      	ldr	r3, [r7, #16]
 800ebd6:	8b5b      	ldrh	r3, [r3, #26]
 800ebd8:	82fb      	strh	r3, [r7, #22]

    LV_LL_READ_BACK(cont->child_ll, child)
 800ebda:	687b      	ldr	r3, [r7, #4]
 800ebdc:	3304      	adds	r3, #4
 800ebde:	4618      	mov	r0, r3
 800ebe0:	f7fd feff 	bl	800c9e2 <lv_ll_get_tail>
 800ebe4:	61f8      	str	r0, [r7, #28]
 800ebe6:	e03f      	b.n	800ec68 <lv_cont_layout_row+0x138>
    {
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 800ebe8:	69f8      	ldr	r0, [r7, #28]
 800ebea:	f7f3 fe1d 	bl	8002828 <lv_obj_get_hidden>
 800ebee:	4603      	mov	r3, r0
 800ebf0:	2b00      	cmp	r3, #0
 800ebf2:	d131      	bne.n	800ec58 <lv_cont_layout_row+0x128>
 800ebf4:	2104      	movs	r1, #4
 800ebf6:	69f8      	ldr	r0, [r7, #28]
 800ebf8:	f7f3 fe7e 	bl	80028f8 <lv_obj_is_protected>
 800ebfc:	4603      	mov	r3, r0
 800ebfe:	2b00      	cmp	r3, #0
 800ec00:	d12a      	bne.n	800ec58 <lv_cont_layout_row+0x128>

//        last_cord -= lv_obj_get_width(child);

        if(base_dir == LV_BIDI_DIR_RTL) lv_obj_align(child, cont, align, -last_cord, vpad_corr);
 800ec02:	7bfb      	ldrb	r3, [r7, #15]
 800ec04:	2b01      	cmp	r3, #1
 800ec06:	d10d      	bne.n	800ec24 <lv_cont_layout_row+0xf4>
 800ec08:	8afb      	ldrh	r3, [r7, #22]
 800ec0a:	425b      	negs	r3, r3
 800ec0c:	b29b      	uxth	r3, r3
 800ec0e:	b219      	sxth	r1, r3
 800ec10:	7efa      	ldrb	r2, [r7, #27]
 800ec12:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800ec16:	9300      	str	r3, [sp, #0]
 800ec18:	460b      	mov	r3, r1
 800ec1a:	6879      	ldr	r1, [r7, #4]
 800ec1c:	69f8      	ldr	r0, [r7, #28]
 800ec1e:	f7f2 fc87 	bl	8001530 <lv_obj_align>
 800ec22:	e00a      	b.n	800ec3a <lv_cont_layout_row+0x10a>
        else lv_obj_align(child, cont, align, last_cord, vpad_corr);
 800ec24:	f9b7 1016 	ldrsh.w	r1, [r7, #22]
 800ec28:	7efa      	ldrb	r2, [r7, #27]
 800ec2a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800ec2e:	9300      	str	r3, [sp, #0]
 800ec30:	460b      	mov	r3, r1
 800ec32:	6879      	ldr	r1, [r7, #4]
 800ec34:	69f8      	ldr	r0, [r7, #28]
 800ec36:	f7f2 fc7b 	bl	8001530 <lv_obj_align>

        last_cord += lv_obj_get_width(child) + style->body.padding.inner;
 800ec3a:	69f8      	ldr	r0, [r7, #28]
 800ec3c:	f7f3 fcec 	bl	8002618 <lv_obj_get_width>
 800ec40:	4603      	mov	r3, r0
 800ec42:	461a      	mov	r2, r3
 800ec44:	693b      	ldr	r3, [r7, #16]
 800ec46:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 800ec4a:	4413      	add	r3, r2
 800ec4c:	b29a      	uxth	r2, r3
 800ec4e:	8afb      	ldrh	r3, [r7, #22]
 800ec50:	4413      	add	r3, r2
 800ec52:	b29b      	uxth	r3, r3
 800ec54:	82fb      	strh	r3, [r7, #22]
 800ec56:	e000      	b.n	800ec5a <lv_cont_layout_row+0x12a>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 800ec58:	bf00      	nop
    LV_LL_READ_BACK(cont->child_ll, child)
 800ec5a:	687b      	ldr	r3, [r7, #4]
 800ec5c:	3304      	adds	r3, #4
 800ec5e:	69f9      	ldr	r1, [r7, #28]
 800ec60:	4618      	mov	r0, r3
 800ec62:	f7fd feeb 	bl	800ca3c <lv_ll_get_prev>
 800ec66:	61f8      	str	r0, [r7, #28]
 800ec68:	69fb      	ldr	r3, [r7, #28]
 800ec6a:	2b00      	cmp	r3, #0
 800ec6c:	d1bc      	bne.n	800ebe8 <lv_cont_layout_row+0xb8>
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 800ec6e:	2101      	movs	r1, #1
 800ec70:	6878      	ldr	r0, [r7, #4]
 800ec72:	f7f3 fa13 	bl	800209c <lv_obj_clear_protect>
}
 800ec76:	bf00      	nop
 800ec78:	3720      	adds	r7, #32
 800ec7a:	46bd      	mov	sp, r7
 800ec7c:	bd80      	pop	{r7, pc}

0800ec7e <lv_cont_layout_center>:
/**
 * Handle the center layout
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_center(lv_obj_t * cont)
{
 800ec7e:	b580      	push	{r7, lr}
 800ec80:	b088      	sub	sp, #32
 800ec82:	af02      	add	r7, sp, #8
 800ec84:	6078      	str	r0, [r7, #4]
    lv_obj_t * child;
    const lv_style_t * style = lv_obj_get_style(cont);
 800ec86:	6878      	ldr	r0, [r7, #4]
 800ec88:	f7f3 fd62 	bl	8002750 <lv_obj_get_style>
 800ec8c:	60b8      	str	r0, [r7, #8]
    uint32_t obj_num         = 0;
 800ec8e:	2300      	movs	r3, #0
 800ec90:	613b      	str	r3, [r7, #16]
    lv_coord_t h_tot         = 0;
 800ec92:	2300      	movs	r3, #0
 800ec94:	81fb      	strh	r3, [r7, #14]

    LV_LL_READ(cont->child_ll, child)
 800ec96:	687b      	ldr	r3, [r7, #4]
 800ec98:	3304      	adds	r3, #4
 800ec9a:	4618      	mov	r0, r3
 800ec9c:	f7fd fe8e 	bl	800c9bc <lv_ll_get_head>
 800eca0:	6178      	str	r0, [r7, #20]
 800eca2:	e026      	b.n	800ecf2 <lv_cont_layout_center+0x74>
    {
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 800eca4:	6978      	ldr	r0, [r7, #20]
 800eca6:	f7f3 fdbf 	bl	8002828 <lv_obj_get_hidden>
 800ecaa:	4603      	mov	r3, r0
 800ecac:	2b00      	cmp	r3, #0
 800ecae:	d118      	bne.n	800ece2 <lv_cont_layout_center+0x64>
 800ecb0:	2104      	movs	r1, #4
 800ecb2:	6978      	ldr	r0, [r7, #20]
 800ecb4:	f7f3 fe20 	bl	80028f8 <lv_obj_is_protected>
 800ecb8:	4603      	mov	r3, r0
 800ecba:	2b00      	cmp	r3, #0
 800ecbc:	d111      	bne.n	800ece2 <lv_cont_layout_center+0x64>
        h_tot += lv_obj_get_height(child) + style->body.padding.inner;
 800ecbe:	6978      	ldr	r0, [r7, #20]
 800ecc0:	f7f3 fccc 	bl	800265c <lv_obj_get_height>
 800ecc4:	4603      	mov	r3, r0
 800ecc6:	461a      	mov	r2, r3
 800ecc8:	68bb      	ldr	r3, [r7, #8]
 800ecca:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 800ecce:	4413      	add	r3, r2
 800ecd0:	b29a      	uxth	r2, r3
 800ecd2:	89fb      	ldrh	r3, [r7, #14]
 800ecd4:	4413      	add	r3, r2
 800ecd6:	b29b      	uxth	r3, r3
 800ecd8:	81fb      	strh	r3, [r7, #14]
        obj_num++;
 800ecda:	693b      	ldr	r3, [r7, #16]
 800ecdc:	3301      	adds	r3, #1
 800ecde:	613b      	str	r3, [r7, #16]
 800ece0:	e000      	b.n	800ece4 <lv_cont_layout_center+0x66>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 800ece2:	bf00      	nop
    LV_LL_READ(cont->child_ll, child)
 800ece4:	687b      	ldr	r3, [r7, #4]
 800ece6:	3304      	adds	r3, #4
 800ece8:	6979      	ldr	r1, [r7, #20]
 800ecea:	4618      	mov	r0, r3
 800ecec:	f7fd fe8c 	bl	800ca08 <lv_ll_get_next>
 800ecf0:	6178      	str	r0, [r7, #20]
 800ecf2:	697b      	ldr	r3, [r7, #20]
 800ecf4:	2b00      	cmp	r3, #0
 800ecf6:	d1d5      	bne.n	800eca4 <lv_cont_layout_center+0x26>
    }

    if(obj_num == 0) return;
 800ecf8:	693b      	ldr	r3, [r7, #16]
 800ecfa:	2b00      	cmp	r3, #0
 800ecfc:	d05c      	beq.n	800edb8 <lv_cont_layout_center+0x13a>

    h_tot -= style->body.padding.inner;
 800ecfe:	89fa      	ldrh	r2, [r7, #14]
 800ed00:	68bb      	ldr	r3, [r7, #8]
 800ed02:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 800ed06:	b29b      	uxth	r3, r3
 800ed08:	1ad3      	subs	r3, r2, r3
 800ed0a:	b29b      	uxth	r3, r3
 800ed0c:	81fb      	strh	r3, [r7, #14]

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_set_protect(cont, LV_PROTECT_CHILD_CHG);
 800ed0e:	2101      	movs	r1, #1
 800ed10:	6878      	ldr	r0, [r7, #4]
 800ed12:	f7f3 f99b 	bl	800204c <lv_obj_set_protect>

    /* Align the children */
    lv_coord_t last_cord = -(h_tot / 2);
 800ed16:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800ed1a:	0fda      	lsrs	r2, r3, #31
 800ed1c:	4413      	add	r3, r2
 800ed1e:	105b      	asrs	r3, r3, #1
 800ed20:	b21b      	sxth	r3, r3
 800ed22:	b29b      	uxth	r3, r3
 800ed24:	425b      	negs	r3, r3
 800ed26:	b29b      	uxth	r3, r3
 800ed28:	81bb      	strh	r3, [r7, #12]
    LV_LL_READ_BACK(cont->child_ll, child)
 800ed2a:	687b      	ldr	r3, [r7, #4]
 800ed2c:	3304      	adds	r3, #4
 800ed2e:	4618      	mov	r0, r3
 800ed30:	f7fd fe57 	bl	800c9e2 <lv_ll_get_tail>
 800ed34:	6178      	str	r0, [r7, #20]
 800ed36:	e037      	b.n	800eda8 <lv_cont_layout_center+0x12a>
    {
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 800ed38:	6978      	ldr	r0, [r7, #20]
 800ed3a:	f7f3 fd75 	bl	8002828 <lv_obj_get_hidden>
 800ed3e:	4603      	mov	r3, r0
 800ed40:	2b00      	cmp	r3, #0
 800ed42:	d129      	bne.n	800ed98 <lv_cont_layout_center+0x11a>
 800ed44:	2104      	movs	r1, #4
 800ed46:	6978      	ldr	r0, [r7, #20]
 800ed48:	f7f3 fdd6 	bl	80028f8 <lv_obj_is_protected>
 800ed4c:	4603      	mov	r3, r0
 800ed4e:	2b00      	cmp	r3, #0
 800ed50:	d122      	bne.n	800ed98 <lv_cont_layout_center+0x11a>

        lv_obj_align(child, cont, LV_ALIGN_CENTER, 0, last_cord + lv_obj_get_height(child) / 2);
 800ed52:	6978      	ldr	r0, [r7, #20]
 800ed54:	f7f3 fc82 	bl	800265c <lv_obj_get_height>
 800ed58:	4603      	mov	r3, r0
 800ed5a:	0fda      	lsrs	r2, r3, #31
 800ed5c:	4413      	add	r3, r2
 800ed5e:	105b      	asrs	r3, r3, #1
 800ed60:	b21b      	sxth	r3, r3
 800ed62:	b29a      	uxth	r2, r3
 800ed64:	89bb      	ldrh	r3, [r7, #12]
 800ed66:	4413      	add	r3, r2
 800ed68:	b29b      	uxth	r3, r3
 800ed6a:	b21b      	sxth	r3, r3
 800ed6c:	9300      	str	r3, [sp, #0]
 800ed6e:	2300      	movs	r3, #0
 800ed70:	2200      	movs	r2, #0
 800ed72:	6879      	ldr	r1, [r7, #4]
 800ed74:	6978      	ldr	r0, [r7, #20]
 800ed76:	f7f2 fbdb 	bl	8001530 <lv_obj_align>
        last_cord += lv_obj_get_height(child) + style->body.padding.inner;
 800ed7a:	6978      	ldr	r0, [r7, #20]
 800ed7c:	f7f3 fc6e 	bl	800265c <lv_obj_get_height>
 800ed80:	4603      	mov	r3, r0
 800ed82:	461a      	mov	r2, r3
 800ed84:	68bb      	ldr	r3, [r7, #8]
 800ed86:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 800ed8a:	4413      	add	r3, r2
 800ed8c:	b29a      	uxth	r2, r3
 800ed8e:	89bb      	ldrh	r3, [r7, #12]
 800ed90:	4413      	add	r3, r2
 800ed92:	b29b      	uxth	r3, r3
 800ed94:	81bb      	strh	r3, [r7, #12]
 800ed96:	e000      	b.n	800ed9a <lv_cont_layout_center+0x11c>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 800ed98:	bf00      	nop
    LV_LL_READ_BACK(cont->child_ll, child)
 800ed9a:	687b      	ldr	r3, [r7, #4]
 800ed9c:	3304      	adds	r3, #4
 800ed9e:	6979      	ldr	r1, [r7, #20]
 800eda0:	4618      	mov	r0, r3
 800eda2:	f7fd fe4b 	bl	800ca3c <lv_ll_get_prev>
 800eda6:	6178      	str	r0, [r7, #20]
 800eda8:	697b      	ldr	r3, [r7, #20]
 800edaa:	2b00      	cmp	r3, #0
 800edac:	d1c4      	bne.n	800ed38 <lv_cont_layout_center+0xba>
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 800edae:	2101      	movs	r1, #1
 800edb0:	6878      	ldr	r0, [r7, #4]
 800edb2:	f7f3 f973 	bl	800209c <lv_obj_clear_protect>
 800edb6:	e000      	b.n	800edba <lv_cont_layout_center+0x13c>
    if(obj_num == 0) return;
 800edb8:	bf00      	nop
}
 800edba:	3718      	adds	r7, #24
 800edbc:	46bd      	mov	sp, r7
 800edbe:	bd80      	pop	{r7, pc}

0800edc0 <lv_cont_layout_pretty>:
 * Handle the pretty layout. Put as many object as possible in row
 * then begin a new row
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_pretty(lv_obj_t * cont)
{
 800edc0:	b5b0      	push	{r4, r5, r7, lr}
 800edc2:	b090      	sub	sp, #64	; 0x40
 800edc4:	af02      	add	r7, sp, #8
 800edc6:	6078      	str	r0, [r7, #4]
    lv_obj_t * child_rs;  /* Row starter child */
    lv_obj_t * child_rc;  /* Row closer child */
    lv_obj_t * child_tmp; /* Temporary child */
    const lv_style_t * style = lv_obj_get_style(cont);
 800edc8:	6878      	ldr	r0, [r7, #4]
 800edca:	f7f3 fcc1 	bl	8002750 <lv_obj_get_style>
 800edce:	61b8      	str	r0, [r7, #24]
    lv_coord_t w_obj         = lv_obj_get_width(cont);
 800edd0:	6878      	ldr	r0, [r7, #4]
 800edd2:	f7f3 fc21 	bl	8002618 <lv_obj_get_width>
 800edd6:	4603      	mov	r3, r0
 800edd8:	82fb      	strh	r3, [r7, #22]
    lv_coord_t act_y         = style->body.padding.top;
 800edda:	69bb      	ldr	r3, [r7, #24]
 800eddc:	8adb      	ldrh	r3, [r3, #22]
 800edde:	857b      	strh	r3, [r7, #42]	; 0x2a
    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/

    child_rs = lv_ll_get_tail(&cont->child_ll); /*Set the row starter child*/
 800ede0:	687b      	ldr	r3, [r7, #4]
 800ede2:	3304      	adds	r3, #4
 800ede4:	4618      	mov	r0, r3
 800ede6:	f7fd fdfc 	bl	800c9e2 <lv_ll_get_tail>
 800edea:	6378      	str	r0, [r7, #52]	; 0x34
    if(child_rs == NULL) return;                /*Return if no child*/
 800edec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800edee:	2b00      	cmp	r3, #0
 800edf0:	f000 8180 	beq.w	800f0f4 <lv_cont_layout_pretty+0x334>

    lv_obj_set_protect(cont, LV_PROTECT_CHILD_CHG);
 800edf4:	2101      	movs	r1, #1
 800edf6:	6878      	ldr	r0, [r7, #4]
 800edf8:	f7f3 f928 	bl	800204c <lv_obj_set_protect>

    child_rc = child_rs; /*Initially the the row starter and closer is the same*/
 800edfc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800edfe:	633b      	str	r3, [r7, #48]	; 0x30
    while(child_rs != NULL) {
 800ee00:	e16d      	b.n	800f0de <lv_cont_layout_pretty+0x31e>
        lv_coord_t h_row = 0;
 800ee02:	2300      	movs	r3, #0
 800ee04:	853b      	strh	r3, [r7, #40]	; 0x28
        lv_coord_t w_row =
            style->body.padding.left + style->body.padding.right; /*The width is at least the left+right hpad*/
 800ee06:	69bb      	ldr	r3, [r7, #24]
 800ee08:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 800ee0c:	b29a      	uxth	r2, r3
 800ee0e:	69bb      	ldr	r3, [r7, #24]
 800ee10:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 800ee14:	b29b      	uxth	r3, r3
 800ee16:	4413      	add	r3, r2
 800ee18:	b29b      	uxth	r3, r3
        lv_coord_t w_row =
 800ee1a:	84fb      	strh	r3, [r7, #38]	; 0x26
        uint32_t obj_num = 0;
 800ee1c:	2300      	movs	r3, #0
 800ee1e:	623b      	str	r3, [r7, #32]

        /*Find the row closer object and collect some data*/
        do {
            if(lv_obj_get_hidden(child_rc) == false && lv_obj_is_protected(child_rc, LV_PROTECT_POS) == false) {
 800ee20:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800ee22:	f7f3 fd01 	bl	8002828 <lv_obj_get_hidden>
 800ee26:	4603      	mov	r3, r0
 800ee28:	f083 0301 	eor.w	r3, r3, #1
 800ee2c:	b2db      	uxtb	r3, r3
 800ee2e:	2b00      	cmp	r3, #0
 800ee30:	d04b      	beq.n	800eeca <lv_cont_layout_pretty+0x10a>
 800ee32:	2104      	movs	r1, #4
 800ee34:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800ee36:	f7f3 fd5f 	bl	80028f8 <lv_obj_is_protected>
 800ee3a:	4603      	mov	r3, r0
 800ee3c:	f083 0301 	eor.w	r3, r3, #1
 800ee40:	b2db      	uxtb	r3, r3
 800ee42:	2b00      	cmp	r3, #0
 800ee44:	d041      	beq.n	800eeca <lv_cont_layout_pretty+0x10a>
                /*If this object is already not fit then break*/
                if(w_row + lv_obj_get_width(child_rc) > w_obj) {
 800ee46:	f9b7 4026 	ldrsh.w	r4, [r7, #38]	; 0x26
 800ee4a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800ee4c:	f7f3 fbe4 	bl	8002618 <lv_obj_get_width>
 800ee50:	4603      	mov	r3, r0
 800ee52:	18e2      	adds	r2, r4, r3
 800ee54:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800ee58:	429a      	cmp	r2, r3
 800ee5a:	dd0d      	ble.n	800ee78 <lv_cont_layout_pretty+0xb8>
                    /*Step back one child because the last already not fit, so the previous is the
                     * closer*/
                    if(child_rc != NULL && obj_num != 0) {
 800ee5c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ee5e:	2b00      	cmp	r3, #0
 800ee60:	d043      	beq.n	800eeea <lv_cont_layout_pretty+0x12a>
 800ee62:	6a3b      	ldr	r3, [r7, #32]
 800ee64:	2b00      	cmp	r3, #0
 800ee66:	d040      	beq.n	800eeea <lv_cont_layout_pretty+0x12a>
                        child_rc = lv_ll_get_next(&cont->child_ll, child_rc);
 800ee68:	687b      	ldr	r3, [r7, #4]
 800ee6a:	3304      	adds	r3, #4
 800ee6c:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800ee6e:	4618      	mov	r0, r3
 800ee70:	f7fd fdca 	bl	800ca08 <lv_ll_get_next>
 800ee74:	6338      	str	r0, [r7, #48]	; 0x30
                    }
                    break;
 800ee76:	e038      	b.n	800eeea <lv_cont_layout_pretty+0x12a>
                }
                w_row += lv_obj_get_width(child_rc) + style->body.padding.inner; /*Add the object width + opad*/
 800ee78:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800ee7a:	f7f3 fbcd 	bl	8002618 <lv_obj_get_width>
 800ee7e:	4603      	mov	r3, r0
 800ee80:	461a      	mov	r2, r3
 800ee82:	69bb      	ldr	r3, [r7, #24]
 800ee84:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 800ee88:	4413      	add	r3, r2
 800ee8a:	b29a      	uxth	r2, r3
 800ee8c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800ee8e:	4413      	add	r3, r2
 800ee90:	b29b      	uxth	r3, r3
 800ee92:	84fb      	strh	r3, [r7, #38]	; 0x26
                h_row = LV_MATH_MAX(h_row, lv_obj_get_height(child_rc));         /*Search the highest object*/
 800ee94:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800ee96:	f7f3 fbe1 	bl	800265c <lv_obj_get_height>
 800ee9a:	4603      	mov	r3, r0
 800ee9c:	461a      	mov	r2, r3
 800ee9e:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 800eea2:	4293      	cmp	r3, r2
 800eea4:	dc04      	bgt.n	800eeb0 <lv_cont_layout_pretty+0xf0>
 800eea6:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800eea8:	f7f3 fbd8 	bl	800265c <lv_obj_get_height>
 800eeac:	4603      	mov	r3, r0
 800eeae:	e001      	b.n	800eeb4 <lv_cont_layout_pretty+0xf4>
 800eeb0:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 800eeb4:	853b      	strh	r3, [r7, #40]	; 0x28
                obj_num++;
 800eeb6:	6a3b      	ldr	r3, [r7, #32]
 800eeb8:	3301      	adds	r3, #1
 800eeba:	623b      	str	r3, [r7, #32]
                if(lv_obj_is_protected(child_rc, LV_PROTECT_FOLLOW))
 800eebc:	2108      	movs	r1, #8
 800eebe:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800eec0:	f7f3 fd1a 	bl	80028f8 <lv_obj_is_protected>
 800eec4:	4603      	mov	r3, r0
 800eec6:	2b00      	cmp	r3, #0
 800eec8:	d111      	bne.n	800eeee <lv_cont_layout_pretty+0x12e>
                    break; /*If can not be followed by an other object then break here*/
            }
            child_rc = lv_ll_get_prev(&cont->child_ll, child_rc); /*Load the next object*/
 800eeca:	687b      	ldr	r3, [r7, #4]
 800eecc:	3304      	adds	r3, #4
 800eece:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800eed0:	4618      	mov	r0, r3
 800eed2:	f7fd fdb3 	bl	800ca3c <lv_ll_get_prev>
 800eed6:	6338      	str	r0, [r7, #48]	; 0x30
            if(obj_num == 0)
 800eed8:	6a3b      	ldr	r3, [r7, #32]
 800eeda:	2b00      	cmp	r3, #0
 800eedc:	d101      	bne.n	800eee2 <lv_cont_layout_pretty+0x122>
                child_rs = child_rc; /*If the first object was hidden (or too long) then set the
 800eede:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800eee0:	637b      	str	r3, [r7, #52]	; 0x34
                                        next as first */
        } while(child_rc != NULL);
 800eee2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800eee4:	2b00      	cmp	r3, #0
 800eee6:	d19b      	bne.n	800ee20 <lv_cont_layout_pretty+0x60>
 800eee8:	e002      	b.n	800eef0 <lv_cont_layout_pretty+0x130>
                    break;
 800eeea:	bf00      	nop
 800eeec:	e000      	b.n	800eef0 <lv_cont_layout_pretty+0x130>
                    break; /*If can not be followed by an other object then break here*/
 800eeee:	bf00      	nop

        /*If the object is too long  then align it to the middle*/
        if(obj_num == 0) {
 800eef0:	6a3b      	ldr	r3, [r7, #32]
 800eef2:	2b00      	cmp	r3, #0
 800eef4:	d112      	bne.n	800ef1c <lv_cont_layout_pretty+0x15c>
            if(child_rc != NULL) {
 800eef6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800eef8:	2b00      	cmp	r3, #0
 800eefa:	f000 80d9 	beq.w	800f0b0 <lv_cont_layout_pretty+0x2f0>
                lv_obj_align(child_rc, cont, LV_ALIGN_IN_TOP_MID, 0, act_y);
 800eefe:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 800ef02:	9300      	str	r3, [sp, #0]
 800ef04:	2300      	movs	r3, #0
 800ef06:	2202      	movs	r2, #2
 800ef08:	6879      	ldr	r1, [r7, #4]
 800ef0a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800ef0c:	f7f2 fb10 	bl	8001530 <lv_obj_align>
                h_row = lv_obj_get_height(child_rc); /*Not set previously because of the early break*/
 800ef10:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800ef12:	f7f3 fba3 	bl	800265c <lv_obj_get_height>
 800ef16:	4603      	mov	r3, r0
 800ef18:	853b      	strh	r3, [r7, #40]	; 0x28
 800ef1a:	e0c9      	b.n	800f0b0 <lv_cont_layout_pretty+0x2f0>
            }
        }
        /*If there is only one object in the row then align it to the middle*/
        else if(obj_num == 1) {
 800ef1c:	6a3b      	ldr	r3, [r7, #32]
 800ef1e:	2b01      	cmp	r3, #1
 800ef20:	d109      	bne.n	800ef36 <lv_cont_layout_pretty+0x176>
            lv_obj_align(child_rs, cont, LV_ALIGN_IN_TOP_MID, 0, act_y);
 800ef22:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 800ef26:	9300      	str	r3, [sp, #0]
 800ef28:	2300      	movs	r3, #0
 800ef2a:	2202      	movs	r2, #2
 800ef2c:	6879      	ldr	r1, [r7, #4]
 800ef2e:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800ef30:	f7f2 fafe 	bl	8001530 <lv_obj_align>
 800ef34:	e0bc      	b.n	800f0b0 <lv_cont_layout_pretty+0x2f0>
        }
        /*If there are two object in the row then align them proportionally*/
        else if(obj_num == 2) {
 800ef36:	6a3b      	ldr	r3, [r7, #32]
 800ef38:	2b02      	cmp	r3, #2
 800ef3a:	d153      	bne.n	800efe4 <lv_cont_layout_pretty+0x224>
            lv_obj_t * obj1 = child_rs;
 800ef3c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ef3e:	613b      	str	r3, [r7, #16]
            lv_obj_t * obj2 = lv_ll_get_prev(&cont->child_ll, child_rs);
 800ef40:	687b      	ldr	r3, [r7, #4]
 800ef42:	3304      	adds	r3, #4
 800ef44:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800ef46:	4618      	mov	r0, r3
 800ef48:	f7fd fd78 	bl	800ca3c <lv_ll_get_prev>
 800ef4c:	60f8      	str	r0, [r7, #12]
            w_row           = lv_obj_get_width(obj1) + lv_obj_get_width(obj2);
 800ef4e:	6938      	ldr	r0, [r7, #16]
 800ef50:	f7f3 fb62 	bl	8002618 <lv_obj_get_width>
 800ef54:	4603      	mov	r3, r0
 800ef56:	b29c      	uxth	r4, r3
 800ef58:	68f8      	ldr	r0, [r7, #12]
 800ef5a:	f7f3 fb5d 	bl	8002618 <lv_obj_get_width>
 800ef5e:	4603      	mov	r3, r0
 800ef60:	b29b      	uxth	r3, r3
 800ef62:	4423      	add	r3, r4
 800ef64:	b29b      	uxth	r3, r3
 800ef66:	84fb      	strh	r3, [r7, #38]	; 0x26
            lv_coord_t pad  = (w_obj - w_row) / 3;
 800ef68:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 800ef6c:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 800ef70:	1ad3      	subs	r3, r2, r3
 800ef72:	4a62      	ldr	r2, [pc, #392]	; (800f0fc <lv_cont_layout_pretty+0x33c>)
 800ef74:	fb82 1203 	smull	r1, r2, r2, r3
 800ef78:	17db      	asrs	r3, r3, #31
 800ef7a:	1ad3      	subs	r3, r2, r3
 800ef7c:	817b      	strh	r3, [r7, #10]
            lv_obj_align(obj1, cont, LV_ALIGN_IN_TOP_LEFT, pad, act_y + (h_row - lv_obj_get_height(obj1)) / 2);
 800ef7e:	f9b7 4028 	ldrsh.w	r4, [r7, #40]	; 0x28
 800ef82:	6938      	ldr	r0, [r7, #16]
 800ef84:	f7f3 fb6a 	bl	800265c <lv_obj_get_height>
 800ef88:	4603      	mov	r3, r0
 800ef8a:	1ae3      	subs	r3, r4, r3
 800ef8c:	0fda      	lsrs	r2, r3, #31
 800ef8e:	4413      	add	r3, r2
 800ef90:	105b      	asrs	r3, r3, #1
 800ef92:	b29a      	uxth	r2, r3
 800ef94:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800ef96:	4413      	add	r3, r2
 800ef98:	b29b      	uxth	r3, r3
 800ef9a:	b21b      	sxth	r3, r3
 800ef9c:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 800efa0:	9300      	str	r3, [sp, #0]
 800efa2:	4613      	mov	r3, r2
 800efa4:	2201      	movs	r2, #1
 800efa6:	6879      	ldr	r1, [r7, #4]
 800efa8:	6938      	ldr	r0, [r7, #16]
 800efaa:	f7f2 fac1 	bl	8001530 <lv_obj_align>
            lv_obj_align(obj2, cont, LV_ALIGN_IN_TOP_RIGHT, -pad, act_y + (h_row - lv_obj_get_height(obj2)) / 2);
 800efae:	897b      	ldrh	r3, [r7, #10]
 800efb0:	425b      	negs	r3, r3
 800efb2:	b29b      	uxth	r3, r3
 800efb4:	b21d      	sxth	r5, r3
 800efb6:	f9b7 4028 	ldrsh.w	r4, [r7, #40]	; 0x28
 800efba:	68f8      	ldr	r0, [r7, #12]
 800efbc:	f7f3 fb4e 	bl	800265c <lv_obj_get_height>
 800efc0:	4603      	mov	r3, r0
 800efc2:	1ae3      	subs	r3, r4, r3
 800efc4:	0fda      	lsrs	r2, r3, #31
 800efc6:	4413      	add	r3, r2
 800efc8:	105b      	asrs	r3, r3, #1
 800efca:	b29a      	uxth	r2, r3
 800efcc:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800efce:	4413      	add	r3, r2
 800efd0:	b29b      	uxth	r3, r3
 800efd2:	b21b      	sxth	r3, r3
 800efd4:	9300      	str	r3, [sp, #0]
 800efd6:	462b      	mov	r3, r5
 800efd8:	2203      	movs	r2, #3
 800efda:	6879      	ldr	r1, [r7, #4]
 800efdc:	68f8      	ldr	r0, [r7, #12]
 800efde:	f7f2 faa7 	bl	8001530 <lv_obj_align>
 800efe2:	e065      	b.n	800f0b0 <lv_cont_layout_pretty+0x2f0>
        }
        /* Align the children (from child_rs to child_rc)*/
        else {
            w_row -= style->body.padding.inner * obj_num;
 800efe4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800efe6:	69bb      	ldr	r3, [r7, #24]
 800efe8:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 800efec:	b299      	uxth	r1, r3
 800efee:	6a3b      	ldr	r3, [r7, #32]
 800eff0:	b29b      	uxth	r3, r3
 800eff2:	fb11 f303 	smulbb	r3, r1, r3
 800eff6:	b29b      	uxth	r3, r3
 800eff8:	1ad3      	subs	r3, r2, r3
 800effa:	b29b      	uxth	r3, r3
 800effc:	84fb      	strh	r3, [r7, #38]	; 0x26
            lv_coord_t new_opad = (w_obj - w_row) / (obj_num - 1);
 800effe:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 800f002:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 800f006:	1ad3      	subs	r3, r2, r3
 800f008:	461a      	mov	r2, r3
 800f00a:	6a3b      	ldr	r3, [r7, #32]
 800f00c:	3b01      	subs	r3, #1
 800f00e:	fbb2 f3f3 	udiv	r3, r2, r3
 800f012:	82bb      	strh	r3, [r7, #20]
            lv_coord_t act_x    = style->body.padding.left; /*x init*/
 800f014:	69bb      	ldr	r3, [r7, #24]
 800f016:	8b5b      	ldrh	r3, [r3, #26]
 800f018:	83fb      	strh	r3, [r7, #30]
            child_tmp           = child_rs;
 800f01a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f01c:	62fb      	str	r3, [r7, #44]	; 0x2c
            while(child_tmp != NULL) {
 800f01e:	e042      	b.n	800f0a6 <lv_cont_layout_pretty+0x2e6>
                if(lv_obj_get_hidden(child_tmp) == false && lv_obj_is_protected(child_tmp, LV_PROTECT_POS) == false) {
 800f020:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800f022:	f7f3 fc01 	bl	8002828 <lv_obj_get_hidden>
 800f026:	4603      	mov	r3, r0
 800f028:	f083 0301 	eor.w	r3, r3, #1
 800f02c:	b2db      	uxtb	r3, r3
 800f02e:	2b00      	cmp	r3, #0
 800f030:	d02e      	beq.n	800f090 <lv_cont_layout_pretty+0x2d0>
 800f032:	2104      	movs	r1, #4
 800f034:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800f036:	f7f3 fc5f 	bl	80028f8 <lv_obj_is_protected>
 800f03a:	4603      	mov	r3, r0
 800f03c:	f083 0301 	eor.w	r3, r3, #1
 800f040:	b2db      	uxtb	r3, r3
 800f042:	2b00      	cmp	r3, #0
 800f044:	d024      	beq.n	800f090 <lv_cont_layout_pretty+0x2d0>
                    lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT, act_x,
                                 act_y + (h_row - lv_obj_get_height(child_tmp)) / 2);
 800f046:	f9b7 4028 	ldrsh.w	r4, [r7, #40]	; 0x28
 800f04a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800f04c:	f7f3 fb06 	bl	800265c <lv_obj_get_height>
 800f050:	4603      	mov	r3, r0
 800f052:	1ae3      	subs	r3, r4, r3
 800f054:	0fda      	lsrs	r2, r3, #31
 800f056:	4413      	add	r3, r2
 800f058:	105b      	asrs	r3, r3, #1
 800f05a:	b29a      	uxth	r2, r3
 800f05c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800f05e:	4413      	add	r3, r2
 800f060:	b29b      	uxth	r3, r3
                    lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT, act_x,
 800f062:	b21b      	sxth	r3, r3
 800f064:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 800f068:	9300      	str	r3, [sp, #0]
 800f06a:	4613      	mov	r3, r2
 800f06c:	2201      	movs	r2, #1
 800f06e:	6879      	ldr	r1, [r7, #4]
 800f070:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800f072:	f7f2 fa5d 	bl	8001530 <lv_obj_align>
                    act_x += lv_obj_get_width(child_tmp) + new_opad;
 800f076:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800f078:	f7f3 face 	bl	8002618 <lv_obj_get_width>
 800f07c:	4603      	mov	r3, r0
 800f07e:	461a      	mov	r2, r3
 800f080:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800f084:	4413      	add	r3, r2
 800f086:	b29a      	uxth	r2, r3
 800f088:	8bfb      	ldrh	r3, [r7, #30]
 800f08a:	4413      	add	r3, r2
 800f08c:	b29b      	uxth	r3, r3
 800f08e:	83fb      	strh	r3, [r7, #30]
                }
                if(child_tmp == child_rc) break;
 800f090:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800f092:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f094:	429a      	cmp	r2, r3
 800f096:	d00a      	beq.n	800f0ae <lv_cont_layout_pretty+0x2ee>
                child_tmp = lv_ll_get_prev(&cont->child_ll, child_tmp);
 800f098:	687b      	ldr	r3, [r7, #4]
 800f09a:	3304      	adds	r3, #4
 800f09c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800f09e:	4618      	mov	r0, r3
 800f0a0:	f7fd fccc 	bl	800ca3c <lv_ll_get_prev>
 800f0a4:	62f8      	str	r0, [r7, #44]	; 0x2c
            while(child_tmp != NULL) {
 800f0a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f0a8:	2b00      	cmp	r3, #0
 800f0aa:	d1b9      	bne.n	800f020 <lv_cont_layout_pretty+0x260>
 800f0ac:	e000      	b.n	800f0b0 <lv_cont_layout_pretty+0x2f0>
                if(child_tmp == child_rc) break;
 800f0ae:	bf00      	nop
            }
        }

        if(child_rc == NULL) break;
 800f0b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f0b2:	2b00      	cmp	r3, #0
 800f0b4:	d018      	beq.n	800f0e8 <lv_cont_layout_pretty+0x328>
        act_y += style->body.padding.inner + h_row;           /*y increment*/
 800f0b6:	69bb      	ldr	r3, [r7, #24]
 800f0b8:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 800f0bc:	b29a      	uxth	r2, r3
 800f0be:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800f0c0:	4413      	add	r3, r2
 800f0c2:	b29a      	uxth	r2, r3
 800f0c4:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800f0c6:	4413      	add	r3, r2
 800f0c8:	b29b      	uxth	r3, r3
 800f0ca:	857b      	strh	r3, [r7, #42]	; 0x2a
        child_rs = lv_ll_get_prev(&cont->child_ll, child_rc); /*Go to the next object*/
 800f0cc:	687b      	ldr	r3, [r7, #4]
 800f0ce:	3304      	adds	r3, #4
 800f0d0:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800f0d2:	4618      	mov	r0, r3
 800f0d4:	f7fd fcb2 	bl	800ca3c <lv_ll_get_prev>
 800f0d8:	6378      	str	r0, [r7, #52]	; 0x34
        child_rc = child_rs;
 800f0da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f0dc:	633b      	str	r3, [r7, #48]	; 0x30
    while(child_rs != NULL) {
 800f0de:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f0e0:	2b00      	cmp	r3, #0
 800f0e2:	f47f ae8e 	bne.w	800ee02 <lv_cont_layout_pretty+0x42>
 800f0e6:	e000      	b.n	800f0ea <lv_cont_layout_pretty+0x32a>
        if(child_rc == NULL) break;
 800f0e8:	bf00      	nop
    }
    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 800f0ea:	2101      	movs	r1, #1
 800f0ec:	6878      	ldr	r0, [r7, #4]
 800f0ee:	f7f2 ffd5 	bl	800209c <lv_obj_clear_protect>
 800f0f2:	e000      	b.n	800f0f6 <lv_cont_layout_pretty+0x336>
    if(child_rs == NULL) return;                /*Return if no child*/
 800f0f4:	bf00      	nop
}
 800f0f6:	3738      	adds	r7, #56	; 0x38
 800f0f8:	46bd      	mov	sp, r7
 800f0fa:	bdb0      	pop	{r4, r5, r7, pc}
 800f0fc:	55555556 	.word	0x55555556

0800f100 <lv_cont_layout_grid>:
/**
 * Handle the grid layout. Align same-sized objects in a grid
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_grid(lv_obj_t * cont)
{
 800f100:	b580      	push	{r7, lr}
 800f102:	b08a      	sub	sp, #40	; 0x28
 800f104:	af00      	add	r7, sp, #0
 800f106:	6078      	str	r0, [r7, #4]
    lv_obj_t * child;
    const lv_style_t * style = lv_obj_get_style(cont);
 800f108:	6878      	ldr	r0, [r7, #4]
 800f10a:	f7f3 fb21 	bl	8002750 <lv_obj_get_style>
 800f10e:	61b8      	str	r0, [r7, #24]
    lv_coord_t w_tot         = lv_obj_get_width(cont);
 800f110:	6878      	ldr	r0, [r7, #4]
 800f112:	f7f3 fa81 	bl	8002618 <lv_obj_get_width>
 800f116:	4603      	mov	r3, r0
 800f118:	82fb      	strh	r3, [r7, #22]
    lv_coord_t w_obj         = lv_obj_get_width(lv_obj_get_child(cont, NULL));
 800f11a:	2100      	movs	r1, #0
 800f11c:	6878      	ldr	r0, [r7, #4]
 800f11e:	f7f3 f9bd 	bl	800249c <lv_obj_get_child>
 800f122:	4603      	mov	r3, r0
 800f124:	4618      	mov	r0, r3
 800f126:	f7f3 fa77 	bl	8002618 <lv_obj_get_width>
 800f12a:	4603      	mov	r3, r0
 800f12c:	82bb      	strh	r3, [r7, #20]
    lv_coord_t w_fit         =  lv_obj_get_width_fit(cont);
 800f12e:	6878      	ldr	r0, [r7, #4]
 800f130:	f7f3 fab6 	bl	80026a0 <lv_obj_get_width_fit>
 800f134:	4603      	mov	r3, r0
 800f136:	827b      	strh	r3, [r7, #18]
    lv_coord_t h_obj         = lv_obj_get_height(lv_obj_get_child(cont, NULL));
 800f138:	2100      	movs	r1, #0
 800f13a:	6878      	ldr	r0, [r7, #4]
 800f13c:	f7f3 f9ae 	bl	800249c <lv_obj_get_child>
 800f140:	4603      	mov	r3, r0
 800f142:	4618      	mov	r0, r3
 800f144:	f7f3 fa8a 	bl	800265c <lv_obj_get_height>
 800f148:	4603      	mov	r3, r0
 800f14a:	823b      	strh	r3, [r7, #16]
    uint16_t obj_row         = (w_fit) / (w_obj + style->body.padding.inner); /*Obj. num. in a row*/
 800f14c:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 800f150:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800f154:	69b9      	ldr	r1, [r7, #24]
 800f156:	f9b1 101e 	ldrsh.w	r1, [r1, #30]
 800f15a:	440b      	add	r3, r1
 800f15c:	fb92 f3f3 	sdiv	r3, r2, r3
 800f160:	81fb      	strh	r3, [r7, #14]
    lv_coord_t x_ofs;
    if(obj_row > 1) {
 800f162:	89fb      	ldrh	r3, [r7, #14]
 800f164:	2b01      	cmp	r3, #1
 800f166:	d911      	bls.n	800f18c <lv_cont_layout_grid+0x8c>
        x_ofs = w_obj + (w_fit - (obj_row * w_obj)) / (obj_row - 1);
 800f168:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 800f16c:	89fb      	ldrh	r3, [r7, #14]
 800f16e:	f9b7 1014 	ldrsh.w	r1, [r7, #20]
 800f172:	fb01 f303 	mul.w	r3, r1, r3
 800f176:	1ad2      	subs	r2, r2, r3
 800f178:	89fb      	ldrh	r3, [r7, #14]
 800f17a:	3b01      	subs	r3, #1
 800f17c:	fb92 f3f3 	sdiv	r3, r2, r3
 800f180:	b29a      	uxth	r2, r3
 800f182:	8abb      	ldrh	r3, [r7, #20]
 800f184:	4413      	add	r3, r2
 800f186:	b29b      	uxth	r3, r3
 800f188:	847b      	strh	r3, [r7, #34]	; 0x22
 800f18a:	e010      	b.n	800f1ae <lv_cont_layout_grid+0xae>
    } else {
        x_ofs = w_tot / 2 - w_obj / 2;
 800f18c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800f190:	0fda      	lsrs	r2, r3, #31
 800f192:	4413      	add	r3, r2
 800f194:	105b      	asrs	r3, r3, #1
 800f196:	b21b      	sxth	r3, r3
 800f198:	b29a      	uxth	r2, r3
 800f19a:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800f19e:	0fd9      	lsrs	r1, r3, #31
 800f1a0:	440b      	add	r3, r1
 800f1a2:	105b      	asrs	r3, r3, #1
 800f1a4:	b21b      	sxth	r3, r3
 800f1a6:	b29b      	uxth	r3, r3
 800f1a8:	1ad3      	subs	r3, r2, r3
 800f1aa:	b29b      	uxth	r3, r3
 800f1ac:	847b      	strh	r3, [r7, #34]	; 0x22
    }
    lv_coord_t y_ofs = h_obj + style->body.padding.inner;
 800f1ae:	69bb      	ldr	r3, [r7, #24]
 800f1b0:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 800f1b4:	b29a      	uxth	r2, r3
 800f1b6:	8a3b      	ldrh	r3, [r7, #16]
 800f1b8:	4413      	add	r3, r2
 800f1ba:	b29b      	uxth	r3, r3
 800f1bc:	81bb      	strh	r3, [r7, #12]

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_set_protect(cont, LV_PROTECT_CHILD_CHG);
 800f1be:	2101      	movs	r1, #1
 800f1c0:	6878      	ldr	r0, [r7, #4]
 800f1c2:	f7f2 ff43 	bl	800204c <lv_obj_set_protect>

    /* Align the children */
    lv_coord_t act_x = style->body.padding.left;
 800f1c6:	69bb      	ldr	r3, [r7, #24]
 800f1c8:	8b5b      	ldrh	r3, [r3, #26]
 800f1ca:	843b      	strh	r3, [r7, #32]
    lv_coord_t act_y = style->body.padding.top;
 800f1cc:	69bb      	ldr	r3, [r7, #24]
 800f1ce:	8adb      	ldrh	r3, [r3, #22]
 800f1d0:	83fb      	strh	r3, [r7, #30]
    uint16_t obj_cnt = 0;
 800f1d2:	2300      	movs	r3, #0
 800f1d4:	83bb      	strh	r3, [r7, #28]
    LV_LL_READ_BACK(cont->child_ll, child)
 800f1d6:	687b      	ldr	r3, [r7, #4]
 800f1d8:	3304      	adds	r3, #4
 800f1da:	4618      	mov	r0, r3
 800f1dc:	f7fd fc01 	bl	800c9e2 <lv_ll_get_tail>
 800f1e0:	6278      	str	r0, [r7, #36]	; 0x24
 800f1e2:	e03f      	b.n	800f264 <lv_cont_layout_grid+0x164>
    {
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 800f1e4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800f1e6:	f7f3 fb1f 	bl	8002828 <lv_obj_get_hidden>
 800f1ea:	4603      	mov	r3, r0
 800f1ec:	2b00      	cmp	r3, #0
 800f1ee:	d131      	bne.n	800f254 <lv_cont_layout_grid+0x154>
 800f1f0:	2104      	movs	r1, #4
 800f1f2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800f1f4:	f7f3 fb80 	bl	80028f8 <lv_obj_is_protected>
 800f1f8:	4603      	mov	r3, r0
 800f1fa:	2b00      	cmp	r3, #0
 800f1fc:	d12a      	bne.n	800f254 <lv_cont_layout_grid+0x154>

        if(obj_row > 1) {
 800f1fe:	89fb      	ldrh	r3, [r7, #14]
 800f200:	2b01      	cmp	r3, #1
 800f202:	d90d      	bls.n	800f220 <lv_cont_layout_grid+0x120>
            lv_obj_set_pos(child, act_x, act_y);
 800f204:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 800f208:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 800f20c:	4619      	mov	r1, r3
 800f20e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800f210:	f7f1 ffd0 	bl	80011b4 <lv_obj_set_pos>
            act_x += x_ofs;
 800f214:	8c3a      	ldrh	r2, [r7, #32]
 800f216:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800f218:	4413      	add	r3, r2
 800f21a:	b29b      	uxth	r3, r3
 800f21c:	843b      	strh	r3, [r7, #32]
 800f21e:	e007      	b.n	800f230 <lv_cont_layout_grid+0x130>
        } else {
            lv_obj_set_pos(child, x_ofs, act_y);
 800f220:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 800f224:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 800f228:	4619      	mov	r1, r3
 800f22a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800f22c:	f7f1 ffc2 	bl	80011b4 <lv_obj_set_pos>
        }
        obj_cnt++;
 800f230:	8bbb      	ldrh	r3, [r7, #28]
 800f232:	3301      	adds	r3, #1
 800f234:	83bb      	strh	r3, [r7, #28]

        if(obj_cnt >= obj_row) {
 800f236:	8bba      	ldrh	r2, [r7, #28]
 800f238:	89fb      	ldrh	r3, [r7, #14]
 800f23a:	429a      	cmp	r2, r3
 800f23c:	d30b      	bcc.n	800f256 <lv_cont_layout_grid+0x156>
            obj_cnt = 0;
 800f23e:	2300      	movs	r3, #0
 800f240:	83bb      	strh	r3, [r7, #28]
            act_x   = style->body.padding.left;
 800f242:	69bb      	ldr	r3, [r7, #24]
 800f244:	8b5b      	ldrh	r3, [r3, #26]
 800f246:	843b      	strh	r3, [r7, #32]
            act_y += y_ofs;
 800f248:	8bfa      	ldrh	r2, [r7, #30]
 800f24a:	89bb      	ldrh	r3, [r7, #12]
 800f24c:	4413      	add	r3, r2
 800f24e:	b29b      	uxth	r3, r3
 800f250:	83fb      	strh	r3, [r7, #30]
 800f252:	e000      	b.n	800f256 <lv_cont_layout_grid+0x156>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 800f254:	bf00      	nop
    LV_LL_READ_BACK(cont->child_ll, child)
 800f256:	687b      	ldr	r3, [r7, #4]
 800f258:	3304      	adds	r3, #4
 800f25a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800f25c:	4618      	mov	r0, r3
 800f25e:	f7fd fbed 	bl	800ca3c <lv_ll_get_prev>
 800f262:	6278      	str	r0, [r7, #36]	; 0x24
 800f264:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f266:	2b00      	cmp	r3, #0
 800f268:	d1bc      	bne.n	800f1e4 <lv_cont_layout_grid+0xe4>
        }
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 800f26a:	2101      	movs	r1, #1
 800f26c:	6878      	ldr	r0, [r7, #4]
 800f26e:	f7f2 ff15 	bl	800209c <lv_obj_clear_protect>
}
 800f272:	bf00      	nop
 800f274:	3728      	adds	r7, #40	; 0x28
 800f276:	46bd      	mov	sp, r7
 800f278:	bd80      	pop	{r7, pc}

0800f27a <lv_cont_refr_autofit>:
/**
 * Handle auto fit. Set the size of the object to involve all children.
 * @param cont pointer to an object which size will be modified
 */
static void lv_cont_refr_autofit(lv_obj_t * cont)
{
 800f27a:	b580      	push	{r7, lr}
 800f27c:	b090      	sub	sp, #64	; 0x40
 800f27e:	af00      	add	r7, sp, #0
 800f280:	6078      	str	r0, [r7, #4]
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 800f282:	6878      	ldr	r0, [r7, #4]
 800f284:	f7f3 fb9e 	bl	80029c4 <lv_obj_get_ext_attr>
 800f288:	63b8      	str	r0, [r7, #56]	; 0x38

    if(ext->fit_left == LV_FIT_NONE && ext->fit_right == LV_FIT_NONE && ext->fit_top == LV_FIT_NONE &&
 800f28a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f28c:	781b      	ldrb	r3, [r3, #0]
 800f28e:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800f292:	b2db      	uxtb	r3, r3
 800f294:	2b00      	cmp	r3, #0
 800f296:	d115      	bne.n	800f2c4 <lv_cont_refr_autofit+0x4a>
 800f298:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f29a:	781b      	ldrb	r3, [r3, #0]
 800f29c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800f2a0:	b2db      	uxtb	r3, r3
 800f2a2:	2b00      	cmp	r3, #0
 800f2a4:	d10e      	bne.n	800f2c4 <lv_cont_refr_autofit+0x4a>
 800f2a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f2a8:	785b      	ldrb	r3, [r3, #1]
 800f2aa:	f003 0303 	and.w	r3, r3, #3
 800f2ae:	b2db      	uxtb	r3, r3
 800f2b0:	2b00      	cmp	r3, #0
 800f2b2:	d107      	bne.n	800f2c4 <lv_cont_refr_autofit+0x4a>
       ext->fit_bottom == LV_FIT_NONE) {
 800f2b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f2b6:	785b      	ldrb	r3, [r3, #1]
 800f2b8:	f003 030c 	and.w	r3, r3, #12
 800f2bc:	b2db      	uxtb	r3, r3
    if(ext->fit_left == LV_FIT_NONE && ext->fit_right == LV_FIT_NONE && ext->fit_top == LV_FIT_NONE &&
 800f2be:	2b00      	cmp	r3, #0
 800f2c0:	f000 81c8 	beq.w	800f654 <lv_cont_refr_autofit+0x3da>
        return;
    }

    lv_area_t tight_area;
    lv_area_t ori;
    const lv_style_t * style = lv_obj_get_style(cont);
 800f2c4:	6878      	ldr	r0, [r7, #4]
 800f2c6:	f7f3 fa43 	bl	8002750 <lv_obj_get_style>
 800f2ca:	6378      	str	r0, [r7, #52]	; 0x34
    lv_obj_t * child_i;

    lv_obj_t * par               = lv_obj_get_parent(cont);
 800f2cc:	6878      	ldr	r0, [r7, #4]
 800f2ce:	f7f3 f8c7 	bl	8002460 <lv_obj_get_parent>
 800f2d2:	6338      	str	r0, [r7, #48]	; 0x30
    const lv_style_t * par_style = lv_obj_get_style(par);
 800f2d4:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800f2d6:	f7f3 fa3b 	bl	8002750 <lv_obj_get_style>
 800f2da:	62f8      	str	r0, [r7, #44]	; 0x2c
    lv_area_t flood_area;
    lv_area_copy(&flood_area, &par->coords);
 800f2dc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f2de:	f103 0210 	add.w	r2, r3, #16
 800f2e2:	f107 0310 	add.w	r3, r7, #16
 800f2e6:	4611      	mov	r1, r2
 800f2e8:	4618      	mov	r0, r3
 800f2ea:	f7ff f98d 	bl	800e608 <lv_area_copy>
    flood_area.x1 += par_style->body.padding.left;
 800f2ee:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800f2f2:	b29a      	uxth	r2, r3
 800f2f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f2f6:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 800f2fa:	b29b      	uxth	r3, r3
 800f2fc:	4413      	add	r3, r2
 800f2fe:	b29b      	uxth	r3, r3
 800f300:	b21b      	sxth	r3, r3
 800f302:	823b      	strh	r3, [r7, #16]
    flood_area.x2 -= par_style->body.padding.right;
 800f304:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800f308:	b29a      	uxth	r2, r3
 800f30a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f30c:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 800f310:	b29b      	uxth	r3, r3
 800f312:	1ad3      	subs	r3, r2, r3
 800f314:	b29b      	uxth	r3, r3
 800f316:	b21b      	sxth	r3, r3
 800f318:	82bb      	strh	r3, [r7, #20]
    flood_area.y1 += par_style->body.padding.top;
 800f31a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800f31e:	b29a      	uxth	r2, r3
 800f320:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f322:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800f326:	b29b      	uxth	r3, r3
 800f328:	4413      	add	r3, r2
 800f32a:	b29b      	uxth	r3, r3
 800f32c:	b21b      	sxth	r3, r3
 800f32e:	827b      	strh	r3, [r7, #18]
    flood_area.y2 -= par_style->body.padding.bottom;
 800f330:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800f334:	b29a      	uxth	r2, r3
 800f336:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f338:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 800f33c:	b29b      	uxth	r3, r3
 800f33e:	1ad3      	subs	r3, r2, r3
 800f340:	b29b      	uxth	r3, r3
 800f342:	b21b      	sxth	r3, r3
 800f344:	82fb      	strh	r3, [r7, #22]

    /*Search the side coordinates of the children*/
    lv_obj_get_coords(cont, &ori);
 800f346:	f107 0318 	add.w	r3, r7, #24
 800f34a:	4619      	mov	r1, r3
 800f34c:	6878      	ldr	r0, [r7, #4]
 800f34e:	f7f3 f8d7 	bl	8002500 <lv_obj_get_coords>
    lv_obj_get_coords(cont, &tight_area);
 800f352:	f107 0320 	add.w	r3, r7, #32
 800f356:	4619      	mov	r1, r3
 800f358:	6878      	ldr	r0, [r7, #4]
 800f35a:	f7f3 f8d1 	bl	8002500 <lv_obj_get_coords>

    bool has_children = lv_ll_is_empty(&cont->child_ll) ? false : true;
 800f35e:	687b      	ldr	r3, [r7, #4]
 800f360:	3304      	adds	r3, #4
 800f362:	4618      	mov	r0, r3
 800f364:	f7fd fbc9 	bl	800cafa <lv_ll_is_empty>
 800f368:	4603      	mov	r3, r0
 800f36a:	f083 0301 	eor.w	r3, r3, #1
 800f36e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

    if(has_children) {
 800f372:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800f376:	2b00      	cmp	r3, #0
 800f378:	d078      	beq.n	800f46c <lv_cont_refr_autofit+0x1f2>
        tight_area.x1 = LV_COORD_MAX;
 800f37a:	f647 4318 	movw	r3, #31768	; 0x7c18
 800f37e:	843b      	strh	r3, [r7, #32]
        tight_area.y1 = LV_COORD_MAX;
 800f380:	f647 4318 	movw	r3, #31768	; 0x7c18
 800f384:	847b      	strh	r3, [r7, #34]	; 0x22
        tight_area.x2 = LV_COORD_MIN;
 800f386:	f248 33e8 	movw	r3, #33768	; 0x83e8
 800f38a:	84bb      	strh	r3, [r7, #36]	; 0x24
        tight_area.y2 = LV_COORD_MIN;
 800f38c:	f248 33e8 	movw	r3, #33768	; 0x83e8
 800f390:	84fb      	strh	r3, [r7, #38]	; 0x26

        LV_LL_READ(cont->child_ll, child_i)
 800f392:	687b      	ldr	r3, [r7, #4]
 800f394:	3304      	adds	r3, #4
 800f396:	4618      	mov	r0, r3
 800f398:	f7fd fb10 	bl	800c9bc <lv_ll_get_head>
 800f39c:	63f8      	str	r0, [r7, #60]	; 0x3c
 800f39e:	e036      	b.n	800f40e <lv_cont_refr_autofit+0x194>
        {
            if(lv_obj_get_hidden(child_i) != false) continue;
 800f3a0:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800f3a2:	f7f3 fa41 	bl	8002828 <lv_obj_get_hidden>
 800f3a6:	4603      	mov	r3, r0
 800f3a8:	2b00      	cmp	r3, #0
 800f3aa:	d128      	bne.n	800f3fe <lv_cont_refr_autofit+0x184>
            tight_area.x1 = LV_MATH_MIN(tight_area.x1, child_i->coords.x1);
 800f3ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f3ae:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 800f3b2:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 800f3b6:	4293      	cmp	r3, r2
 800f3b8:	bfa8      	it	ge
 800f3ba:	4613      	movge	r3, r2
 800f3bc:	b21b      	sxth	r3, r3
 800f3be:	843b      	strh	r3, [r7, #32]
            tight_area.y1 = LV_MATH_MIN(tight_area.y1, child_i->coords.y1);
 800f3c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f3c2:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 800f3c6:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 800f3ca:	4293      	cmp	r3, r2
 800f3cc:	bfa8      	it	ge
 800f3ce:	4613      	movge	r3, r2
 800f3d0:	b21b      	sxth	r3, r3
 800f3d2:	847b      	strh	r3, [r7, #34]	; 0x22
            tight_area.x2 = LV_MATH_MAX(tight_area.x2, child_i->coords.x2);
 800f3d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f3d6:	f9b3 2014 	ldrsh.w	r2, [r3, #20]
 800f3da:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 800f3de:	4293      	cmp	r3, r2
 800f3e0:	bfb8      	it	lt
 800f3e2:	4613      	movlt	r3, r2
 800f3e4:	b21b      	sxth	r3, r3
 800f3e6:	84bb      	strh	r3, [r7, #36]	; 0x24
            tight_area.y2 = LV_MATH_MAX(tight_area.y2, child_i->coords.y2);
 800f3e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f3ea:	f9b3 2016 	ldrsh.w	r2, [r3, #22]
 800f3ee:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 800f3f2:	4293      	cmp	r3, r2
 800f3f4:	bfb8      	it	lt
 800f3f6:	4613      	movlt	r3, r2
 800f3f8:	b21b      	sxth	r3, r3
 800f3fa:	84fb      	strh	r3, [r7, #38]	; 0x26
 800f3fc:	e000      	b.n	800f400 <lv_cont_refr_autofit+0x186>
            if(lv_obj_get_hidden(child_i) != false) continue;
 800f3fe:	bf00      	nop
        LV_LL_READ(cont->child_ll, child_i)
 800f400:	687b      	ldr	r3, [r7, #4]
 800f402:	3304      	adds	r3, #4
 800f404:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800f406:	4618      	mov	r0, r3
 800f408:	f7fd fafe 	bl	800ca08 <lv_ll_get_next>
 800f40c:	63f8      	str	r0, [r7, #60]	; 0x3c
 800f40e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f410:	2b00      	cmp	r3, #0
 800f412:	d1c5      	bne.n	800f3a0 <lv_cont_refr_autofit+0x126>
        }

        tight_area.x1 -= style->body.padding.left;
 800f414:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 800f418:	b29a      	uxth	r2, r3
 800f41a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f41c:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 800f420:	b29b      	uxth	r3, r3
 800f422:	1ad3      	subs	r3, r2, r3
 800f424:	b29b      	uxth	r3, r3
 800f426:	b21b      	sxth	r3, r3
 800f428:	843b      	strh	r3, [r7, #32]
        tight_area.x2 += style->body.padding.right;
 800f42a:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 800f42e:	b29a      	uxth	r2, r3
 800f430:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f432:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 800f436:	b29b      	uxth	r3, r3
 800f438:	4413      	add	r3, r2
 800f43a:	b29b      	uxth	r3, r3
 800f43c:	b21b      	sxth	r3, r3
 800f43e:	84bb      	strh	r3, [r7, #36]	; 0x24
        tight_area.y1 -= style->body.padding.top;
 800f440:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 800f444:	b29a      	uxth	r2, r3
 800f446:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f448:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800f44c:	b29b      	uxth	r3, r3
 800f44e:	1ad3      	subs	r3, r2, r3
 800f450:	b29b      	uxth	r3, r3
 800f452:	b21b      	sxth	r3, r3
 800f454:	847b      	strh	r3, [r7, #34]	; 0x22
        tight_area.y2 += style->body.padding.bottom;
 800f456:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 800f45a:	b29a      	uxth	r2, r3
 800f45c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f45e:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 800f462:	b29b      	uxth	r3, r3
 800f464:	4413      	add	r3, r2
 800f466:	b29b      	uxth	r3, r3
 800f468:	b21b      	sxth	r3, r3
 800f46a:	84fb      	strh	r3, [r7, #38]	; 0x26
    }

    lv_area_t new_area;
    lv_area_copy(&new_area, &ori);
 800f46c:	f107 0218 	add.w	r2, r7, #24
 800f470:	f107 0308 	add.w	r3, r7, #8
 800f474:	4611      	mov	r1, r2
 800f476:	4618      	mov	r0, r3
 800f478:	f7ff f8c6 	bl	800e608 <lv_area_copy>

    switch(ext->fit_left) {
 800f47c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f47e:	781b      	ldrb	r3, [r3, #0]
 800f480:	f3c3 1301 	ubfx	r3, r3, #4, #2
 800f484:	b2db      	uxtb	r3, r3
 800f486:	2b02      	cmp	r3, #2
 800f488:	d008      	beq.n	800f49c <lv_cont_refr_autofit+0x222>
 800f48a:	2b03      	cmp	r3, #3
 800f48c:	d00a      	beq.n	800f4a4 <lv_cont_refr_autofit+0x22a>
 800f48e:	2b01      	cmp	r3, #1
 800f490:	d000      	beq.n	800f494 <lv_cont_refr_autofit+0x21a>
        case LV_FIT_TIGHT: new_area.x1 = tight_area.x1; break;
        case LV_FIT_FLOOD: new_area.x1 = flood_area.x1; break;
        case LV_FIT_FILL: new_area.x1 = has_children ? LV_MATH_MIN(tight_area.x1, flood_area.x1) : flood_area.x1; break;
        default: break;
 800f492:	e018      	b.n	800f4c6 <lv_cont_refr_autofit+0x24c>
        case LV_FIT_TIGHT: new_area.x1 = tight_area.x1; break;
 800f494:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 800f498:	813b      	strh	r3, [r7, #8]
 800f49a:	e014      	b.n	800f4c6 <lv_cont_refr_autofit+0x24c>
        case LV_FIT_FLOOD: new_area.x1 = flood_area.x1; break;
 800f49c:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800f4a0:	813b      	strh	r3, [r7, #8]
 800f4a2:	e010      	b.n	800f4c6 <lv_cont_refr_autofit+0x24c>
        case LV_FIT_FILL: new_area.x1 = has_children ? LV_MATH_MIN(tight_area.x1, flood_area.x1) : flood_area.x1; break;
 800f4a4:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800f4a8:	2b00      	cmp	r3, #0
 800f4aa:	d008      	beq.n	800f4be <lv_cont_refr_autofit+0x244>
 800f4ac:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 800f4b0:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 800f4b4:	4293      	cmp	r3, r2
 800f4b6:	bfa8      	it	ge
 800f4b8:	4613      	movge	r3, r2
 800f4ba:	b21b      	sxth	r3, r3
 800f4bc:	e001      	b.n	800f4c2 <lv_cont_refr_autofit+0x248>
 800f4be:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800f4c2:	813b      	strh	r3, [r7, #8]
 800f4c4:	bf00      	nop
    }

    switch(ext->fit_right) {
 800f4c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f4c8:	781b      	ldrb	r3, [r3, #0]
 800f4ca:	f3c3 1381 	ubfx	r3, r3, #6, #2
 800f4ce:	b2db      	uxtb	r3, r3
 800f4d0:	2b02      	cmp	r3, #2
 800f4d2:	d008      	beq.n	800f4e6 <lv_cont_refr_autofit+0x26c>
 800f4d4:	2b03      	cmp	r3, #3
 800f4d6:	d00a      	beq.n	800f4ee <lv_cont_refr_autofit+0x274>
 800f4d8:	2b01      	cmp	r3, #1
 800f4da:	d000      	beq.n	800f4de <lv_cont_refr_autofit+0x264>
        case LV_FIT_TIGHT: new_area.x2 = tight_area.x2; break;
        case LV_FIT_FLOOD: new_area.x2 = flood_area.x2; break;
        case LV_FIT_FILL: new_area.x2 = has_children ? LV_MATH_MAX(tight_area.x2, flood_area.x2) : flood_area.x2; break;
        default: break;
 800f4dc:	e018      	b.n	800f510 <lv_cont_refr_autofit+0x296>
        case LV_FIT_TIGHT: new_area.x2 = tight_area.x2; break;
 800f4de:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 800f4e2:	81bb      	strh	r3, [r7, #12]
 800f4e4:	e014      	b.n	800f510 <lv_cont_refr_autofit+0x296>
        case LV_FIT_FLOOD: new_area.x2 = flood_area.x2; break;
 800f4e6:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800f4ea:	81bb      	strh	r3, [r7, #12]
 800f4ec:	e010      	b.n	800f510 <lv_cont_refr_autofit+0x296>
        case LV_FIT_FILL: new_area.x2 = has_children ? LV_MATH_MAX(tight_area.x2, flood_area.x2) : flood_area.x2; break;
 800f4ee:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800f4f2:	2b00      	cmp	r3, #0
 800f4f4:	d008      	beq.n	800f508 <lv_cont_refr_autofit+0x28e>
 800f4f6:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 800f4fa:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 800f4fe:	4293      	cmp	r3, r2
 800f500:	bfb8      	it	lt
 800f502:	4613      	movlt	r3, r2
 800f504:	b21b      	sxth	r3, r3
 800f506:	e001      	b.n	800f50c <lv_cont_refr_autofit+0x292>
 800f508:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800f50c:	81bb      	strh	r3, [r7, #12]
 800f50e:	bf00      	nop
    }

    switch(ext->fit_top) {
 800f510:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f512:	785b      	ldrb	r3, [r3, #1]
 800f514:	f3c3 0301 	ubfx	r3, r3, #0, #2
 800f518:	b2db      	uxtb	r3, r3
 800f51a:	2b02      	cmp	r3, #2
 800f51c:	d008      	beq.n	800f530 <lv_cont_refr_autofit+0x2b6>
 800f51e:	2b03      	cmp	r3, #3
 800f520:	d00a      	beq.n	800f538 <lv_cont_refr_autofit+0x2be>
 800f522:	2b01      	cmp	r3, #1
 800f524:	d000      	beq.n	800f528 <lv_cont_refr_autofit+0x2ae>
        case LV_FIT_TIGHT: new_area.y1 = tight_area.y1; break;
        case LV_FIT_FLOOD: new_area.y1 = flood_area.y1; break;
        case LV_FIT_FILL: new_area.y1 = has_children ? LV_MATH_MIN(tight_area.y1, flood_area.y1) : flood_area.y1; break;
        default: break;
 800f526:	e018      	b.n	800f55a <lv_cont_refr_autofit+0x2e0>
        case LV_FIT_TIGHT: new_area.y1 = tight_area.y1; break;
 800f528:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 800f52c:	817b      	strh	r3, [r7, #10]
 800f52e:	e014      	b.n	800f55a <lv_cont_refr_autofit+0x2e0>
        case LV_FIT_FLOOD: new_area.y1 = flood_area.y1; break;
 800f530:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800f534:	817b      	strh	r3, [r7, #10]
 800f536:	e010      	b.n	800f55a <lv_cont_refr_autofit+0x2e0>
        case LV_FIT_FILL: new_area.y1 = has_children ? LV_MATH_MIN(tight_area.y1, flood_area.y1) : flood_area.y1; break;
 800f538:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800f53c:	2b00      	cmp	r3, #0
 800f53e:	d008      	beq.n	800f552 <lv_cont_refr_autofit+0x2d8>
 800f540:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 800f544:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 800f548:	4293      	cmp	r3, r2
 800f54a:	bfa8      	it	ge
 800f54c:	4613      	movge	r3, r2
 800f54e:	b21b      	sxth	r3, r3
 800f550:	e001      	b.n	800f556 <lv_cont_refr_autofit+0x2dc>
 800f552:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800f556:	817b      	strh	r3, [r7, #10]
 800f558:	bf00      	nop
    }

    switch(ext->fit_bottom) {
 800f55a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f55c:	785b      	ldrb	r3, [r3, #1]
 800f55e:	f3c3 0381 	ubfx	r3, r3, #2, #2
 800f562:	b2db      	uxtb	r3, r3
 800f564:	2b02      	cmp	r3, #2
 800f566:	d008      	beq.n	800f57a <lv_cont_refr_autofit+0x300>
 800f568:	2b03      	cmp	r3, #3
 800f56a:	d00a      	beq.n	800f582 <lv_cont_refr_autofit+0x308>
 800f56c:	2b01      	cmp	r3, #1
 800f56e:	d000      	beq.n	800f572 <lv_cont_refr_autofit+0x2f8>
        case LV_FIT_TIGHT: new_area.y2 = tight_area.y2; break;
        case LV_FIT_FLOOD: new_area.y2 = flood_area.y2; break;
        case LV_FIT_FILL: new_area.y2 = has_children ? LV_MATH_MAX(tight_area.y2, flood_area.y2) : flood_area.y2; break;
        default: break;
 800f570:	e018      	b.n	800f5a4 <lv_cont_refr_autofit+0x32a>
        case LV_FIT_TIGHT: new_area.y2 = tight_area.y2; break;
 800f572:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 800f576:	81fb      	strh	r3, [r7, #14]
 800f578:	e014      	b.n	800f5a4 <lv_cont_refr_autofit+0x32a>
        case LV_FIT_FLOOD: new_area.y2 = flood_area.y2; break;
 800f57a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800f57e:	81fb      	strh	r3, [r7, #14]
 800f580:	e010      	b.n	800f5a4 <lv_cont_refr_autofit+0x32a>
        case LV_FIT_FILL: new_area.y2 = has_children ? LV_MATH_MAX(tight_area.y2, flood_area.y2) : flood_area.y2; break;
 800f582:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800f586:	2b00      	cmp	r3, #0
 800f588:	d008      	beq.n	800f59c <lv_cont_refr_autofit+0x322>
 800f58a:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 800f58e:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 800f592:	4293      	cmp	r3, r2
 800f594:	bfb8      	it	lt
 800f596:	4613      	movlt	r3, r2
 800f598:	b21b      	sxth	r3, r3
 800f59a:	e001      	b.n	800f5a0 <lv_cont_refr_autofit+0x326>
 800f59c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800f5a0:	81fb      	strh	r3, [r7, #14]
 800f5a2:	bf00      	nop
    }

    /*Do nothing if the coordinates are not changed*/
    if(cont->coords.x1 != new_area.x1 || cont->coords.y1 != new_area.y1 || cont->coords.x2 != new_area.x2 ||
 800f5a4:	687b      	ldr	r3, [r7, #4]
 800f5a6:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 800f5aa:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 800f5ae:	429a      	cmp	r2, r3
 800f5b0:	d114      	bne.n	800f5dc <lv_cont_refr_autofit+0x362>
 800f5b2:	687b      	ldr	r3, [r7, #4]
 800f5b4:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 800f5b8:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 800f5bc:	429a      	cmp	r2, r3
 800f5be:	d10d      	bne.n	800f5dc <lv_cont_refr_autofit+0x362>
 800f5c0:	687b      	ldr	r3, [r7, #4]
 800f5c2:	f9b3 2014 	ldrsh.w	r2, [r3, #20]
 800f5c6:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 800f5ca:	429a      	cmp	r2, r3
 800f5cc:	d106      	bne.n	800f5dc <lv_cont_refr_autofit+0x362>
       cont->coords.y2 != new_area.y2) {
 800f5ce:	687b      	ldr	r3, [r7, #4]
 800f5d0:	f9b3 2016 	ldrsh.w	r2, [r3, #22]
 800f5d4:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    if(cont->coords.x1 != new_area.x1 || cont->coords.y1 != new_area.y1 || cont->coords.x2 != new_area.x2 ||
 800f5d8:	429a      	cmp	r2, r3
 800f5da:	d03c      	beq.n	800f656 <lv_cont_refr_autofit+0x3dc>

        lv_obj_invalidate(cont);
 800f5dc:	6878      	ldr	r0, [r7, #4]
 800f5de:	f7f1 fd5d 	bl	800109c <lv_obj_invalidate>
        lv_area_copy(&cont->coords, &new_area);
 800f5e2:	687b      	ldr	r3, [r7, #4]
 800f5e4:	3310      	adds	r3, #16
 800f5e6:	f107 0208 	add.w	r2, r7, #8
 800f5ea:	4611      	mov	r1, r2
 800f5ec:	4618      	mov	r0, r3
 800f5ee:	f7ff f80b 	bl	800e608 <lv_area_copy>
        lv_obj_invalidate(cont);
 800f5f2:	6878      	ldr	r0, [r7, #4]
 800f5f4:	f7f1 fd52 	bl	800109c <lv_obj_invalidate>

        /*Notify the object about its new coordinates*/
        cont->signal_cb(cont, LV_SIGNAL_CORD_CHG, &ori);
 800f5f8:	687b      	ldr	r3, [r7, #4]
 800f5fa:	69db      	ldr	r3, [r3, #28]
 800f5fc:	f107 0218 	add.w	r2, r7, #24
 800f600:	2102      	movs	r1, #2
 800f602:	6878      	ldr	r0, [r7, #4]
 800f604:	4798      	blx	r3

        /*Inform the parent about the new coordinates*/
        par->signal_cb(par, LV_SIGNAL_CHILD_CHG, cont);
 800f606:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f608:	69db      	ldr	r3, [r3, #28]
 800f60a:	687a      	ldr	r2, [r7, #4]
 800f60c:	2101      	movs	r1, #1
 800f60e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800f610:	4798      	blx	r3

        if(lv_obj_get_auto_realign(cont)) {
 800f612:	6878      	ldr	r0, [r7, #4]
 800f614:	f7f3 f876 	bl	8002704 <lv_obj_get_auto_realign>
 800f618:	4603      	mov	r3, r0
 800f61a:	2b00      	cmp	r3, #0
 800f61c:	d002      	beq.n	800f624 <lv_cont_refr_autofit+0x3aa>
            lv_obj_realign(cont);
 800f61e:	6878      	ldr	r0, [r7, #4]
 800f620:	f7f2 fc46 	bl	8001eb0 <lv_obj_realign>
        }

        /*Tell the children the parent's size has changed*/
        LV_LL_READ(cont->child_ll, child_i)
 800f624:	687b      	ldr	r3, [r7, #4]
 800f626:	3304      	adds	r3, #4
 800f628:	4618      	mov	r0, r3
 800f62a:	f7fd f9c7 	bl	800c9bc <lv_ll_get_head>
 800f62e:	63f8      	str	r0, [r7, #60]	; 0x3c
 800f630:	e00c      	b.n	800f64c <lv_cont_refr_autofit+0x3d2>
        {
            child_i->signal_cb(child_i, LV_SIGNAL_PARENT_SIZE_CHG, NULL);
 800f632:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f634:	69db      	ldr	r3, [r3, #28]
 800f636:	2200      	movs	r2, #0
 800f638:	2103      	movs	r1, #3
 800f63a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800f63c:	4798      	blx	r3
        LV_LL_READ(cont->child_ll, child_i)
 800f63e:	687b      	ldr	r3, [r7, #4]
 800f640:	3304      	adds	r3, #4
 800f642:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800f644:	4618      	mov	r0, r3
 800f646:	f7fd f9df 	bl	800ca08 <lv_ll_get_next>
 800f64a:	63f8      	str	r0, [r7, #60]	; 0x3c
 800f64c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f64e:	2b00      	cmp	r3, #0
 800f650:	d1ef      	bne.n	800f632 <lv_cont_refr_autofit+0x3b8>
 800f652:	e000      	b.n	800f656 <lv_cont_refr_autofit+0x3dc>
        return;
 800f654:	bf00      	nop
        }
    }
}
 800f656:	3740      	adds	r7, #64	; 0x40
 800f658:	46bd      	mov	sp, r7
 800f65a:	bd80      	pop	{r7, pc}

0800f65c <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
 800f65c:	b480      	push	{r7}
 800f65e:	b083      	sub	sp, #12
 800f660:	af00      	add	r7, sp, #0
 800f662:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 800f664:	687b      	ldr	r3, [r7, #4]
 800f666:	7a1b      	ldrb	r3, [r3, #8]
}
 800f668:	4618      	mov	r0, r3
 800f66a:	370c      	adds	r7, #12
 800f66c:	46bd      	mov	sp, r7
 800f66e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f672:	4770      	bx	lr

0800f674 <lv_area_get_width>:
{
 800f674:	b480      	push	{r7}
 800f676:	b083      	sub	sp, #12
 800f678:	af00      	add	r7, sp, #0
 800f67a:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 800f67c:	687b      	ldr	r3, [r7, #4]
 800f67e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800f682:	b29a      	uxth	r2, r3
 800f684:	687b      	ldr	r3, [r7, #4]
 800f686:	f9b3 3000 	ldrsh.w	r3, [r3]
 800f68a:	b29b      	uxth	r3, r3
 800f68c:	1ad3      	subs	r3, r2, r3
 800f68e:	b29b      	uxth	r3, r3
 800f690:	3301      	adds	r3, #1
 800f692:	b29b      	uxth	r3, r3
 800f694:	b21b      	sxth	r3, r3
}
 800f696:	4618      	mov	r0, r3
 800f698:	370c      	adds	r7, #12
 800f69a:	46bd      	mov	sp, r7
 800f69c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6a0:	4770      	bx	lr

0800f6a2 <lv_area_get_height>:
{
 800f6a2:	b480      	push	{r7}
 800f6a4:	b083      	sub	sp, #12
 800f6a6:	af00      	add	r7, sp, #0
 800f6a8:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 800f6aa:	687b      	ldr	r3, [r7, #4]
 800f6ac:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800f6b0:	b29a      	uxth	r2, r3
 800f6b2:	687b      	ldr	r3, [r7, #4]
 800f6b4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800f6b8:	b29b      	uxth	r3, r3
 800f6ba:	1ad3      	subs	r3, r2, r3
 800f6bc:	b29b      	uxth	r3, r3
 800f6be:	3301      	adds	r3, #1
 800f6c0:	b29b      	uxth	r3, r3
 800f6c2:	b21b      	sxth	r3, r3
}
 800f6c4:	4618      	mov	r0, r3
 800f6c6:	370c      	adds	r7, #12
 800f6c8:	46bd      	mov	sp, r7
 800f6ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6ce:	4770      	bx	lr

0800f6d0 <lv_label_set_style>:
 * @param label pointer to an label object
 * @param type which style should be get (can be only `LV_LABEL_STYLE_MAIN`)
 * @param style pointer to a style
 */
static inline void lv_label_set_style(lv_obj_t * label, lv_label_style_t type, const lv_style_t * style)
{
 800f6d0:	b580      	push	{r7, lr}
 800f6d2:	b084      	sub	sp, #16
 800f6d4:	af00      	add	r7, sp, #0
 800f6d6:	60f8      	str	r0, [r7, #12]
 800f6d8:	460b      	mov	r3, r1
 800f6da:	607a      	str	r2, [r7, #4]
 800f6dc:	72fb      	strb	r3, [r7, #11]
    (void)type; /*Unused*/
    lv_obj_set_style(label, style);
 800f6de:	6879      	ldr	r1, [r7, #4]
 800f6e0:	68f8      	ldr	r0, [r7, #12]
 800f6e2:	f7f2 fc2b 	bl	8001f3c <lv_obj_set_style>
}
 800f6e6:	bf00      	nop
 800f6e8:	3710      	adds	r7, #16
 800f6ea:	46bd      	mov	sp, r7
 800f6ec:	bd80      	pop	{r7, pc}

0800f6ee <lv_label_get_style>:
 * @param label pointer to an label object
 * @param type which style should be get (can be only `LV_LABEL_STYLE_MAIN`)
 * @return pointer to the label's style
 */
static inline const lv_style_t * lv_label_get_style(const lv_obj_t * label, lv_label_style_t type)
{
 800f6ee:	b580      	push	{r7, lr}
 800f6f0:	b082      	sub	sp, #8
 800f6f2:	af00      	add	r7, sp, #0
 800f6f4:	6078      	str	r0, [r7, #4]
 800f6f6:	460b      	mov	r3, r1
 800f6f8:	70fb      	strb	r3, [r7, #3]
    (void)type; /*Unused*/
    return lv_obj_get_style(label);
 800f6fa:	6878      	ldr	r0, [r7, #4]
 800f6fc:	f7f3 f828 	bl	8002750 <lv_obj_get_style>
 800f700:	4603      	mov	r3, r0
}
 800f702:	4618      	mov	r0, r3
 800f704:	3708      	adds	r7, #8
 800f706:	46bd      	mov	sp, r7
 800f708:	bd80      	pop	{r7, pc}
	...

0800f70c <lv_label_create>:
 * @param par pointer to an object, it will be the parent of the new label
 * @param copy pointer to a button object, if not NULL then the new object will be copied from it
 * @return pointer to the created button
 */
lv_obj_t * lv_label_create(lv_obj_t * par, const lv_obj_t * copy)
{
 800f70c:	b5b0      	push	{r4, r5, r7, lr}
 800f70e:	b086      	sub	sp, #24
 800f710:	af00      	add	r7, sp, #0
 800f712:	6078      	str	r0, [r7, #4]
 800f714:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("label create started");

    /*Create a basic object*/
    lv_obj_t * new_label = lv_obj_create(par, copy);
 800f716:	6839      	ldr	r1, [r7, #0]
 800f718:	6878      	ldr	r0, [r7, #4]
 800f71a:	f7f1 f92b 	bl	8000974 <lv_obj_create>
 800f71e:	6178      	str	r0, [r7, #20]
    LV_ASSERT_MEM(new_label);
 800f720:	6978      	ldr	r0, [r7, #20]
 800f722:	f7f0 fd69 	bl	80001f8 <lv_debug_check_null>
 800f726:	4603      	mov	r3, r0
 800f728:	f083 0301 	eor.w	r3, r3, #1
 800f72c:	b2db      	uxtb	r3, r3
 800f72e:	2b00      	cmp	r3, #0
 800f730:	d008      	beq.n	800f744 <lv_label_create+0x38>
 800f732:	697b      	ldr	r3, [r7, #20]
 800f734:	f04f 0400 	mov.w	r4, #0
 800f738:	461a      	mov	r2, r3
 800f73a:	4623      	mov	r3, r4
 800f73c:	4898      	ldr	r0, [pc, #608]	; (800f9a0 <lv_label_create+0x294>)
 800f73e:	f7f0 fd85 	bl	800024c <lv_debug_log_error>
 800f742:	e7fe      	b.n	800f742 <lv_label_create+0x36>
    if(new_label == NULL) return NULL;
 800f744:	697b      	ldr	r3, [r7, #20]
 800f746:	2b00      	cmp	r3, #0
 800f748:	d101      	bne.n	800f74e <lv_label_create+0x42>
 800f74a:	2300      	movs	r3, #0
 800f74c:	e124      	b.n	800f998 <lv_label_create+0x28c>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_label);
 800f74e:	4b95      	ldr	r3, [pc, #596]	; (800f9a4 <lv_label_create+0x298>)
 800f750:	681b      	ldr	r3, [r3, #0]
 800f752:	2b00      	cmp	r3, #0
 800f754:	d105      	bne.n	800f762 <lv_label_create+0x56>
 800f756:	6978      	ldr	r0, [r7, #20]
 800f758:	f7f3 f8f8 	bl	800294c <lv_obj_get_signal_cb>
 800f75c:	4602      	mov	r2, r0
 800f75e:	4b91      	ldr	r3, [pc, #580]	; (800f9a4 <lv_label_create+0x298>)
 800f760:	601a      	str	r2, [r3, #0]

    /*Extend the basic object to a label object*/
    lv_obj_allocate_ext_attr(new_label, sizeof(lv_label_ext_t));
 800f762:	2114      	movs	r1, #20
 800f764:	6978      	ldr	r0, [r7, #20]
 800f766:	f7f2 fdb3 	bl	80022d0 <lv_obj_allocate_ext_attr>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(new_label);
 800f76a:	6978      	ldr	r0, [r7, #20]
 800f76c:	f7f3 f92a 	bl	80029c4 <lv_obj_get_ext_attr>
 800f770:	6138      	str	r0, [r7, #16]
    LV_ASSERT_MEM(ext);
 800f772:	6938      	ldr	r0, [r7, #16]
 800f774:	f7f0 fd40 	bl	80001f8 <lv_debug_check_null>
 800f778:	4603      	mov	r3, r0
 800f77a:	f083 0301 	eor.w	r3, r3, #1
 800f77e:	b2db      	uxtb	r3, r3
 800f780:	2b00      	cmp	r3, #0
 800f782:	d008      	beq.n	800f796 <lv_label_create+0x8a>
 800f784:	693b      	ldr	r3, [r7, #16]
 800f786:	f04f 0400 	mov.w	r4, #0
 800f78a:	461a      	mov	r2, r3
 800f78c:	4623      	mov	r3, r4
 800f78e:	4884      	ldr	r0, [pc, #528]	; (800f9a0 <lv_label_create+0x294>)
 800f790:	f7f0 fd5c 	bl	800024c <lv_debug_log_error>
 800f794:	e7fe      	b.n	800f794 <lv_label_create+0x88>
    if(ext == NULL) return NULL;
 800f796:	693b      	ldr	r3, [r7, #16]
 800f798:	2b00      	cmp	r3, #0
 800f79a:	d101      	bne.n	800f7a0 <lv_label_create+0x94>
 800f79c:	2300      	movs	r3, #0
 800f79e:	e0fb      	b.n	800f998 <lv_label_create+0x28c>

    ext->text       = NULL;
 800f7a0:	693b      	ldr	r3, [r7, #16]
 800f7a2:	2200      	movs	r2, #0
 800f7a4:	601a      	str	r2, [r3, #0]
    ext->static_txt = 0;
 800f7a6:	693a      	ldr	r2, [r7, #16]
 800f7a8:	7c13      	ldrb	r3, [r2, #16]
 800f7aa:	f36f 03c3 	bfc	r3, #3, #1
 800f7ae:	7413      	strb	r3, [r2, #16]
    ext->recolor    = 0;
 800f7b0:	693a      	ldr	r2, [r7, #16]
 800f7b2:	7c13      	ldrb	r3, [r2, #16]
 800f7b4:	f36f 1386 	bfc	r3, #6, #1
 800f7b8:	7413      	strb	r3, [r2, #16]
    ext->body_draw  = 0;
 800f7ba:	693a      	ldr	r2, [r7, #16]
 800f7bc:	7c53      	ldrb	r3, [r2, #17]
 800f7be:	f36f 0300 	bfc	r3, #0, #1
 800f7c2:	7453      	strb	r3, [r2, #17]
    ext->align      = LV_LABEL_ALIGN_AUTO;
 800f7c4:	693a      	ldr	r2, [r7, #16]
 800f7c6:	7c13      	ldrb	r3, [r2, #16]
 800f7c8:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 800f7cc:	7413      	strb	r3, [r2, #16]
    ext->dot_end    = LV_LABEL_DOT_END_INV;
 800f7ce:	693b      	ldr	r3, [r7, #16]
 800f7d0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800f7d4:	811a      	strh	r2, [r3, #8]
    ext->long_mode  = LV_LABEL_LONG_EXPAND;
 800f7d6:	693a      	ldr	r2, [r7, #16]
 800f7d8:	7c13      	ldrb	r3, [r2, #16]
 800f7da:	f36f 0302 	bfc	r3, #0, #3
 800f7de:	7413      	strb	r3, [r2, #16]
#if LV_USE_ANIMATION
    ext->anim_speed = LV_LABEL_DEF_SCROLL_SPEED;
 800f7e0:	693b      	ldr	r3, [r7, #16]
 800f7e2:	2219      	movs	r2, #25
 800f7e4:	81da      	strh	r2, [r3, #14]
#endif
    ext->offset.x = 0;
 800f7e6:	693b      	ldr	r3, [r7, #16]
 800f7e8:	2200      	movs	r2, #0
 800f7ea:	815a      	strh	r2, [r3, #10]
    ext->offset.y = 0;
 800f7ec:	693b      	ldr	r3, [r7, #16]
 800f7ee:	2200      	movs	r2, #0
 800f7f0:	819a      	strh	r2, [r3, #12]

#if LV_LABEL_TEXT_SEL
    ext->txt_sel_start = LV_DRAW_LABEL_NO_TXT_SEL;
    ext->txt_sel_end   = LV_DRAW_LABEL_NO_TXT_SEL;
#endif
    ext->dot.tmp_ptr   = NULL;
 800f7f2:	693b      	ldr	r3, [r7, #16]
 800f7f4:	2200      	movs	r2, #0
 800f7f6:	605a      	str	r2, [r3, #4]
    ext->dot_tmp_alloc = 0;
 800f7f8:	693a      	ldr	r2, [r7, #16]
 800f7fa:	7c53      	ldrb	r3, [r2, #17]
 800f7fc:	f36f 0341 	bfc	r3, #1, #1
 800f800:	7453      	strb	r3, [r2, #17]

    lv_obj_set_design_cb(new_label, lv_label_design);
 800f802:	4969      	ldr	r1, [pc, #420]	; (800f9a8 <lv_label_create+0x29c>)
 800f804:	6978      	ldr	r0, [r7, #20]
 800f806:	f7f2 fd43 	bl	8002290 <lv_obj_set_design_cb>
    lv_obj_set_signal_cb(new_label, lv_label_signal);
 800f80a:	4968      	ldr	r1, [pc, #416]	; (800f9ac <lv_label_create+0x2a0>)
 800f80c:	6978      	ldr	r0, [r7, #20]
 800f80e:	f7f2 fd1f 	bl	8002250 <lv_obj_set_signal_cb>

    /*Init the new label*/
    if(copy == NULL) {
 800f812:	683b      	ldr	r3, [r7, #0]
 800f814:	2b00      	cmp	r3, #0
 800f816:	d111      	bne.n	800f83c <lv_label_create+0x130>
        lv_obj_set_click(new_label, false);
 800f818:	2100      	movs	r1, #0
 800f81a:	6978      	ldr	r0, [r7, #20]
 800f81c:	f7f2 fbf0 	bl	8002000 <lv_obj_set_click>
        lv_label_set_long_mode(new_label, LV_LABEL_LONG_EXPAND);
 800f820:	2100      	movs	r1, #0
 800f822:	6978      	ldr	r0, [r7, #20]
 800f824:	f000 f9be 	bl	800fba4 <lv_label_set_long_mode>
        lv_label_set_text(new_label, "Text");
 800f828:	4961      	ldr	r1, [pc, #388]	; (800f9b0 <lv_label_create+0x2a4>)
 800f82a:	6978      	ldr	r0, [r7, #20]
 800f82c:	f000 f8c2 	bl	800f9b4 <lv_label_set_text>
        lv_label_set_style(new_label, LV_LABEL_STYLE_MAIN, NULL); /*Inherit parent's style*/
 800f830:	2200      	movs	r2, #0
 800f832:	2100      	movs	r1, #0
 800f834:	6978      	ldr	r0, [r7, #20]
 800f836:	f7ff ff4b 	bl	800f6d0 <lv_label_set_style>
 800f83a:	e0ac      	b.n	800f996 <lv_label_create+0x28a>
    }
    /*Copy 'copy' if not NULL*/
    else {
        lv_label_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 800f83c:	6838      	ldr	r0, [r7, #0]
 800f83e:	f7f3 f8c1 	bl	80029c4 <lv_obj_get_ext_attr>
 800f842:	60f8      	str	r0, [r7, #12]
        lv_label_set_long_mode(new_label, lv_label_get_long_mode(copy));
 800f844:	6838      	ldr	r0, [r7, #0]
 800f846:	f000 faf3 	bl	800fe30 <lv_label_get_long_mode>
 800f84a:	4603      	mov	r3, r0
 800f84c:	4619      	mov	r1, r3
 800f84e:	6978      	ldr	r0, [r7, #20]
 800f850:	f000 f9a8 	bl	800fba4 <lv_label_set_long_mode>
        lv_label_set_recolor(new_label, lv_label_get_recolor(copy));
 800f854:	6838      	ldr	r0, [r7, #0]
 800f856:	f000 fb3d 	bl	800fed4 <lv_label_get_recolor>
 800f85a:	4603      	mov	r3, r0
 800f85c:	4619      	mov	r1, r3
 800f85e:	6978      	ldr	r0, [r7, #20]
 800f860:	f000 fa48 	bl	800fcf4 <lv_label_set_recolor>
        lv_label_set_body_draw(new_label, lv_label_get_body_draw(copy));
 800f864:	6838      	ldr	r0, [r7, #0]
 800f866:	f000 fb5f 	bl	800ff28 <lv_label_get_body_draw>
 800f86a:	4603      	mov	r3, r0
 800f86c:	4619      	mov	r1, r3
 800f86e:	6978      	ldr	r0, [r7, #20]
 800f870:	f000 fa7c 	bl	800fd6c <lv_label_set_body_draw>
        lv_label_set_align(new_label, lv_label_get_align(copy));
 800f874:	6838      	ldr	r0, [r7, #0]
 800f876:	f000 fb01 	bl	800fe7c <lv_label_get_align>
 800f87a:	4603      	mov	r3, r0
 800f87c:	4619      	mov	r1, r3
 800f87e:	6978      	ldr	r0, [r7, #20]
 800f880:	f000 fa00 	bl	800fc84 <lv_label_set_align>
        if(copy_ext->static_txt == 0)
 800f884:	68fb      	ldr	r3, [r7, #12]
 800f886:	7c1b      	ldrb	r3, [r3, #16]
 800f888:	f003 0308 	and.w	r3, r3, #8
 800f88c:	b2db      	uxtb	r3, r3
 800f88e:	2b00      	cmp	r3, #0
 800f890:	d108      	bne.n	800f8a4 <lv_label_create+0x198>
            lv_label_set_text(new_label, lv_label_get_text(copy));
 800f892:	6838      	ldr	r0, [r7, #0]
 800f894:	f000 faaa 	bl	800fdec <lv_label_get_text>
 800f898:	4603      	mov	r3, r0
 800f89a:	4619      	mov	r1, r3
 800f89c:	6978      	ldr	r0, [r7, #20]
 800f89e:	f000 f889 	bl	800f9b4 <lv_label_set_text>
 800f8a2:	e007      	b.n	800f8b4 <lv_label_create+0x1a8>
        else
            lv_label_set_static_text(new_label, lv_label_get_text(copy));
 800f8a4:	6838      	ldr	r0, [r7, #0]
 800f8a6:	f000 faa1 	bl	800fdec <lv_label_get_text>
 800f8aa:	4603      	mov	r3, r0
 800f8ac:	4619      	mov	r1, r3
 800f8ae:	6978      	ldr	r0, [r7, #20]
 800f8b0:	f000 f936 	bl	800fb20 <lv_label_set_static_text>

        /*In DOT mode save the text byte-to-byte because a '\0' can be in the middle*/
        if(copy_ext->long_mode == LV_LABEL_LONG_DOT) {
 800f8b4:	68fb      	ldr	r3, [r7, #12]
 800f8b6:	7c1b      	ldrb	r3, [r3, #16]
 800f8b8:	f003 0307 	and.w	r3, r3, #7
 800f8bc:	b2db      	uxtb	r3, r3
 800f8be:	2b02      	cmp	r3, #2
 800f8c0:	d138      	bne.n	800f934 <lv_label_create+0x228>
            ext->text = lv_mem_realloc(ext->text, lv_mem_get_size(copy_ext->text));
 800f8c2:	693b      	ldr	r3, [r7, #16]
 800f8c4:	681c      	ldr	r4, [r3, #0]
 800f8c6:	68fb      	ldr	r3, [r7, #12]
 800f8c8:	681b      	ldr	r3, [r3, #0]
 800f8ca:	4618      	mov	r0, r3
 800f8cc:	f7fd fa60 	bl	800cd90 <lv_mem_get_size>
 800f8d0:	4603      	mov	r3, r0
 800f8d2:	4619      	mov	r1, r3
 800f8d4:	4620      	mov	r0, r4
 800f8d6:	f7fd fa0f 	bl	800ccf8 <lv_mem_realloc>
 800f8da:	4602      	mov	r2, r0
 800f8dc:	693b      	ldr	r3, [r7, #16]
 800f8de:	601a      	str	r2, [r3, #0]
            LV_ASSERT_MEM(ext->text);
 800f8e0:	693b      	ldr	r3, [r7, #16]
 800f8e2:	681b      	ldr	r3, [r3, #0]
 800f8e4:	4618      	mov	r0, r3
 800f8e6:	f7f0 fc87 	bl	80001f8 <lv_debug_check_null>
 800f8ea:	4603      	mov	r3, r0
 800f8ec:	f083 0301 	eor.w	r3, r3, #1
 800f8f0:	b2db      	uxtb	r3, r3
 800f8f2:	2b00      	cmp	r3, #0
 800f8f4:	d009      	beq.n	800f90a <lv_label_create+0x1fe>
 800f8f6:	693b      	ldr	r3, [r7, #16]
 800f8f8:	681b      	ldr	r3, [r3, #0]
 800f8fa:	f04f 0400 	mov.w	r4, #0
 800f8fe:	461a      	mov	r2, r3
 800f900:	4623      	mov	r3, r4
 800f902:	4827      	ldr	r0, [pc, #156]	; (800f9a0 <lv_label_create+0x294>)
 800f904:	f7f0 fca2 	bl	800024c <lv_debug_log_error>
 800f908:	e7fe      	b.n	800f908 <lv_label_create+0x1fc>
            if(ext->text == NULL) return NULL;
 800f90a:	693b      	ldr	r3, [r7, #16]
 800f90c:	681b      	ldr	r3, [r3, #0]
 800f90e:	2b00      	cmp	r3, #0
 800f910:	d101      	bne.n	800f916 <lv_label_create+0x20a>
 800f912:	2300      	movs	r3, #0
 800f914:	e040      	b.n	800f998 <lv_label_create+0x28c>
            memcpy(ext->text, copy_ext->text, lv_mem_get_size(copy_ext->text));
 800f916:	693b      	ldr	r3, [r7, #16]
 800f918:	681c      	ldr	r4, [r3, #0]
 800f91a:	68fb      	ldr	r3, [r7, #12]
 800f91c:	681d      	ldr	r5, [r3, #0]
 800f91e:	68fb      	ldr	r3, [r7, #12]
 800f920:	681b      	ldr	r3, [r3, #0]
 800f922:	4618      	mov	r0, r3
 800f924:	f7fd fa34 	bl	800cd90 <lv_mem_get_size>
 800f928:	4603      	mov	r3, r0
 800f92a:	461a      	mov	r2, r3
 800f92c:	4629      	mov	r1, r5
 800f92e:	4620      	mov	r0, r4
 800f930:	f003 ff0a 	bl	8013748 <memcpy>
        }

        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
 800f934:	68fb      	ldr	r3, [r7, #12]
 800f936:	7c5b      	ldrb	r3, [r3, #17]
 800f938:	f003 0302 	and.w	r3, r3, #2
 800f93c:	b2db      	uxtb	r3, r3
 800f93e:	2b00      	cmp	r3, #0
 800f940:	d012      	beq.n	800f968 <lv_label_create+0x25c>
 800f942:	68fb      	ldr	r3, [r7, #12]
 800f944:	685b      	ldr	r3, [r3, #4]
 800f946:	2b00      	cmp	r3, #0
 800f948:	d00e      	beq.n	800f968 <lv_label_create+0x25c>
            uint16_t len = (uint16_t    )strlen(copy_ext->dot.tmp_ptr);
 800f94a:	68fb      	ldr	r3, [r7, #12]
 800f94c:	685b      	ldr	r3, [r3, #4]
 800f94e:	4618      	mov	r0, r3
 800f950:	f7f0 fc4a 	bl	80001e8 <strlen>
 800f954:	4603      	mov	r3, r0
 800f956:	817b      	strh	r3, [r7, #10]
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
 800f958:	693b      	ldr	r3, [r7, #16]
 800f95a:	685b      	ldr	r3, [r3, #4]
 800f95c:	897a      	ldrh	r2, [r7, #10]
 800f95e:	4619      	mov	r1, r3
 800f960:	6978      	ldr	r0, [r7, #20]
 800f962:	f001 faf9 	bl	8010f58 <lv_label_set_dot_tmp>
        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
 800f966:	e005      	b.n	800f974 <lv_label_create+0x268>
        } else {
            memcpy(ext->dot.tmp, copy_ext->dot.tmp, sizeof(ext->dot.tmp));
 800f968:	693b      	ldr	r3, [r7, #16]
 800f96a:	3304      	adds	r3, #4
 800f96c:	68fa      	ldr	r2, [r7, #12]
 800f96e:	3204      	adds	r2, #4
 800f970:	6812      	ldr	r2, [r2, #0]
 800f972:	601a      	str	r2, [r3, #0]
        }
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
 800f974:	68fb      	ldr	r3, [r7, #12]
 800f976:	7c5b      	ldrb	r3, [r3, #17]
 800f978:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800f97c:	b2d9      	uxtb	r1, r3
 800f97e:	693a      	ldr	r2, [r7, #16]
 800f980:	7c53      	ldrb	r3, [r2, #17]
 800f982:	f361 0341 	bfi	r3, r1, #1, #1
 800f986:	7453      	strb	r3, [r2, #17]
        ext->dot_end       = copy_ext->dot_end;
 800f988:	68fb      	ldr	r3, [r7, #12]
 800f98a:	891a      	ldrh	r2, [r3, #8]
 800f98c:	693b      	ldr	r3, [r7, #16]
 800f98e:	811a      	strh	r2, [r3, #8]

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_label);
 800f990:	6978      	ldr	r0, [r7, #20]
 800f992:	f7f2 fb0d 	bl	8001fb0 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("label created");

    return new_label;
 800f996:	697b      	ldr	r3, [r7, #20]
}
 800f998:	4618      	mov	r0, r3
 800f99a:	3718      	adds	r7, #24
 800f99c:	46bd      	mov	sp, r7
 800f99e:	bdb0      	pop	{r4, r5, r7, pc}
 800f9a0:	08013904 	.word	0x08013904
 800f9a4:	200082dc 	.word	0x200082dc
 800f9a8:	08010365 	.word	0x08010365
 800f9ac:	080106e9 	.word	0x080106e9
 800f9b0:	08013914 	.word	0x08013914

0800f9b4 <lv_label_set_text>:
 * Set a new text for a label. Memory will be allocated to store the text by the label.
 * @param label pointer to a label object
 * @param text '\0' terminated character string. NULL to refresh with the current text.
 */
void lv_label_set_text(lv_obj_t * label, const char * text)
{
 800f9b4:	b590      	push	{r4, r7, lr}
 800f9b6:	b085      	sub	sp, #20
 800f9b8:	af00      	add	r7, sp, #0
 800f9ba:	6078      	str	r0, [r7, #4]
 800f9bc:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800f9be:	6878      	ldr	r0, [r7, #4]
 800f9c0:	f7f0 fc1a 	bl	80001f8 <lv_debug_check_null>
 800f9c4:	4603      	mov	r3, r0
 800f9c6:	f083 0301 	eor.w	r3, r3, #1
 800f9ca:	b2db      	uxtb	r3, r3
 800f9cc:	2b00      	cmp	r3, #0
 800f9ce:	d008      	beq.n	800f9e2 <lv_label_set_text+0x2e>
 800f9d0:	687b      	ldr	r3, [r7, #4]
 800f9d2:	f04f 0400 	mov.w	r4, #0
 800f9d6:	461a      	mov	r2, r3
 800f9d8:	4623      	mov	r3, r4
 800f9da:	484f      	ldr	r0, [pc, #316]	; (800fb18 <lv_label_set_text+0x164>)
 800f9dc:	f7f0 fc36 	bl	800024c <lv_debug_log_error>
 800f9e0:	e7fe      	b.n	800f9e0 <lv_label_set_text+0x2c>

    lv_obj_invalidate(label);
 800f9e2:	6878      	ldr	r0, [r7, #4]
 800f9e4:	f7f1 fb5a 	bl	800109c <lv_obj_invalidate>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 800f9e8:	6878      	ldr	r0, [r7, #4]
 800f9ea:	f7f2 ffeb 	bl	80029c4 <lv_obj_get_ext_attr>
 800f9ee:	60f8      	str	r0, [r7, #12]

    /*If text is NULL then refresh */
    if(text == NULL) {
 800f9f0:	683b      	ldr	r3, [r7, #0]
 800f9f2:	2b00      	cmp	r3, #0
 800f9f4:	d103      	bne.n	800f9fe <lv_label_set_text+0x4a>
        lv_label_refr_text(label);
 800f9f6:	6878      	ldr	r0, [r7, #4]
 800f9f8:	f000 ff42 	bl	8010880 <lv_label_refr_text>
        return;
 800f9fc:	e088      	b.n	800fb10 <lv_label_set_text+0x15c>
    }

    LV_ASSERT_STR(text);
 800f9fe:	6838      	ldr	r0, [r7, #0]
 800fa00:	f7f0 fbfa 	bl	80001f8 <lv_debug_check_null>
 800fa04:	4603      	mov	r3, r0
 800fa06:	f083 0301 	eor.w	r3, r3, #1
 800fa0a:	b2db      	uxtb	r3, r3
 800fa0c:	2b00      	cmp	r3, #0
 800fa0e:	d008      	beq.n	800fa22 <lv_label_set_text+0x6e>
 800fa10:	683b      	ldr	r3, [r7, #0]
 800fa12:	f04f 0400 	mov.w	r4, #0
 800fa16:	461a      	mov	r2, r3
 800fa18:	4623      	mov	r3, r4
 800fa1a:	483f      	ldr	r0, [pc, #252]	; (800fb18 <lv_label_set_text+0x164>)
 800fa1c:	f7f0 fc16 	bl	800024c <lv_debug_log_error>
 800fa20:	e7fe      	b.n	800fa20 <lv_label_set_text+0x6c>

    if(ext->text == text) {
 800fa22:	68fb      	ldr	r3, [r7, #12]
 800fa24:	681b      	ldr	r3, [r3, #0]
 800fa26:	683a      	ldr	r2, [r7, #0]
 800fa28:	429a      	cmp	r2, r3
 800fa2a:	d129      	bne.n	800fa80 <lv_label_set_text+0xcc>
        /*If set its own text then reallocate it (maybe its size changed)*/
        ext->text = lv_mem_realloc(ext->text, strlen(ext->text) + 1);
 800fa2c:	68fb      	ldr	r3, [r7, #12]
 800fa2e:	681c      	ldr	r4, [r3, #0]
 800fa30:	68fb      	ldr	r3, [r7, #12]
 800fa32:	681b      	ldr	r3, [r3, #0]
 800fa34:	4618      	mov	r0, r3
 800fa36:	f7f0 fbd7 	bl	80001e8 <strlen>
 800fa3a:	4603      	mov	r3, r0
 800fa3c:	3301      	adds	r3, #1
 800fa3e:	4619      	mov	r1, r3
 800fa40:	4620      	mov	r0, r4
 800fa42:	f7fd f959 	bl	800ccf8 <lv_mem_realloc>
 800fa46:	4602      	mov	r2, r0
 800fa48:	68fb      	ldr	r3, [r7, #12]
 800fa4a:	601a      	str	r2, [r3, #0]
        LV_ASSERT_MEM(ext->text);
 800fa4c:	68fb      	ldr	r3, [r7, #12]
 800fa4e:	681b      	ldr	r3, [r3, #0]
 800fa50:	4618      	mov	r0, r3
 800fa52:	f7f0 fbd1 	bl	80001f8 <lv_debug_check_null>
 800fa56:	4603      	mov	r3, r0
 800fa58:	f083 0301 	eor.w	r3, r3, #1
 800fa5c:	b2db      	uxtb	r3, r3
 800fa5e:	2b00      	cmp	r3, #0
 800fa60:	d009      	beq.n	800fa76 <lv_label_set_text+0xc2>
 800fa62:	68fb      	ldr	r3, [r7, #12]
 800fa64:	681b      	ldr	r3, [r3, #0]
 800fa66:	f04f 0400 	mov.w	r4, #0
 800fa6a:	461a      	mov	r2, r3
 800fa6c:	4623      	mov	r3, r4
 800fa6e:	482b      	ldr	r0, [pc, #172]	; (800fb1c <lv_label_set_text+0x168>)
 800fa70:	f7f0 fbec 	bl	800024c <lv_debug_log_error>
 800fa74:	e7fe      	b.n	800fa74 <lv_label_set_text+0xc0>
        if(ext->text == NULL) return;
 800fa76:	68fb      	ldr	r3, [r7, #12]
 800fa78:	681b      	ldr	r3, [r3, #0]
 800fa7a:	2b00      	cmp	r3, #0
 800fa7c:	d143      	bne.n	800fb06 <lv_label_set_text+0x152>
 800fa7e:	e047      	b.n	800fb10 <lv_label_set_text+0x15c>
    } else {
        /*Allocate space for the new text*/
        size_t len = strlen(text) + 1;
 800fa80:	6838      	ldr	r0, [r7, #0]
 800fa82:	f7f0 fbb1 	bl	80001e8 <strlen>
 800fa86:	4603      	mov	r3, r0
 800fa88:	3301      	adds	r3, #1
 800fa8a:	60bb      	str	r3, [r7, #8]
        if(ext->text != NULL && ext->static_txt == 0) {
 800fa8c:	68fb      	ldr	r3, [r7, #12]
 800fa8e:	681b      	ldr	r3, [r3, #0]
 800fa90:	2b00      	cmp	r3, #0
 800fa92:	d00e      	beq.n	800fab2 <lv_label_set_text+0xfe>
 800fa94:	68fb      	ldr	r3, [r7, #12]
 800fa96:	7c1b      	ldrb	r3, [r3, #16]
 800fa98:	f003 0308 	and.w	r3, r3, #8
 800fa9c:	b2db      	uxtb	r3, r3
 800fa9e:	2b00      	cmp	r3, #0
 800faa0:	d107      	bne.n	800fab2 <lv_label_set_text+0xfe>
            lv_mem_free(ext->text);
 800faa2:	68fb      	ldr	r3, [r7, #12]
 800faa4:	681b      	ldr	r3, [r3, #0]
 800faa6:	4618      	mov	r0, r3
 800faa8:	f7fd f8e2 	bl	800cc70 <lv_mem_free>
            ext->text = NULL;
 800faac:	68fb      	ldr	r3, [r7, #12]
 800faae:	2200      	movs	r2, #0
 800fab0:	601a      	str	r2, [r3, #0]
        }

        ext->text = lv_mem_alloc(len);
 800fab2:	68b8      	ldr	r0, [r7, #8]
 800fab4:	f7fd f8aa 	bl	800cc0c <lv_mem_alloc>
 800fab8:	4602      	mov	r2, r0
 800faba:	68fb      	ldr	r3, [r7, #12]
 800fabc:	601a      	str	r2, [r3, #0]
        LV_ASSERT_MEM(ext->text);
 800fabe:	68fb      	ldr	r3, [r7, #12]
 800fac0:	681b      	ldr	r3, [r3, #0]
 800fac2:	4618      	mov	r0, r3
 800fac4:	f7f0 fb98 	bl	80001f8 <lv_debug_check_null>
 800fac8:	4603      	mov	r3, r0
 800faca:	f083 0301 	eor.w	r3, r3, #1
 800face:	b2db      	uxtb	r3, r3
 800fad0:	2b00      	cmp	r3, #0
 800fad2:	d009      	beq.n	800fae8 <lv_label_set_text+0x134>
 800fad4:	68fb      	ldr	r3, [r7, #12]
 800fad6:	681b      	ldr	r3, [r3, #0]
 800fad8:	f04f 0400 	mov.w	r4, #0
 800fadc:	461a      	mov	r2, r3
 800fade:	4623      	mov	r3, r4
 800fae0:	480e      	ldr	r0, [pc, #56]	; (800fb1c <lv_label_set_text+0x168>)
 800fae2:	f7f0 fbb3 	bl	800024c <lv_debug_log_error>
 800fae6:	e7fe      	b.n	800fae6 <lv_label_set_text+0x132>
        if(ext->text == NULL) return;
 800fae8:	68fb      	ldr	r3, [r7, #12]
 800faea:	681b      	ldr	r3, [r3, #0]
 800faec:	2b00      	cmp	r3, #0
 800faee:	d00e      	beq.n	800fb0e <lv_label_set_text+0x15a>

        strcpy(ext->text, text);
 800faf0:	68fb      	ldr	r3, [r7, #12]
 800faf2:	681b      	ldr	r3, [r3, #0]
 800faf4:	6839      	ldr	r1, [r7, #0]
 800faf6:	4618      	mov	r0, r3
 800faf8:	f003 fe39 	bl	801376e <strcpy>

        /*Now the text is dynamically allocated*/
        ext->static_txt = 0;
 800fafc:	68fa      	ldr	r2, [r7, #12]
 800fafe:	7c13      	ldrb	r3, [r2, #16]
 800fb00:	f36f 03c3 	bfc	r3, #3, #1
 800fb04:	7413      	strb	r3, [r2, #16]
    }

    lv_label_refr_text(label);
 800fb06:	6878      	ldr	r0, [r7, #4]
 800fb08:	f000 feba 	bl	8010880 <lv_label_refr_text>
 800fb0c:	e000      	b.n	800fb10 <lv_label_set_text+0x15c>
        if(ext->text == NULL) return;
 800fb0e:	bf00      	nop
}
 800fb10:	3714      	adds	r7, #20
 800fb12:	46bd      	mov	sp, r7
 800fb14:	bd90      	pop	{r4, r7, pc}
 800fb16:	bf00      	nop
 800fb18:	0801391c 	.word	0x0801391c
 800fb1c:	08013904 	.word	0x08013904

0800fb20 <lv_label_set_static_text>:
 * has to be 'alive' while the label exist.
 * @param label pointer to a label object
 * @param text pointer to a text. NULL to refresh with the current text.
 */
void lv_label_set_static_text(lv_obj_t * label, const char * text)
{
 800fb20:	b590      	push	{r4, r7, lr}
 800fb22:	b085      	sub	sp, #20
 800fb24:	af00      	add	r7, sp, #0
 800fb26:	6078      	str	r0, [r7, #4]
 800fb28:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800fb2a:	6878      	ldr	r0, [r7, #4]
 800fb2c:	f7f0 fb64 	bl	80001f8 <lv_debug_check_null>
 800fb30:	4603      	mov	r3, r0
 800fb32:	f083 0301 	eor.w	r3, r3, #1
 800fb36:	b2db      	uxtb	r3, r3
 800fb38:	2b00      	cmp	r3, #0
 800fb3a:	d008      	beq.n	800fb4e <lv_label_set_static_text+0x2e>
 800fb3c:	687b      	ldr	r3, [r7, #4]
 800fb3e:	f04f 0400 	mov.w	r4, #0
 800fb42:	461a      	mov	r2, r3
 800fb44:	4623      	mov	r3, r4
 800fb46:	4816      	ldr	r0, [pc, #88]	; (800fba0 <lv_label_set_static_text+0x80>)
 800fb48:	f7f0 fb80 	bl	800024c <lv_debug_log_error>
 800fb4c:	e7fe      	b.n	800fb4c <lv_label_set_static_text+0x2c>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 800fb4e:	6878      	ldr	r0, [r7, #4]
 800fb50:	f7f2 ff38 	bl	80029c4 <lv_obj_get_ext_attr>
 800fb54:	60f8      	str	r0, [r7, #12]
    if(ext->static_txt == 0 && ext->text != NULL) {
 800fb56:	68fb      	ldr	r3, [r7, #12]
 800fb58:	7c1b      	ldrb	r3, [r3, #16]
 800fb5a:	f003 0308 	and.w	r3, r3, #8
 800fb5e:	b2db      	uxtb	r3, r3
 800fb60:	2b00      	cmp	r3, #0
 800fb62:	d10b      	bne.n	800fb7c <lv_label_set_static_text+0x5c>
 800fb64:	68fb      	ldr	r3, [r7, #12]
 800fb66:	681b      	ldr	r3, [r3, #0]
 800fb68:	2b00      	cmp	r3, #0
 800fb6a:	d007      	beq.n	800fb7c <lv_label_set_static_text+0x5c>
        lv_mem_free(ext->text);
 800fb6c:	68fb      	ldr	r3, [r7, #12]
 800fb6e:	681b      	ldr	r3, [r3, #0]
 800fb70:	4618      	mov	r0, r3
 800fb72:	f7fd f87d 	bl	800cc70 <lv_mem_free>
        ext->text = NULL;
 800fb76:	68fb      	ldr	r3, [r7, #12]
 800fb78:	2200      	movs	r2, #0
 800fb7a:	601a      	str	r2, [r3, #0]
    }

    if(text != NULL) {
 800fb7c:	683b      	ldr	r3, [r7, #0]
 800fb7e:	2b00      	cmp	r3, #0
 800fb80:	d007      	beq.n	800fb92 <lv_label_set_static_text+0x72>
        ext->static_txt = 1;
 800fb82:	68fa      	ldr	r2, [r7, #12]
 800fb84:	7c13      	ldrb	r3, [r2, #16]
 800fb86:	f043 0308 	orr.w	r3, r3, #8
 800fb8a:	7413      	strb	r3, [r2, #16]
        ext->text       = (char *)text;
 800fb8c:	68fb      	ldr	r3, [r7, #12]
 800fb8e:	683a      	ldr	r2, [r7, #0]
 800fb90:	601a      	str	r2, [r3, #0]
    }

    lv_label_refr_text(label);
 800fb92:	6878      	ldr	r0, [r7, #4]
 800fb94:	f000 fe74 	bl	8010880 <lv_label_refr_text>
}
 800fb98:	bf00      	nop
 800fb9a:	3714      	adds	r7, #20
 800fb9c:	46bd      	mov	sp, r7
 800fb9e:	bd90      	pop	{r4, r7, pc}
 800fba0:	0801391c 	.word	0x0801391c

0800fba4 <lv_label_set_long_mode>:
 * @param long_mode the new mode from 'lv_label_long_mode' enum.
 *                  In LV_LONG_BREAK/LONG/ROLL the size of the label should be set AFTER this
 * function
 */
void lv_label_set_long_mode(lv_obj_t * label, lv_label_long_mode_t long_mode)
{
 800fba4:	b590      	push	{r4, r7, lr}
 800fba6:	b085      	sub	sp, #20
 800fba8:	af00      	add	r7, sp, #0
 800fbaa:	6078      	str	r0, [r7, #4]
 800fbac:	460b      	mov	r3, r1
 800fbae:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800fbb0:	6878      	ldr	r0, [r7, #4]
 800fbb2:	f7f0 fb21 	bl	80001f8 <lv_debug_check_null>
 800fbb6:	4603      	mov	r3, r0
 800fbb8:	f083 0301 	eor.w	r3, r3, #1
 800fbbc:	b2db      	uxtb	r3, r3
 800fbbe:	2b00      	cmp	r3, #0
 800fbc0:	d008      	beq.n	800fbd4 <lv_label_set_long_mode+0x30>
 800fbc2:	687b      	ldr	r3, [r7, #4]
 800fbc4:	f04f 0400 	mov.w	r4, #0
 800fbc8:	461a      	mov	r2, r3
 800fbca:	4623      	mov	r3, r4
 800fbcc:	4828      	ldr	r0, [pc, #160]	; (800fc70 <lv_label_set_long_mode+0xcc>)
 800fbce:	f7f0 fb3d 	bl	800024c <lv_debug_log_error>
 800fbd2:	e7fe      	b.n	800fbd2 <lv_label_set_long_mode+0x2e>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 800fbd4:	6878      	ldr	r0, [r7, #4]
 800fbd6:	f7f2 fef5 	bl	80029c4 <lv_obj_get_ext_attr>
 800fbda:	60f8      	str	r0, [r7, #12]

#if LV_USE_ANIMATION
    /*Delete the old animation (if exists)*/
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_obj_set_x);
 800fbdc:	4925      	ldr	r1, [pc, #148]	; (800fc74 <lv_label_set_long_mode+0xd0>)
 800fbde:	6878      	ldr	r0, [r7, #4]
 800fbe0:	f7fc f87a 	bl	800bcd8 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_obj_set_y);
 800fbe4:	4924      	ldr	r1, [pc, #144]	; (800fc78 <lv_label_set_long_mode+0xd4>)
 800fbe6:	6878      	ldr	r0, [r7, #4]
 800fbe8:	f7fc f876 	bl	800bcd8 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 800fbec:	4923      	ldr	r1, [pc, #140]	; (800fc7c <lv_label_set_long_mode+0xd8>)
 800fbee:	6878      	ldr	r0, [r7, #4]
 800fbf0:	f7fc f872 	bl	800bcd8 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 800fbf4:	4922      	ldr	r1, [pc, #136]	; (800fc80 <lv_label_set_long_mode+0xdc>)
 800fbf6:	6878      	ldr	r0, [r7, #4]
 800fbf8:	f7fc f86e 	bl	800bcd8 <lv_anim_del>
#endif
    ext->offset.x = 0;
 800fbfc:	68fb      	ldr	r3, [r7, #12]
 800fbfe:	2200      	movs	r2, #0
 800fc00:	815a      	strh	r2, [r3, #10]
    ext->offset.y = 0;
 800fc02:	68fb      	ldr	r3, [r7, #12]
 800fc04:	2200      	movs	r2, #0
 800fc06:	819a      	strh	r2, [r3, #12]

    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
 800fc08:	78fb      	ldrb	r3, [r7, #3]
 800fc0a:	2b03      	cmp	r3, #3
 800fc0c:	d005      	beq.n	800fc1a <lv_label_set_long_mode+0x76>
 800fc0e:	78fb      	ldrb	r3, [r7, #3]
 800fc10:	2b04      	cmp	r3, #4
 800fc12:	d002      	beq.n	800fc1a <lv_label_set_long_mode+0x76>
 800fc14:	78fb      	ldrb	r3, [r7, #3]
 800fc16:	2b05      	cmp	r3, #5
 800fc18:	d105      	bne.n	800fc26 <lv_label_set_long_mode+0x82>
        ext->expand = 1;
 800fc1a:	68fa      	ldr	r2, [r7, #12]
 800fc1c:	7c13      	ldrb	r3, [r2, #16]
 800fc1e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fc22:	7413      	strb	r3, [r2, #16]
 800fc24:	e004      	b.n	800fc30 <lv_label_set_long_mode+0x8c>
    else
        ext->expand = 0;
 800fc26:	68fa      	ldr	r2, [r7, #12]
 800fc28:	7c13      	ldrb	r3, [r2, #16]
 800fc2a:	f36f 13c7 	bfc	r3, #7, #1
 800fc2e:	7413      	strb	r3, [r2, #16]

    /*Restore the character under the dots*/
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
 800fc30:	68fb      	ldr	r3, [r7, #12]
 800fc32:	7c1b      	ldrb	r3, [r3, #16]
 800fc34:	f003 0307 	and.w	r3, r3, #7
 800fc38:	b2db      	uxtb	r3, r3
 800fc3a:	2b02      	cmp	r3, #2
 800fc3c:	d108      	bne.n	800fc50 <lv_label_set_long_mode+0xac>
 800fc3e:	68fb      	ldr	r3, [r7, #12]
 800fc40:	891b      	ldrh	r3, [r3, #8]
 800fc42:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800fc46:	4293      	cmp	r3, r2
 800fc48:	d002      	beq.n	800fc50 <lv_label_set_long_mode+0xac>
        lv_label_revert_dots(label);
 800fc4a:	6878      	ldr	r0, [r7, #4]
 800fc4c:	f001 f902 	bl	8010e54 <lv_label_revert_dots>
    }

    ext->long_mode = long_mode;
 800fc50:	78fb      	ldrb	r3, [r7, #3]
 800fc52:	f003 0307 	and.w	r3, r3, #7
 800fc56:	b2d9      	uxtb	r1, r3
 800fc58:	68fa      	ldr	r2, [r7, #12]
 800fc5a:	7c13      	ldrb	r3, [r2, #16]
 800fc5c:	f361 0302 	bfi	r3, r1, #0, #3
 800fc60:	7413      	strb	r3, [r2, #16]
    lv_label_refr_text(label);
 800fc62:	6878      	ldr	r0, [r7, #4]
 800fc64:	f000 fe0c 	bl	8010880 <lv_label_refr_text>
}
 800fc68:	bf00      	nop
 800fc6a:	3714      	adds	r7, #20
 800fc6c:	46bd      	mov	sp, r7
 800fc6e:	bd90      	pop	{r4, r7, pc}
 800fc70:	0801391c 	.word	0x0801391c
 800fc74:	080012f5 	.word	0x080012f5
 800fc78:	08001349 	.word	0x08001349
 800fc7c:	08010f09 	.word	0x08010f09
 800fc80:	08010f31 	.word	0x08010f31

0800fc84 <lv_label_set_align>:
 * Set the align of the label (left or center)
 * @param label pointer to a label object
 * @param align 'LV_LABEL_ALIGN_LEFT' or 'LV_LABEL_ALIGN_LEFT'
 */
void lv_label_set_align(lv_obj_t * label, lv_label_align_t align)
{
 800fc84:	b590      	push	{r4, r7, lr}
 800fc86:	b085      	sub	sp, #20
 800fc88:	af00      	add	r7, sp, #0
 800fc8a:	6078      	str	r0, [r7, #4]
 800fc8c:	460b      	mov	r3, r1
 800fc8e:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800fc90:	6878      	ldr	r0, [r7, #4]
 800fc92:	f7f0 fab1 	bl	80001f8 <lv_debug_check_null>
 800fc96:	4603      	mov	r3, r0
 800fc98:	f083 0301 	eor.w	r3, r3, #1
 800fc9c:	b2db      	uxtb	r3, r3
 800fc9e:	2b00      	cmp	r3, #0
 800fca0:	d008      	beq.n	800fcb4 <lv_label_set_align+0x30>
 800fca2:	687b      	ldr	r3, [r7, #4]
 800fca4:	f04f 0400 	mov.w	r4, #0
 800fca8:	461a      	mov	r2, r3
 800fcaa:	4623      	mov	r3, r4
 800fcac:	4810      	ldr	r0, [pc, #64]	; (800fcf0 <lv_label_set_align+0x6c>)
 800fcae:	f7f0 facd 	bl	800024c <lv_debug_log_error>
 800fcb2:	e7fe      	b.n	800fcb2 <lv_label_set_align+0x2e>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 800fcb4:	6878      	ldr	r0, [r7, #4]
 800fcb6:	f7f2 fe85 	bl	80029c4 <lv_obj_get_ext_attr>
 800fcba:	60f8      	str	r0, [r7, #12]
    if(ext->align == align) return;
 800fcbc:	68fb      	ldr	r3, [r7, #12]
 800fcbe:	7c1b      	ldrb	r3, [r3, #16]
 800fcc0:	f3c3 1301 	ubfx	r3, r3, #4, #2
 800fcc4:	b2db      	uxtb	r3, r3
 800fcc6:	461a      	mov	r2, r3
 800fcc8:	78fb      	ldrb	r3, [r7, #3]
 800fcca:	429a      	cmp	r2, r3
 800fccc:	d00c      	beq.n	800fce8 <lv_label_set_align+0x64>

    ext->align = align;
 800fcce:	78fb      	ldrb	r3, [r7, #3]
 800fcd0:	f003 0303 	and.w	r3, r3, #3
 800fcd4:	b2d9      	uxtb	r1, r3
 800fcd6:	68fa      	ldr	r2, [r7, #12]
 800fcd8:	7c13      	ldrb	r3, [r2, #16]
 800fcda:	f361 1305 	bfi	r3, r1, #4, #2
 800fcde:	7413      	strb	r3, [r2, #16]

    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
 800fce0:	6878      	ldr	r0, [r7, #4]
 800fce2:	f7f1 f9db 	bl	800109c <lv_obj_invalidate>
 800fce6:	e000      	b.n	800fcea <lv_label_set_align+0x66>
    if(ext->align == align) return;
 800fce8:	bf00      	nop
                                 (lv_refr_label_text() not required)*/
}
 800fcea:	3714      	adds	r7, #20
 800fcec:	46bd      	mov	sp, r7
 800fcee:	bd90      	pop	{r4, r7, pc}
 800fcf0:	0801391c 	.word	0x0801391c

0800fcf4 <lv_label_set_recolor>:
 * Enable the recoloring by in-line commands
 * @param label pointer to a label object
 * @param en true: enable recoloring, false: disable
 */
void lv_label_set_recolor(lv_obj_t * label, bool en)
{
 800fcf4:	b590      	push	{r4, r7, lr}
 800fcf6:	b085      	sub	sp, #20
 800fcf8:	af00      	add	r7, sp, #0
 800fcfa:	6078      	str	r0, [r7, #4]
 800fcfc:	460b      	mov	r3, r1
 800fcfe:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800fd00:	6878      	ldr	r0, [r7, #4]
 800fd02:	f7f0 fa79 	bl	80001f8 <lv_debug_check_null>
 800fd06:	4603      	mov	r3, r0
 800fd08:	f083 0301 	eor.w	r3, r3, #1
 800fd0c:	b2db      	uxtb	r3, r3
 800fd0e:	2b00      	cmp	r3, #0
 800fd10:	d008      	beq.n	800fd24 <lv_label_set_recolor+0x30>
 800fd12:	687b      	ldr	r3, [r7, #4]
 800fd14:	f04f 0400 	mov.w	r4, #0
 800fd18:	461a      	mov	r2, r3
 800fd1a:	4623      	mov	r3, r4
 800fd1c:	4812      	ldr	r0, [pc, #72]	; (800fd68 <lv_label_set_recolor+0x74>)
 800fd1e:	f7f0 fa95 	bl	800024c <lv_debug_log_error>
 800fd22:	e7fe      	b.n	800fd22 <lv_label_set_recolor+0x2e>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 800fd24:	6878      	ldr	r0, [r7, #4]
 800fd26:	f7f2 fe4d 	bl	80029c4 <lv_obj_get_ext_attr>
 800fd2a:	60f8      	str	r0, [r7, #12]
    if(ext->recolor == en) return;
 800fd2c:	68fb      	ldr	r3, [r7, #12]
 800fd2e:	7c1b      	ldrb	r3, [r3, #16]
 800fd30:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800fd34:	b2db      	uxtb	r3, r3
 800fd36:	78fa      	ldrb	r2, [r7, #3]
 800fd38:	429a      	cmp	r2, r3
 800fd3a:	d011      	beq.n	800fd60 <lv_label_set_recolor+0x6c>

    ext->recolor = en == false ? 0 : 1;
 800fd3c:	78fb      	ldrb	r3, [r7, #3]
 800fd3e:	f083 0301 	eor.w	r3, r3, #1
 800fd42:	b2db      	uxtb	r3, r3
 800fd44:	2b00      	cmp	r3, #0
 800fd46:	d001      	beq.n	800fd4c <lv_label_set_recolor+0x58>
 800fd48:	2100      	movs	r1, #0
 800fd4a:	e000      	b.n	800fd4e <lv_label_set_recolor+0x5a>
 800fd4c:	2101      	movs	r1, #1
 800fd4e:	68fa      	ldr	r2, [r7, #12]
 800fd50:	7c13      	ldrb	r3, [r2, #16]
 800fd52:	f361 1386 	bfi	r3, r1, #6, #1
 800fd56:	7413      	strb	r3, [r2, #16]

    lv_label_refr_text(label); /*Refresh the text because the potential colo codes in text needs to
 800fd58:	6878      	ldr	r0, [r7, #4]
 800fd5a:	f000 fd91 	bl	8010880 <lv_label_refr_text>
 800fd5e:	e000      	b.n	800fd62 <lv_label_set_recolor+0x6e>
    if(ext->recolor == en) return;
 800fd60:	bf00      	nop
                                  be hided or revealed*/
}
 800fd62:	3714      	adds	r7, #20
 800fd64:	46bd      	mov	sp, r7
 800fd66:	bd90      	pop	{r4, r7, pc}
 800fd68:	0801391c 	.word	0x0801391c

0800fd6c <lv_label_set_body_draw>:
 * Set the label to draw (or not draw) background specified in its style's body
 * @param label pointer to a label object
 * @param en true: draw body; false: don't draw body
 */
void lv_label_set_body_draw(lv_obj_t * label, bool en)
{
 800fd6c:	b590      	push	{r4, r7, lr}
 800fd6e:	b085      	sub	sp, #20
 800fd70:	af00      	add	r7, sp, #0
 800fd72:	6078      	str	r0, [r7, #4]
 800fd74:	460b      	mov	r3, r1
 800fd76:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800fd78:	6878      	ldr	r0, [r7, #4]
 800fd7a:	f7f0 fa3d 	bl	80001f8 <lv_debug_check_null>
 800fd7e:	4603      	mov	r3, r0
 800fd80:	f083 0301 	eor.w	r3, r3, #1
 800fd84:	b2db      	uxtb	r3, r3
 800fd86:	2b00      	cmp	r3, #0
 800fd88:	d008      	beq.n	800fd9c <lv_label_set_body_draw+0x30>
 800fd8a:	687b      	ldr	r3, [r7, #4]
 800fd8c:	f04f 0400 	mov.w	r4, #0
 800fd90:	461a      	mov	r2, r3
 800fd92:	4623      	mov	r3, r4
 800fd94:	4814      	ldr	r0, [pc, #80]	; (800fde8 <lv_label_set_body_draw+0x7c>)
 800fd96:	f7f0 fa59 	bl	800024c <lv_debug_log_error>
 800fd9a:	e7fe      	b.n	800fd9a <lv_label_set_body_draw+0x2e>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 800fd9c:	6878      	ldr	r0, [r7, #4]
 800fd9e:	f7f2 fe11 	bl	80029c4 <lv_obj_get_ext_attr>
 800fda2:	60f8      	str	r0, [r7, #12]
    if(ext->body_draw == en) return;
 800fda4:	68fb      	ldr	r3, [r7, #12]
 800fda6:	7c5b      	ldrb	r3, [r3, #17]
 800fda8:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800fdac:	b2db      	uxtb	r3, r3
 800fdae:	78fa      	ldrb	r2, [r7, #3]
 800fdb0:	429a      	cmp	r2, r3
 800fdb2:	d014      	beq.n	800fdde <lv_label_set_body_draw+0x72>

    ext->body_draw = en == false ? 0 : 1;
 800fdb4:	78fb      	ldrb	r3, [r7, #3]
 800fdb6:	f083 0301 	eor.w	r3, r3, #1
 800fdba:	b2db      	uxtb	r3, r3
 800fdbc:	2b00      	cmp	r3, #0
 800fdbe:	d001      	beq.n	800fdc4 <lv_label_set_body_draw+0x58>
 800fdc0:	2100      	movs	r1, #0
 800fdc2:	e000      	b.n	800fdc6 <lv_label_set_body_draw+0x5a>
 800fdc4:	2101      	movs	r1, #1
 800fdc6:	68fa      	ldr	r2, [r7, #12]
 800fdc8:	7c53      	ldrb	r3, [r2, #17]
 800fdca:	f361 0300 	bfi	r3, r1, #0, #1
 800fdce:	7453      	strb	r3, [r2, #17]

    lv_obj_refresh_ext_draw_pad(label);
 800fdd0:	6878      	ldr	r0, [r7, #4]
 800fdd2:	f7f2 faa7 	bl	8002324 <lv_obj_refresh_ext_draw_pad>

    lv_obj_invalidate(label);
 800fdd6:	6878      	ldr	r0, [r7, #4]
 800fdd8:	f7f1 f960 	bl	800109c <lv_obj_invalidate>
 800fddc:	e000      	b.n	800fde0 <lv_label_set_body_draw+0x74>
    if(ext->body_draw == en) return;
 800fdde:	bf00      	nop
}
 800fde0:	3714      	adds	r7, #20
 800fde2:	46bd      	mov	sp, r7
 800fde4:	bd90      	pop	{r4, r7, pc}
 800fde6:	bf00      	nop
 800fde8:	0801391c 	.word	0x0801391c

0800fdec <lv_label_get_text>:
 * Get the text of a label
 * @param label pointer to a label object
 * @return the text of the label
 */
char * lv_label_get_text(const lv_obj_t * label)
{
 800fdec:	b590      	push	{r4, r7, lr}
 800fdee:	b085      	sub	sp, #20
 800fdf0:	af00      	add	r7, sp, #0
 800fdf2:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800fdf4:	6878      	ldr	r0, [r7, #4]
 800fdf6:	f7f0 f9ff 	bl	80001f8 <lv_debug_check_null>
 800fdfa:	4603      	mov	r3, r0
 800fdfc:	f083 0301 	eor.w	r3, r3, #1
 800fe00:	b2db      	uxtb	r3, r3
 800fe02:	2b00      	cmp	r3, #0
 800fe04:	d008      	beq.n	800fe18 <lv_label_get_text+0x2c>
 800fe06:	687b      	ldr	r3, [r7, #4]
 800fe08:	f04f 0400 	mov.w	r4, #0
 800fe0c:	461a      	mov	r2, r3
 800fe0e:	4623      	mov	r3, r4
 800fe10:	4806      	ldr	r0, [pc, #24]	; (800fe2c <lv_label_get_text+0x40>)
 800fe12:	f7f0 fa1b 	bl	800024c <lv_debug_log_error>
 800fe16:	e7fe      	b.n	800fe16 <lv_label_get_text+0x2a>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 800fe18:	6878      	ldr	r0, [r7, #4]
 800fe1a:	f7f2 fdd3 	bl	80029c4 <lv_obj_get_ext_attr>
 800fe1e:	60f8      	str	r0, [r7, #12]

    return ext->text;
 800fe20:	68fb      	ldr	r3, [r7, #12]
 800fe22:	681b      	ldr	r3, [r3, #0]
}
 800fe24:	4618      	mov	r0, r3
 800fe26:	3714      	adds	r7, #20
 800fe28:	46bd      	mov	sp, r7
 800fe2a:	bd90      	pop	{r4, r7, pc}
 800fe2c:	0801391c 	.word	0x0801391c

0800fe30 <lv_label_get_long_mode>:
 * Get the long mode of a label
 * @param label pointer to a label object
 * @return the long mode
 */
lv_label_long_mode_t lv_label_get_long_mode(const lv_obj_t * label)
{
 800fe30:	b590      	push	{r4, r7, lr}
 800fe32:	b085      	sub	sp, #20
 800fe34:	af00      	add	r7, sp, #0
 800fe36:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800fe38:	6878      	ldr	r0, [r7, #4]
 800fe3a:	f7f0 f9dd 	bl	80001f8 <lv_debug_check_null>
 800fe3e:	4603      	mov	r3, r0
 800fe40:	f083 0301 	eor.w	r3, r3, #1
 800fe44:	b2db      	uxtb	r3, r3
 800fe46:	2b00      	cmp	r3, #0
 800fe48:	d008      	beq.n	800fe5c <lv_label_get_long_mode+0x2c>
 800fe4a:	687b      	ldr	r3, [r7, #4]
 800fe4c:	f04f 0400 	mov.w	r4, #0
 800fe50:	461a      	mov	r2, r3
 800fe52:	4623      	mov	r3, r4
 800fe54:	4808      	ldr	r0, [pc, #32]	; (800fe78 <lv_label_get_long_mode+0x48>)
 800fe56:	f7f0 f9f9 	bl	800024c <lv_debug_log_error>
 800fe5a:	e7fe      	b.n	800fe5a <lv_label_get_long_mode+0x2a>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 800fe5c:	6878      	ldr	r0, [r7, #4]
 800fe5e:	f7f2 fdb1 	bl	80029c4 <lv_obj_get_ext_attr>
 800fe62:	60f8      	str	r0, [r7, #12]
    return ext->long_mode;
 800fe64:	68fb      	ldr	r3, [r7, #12]
 800fe66:	7c1b      	ldrb	r3, [r3, #16]
 800fe68:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800fe6c:	b2db      	uxtb	r3, r3
}
 800fe6e:	4618      	mov	r0, r3
 800fe70:	3714      	adds	r7, #20
 800fe72:	46bd      	mov	sp, r7
 800fe74:	bd90      	pop	{r4, r7, pc}
 800fe76:	bf00      	nop
 800fe78:	0801391c 	.word	0x0801391c

0800fe7c <lv_label_get_align>:
 * Get the align attribute
 * @param label pointer to a label object
 * @return LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER
 */
lv_label_align_t lv_label_get_align(const lv_obj_t * label)
{
 800fe7c:	b590      	push	{r4, r7, lr}
 800fe7e:	b085      	sub	sp, #20
 800fe80:	af00      	add	r7, sp, #0
 800fe82:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800fe84:	6878      	ldr	r0, [r7, #4]
 800fe86:	f7f0 f9b7 	bl	80001f8 <lv_debug_check_null>
 800fe8a:	4603      	mov	r3, r0
 800fe8c:	f083 0301 	eor.w	r3, r3, #1
 800fe90:	b2db      	uxtb	r3, r3
 800fe92:	2b00      	cmp	r3, #0
 800fe94:	d008      	beq.n	800fea8 <lv_label_get_align+0x2c>
 800fe96:	687b      	ldr	r3, [r7, #4]
 800fe98:	f04f 0400 	mov.w	r4, #0
 800fe9c:	461a      	mov	r2, r3
 800fe9e:	4623      	mov	r3, r4
 800fea0:	480b      	ldr	r0, [pc, #44]	; (800fed0 <lv_label_get_align+0x54>)
 800fea2:	f7f0 f9d3 	bl	800024c <lv_debug_log_error>
 800fea6:	e7fe      	b.n	800fea6 <lv_label_get_align+0x2a>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 800fea8:	6878      	ldr	r0, [r7, #4]
 800feaa:	f7f2 fd8b 	bl	80029c4 <lv_obj_get_ext_attr>
 800feae:	60b8      	str	r0, [r7, #8]

    lv_label_align_t align = ext->align;
 800feb0:	68bb      	ldr	r3, [r7, #8]
 800feb2:	7c1b      	ldrb	r3, [r3, #16]
 800feb4:	f3c3 1301 	ubfx	r3, r3, #4, #2
 800feb8:	b2db      	uxtb	r3, r3
 800feba:	73fb      	strb	r3, [r7, #15]

    if(align == LV_LABEL_ALIGN_AUTO) {
 800febc:	7bfb      	ldrb	r3, [r7, #15]
 800febe:	2b03      	cmp	r3, #3
 800fec0:	d101      	bne.n	800fec6 <lv_label_get_align+0x4a>
        if(base_dir == LV_BIDI_DIR_AUTO) base_dir = lv_bidi_detect_base_dir(ext->text);

        if(base_dir == LV_BIDI_DIR_LTR) align = LV_LABEL_ALIGN_LEFT;
        else if (base_dir == LV_BIDI_DIR_RTL) align = LV_LABEL_ALIGN_RIGHT;
#else
        align = LV_LABEL_ALIGN_LEFT;
 800fec2:	2300      	movs	r3, #0
 800fec4:	73fb      	strb	r3, [r7, #15]
#endif
    }

    return align;
 800fec6:	7bfb      	ldrb	r3, [r7, #15]
}
 800fec8:	4618      	mov	r0, r3
 800feca:	3714      	adds	r7, #20
 800fecc:	46bd      	mov	sp, r7
 800fece:	bd90      	pop	{r4, r7, pc}
 800fed0:	0801391c 	.word	0x0801391c

0800fed4 <lv_label_get_recolor>:
 * Get the recoloring attribute
 * @param label pointer to a label object
 * @return true: recoloring is enabled, false: disable
 */
bool lv_label_get_recolor(const lv_obj_t * label)
{
 800fed4:	b590      	push	{r4, r7, lr}
 800fed6:	b085      	sub	sp, #20
 800fed8:	af00      	add	r7, sp, #0
 800feda:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800fedc:	6878      	ldr	r0, [r7, #4]
 800fede:	f7f0 f98b 	bl	80001f8 <lv_debug_check_null>
 800fee2:	4603      	mov	r3, r0
 800fee4:	f083 0301 	eor.w	r3, r3, #1
 800fee8:	b2db      	uxtb	r3, r3
 800feea:	2b00      	cmp	r3, #0
 800feec:	d008      	beq.n	800ff00 <lv_label_get_recolor+0x2c>
 800feee:	687b      	ldr	r3, [r7, #4]
 800fef0:	f04f 0400 	mov.w	r4, #0
 800fef4:	461a      	mov	r2, r3
 800fef6:	4623      	mov	r3, r4
 800fef8:	480a      	ldr	r0, [pc, #40]	; (800ff24 <lv_label_get_recolor+0x50>)
 800fefa:	f7f0 f9a7 	bl	800024c <lv_debug_log_error>
 800fefe:	e7fe      	b.n	800fefe <lv_label_get_recolor+0x2a>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 800ff00:	6878      	ldr	r0, [r7, #4]
 800ff02:	f7f2 fd5f 	bl	80029c4 <lv_obj_get_ext_attr>
 800ff06:	60f8      	str	r0, [r7, #12]
    return ext->recolor == 0 ? false : true;
 800ff08:	68fb      	ldr	r3, [r7, #12]
 800ff0a:	7c1b      	ldrb	r3, [r3, #16]
 800ff0c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ff10:	b2db      	uxtb	r3, r3
 800ff12:	2b00      	cmp	r3, #0
 800ff14:	bf14      	ite	ne
 800ff16:	2301      	movne	r3, #1
 800ff18:	2300      	moveq	r3, #0
 800ff1a:	b2db      	uxtb	r3, r3
}
 800ff1c:	4618      	mov	r0, r3
 800ff1e:	3714      	adds	r7, #20
 800ff20:	46bd      	mov	sp, r7
 800ff22:	bd90      	pop	{r4, r7, pc}
 800ff24:	0801391c 	.word	0x0801391c

0800ff28 <lv_label_get_body_draw>:
 * Get the body draw attribute
 * @param label pointer to a label object
 * @return true: draw body; false: don't draw body
 */
bool lv_label_get_body_draw(const lv_obj_t * label)
{
 800ff28:	b590      	push	{r4, r7, lr}
 800ff2a:	b085      	sub	sp, #20
 800ff2c:	af00      	add	r7, sp, #0
 800ff2e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800ff30:	6878      	ldr	r0, [r7, #4]
 800ff32:	f7f0 f961 	bl	80001f8 <lv_debug_check_null>
 800ff36:	4603      	mov	r3, r0
 800ff38:	f083 0301 	eor.w	r3, r3, #1
 800ff3c:	b2db      	uxtb	r3, r3
 800ff3e:	2b00      	cmp	r3, #0
 800ff40:	d008      	beq.n	800ff54 <lv_label_get_body_draw+0x2c>
 800ff42:	687b      	ldr	r3, [r7, #4]
 800ff44:	f04f 0400 	mov.w	r4, #0
 800ff48:	461a      	mov	r2, r3
 800ff4a:	4623      	mov	r3, r4
 800ff4c:	480a      	ldr	r0, [pc, #40]	; (800ff78 <lv_label_get_body_draw+0x50>)
 800ff4e:	f7f0 f97d 	bl	800024c <lv_debug_log_error>
 800ff52:	e7fe      	b.n	800ff52 <lv_label_get_body_draw+0x2a>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 800ff54:	6878      	ldr	r0, [r7, #4]
 800ff56:	f7f2 fd35 	bl	80029c4 <lv_obj_get_ext_attr>
 800ff5a:	60f8      	str	r0, [r7, #12]
    return ext->body_draw == 0 ? false : true;
 800ff5c:	68fb      	ldr	r3, [r7, #12]
 800ff5e:	7c5b      	ldrb	r3, [r3, #17]
 800ff60:	f003 0301 	and.w	r3, r3, #1
 800ff64:	b2db      	uxtb	r3, r3
 800ff66:	2b00      	cmp	r3, #0
 800ff68:	bf14      	ite	ne
 800ff6a:	2301      	movne	r3, #1
 800ff6c:	2300      	moveq	r3, #0
 800ff6e:	b2db      	uxtb	r3, r3
}
 800ff70:	4618      	mov	r0, r3
 800ff72:	3714      	adds	r7, #20
 800ff74:	46bd      	mov	sp, r7
 800ff76:	bd90      	pop	{r4, r7, pc}
 800ff78:	0801391c 	.word	0x0801391c

0800ff7c <lv_label_get_letter_on>:
 * @param pos pointer to point with coordinates on a the label
 * @return the index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter)
 * Expressed in character index and not byte index (different in UTF-8)
 */
uint16_t lv_label_get_letter_on(const lv_obj_t * label, lv_point_t * pos)
{
 800ff7c:	b590      	push	{r4, r7, lr}
 800ff7e:	b097      	sub	sp, #92	; 0x5c
 800ff80:	af02      	add	r7, sp, #8
 800ff82:	6078      	str	r0, [r7, #4]
 800ff84:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 800ff86:	6878      	ldr	r0, [r7, #4]
 800ff88:	f7f0 f936 	bl	80001f8 <lv_debug_check_null>
 800ff8c:	4603      	mov	r3, r0
 800ff8e:	f083 0301 	eor.w	r3, r3, #1
 800ff92:	b2db      	uxtb	r3, r3
 800ff94:	2b00      	cmp	r3, #0
 800ff96:	d008      	beq.n	800ffaa <lv_label_get_letter_on+0x2e>
 800ff98:	687b      	ldr	r3, [r7, #4]
 800ff9a:	f04f 0400 	mov.w	r4, #0
 800ff9e:	461a      	mov	r2, r3
 800ffa0:	4623      	mov	r3, r4
 800ffa2:	48ab      	ldr	r0, [pc, #684]	; (8010250 <lv_label_get_letter_on+0x2d4>)
 800ffa4:	f7f0 f952 	bl	800024c <lv_debug_log_error>
 800ffa8:	e7fe      	b.n	800ffa8 <lv_label_get_letter_on+0x2c>
    LV_ASSERT_NULL(pos);
 800ffaa:	6838      	ldr	r0, [r7, #0]
 800ffac:	f7f0 f924 	bl	80001f8 <lv_debug_check_null>
 800ffb0:	4603      	mov	r3, r0
 800ffb2:	f083 0301 	eor.w	r3, r3, #1
 800ffb6:	b2db      	uxtb	r3, r3
 800ffb8:	2b00      	cmp	r3, #0
 800ffba:	d008      	beq.n	800ffce <lv_label_get_letter_on+0x52>
 800ffbc:	683b      	ldr	r3, [r7, #0]
 800ffbe:	f04f 0400 	mov.w	r4, #0
 800ffc2:	461a      	mov	r2, r3
 800ffc4:	4623      	mov	r3, r4
 800ffc6:	48a2      	ldr	r0, [pc, #648]	; (8010250 <lv_label_get_letter_on+0x2d4>)
 800ffc8:	f7f0 f940 	bl	800024c <lv_debug_log_error>
 800ffcc:	e7fe      	b.n	800ffcc <lv_label_get_letter_on+0x50>

    const char * txt         = lv_label_get_text(label);
 800ffce:	6878      	ldr	r0, [r7, #4]
 800ffd0:	f7ff ff0c 	bl	800fdec <lv_label_get_text>
 800ffd4:	63b8      	str	r0, [r7, #56]	; 0x38
    lv_label_ext_t * ext     = lv_obj_get_ext_attr(label);
 800ffd6:	6878      	ldr	r0, [r7, #4]
 800ffd8:	f7f2 fcf4 	bl	80029c4 <lv_obj_get_ext_attr>
 800ffdc:	6378      	str	r0, [r7, #52]	; 0x34
    uint32_t line_start      = 0;
 800ffde:	2300      	movs	r3, #0
 800ffe0:	64fb      	str	r3, [r7, #76]	; 0x4c
    uint32_t new_line_start  = 0;
 800ffe2:	2300      	movs	r3, #0
 800ffe4:	64bb      	str	r3, [r7, #72]	; 0x48
    lv_coord_t max_w         = lv_obj_get_width(label);
 800ffe6:	6878      	ldr	r0, [r7, #4]
 800ffe8:	f7f2 fb16 	bl	8002618 <lv_obj_get_width>
 800ffec:	4603      	mov	r3, r0
 800ffee:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
    const lv_style_t * style = lv_obj_get_style(label);
 800fff2:	6878      	ldr	r0, [r7, #4]
 800fff4:	f7f2 fbac 	bl	8002750 <lv_obj_get_style>
 800fff8:	6338      	str	r0, [r7, #48]	; 0x30
    const lv_font_t * font   = style->text.font;
 800fffa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fffc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800fffe:	62fb      	str	r3, [r7, #44]	; 0x2c
    uint8_t letter_height    = lv_font_get_line_height(font);
 8010000:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8010002:	f7ff fb2b 	bl	800f65c <lv_font_get_line_height>
 8010006:	4603      	mov	r3, r0
 8010008:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    lv_coord_t y             = 0;
 801000c:	2300      	movs	r3, #0
 801000e:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
    lv_txt_flag_t flag       = LV_TXT_FLAG_NONE;
 8010012:	2300      	movs	r3, #0
 8010014:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    uint16_t logical_pos;
    char *bidi_txt;

    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 8010018:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801001a:	7c1b      	ldrb	r3, [r3, #16]
 801001c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010020:	b2db      	uxtb	r3, r3
 8010022:	2b00      	cmp	r3, #0
 8010024:	d005      	beq.n	8010032 <lv_label_get_letter_on+0xb6>
 8010026:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 801002a:	f043 0301 	orr.w	r3, r3, #1
 801002e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 8010032:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010034:	7c1b      	ldrb	r3, [r3, #16]
 8010036:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801003a:	b2db      	uxtb	r3, r3
 801003c:	2b00      	cmp	r3, #0
 801003e:	d005      	beq.n	801004c <lv_label_get_letter_on+0xd0>
 8010040:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8010044:	f043 0302 	orr.w	r3, r3, #2
 8010048:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43

    lv_label_align_t align = lv_label_get_align(label);
 801004c:	6878      	ldr	r0, [r7, #4]
 801004e:	f7ff ff15 	bl	800fe7c <lv_label_get_align>
 8010052:	4603      	mov	r3, r0
 8010054:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
 8010058:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 801005c:	2b01      	cmp	r3, #1
 801005e:	d105      	bne.n	801006c <lv_label_get_letter_on+0xf0>
 8010060:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8010064:	f043 0304 	orr.w	r3, r3, #4
 8010068:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
 801006c:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 8010070:	2b02      	cmp	r3, #2
 8010072:	d105      	bne.n	8010080 <lv_label_get_letter_on+0x104>
 8010074:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8010078:	f043 0308 	orr.w	r3, r3, #8
 801007c:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43

    /*If the width will be expanded set the max length to very big */
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
 8010080:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010082:	7c1b      	ldrb	r3, [r3, #16]
 8010084:	f003 0307 	and.w	r3, r3, #7
 8010088:	b2db      	uxtb	r3, r3
 801008a:	2b00      	cmp	r3, #0
 801008c:	d14c      	bne.n	8010128 <lv_label_get_letter_on+0x1ac>
        max_w = LV_COORD_MAX;
 801008e:	f647 4318 	movw	r3, #31768	; 0x7c18
 8010092:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
    }

    /*Search the line of the index letter */;
    while(txt[line_start] != '\0') {
 8010096:	e047      	b.n	8010128 <lv_label_get_letter_on+0x1ac>
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
 8010098:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801009a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801009c:	18d0      	adds	r0, r2, r3
 801009e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80100a0:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 80100a4:	f9b7 1046 	ldrsh.w	r1, [r7, #70]	; 0x46
 80100a8:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 80100ac:	9300      	str	r3, [sp, #0]
 80100ae:	460b      	mov	r3, r1
 80100b0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80100b2:	f7fd fbdf 	bl	800d874 <lv_txt_get_next_line>
 80100b6:	4603      	mov	r3, r0
 80100b8:	461a      	mov	r2, r3
 80100ba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80100bc:	4413      	add	r3, r2
 80100be:	64bb      	str	r3, [r7, #72]	; 0x48

        if(pos->y <= y + letter_height) {
 80100c0:	683b      	ldr	r3, [r7, #0]
 80100c2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80100c6:	4619      	mov	r1, r3
 80100c8:	f9b7 2044 	ldrsh.w	r2, [r7, #68]	; 0x44
 80100cc:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80100d0:	4413      	add	r3, r2
 80100d2:	4299      	cmp	r1, r3
 80100d4:	dc17      	bgt.n	8010106 <lv_label_get_letter_on+0x18a>
            /*The line is found (stored in 'line_start')*/
            /* Include the NULL terminator in the last line */
            uint32_t tmp = new_line_start;
 80100d6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80100d8:	60bb      	str	r3, [r7, #8]
            uint32_t letter;
            letter = lv_txt_encoded_prev(txt, &tmp);
 80100da:	4b5e      	ldr	r3, [pc, #376]	; (8010254 <lv_label_get_letter_on+0x2d8>)
 80100dc:	681b      	ldr	r3, [r3, #0]
 80100de:	f107 0208 	add.w	r2, r7, #8
 80100e2:	4611      	mov	r1, r2
 80100e4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80100e6:	4798      	blx	r3
 80100e8:	6278      	str	r0, [r7, #36]	; 0x24
            if(letter != '\n' && txt[new_line_start] == '\0' ) new_line_start++;
 80100ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80100ec:	2b0a      	cmp	r3, #10
 80100ee:	d022      	beq.n	8010136 <lv_label_get_letter_on+0x1ba>
 80100f0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80100f2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80100f4:	4413      	add	r3, r2
 80100f6:	781b      	ldrb	r3, [r3, #0]
 80100f8:	2b00      	cmp	r3, #0
 80100fa:	d11c      	bne.n	8010136 <lv_label_get_letter_on+0x1ba>
 80100fc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80100fe:	3301      	adds	r3, #1
 8010100:	64bb      	str	r3, [r7, #72]	; 0x48
            break;
 8010102:	bf00      	nop
 8010104:	e017      	b.n	8010136 <lv_label_get_letter_on+0x1ba>
        }
        y += letter_height + style->text.line_space;
 8010106:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 801010a:	b29a      	uxth	r2, r3
 801010c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801010e:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8010112:	b29b      	uxth	r3, r3
 8010114:	4413      	add	r3, r2
 8010116:	b29a      	uxth	r2, r3
 8010118:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 801011c:	4413      	add	r3, r2
 801011e:	b29b      	uxth	r3, r3
 8010120:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44

        line_start = new_line_start;
 8010124:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010126:	64fb      	str	r3, [r7, #76]	; 0x4c
    while(txt[line_start] != '\0') {
 8010128:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801012a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801012c:	4413      	add	r3, r2
 801012e:	781b      	ldrb	r3, [r3, #0]
 8010130:	2b00      	cmp	r3, #0
 8010132:	d1b1      	bne.n	8010098 <lv_label_get_letter_on+0x11c>
 8010134:	e000      	b.n	8010138 <lv_label_get_letter_on+0x1bc>
            break;
 8010136:	bf00      	nop
    bidi_txt = lv_draw_get_buf(new_line_start - line_start + 1);
    uint16_t txt_len = new_line_start - line_start;
    if(bidi_txt[new_line_start] == '\0') txt_len--;
    lv_bidi_process_paragraph(txt + line_start, bidi_txt, txt_len, lv_obj_get_base_dir(label), NULL, 0);
#else
    bidi_txt = (char*)txt + line_start;
 8010138:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801013a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801013c:	4413      	add	r3, r2
 801013e:	623b      	str	r3, [r7, #32]
#endif

    /*Calculate the x coordinate*/
    lv_coord_t x = 0;
 8010140:	2300      	movs	r3, #0
 8010142:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
    if(align == LV_LABEL_ALIGN_CENTER) {
 8010146:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 801014a:	2b01      	cmp	r3, #1
 801014c:	d12a      	bne.n	80101a4 <lv_label_get_letter_on+0x228>
        lv_coord_t line_w;
        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, style->text.letter_space, flag);
 801014e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010150:	b29a      	uxth	r2, r3
 8010152:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010154:	b29b      	uxth	r3, r3
 8010156:	1ad3      	subs	r3, r2, r3
 8010158:	b299      	uxth	r1, r3
 801015a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801015c:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8010160:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8010164:	9300      	str	r3, [sp, #0]
 8010166:	4613      	mov	r3, r2
 8010168:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801016a:	6a38      	ldr	r0, [r7, #32]
 801016c:	f7fd fc14 	bl	800d998 <lv_txt_get_width>
 8010170:	4603      	mov	r3, r0
 8010172:	83bb      	strh	r3, [r7, #28]
        x += lv_obj_get_width(label) / 2 - line_w / 2;
 8010174:	6878      	ldr	r0, [r7, #4]
 8010176:	f7f2 fa4f 	bl	8002618 <lv_obj_get_width>
 801017a:	4603      	mov	r3, r0
 801017c:	0fda      	lsrs	r2, r3, #31
 801017e:	4413      	add	r3, r2
 8010180:	105b      	asrs	r3, r3, #1
 8010182:	b21b      	sxth	r3, r3
 8010184:	4619      	mov	r1, r3
 8010186:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 801018a:	0fda      	lsrs	r2, r3, #31
 801018c:	4413      	add	r3, r2
 801018e:	105b      	asrs	r3, r3, #1
 8010190:	b21b      	sxth	r3, r3
 8010192:	1acb      	subs	r3, r1, r3
 8010194:	b29a      	uxth	r2, r3
 8010196:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 801019a:	4413      	add	r3, r2
 801019c:	b29b      	uxth	r3, r3
 801019e:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
 80101a2:	e025      	b.n	80101f0 <lv_label_get_letter_on+0x274>
    }
    else if(align == LV_LABEL_ALIGN_RIGHT) {
 80101a4:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 80101a8:	2b02      	cmp	r3, #2
 80101aa:	d121      	bne.n	80101f0 <lv_label_get_letter_on+0x274>
        lv_coord_t line_w;
        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, style->text.letter_space, flag);
 80101ac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80101ae:	b29a      	uxth	r2, r3
 80101b0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101b2:	b29b      	uxth	r3, r3
 80101b4:	1ad3      	subs	r3, r2, r3
 80101b6:	b299      	uxth	r1, r3
 80101b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80101ba:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 80101be:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 80101c2:	9300      	str	r3, [sp, #0]
 80101c4:	4613      	mov	r3, r2
 80101c6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80101c8:	6a38      	ldr	r0, [r7, #32]
 80101ca:	f7fd fbe5 	bl	800d998 <lv_txt_get_width>
 80101ce:	4603      	mov	r3, r0
 80101d0:	83fb      	strh	r3, [r7, #30]
        x += lv_obj_get_width(label) - line_w;
 80101d2:	6878      	ldr	r0, [r7, #4]
 80101d4:	f7f2 fa20 	bl	8002618 <lv_obj_get_width>
 80101d8:	4603      	mov	r3, r0
 80101da:	461a      	mov	r2, r3
 80101dc:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80101e0:	1ad3      	subs	r3, r2, r3
 80101e2:	b29a      	uxth	r2, r3
 80101e4:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 80101e8:	4413      	add	r3, r2
 80101ea:	b29b      	uxth	r3, r3
 80101ec:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
    }

    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 80101f0:	2300      	movs	r3, #0
 80101f2:	747b      	strb	r3, [r7, #17]

    uint32_t i = 0;
 80101f4:	2300      	movs	r3, #0
 80101f6:	60fb      	str	r3, [r7, #12]
    uint32_t i_act = i;
 80101f8:	68fb      	ldr	r3, [r7, #12]
 80101fa:	63fb      	str	r3, [r7, #60]	; 0x3c
    uint32_t letter;
    uint32_t letter_next;

    if(new_line_start > 0) {
 80101fc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80101fe:	2b00      	cmp	r3, #0
 8010200:	d05b      	beq.n	80102ba <lv_label_get_letter_on+0x33e>
        while(i + line_start < new_line_start) {
 8010202:	e054      	b.n	80102ae <lv_label_get_letter_on+0x332>
            /* Get the current letter.*/
            letter = lv_txt_encoded_next(bidi_txt, &i);
 8010204:	4b14      	ldr	r3, [pc, #80]	; (8010258 <lv_label_get_letter_on+0x2dc>)
 8010206:	681b      	ldr	r3, [r3, #0]
 8010208:	f107 020c 	add.w	r2, r7, #12
 801020c:	4611      	mov	r1, r2
 801020e:	6a38      	ldr	r0, [r7, #32]
 8010210:	4798      	blx	r3
 8010212:	61b8      	str	r0, [r7, #24]

            /*Get the next letter too for kerning*/
            letter_next = lv_txt_encoded_next(&bidi_txt[i], NULL);
 8010214:	4b10      	ldr	r3, [pc, #64]	; (8010258 <lv_label_get_letter_on+0x2dc>)
 8010216:	681b      	ldr	r3, [r3, #0]
 8010218:	68fa      	ldr	r2, [r7, #12]
 801021a:	6a39      	ldr	r1, [r7, #32]
 801021c:	440a      	add	r2, r1
 801021e:	2100      	movs	r1, #0
 8010220:	4610      	mov	r0, r2
 8010222:	4798      	blx	r3
 8010224:	6178      	str	r0, [r7, #20]

            /*Handle the recolor command*/
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 8010226:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 801022a:	f003 0301 	and.w	r3, r3, #1
 801022e:	2b00      	cmp	r3, #0
 8010230:	d014      	beq.n	801025c <lv_label_get_letter_on+0x2e0>
                if(lv_txt_is_cmd(&cmd_state, bidi_txt[i]) != false) {
 8010232:	68fb      	ldr	r3, [r7, #12]
 8010234:	6a3a      	ldr	r2, [r7, #32]
 8010236:	4413      	add	r3, r2
 8010238:	781b      	ldrb	r3, [r3, #0]
 801023a:	461a      	mov	r2, r3
 801023c:	f107 0311 	add.w	r3, r7, #17
 8010240:	4611      	mov	r1, r2
 8010242:	4618      	mov	r0, r3
 8010244:	f7fd fc12 	bl	800da6c <lv_txt_is_cmd>
 8010248:	4603      	mov	r3, r0
 801024a:	2b00      	cmp	r3, #0
 801024c:	d006      	beq.n	801025c <lv_label_get_letter_on+0x2e0>
                    continue; /*Skip the letter is it is part of a command*/
 801024e:	e02e      	b.n	80102ae <lv_label_get_letter_on+0x332>
 8010250:	0801391c 	.word	0x0801391c
 8010254:	20000058 	.word	0x20000058
 8010258:	20000054 	.word	0x20000054
                }
            }

            x += lv_font_get_glyph_width(font, letter, letter_next);
 801025c:	697a      	ldr	r2, [r7, #20]
 801025e:	69b9      	ldr	r1, [r7, #24]
 8010260:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8010262:	f7fa fcb7 	bl	800abd4 <lv_font_get_glyph_width>
 8010266:	4603      	mov	r3, r0
 8010268:	461a      	mov	r2, r3
 801026a:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 801026e:	4413      	add	r3, r2
 8010270:	b29b      	uxth	r3, r3
 8010272:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40

            /*Finish if the x position or the last char of the line is reached*/
            if(pos->x < x || i + line_start == new_line_start) {
 8010276:	683b      	ldr	r3, [r7, #0]
 8010278:	f9b3 3000 	ldrsh.w	r3, [r3]
 801027c:	f9b7 2040 	ldrsh.w	r2, [r7, #64]	; 0x40
 8010280:	429a      	cmp	r2, r3
 8010282:	dc05      	bgt.n	8010290 <lv_label_get_letter_on+0x314>
 8010284:	68fa      	ldr	r2, [r7, #12]
 8010286:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010288:	4413      	add	r3, r2
 801028a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801028c:	429a      	cmp	r2, r3
 801028e:	d102      	bne.n	8010296 <lv_label_get_letter_on+0x31a>
                i = i_act;
 8010290:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010292:	60fb      	str	r3, [r7, #12]
                break;
 8010294:	e011      	b.n	80102ba <lv_label_get_letter_on+0x33e>
            }
            x += style->text.letter_space;
 8010296:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010298:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 801029c:	b29a      	uxth	r2, r3
 801029e:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 80102a2:	4413      	add	r3, r2
 80102a4:	b29b      	uxth	r3, r3
 80102a6:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
            i_act = i;
 80102aa:	68fb      	ldr	r3, [r7, #12]
 80102ac:	63fb      	str	r3, [r7, #60]	; 0x3c
        while(i + line_start < new_line_start) {
 80102ae:	68fa      	ldr	r2, [r7, #12]
 80102b0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102b2:	4413      	add	r3, r2
 80102b4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80102b6:	429a      	cmp	r2, r3
 80102b8:	d8a4      	bhi.n	8010204 <lv_label_get_letter_on+0x288>
    /*Handle Bidi*/
    bool is_rtl;
    logical_pos = lv_bidi_get_logical_pos(&txt[line_start], NULL, txt_len, lv_obj_get_base_dir(label), lv_txt_encoded_get_char_id(bidi_txt, i), &is_rtl);
    if (is_rtl) logical_pos++;
#else
    logical_pos = lv_txt_encoded_get_char_id(bidi_txt, i);
 80102ba:	4b0b      	ldr	r3, [pc, #44]	; (80102e8 <lv_label_get_letter_on+0x36c>)
 80102bc:	681b      	ldr	r3, [r3, #0]
 80102be:	68fa      	ldr	r2, [r7, #12]
 80102c0:	4611      	mov	r1, r2
 80102c2:	6a38      	ldr	r0, [r7, #32]
 80102c4:	4798      	blx	r3
 80102c6:	4603      	mov	r3, r0
 80102c8:	827b      	strh	r3, [r7, #18]
#endif

    return  logical_pos + lv_txt_encoded_get_char_id(txt, line_start);
 80102ca:	4b07      	ldr	r3, [pc, #28]	; (80102e8 <lv_label_get_letter_on+0x36c>)
 80102cc:	681b      	ldr	r3, [r3, #0]
 80102ce:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80102d0:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80102d2:	4798      	blx	r3
 80102d4:	4603      	mov	r3, r0
 80102d6:	b29a      	uxth	r2, r3
 80102d8:	8a7b      	ldrh	r3, [r7, #18]
 80102da:	4413      	add	r3, r2
 80102dc:	b29b      	uxth	r3, r3
}
 80102de:	4618      	mov	r0, r3
 80102e0:	3754      	adds	r7, #84	; 0x54
 80102e2:	46bd      	mov	sp, r7
 80102e4:	bd90      	pop	{r4, r7, pc}
 80102e6:	bf00      	nop
 80102e8:	20000060 	.word	0x20000060

080102ec <lv_label_get_text_sel_start>:
 * @brief Get the selection start index.
 * @param label pointer to a label object.
 * @return selection start index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected.
 */
uint16_t lv_label_get_text_sel_start(const lv_obj_t * label)
{
 80102ec:	b590      	push	{r4, r7, lr}
 80102ee:	b083      	sub	sp, #12
 80102f0:	af00      	add	r7, sp, #0
 80102f2:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 80102f4:	6878      	ldr	r0, [r7, #4]
 80102f6:	f7ef ff7f 	bl	80001f8 <lv_debug_check_null>
 80102fa:	4603      	mov	r3, r0
 80102fc:	f083 0301 	eor.w	r3, r3, #1
 8010300:	b2db      	uxtb	r3, r3
 8010302:	2b00      	cmp	r3, #0
 8010304:	d008      	beq.n	8010318 <lv_label_get_text_sel_start+0x2c>
 8010306:	687b      	ldr	r3, [r7, #4]
 8010308:	f04f 0400 	mov.w	r4, #0
 801030c:	461a      	mov	r2, r3
 801030e:	4623      	mov	r3, r4
 8010310:	4804      	ldr	r0, [pc, #16]	; (8010324 <lv_label_get_text_sel_start+0x38>)
 8010312:	f7ef ff9b 	bl	800024c <lv_debug_log_error>
 8010316:	e7fe      	b.n	8010316 <lv_label_get_text_sel_start+0x2a>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    return ext->txt_sel_start;

#else
    (void)label;    /*Unused*/
    return LV_LABEL_TEXT_SEL_OFF;
 8010318:	f64f 73ff 	movw	r3, #65535	; 0xffff
#endif
}
 801031c:	4618      	mov	r0, r3
 801031e:	370c      	adds	r7, #12
 8010320:	46bd      	mov	sp, r7
 8010322:	bd90      	pop	{r4, r7, pc}
 8010324:	0801391c 	.word	0x0801391c

08010328 <lv_label_get_text_sel_end>:
 * @brief Get the selection end index.
 * @param label pointer to a label object.
 * @return selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected.
 */
uint16_t lv_label_get_text_sel_end(const lv_obj_t * label)
{
 8010328:	b590      	push	{r4, r7, lr}
 801032a:	b083      	sub	sp, #12
 801032c:	af00      	add	r7, sp, #0
 801032e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 8010330:	6878      	ldr	r0, [r7, #4]
 8010332:	f7ef ff61 	bl	80001f8 <lv_debug_check_null>
 8010336:	4603      	mov	r3, r0
 8010338:	f083 0301 	eor.w	r3, r3, #1
 801033c:	b2db      	uxtb	r3, r3
 801033e:	2b00      	cmp	r3, #0
 8010340:	d008      	beq.n	8010354 <lv_label_get_text_sel_end+0x2c>
 8010342:	687b      	ldr	r3, [r7, #4]
 8010344:	f04f 0400 	mov.w	r4, #0
 8010348:	461a      	mov	r2, r3
 801034a:	4623      	mov	r3, r4
 801034c:	4804      	ldr	r0, [pc, #16]	; (8010360 <lv_label_get_text_sel_end+0x38>)
 801034e:	f7ef ff7d 	bl	800024c <lv_debug_log_error>
 8010352:	e7fe      	b.n	8010352 <lv_label_get_text_sel_end+0x2a>
#if LV_LABEL_TEXT_SEL
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    return ext->txt_sel_end;
#else
    (void)label; /*Unused*/
    return LV_LABEL_TEXT_SEL_OFF;
 8010354:	f64f 73ff 	movw	r3, #65535	; 0xffff
#endif
}
 8010358:	4618      	mov	r0, r3
 801035a:	370c      	adds	r7, #12
 801035c:	46bd      	mov	sp, r7
 801035e:	bd90      	pop	{r4, r7, pc}
 8010360:	0801391c 	.word	0x0801391c

08010364 <lv_label_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_label_design(lv_obj_t * label, const lv_area_t * mask, lv_design_mode_t mode)
{
 8010364:	b5b0      	push	{r4, r5, r7, lr}
 8010366:	b09a      	sub	sp, #104	; 0x68
 8010368:	af06      	add	r7, sp, #24
 801036a:	60f8      	str	r0, [r7, #12]
 801036c:	60b9      	str	r1, [r7, #8]
 801036e:	4613      	mov	r3, r2
 8010370:	71fb      	strb	r3, [r7, #7]
    /* A label never covers an area */
    if(mode == LV_DESIGN_COVER_CHK)
 8010372:	79fb      	ldrb	r3, [r7, #7]
 8010374:	2b02      	cmp	r3, #2
 8010376:	d101      	bne.n	801037c <lv_label_design+0x18>
        return false;
 8010378:	2300      	movs	r3, #0
 801037a:	e1b1      	b.n	80106e0 <lv_label_design+0x37c>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
 801037c:	79fb      	ldrb	r3, [r7, #7]
 801037e:	2b00      	cmp	r3, #0
 8010380:	f040 81ad 	bne.w	80106de <lv_label_design+0x37a>
        lv_area_t coords;
        const lv_style_t * style = lv_obj_get_style(label);
 8010384:	68f8      	ldr	r0, [r7, #12]
 8010386:	f7f2 f9e3 	bl	8002750 <lv_obj_get_style>
 801038a:	64b8      	str	r0, [r7, #72]	; 0x48
        lv_opa_t opa_scale       = lv_obj_get_opa_scale(label);
 801038c:	68f8      	ldr	r0, [r7, #12]
 801038e:	f7f2 fa7f 	bl	8002890 <lv_obj_get_opa_scale>
 8010392:	4603      	mov	r3, r0
 8010394:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        lv_obj_get_coords(label, &coords);
 8010398:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801039c:	4619      	mov	r1, r3
 801039e:	68f8      	ldr	r0, [r7, #12]
 80103a0:	f7f2 f8ae 	bl	8002500 <lv_obj_get_coords>

#if LV_USE_GROUP
        lv_group_t * g = lv_obj_get_group(label);
 80103a4:	68f8      	ldr	r0, [r7, #12]
 80103a6:	f7f2 fb2b 	bl	8002a00 <lv_obj_get_group>
 80103aa:	6438      	str	r0, [r7, #64]	; 0x40
        if(lv_group_get_focused(g) == label) {
 80103ac:	6c38      	ldr	r0, [r7, #64]	; 0x40
 80103ae:	f7f0 f8dd 	bl	800056c <lv_group_get_focused>
 80103b2:	4602      	mov	r2, r0
 80103b4:	68fb      	ldr	r3, [r7, #12]
 80103b6:	4293      	cmp	r3, r2
 80103b8:	d107      	bne.n	80103ca <lv_label_design+0x66>
            lv_draw_rect(&coords, mask, style, opa_scale);
 80103ba:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80103be:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 80103c2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80103c4:	68b9      	ldr	r1, [r7, #8]
 80103c6:	f7f5 fbb6 	bl	8005b36 <lv_draw_rect>
        }
#endif

        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80103ca:	68f8      	ldr	r0, [r7, #12]
 80103cc:	f7f2 fafa 	bl	80029c4 <lv_obj_get_ext_attr>
 80103d0:	63f8      	str	r0, [r7, #60]	; 0x3c

        if(ext->body_draw) {
 80103d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80103d4:	7c5b      	ldrb	r3, [r3, #17]
 80103d6:	f003 0301 	and.w	r3, r3, #1
 80103da:	b2db      	uxtb	r3, r3
 80103dc:	2b00      	cmp	r3, #0
 80103de:	d03b      	beq.n	8010458 <lv_label_design+0xf4>
            lv_area_t bg;
            lv_obj_get_coords(label, &bg);
 80103e0:	f107 0320 	add.w	r3, r7, #32
 80103e4:	4619      	mov	r1, r3
 80103e6:	68f8      	ldr	r0, [r7, #12]
 80103e8:	f7f2 f88a 	bl	8002500 <lv_obj_get_coords>
            bg.x1 -= style->body.padding.left;
 80103ec:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 80103f0:	b29a      	uxth	r2, r3
 80103f2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80103f4:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 80103f8:	b29b      	uxth	r3, r3
 80103fa:	1ad3      	subs	r3, r2, r3
 80103fc:	b29b      	uxth	r3, r3
 80103fe:	b21b      	sxth	r3, r3
 8010400:	843b      	strh	r3, [r7, #32]
            bg.x2 += style->body.padding.right;
 8010402:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8010406:	b29a      	uxth	r2, r3
 8010408:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801040a:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 801040e:	b29b      	uxth	r3, r3
 8010410:	4413      	add	r3, r2
 8010412:	b29b      	uxth	r3, r3
 8010414:	b21b      	sxth	r3, r3
 8010416:	84bb      	strh	r3, [r7, #36]	; 0x24
            bg.y1 -= style->body.padding.top;
 8010418:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801041c:	b29a      	uxth	r2, r3
 801041e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010420:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8010424:	b29b      	uxth	r3, r3
 8010426:	1ad3      	subs	r3, r2, r3
 8010428:	b29b      	uxth	r3, r3
 801042a:	b21b      	sxth	r3, r3
 801042c:	847b      	strh	r3, [r7, #34]	; 0x22
            bg.y2 += style->body.padding.bottom;
 801042e:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8010432:	b29a      	uxth	r2, r3
 8010434:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010436:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 801043a:	b29b      	uxth	r3, r3
 801043c:	4413      	add	r3, r2
 801043e:	b29b      	uxth	r3, r3
 8010440:	b21b      	sxth	r3, r3
 8010442:	84fb      	strh	r3, [r7, #38]	; 0x26

            lv_draw_rect(&bg, mask, style, lv_obj_get_opa_scale(label));
 8010444:	68f8      	ldr	r0, [r7, #12]
 8010446:	f7f2 fa23 	bl	8002890 <lv_obj_get_opa_scale>
 801044a:	4603      	mov	r3, r0
 801044c:	f107 0020 	add.w	r0, r7, #32
 8010450:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8010452:	68b9      	ldr	r1, [r7, #8]
 8010454:	f7f5 fb6f 	bl	8005b36 <lv_draw_rect>
        }

        lv_label_align_t align = lv_label_get_align(label);
 8010458:	68f8      	ldr	r0, [r7, #12]
 801045a:	f7ff fd0f 	bl	800fe7c <lv_label_get_align>
 801045e:	4603      	mov	r3, r0
 8010460:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b

        lv_txt_flag_t flag = LV_TXT_FLAG_NONE;
 8010464:	2300      	movs	r3, #0
 8010466:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 801046a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801046c:	7c1b      	ldrb	r3, [r3, #16]
 801046e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010472:	b2db      	uxtb	r3, r3
 8010474:	2b00      	cmp	r3, #0
 8010476:	d005      	beq.n	8010484 <lv_label_design+0x120>
 8010478:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 801047c:	f043 0301 	orr.w	r3, r3, #1
 8010480:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 8010484:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010486:	7c1b      	ldrb	r3, [r3, #16]
 8010488:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801048c:	b2db      	uxtb	r3, r3
 801048e:	2b00      	cmp	r3, #0
 8010490:	d005      	beq.n	801049e <lv_label_design+0x13a>
 8010492:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8010496:	f043 0302 	orr.w	r3, r3, #2
 801049a:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
 801049e:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 80104a2:	2b01      	cmp	r3, #1
 80104a4:	d105      	bne.n	80104b2 <lv_label_design+0x14e>
 80104a6:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 80104aa:	f043 0304 	orr.w	r3, r3, #4
 80104ae:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
 80104b2:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 80104b6:	2b02      	cmp	r3, #2
 80104b8:	d105      	bne.n	80104c6 <lv_label_design+0x162>
 80104ba:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 80104be:	f043 0308 	orr.w	r3, r3, #8
 80104c2:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f

        /* In ROLL mode the CENTER and RIGHT are pointless so remove them.
         * (In addition they will result mis-alignment is this case)*/
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
 80104c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80104c8:	7c1b      	ldrb	r3, [r3, #16]
 80104ca:	f003 0307 	and.w	r3, r3, #7
 80104ce:	b2db      	uxtb	r3, r3
 80104d0:	2b03      	cmp	r3, #3
 80104d2:	d006      	beq.n	80104e2 <lv_label_design+0x17e>
 80104d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80104d6:	7c1b      	ldrb	r3, [r3, #16]
 80104d8:	f003 0307 	and.w	r3, r3, #7
 80104dc:	b2db      	uxtb	r3, r3
 80104de:	2b04      	cmp	r3, #4
 80104e0:	d138      	bne.n	8010554 <lv_label_design+0x1f0>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
 80104e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80104e4:	7c1b      	ldrb	r3, [r3, #16]
 80104e6:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80104ea:	b2db      	uxtb	r3, r3
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
 80104ec:	2b10      	cmp	r3, #16
 80104ee:	d006      	beq.n	80104fe <lv_label_design+0x19a>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
 80104f0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80104f2:	7c1b      	ldrb	r3, [r3, #16]
 80104f4:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80104f8:	b2db      	uxtb	r3, r3
 80104fa:	2b20      	cmp	r3, #32
 80104fc:	d12a      	bne.n	8010554 <lv_label_design+0x1f0>
            lv_point_t size;
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
 80104fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010500:	6819      	ldr	r1, [r3, #0]
 8010502:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010504:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8010506:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010508:	f9b3 5028 	ldrsh.w	r5, [r3, #40]	; 0x28
 801050c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801050e:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8010512:	f107 001c 	add.w	r0, r7, #28
 8010516:	f897 204f 	ldrb.w	r2, [r7, #79]	; 0x4f
 801051a:	9202      	str	r2, [sp, #8]
 801051c:	f647 4218 	movw	r2, #31768	; 0x7c18
 8010520:	9201      	str	r2, [sp, #4]
 8010522:	9300      	str	r3, [sp, #0]
 8010524:	462b      	mov	r3, r5
 8010526:	4622      	mov	r2, r4
 8010528:	f7fc ffd4 	bl	800d4d4 <lv_txt_get_size>
                            LV_COORD_MAX, flag);
            if(size.x > lv_obj_get_width(label)) {
 801052c:	f9b7 401c 	ldrsh.w	r4, [r7, #28]
 8010530:	68f8      	ldr	r0, [r7, #12]
 8010532:	f7f2 f871 	bl	8002618 <lv_obj_get_width>
 8010536:	4603      	mov	r3, r0
 8010538:	429c      	cmp	r4, r3
 801053a:	dd0b      	ble.n	8010554 <lv_label_design+0x1f0>
                flag &= ~LV_TXT_FLAG_RIGHT;
 801053c:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8010540:	f023 0308 	bic.w	r3, r3, #8
 8010544:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
                flag &= ~LV_TXT_FLAG_CENTER;
 8010548:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 801054c:	f023 0304 	bic.w	r3, r3, #4
 8010550:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC || lv_obj_get_height(label) < LV_LABEL_HINT_HEIGHT_LIMIT)
            hint = NULL;

#else
        /*Just for compatibility*/
        lv_draw_label_hint_t * hint = NULL;
 8010554:	2300      	movs	r3, #0
 8010556:	637b      	str	r3, [r7, #52]	; 0x34
#endif
        lv_draw_label_txt_sel_t sel;

        sel.start = lv_label_get_text_sel_start(label);
 8010558:	68f8      	ldr	r0, [r7, #12]
 801055a:	f7ff fec7 	bl	80102ec <lv_label_get_text_sel_start>
 801055e:	4603      	mov	r3, r0
 8010560:	853b      	strh	r3, [r7, #40]	; 0x28
        sel.end = lv_label_get_text_sel_end(label);
 8010562:	68f8      	ldr	r0, [r7, #12]
 8010564:	f7ff fee0 	bl	8010328 <lv_label_get_text_sel_end>
 8010568:	4603      	mov	r3, r0
 801056a:	857b      	strh	r3, [r7, #42]	; 0x2a
        lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ext->offset, &sel, hint, lv_obj_get_base_dir(label));
 801056c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801056e:	681c      	ldr	r4, [r3, #0]
 8010570:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010572:	f103 050a 	add.w	r5, r3, #10
 8010576:	68f8      	ldr	r0, [r7, #12]
 8010578:	f7f2 f97e 	bl	8002878 <lv_obj_get_base_dir>
 801057c:	4603      	mov	r3, r0
 801057e:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 8010582:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8010586:	9305      	str	r3, [sp, #20]
 8010588:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801058a:	9304      	str	r3, [sp, #16]
 801058c:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8010590:	9303      	str	r3, [sp, #12]
 8010592:	9502      	str	r5, [sp, #8]
 8010594:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8010598:	9301      	str	r3, [sp, #4]
 801059a:	9400      	str	r4, [sp, #0]
 801059c:	4613      	mov	r3, r2
 801059e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80105a0:	68b9      	ldr	r1, [r7, #8]
 80105a2:	f7f4 fddf 	bl	8005164 <lv_draw_label>


        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
 80105a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80105a8:	7c1b      	ldrb	r3, [r3, #16]
 80105aa:	f003 0307 	and.w	r3, r3, #7
 80105ae:	b2db      	uxtb	r3, r3
 80105b0:	2b04      	cmp	r3, #4
 80105b2:	f040 8094 	bne.w	80106de <lv_label_design+0x37a>
            lv_point_t size;
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
 80105b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80105b8:	6819      	ldr	r1, [r3, #0]
 80105ba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80105bc:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80105be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80105c0:	f9b3 5028 	ldrsh.w	r5, [r3, #40]	; 0x28
 80105c4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80105c6:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 80105ca:	f107 0018 	add.w	r0, r7, #24
 80105ce:	f897 204f 	ldrb.w	r2, [r7, #79]	; 0x4f
 80105d2:	9202      	str	r2, [sp, #8]
 80105d4:	f647 4218 	movw	r2, #31768	; 0x7c18
 80105d8:	9201      	str	r2, [sp, #4]
 80105da:	9300      	str	r3, [sp, #0]
 80105dc:	462b      	mov	r3, r5
 80105de:	4622      	mov	r2, r4
 80105e0:	f7fc ff78 	bl	800d4d4 <lv_txt_get_size>
                            LV_COORD_MAX, flag);

            lv_point_t ofs;

            /*Draw the text again next to the original to make an circular effect */
            if(size.x > lv_obj_get_width(label)) {
 80105e4:	f9b7 4018 	ldrsh.w	r4, [r7, #24]
 80105e8:	68f8      	ldr	r0, [r7, #12]
 80105ea:	f7f2 f815 	bl	8002618 <lv_obj_get_width>
 80105ee:	4603      	mov	r3, r0
 80105f0:	429c      	cmp	r4, r3
 80105f2:	dd38      	ble.n	8010666 <lv_label_design+0x302>
                ofs.x = ext->offset.x + size.x +
 80105f4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80105f6:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 80105fa:	b29a      	uxth	r2, r3
 80105fc:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8010600:	b29b      	uxth	r3, r3
 8010602:	4413      	add	r3, r2
 8010604:	b29c      	uxth	r4, r3
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
 8010606:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010608:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801060a:	2220      	movs	r2, #32
 801060c:	2120      	movs	r1, #32
 801060e:	4618      	mov	r0, r3
 8010610:	f7fa fae0 	bl	800abd4 <lv_font_get_glyph_width>
 8010614:	4603      	mov	r3, r0
                ofs.x = ext->offset.x + size.x +
 8010616:	461a      	mov	r2, r3
 8010618:	0052      	lsls	r2, r2, #1
 801061a:	4413      	add	r3, r2
 801061c:	b29b      	uxth	r3, r3
 801061e:	4423      	add	r3, r4
 8010620:	b29b      	uxth	r3, r3
 8010622:	b21b      	sxth	r3, r3
 8010624:	82bb      	strh	r3, [r7, #20]
                ofs.y = ext->offset.y;
 8010626:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010628:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 801062c:	82fb      	strh	r3, [r7, #22]

                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
 801062e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010630:	681c      	ldr	r4, [r3, #0]
 8010632:	68f8      	ldr	r0, [r7, #12]
 8010634:	f7f2 f920 	bl	8002878 <lv_obj_get_base_dir>
 8010638:	4603      	mov	r3, r0
 801063a:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 801063e:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8010642:	9305      	str	r3, [sp, #20]
 8010644:	2300      	movs	r3, #0
 8010646:	9304      	str	r3, [sp, #16]
 8010648:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801064c:	9303      	str	r3, [sp, #12]
 801064e:	f107 0314 	add.w	r3, r7, #20
 8010652:	9302      	str	r3, [sp, #8]
 8010654:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8010658:	9301      	str	r3, [sp, #4]
 801065a:	9400      	str	r4, [sp, #0]
 801065c:	4613      	mov	r3, r2
 801065e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8010660:	68b9      	ldr	r1, [r7, #8]
 8010662:	f7f4 fd7f 	bl	8005164 <lv_draw_label>
            }

            /*Draw the text again below the original to make an circular effect */
            if(size.y > lv_obj_get_height(label)) {
 8010666:	f9b7 401a 	ldrsh.w	r4, [r7, #26]
 801066a:	68f8      	ldr	r0, [r7, #12]
 801066c:	f7f1 fff6 	bl	800265c <lv_obj_get_height>
 8010670:	4603      	mov	r3, r0
 8010672:	429c      	cmp	r4, r3
 8010674:	dd33      	ble.n	80106de <lv_label_design+0x37a>
                ofs.x = ext->offset.x;
 8010676:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010678:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801067c:	82bb      	strh	r3, [r7, #20]
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
 801067e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010680:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8010684:	b29a      	uxth	r2, r3
 8010686:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801068a:	b29b      	uxth	r3, r3
 801068c:	4413      	add	r3, r2
 801068e:	b29c      	uxth	r4, r3
 8010690:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010692:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010694:	4618      	mov	r0, r3
 8010696:	f7fe ffe1 	bl	800f65c <lv_font_get_line_height>
 801069a:	4603      	mov	r3, r0
 801069c:	b29b      	uxth	r3, r3
 801069e:	4423      	add	r3, r4
 80106a0:	b29b      	uxth	r3, r3
 80106a2:	b21b      	sxth	r3, r3
 80106a4:	82fb      	strh	r3, [r7, #22]
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs, &sel, NULL, lv_obj_get_base_dir(label));
 80106a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80106a8:	681c      	ldr	r4, [r3, #0]
 80106aa:	68f8      	ldr	r0, [r7, #12]
 80106ac:	f7f2 f8e4 	bl	8002878 <lv_obj_get_base_dir>
 80106b0:	4603      	mov	r3, r0
 80106b2:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 80106b6:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 80106ba:	9305      	str	r3, [sp, #20]
 80106bc:	2300      	movs	r3, #0
 80106be:	9304      	str	r3, [sp, #16]
 80106c0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80106c4:	9303      	str	r3, [sp, #12]
 80106c6:	f107 0314 	add.w	r3, r7, #20
 80106ca:	9302      	str	r3, [sp, #8]
 80106cc:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 80106d0:	9301      	str	r3, [sp, #4]
 80106d2:	9400      	str	r4, [sp, #0]
 80106d4:	4613      	mov	r3, r2
 80106d6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80106d8:	68b9      	ldr	r1, [r7, #8]
 80106da:	f7f4 fd43 	bl	8005164 <lv_draw_label>
            }
        }
    }
    return true;
 80106de:	2301      	movs	r3, #1
}
 80106e0:	4618      	mov	r0, r3
 80106e2:	3750      	adds	r7, #80	; 0x50
 80106e4:	46bd      	mov	sp, r7
 80106e6:	bdb0      	pop	{r4, r5, r7, pc}

080106e8 <lv_label_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_label_signal(lv_obj_t * label, lv_signal_t sign, void * param)
{
 80106e8:	b590      	push	{r4, r7, lr}
 80106ea:	b089      	sub	sp, #36	; 0x24
 80106ec:	af00      	add	r7, sp, #0
 80106ee:	60f8      	str	r0, [r7, #12]
 80106f0:	460b      	mov	r3, r1
 80106f2:	607a      	str	r2, [r7, #4]
 80106f4:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(label, sign, param);
 80106f6:	4b60      	ldr	r3, [pc, #384]	; (8010878 <lv_label_signal+0x190>)
 80106f8:	681b      	ldr	r3, [r3, #0]
 80106fa:	7af9      	ldrb	r1, [r7, #11]
 80106fc:	687a      	ldr	r2, [r7, #4]
 80106fe:	68f8      	ldr	r0, [r7, #12]
 8010700:	4798      	blx	r3
 8010702:	4603      	mov	r3, r0
 8010704:	77bb      	strb	r3, [r7, #30]
    if(res != LV_RES_OK) return res;
 8010706:	7fbb      	ldrb	r3, [r7, #30]
 8010708:	2b01      	cmp	r3, #1
 801070a:	d001      	beq.n	8010710 <lv_label_signal+0x28>
 801070c:	7fbb      	ldrb	r3, [r7, #30]
 801070e:	e0af      	b.n	8010870 <lv_label_signal+0x188>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
 8010710:	7afb      	ldrb	r3, [r7, #11]
 8010712:	2b07      	cmp	r3, #7
 8010714:	d105      	bne.n	8010722 <lv_label_signal+0x3a>
 8010716:	4959      	ldr	r1, [pc, #356]	; (801087c <lv_label_signal+0x194>)
 8010718:	6878      	ldr	r0, [r7, #4]
 801071a:	f7f2 f9bb 	bl	8002a94 <lv_obj_handle_get_type_signal>
 801071e:	4603      	mov	r3, r0
 8010720:	e0a6      	b.n	8010870 <lv_label_signal+0x188>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8010722:	68f8      	ldr	r0, [r7, #12]
 8010724:	f7f2 f94e 	bl	80029c4 <lv_obj_get_ext_attr>
 8010728:	61b8      	str	r0, [r7, #24]
    if(sign == LV_SIGNAL_CLEANUP) {
 801072a:	7afb      	ldrb	r3, [r7, #11]
 801072c:	2b00      	cmp	r3, #0
 801072e:	d112      	bne.n	8010756 <lv_label_signal+0x6e>
        if(ext->static_txt == 0) {
 8010730:	69bb      	ldr	r3, [r7, #24]
 8010732:	7c1b      	ldrb	r3, [r3, #16]
 8010734:	f003 0308 	and.w	r3, r3, #8
 8010738:	b2db      	uxtb	r3, r3
 801073a:	2b00      	cmp	r3, #0
 801073c:	d107      	bne.n	801074e <lv_label_signal+0x66>
            lv_mem_free(ext->text);
 801073e:	69bb      	ldr	r3, [r7, #24]
 8010740:	681b      	ldr	r3, [r3, #0]
 8010742:	4618      	mov	r0, r3
 8010744:	f7fc fa94 	bl	800cc70 <lv_mem_free>
            ext->text = NULL;
 8010748:	69bb      	ldr	r3, [r7, #24]
 801074a:	2200      	movs	r2, #0
 801074c:	601a      	str	r2, [r3, #0]
        }
        lv_label_dot_tmp_free(label);
 801074e:	68f8      	ldr	r0, [r7, #12]
 8010750:	f000 fc5d 	bl	801100e <lv_label_dot_tmp_free>
 8010754:	e08b      	b.n	801086e <lv_label_signal+0x186>
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
 8010756:	7afb      	ldrb	r3, [r7, #11]
 8010758:	2b04      	cmp	r3, #4
 801075a:	d106      	bne.n	801076a <lv_label_signal+0x82>
        /*Revert dots for proper refresh*/
        lv_label_revert_dots(label);
 801075c:	68f8      	ldr	r0, [r7, #12]
 801075e:	f000 fb79 	bl	8010e54 <lv_label_revert_dots>

        lv_label_refr_text(label);
 8010762:	68f8      	ldr	r0, [r7, #12]
 8010764:	f000 f88c 	bl	8010880 <lv_label_refr_text>
 8010768:	e081      	b.n	801086e <lv_label_signal+0x186>
    } else if(sign == LV_SIGNAL_CORD_CHG) {
 801076a:	7afb      	ldrb	r3, [r7, #11]
 801076c:	2b02      	cmp	r3, #2
 801076e:	d120      	bne.n	80107b2 <lv_label_signal+0xca>
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
 8010770:	68fb      	ldr	r3, [r7, #12]
 8010772:	3310      	adds	r3, #16
 8010774:	4618      	mov	r0, r3
 8010776:	f7fe ff7d 	bl	800f674 <lv_area_get_width>
 801077a:	4603      	mov	r3, r0
 801077c:	461c      	mov	r4, r3
 801077e:	6878      	ldr	r0, [r7, #4]
 8010780:	f7fe ff78 	bl	800f674 <lv_area_get_width>
 8010784:	4603      	mov	r3, r0
 8010786:	429c      	cmp	r4, r3
 8010788:	d10c      	bne.n	80107a4 <lv_label_signal+0xbc>
           lv_area_get_height(&label->coords) != lv_area_get_height(param)) {
 801078a:	68fb      	ldr	r3, [r7, #12]
 801078c:	3310      	adds	r3, #16
 801078e:	4618      	mov	r0, r3
 8010790:	f7fe ff87 	bl	800f6a2 <lv_area_get_height>
 8010794:	4603      	mov	r3, r0
 8010796:	461c      	mov	r4, r3
 8010798:	6878      	ldr	r0, [r7, #4]
 801079a:	f7fe ff82 	bl	800f6a2 <lv_area_get_height>
 801079e:	4603      	mov	r3, r0
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
 80107a0:	429c      	cmp	r4, r3
 80107a2:	d064      	beq.n	801086e <lv_label_signal+0x186>
            lv_label_revert_dots(label);
 80107a4:	68f8      	ldr	r0, [r7, #12]
 80107a6:	f000 fb55 	bl	8010e54 <lv_label_revert_dots>
            lv_label_refr_text(label);
 80107aa:	68f8      	ldr	r0, [r7, #12]
 80107ac:	f000 f868 	bl	8010880 <lv_label_refr_text>
 80107b0:	e05d      	b.n	801086e <lv_label_signal+0x186>
        }
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 80107b2:	7afb      	ldrb	r3, [r7, #11]
 80107b4:	2b06      	cmp	r3, #6
 80107b6:	d13c      	bne.n	8010832 <lv_label_signal+0x14a>
        if(ext->body_draw) {
 80107b8:	69bb      	ldr	r3, [r7, #24]
 80107ba:	7c5b      	ldrb	r3, [r3, #17]
 80107bc:	f003 0301 	and.w	r3, r3, #1
 80107c0:	b2db      	uxtb	r3, r3
 80107c2:	2b00      	cmp	r3, #0
 80107c4:	d053      	beq.n	801086e <lv_label_signal+0x186>
            const lv_style_t * style = lv_label_get_style(label, LV_LABEL_STYLE_MAIN);
 80107c6:	2100      	movs	r1, #0
 80107c8:	68f8      	ldr	r0, [r7, #12]
 80107ca:	f7fe ff90 	bl	800f6ee <lv_label_get_style>
 80107ce:	6138      	str	r0, [r7, #16]

            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.left);
 80107d0:	693b      	ldr	r3, [r7, #16]
 80107d2:	f9b3 201a 	ldrsh.w	r2, [r3, #26]
 80107d6:	68fb      	ldr	r3, [r7, #12]
 80107d8:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 80107dc:	4293      	cmp	r3, r2
 80107de:	bfb8      	it	lt
 80107e0:	4613      	movlt	r3, r2
 80107e2:	b21a      	sxth	r2, r3
 80107e4:	68fb      	ldr	r3, [r7, #12]
 80107e6:	869a      	strh	r2, [r3, #52]	; 0x34
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.right);
 80107e8:	693b      	ldr	r3, [r7, #16]
 80107ea:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
 80107ee:	68fb      	ldr	r3, [r7, #12]
 80107f0:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 80107f4:	4293      	cmp	r3, r2
 80107f6:	bfb8      	it	lt
 80107f8:	4613      	movlt	r3, r2
 80107fa:	b21a      	sxth	r2, r3
 80107fc:	68fb      	ldr	r3, [r7, #12]
 80107fe:	869a      	strh	r2, [r3, #52]	; 0x34
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.top);
 8010800:	693b      	ldr	r3, [r7, #16]
 8010802:	f9b3 2016 	ldrsh.w	r2, [r3, #22]
 8010806:	68fb      	ldr	r3, [r7, #12]
 8010808:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 801080c:	4293      	cmp	r3, r2
 801080e:	bfb8      	it	lt
 8010810:	4613      	movlt	r3, r2
 8010812:	b21a      	sxth	r2, r3
 8010814:	68fb      	ldr	r3, [r7, #12]
 8010816:	869a      	strh	r2, [r3, #52]	; 0x34
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.bottom);
 8010818:	693b      	ldr	r3, [r7, #16]
 801081a:	f9b3 2018 	ldrsh.w	r2, [r3, #24]
 801081e:	68fb      	ldr	r3, [r7, #12]
 8010820:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 8010824:	4293      	cmp	r3, r2
 8010826:	bfb8      	it	lt
 8010828:	4613      	movlt	r3, r2
 801082a:	b21a      	sxth	r2, r3
 801082c:	68fb      	ldr	r3, [r7, #12]
 801082e:	869a      	strh	r2, [r3, #52]	; 0x34
 8010830:	e01d      	b.n	801086e <lv_label_signal+0x186>
        }
    }
    else if(sign == LV_SIGNAL_BASE_DIR_CHG) {
 8010832:	7afb      	ldrb	r3, [r7, #11]
 8010834:	2b05      	cmp	r3, #5
 8010836:	d01a      	beq.n	801086e <lv_label_signal+0x186>
#if LV_USE_BIDI
        if(ext->static_txt == 0) lv_label_set_text(label, NULL);
#endif
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 8010838:	7afb      	ldrb	r3, [r7, #11]
 801083a:	2b07      	cmp	r3, #7
 801083c:	d117      	bne.n	801086e <lv_label_signal+0x186>
        lv_obj_type_t * buf = param;
 801083e:	687b      	ldr	r3, [r7, #4]
 8010840:	617b      	str	r3, [r7, #20]
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 8010842:	2300      	movs	r3, #0
 8010844:	77fb      	strb	r3, [r7, #31]
 8010846:	e008      	b.n	801085a <lv_label_signal+0x172>
            if(buf->type[i] == NULL) break;
 8010848:	7ffa      	ldrb	r2, [r7, #31]
 801084a:	697b      	ldr	r3, [r7, #20]
 801084c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010850:	2b00      	cmp	r3, #0
 8010852:	d006      	beq.n	8010862 <lv_label_signal+0x17a>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 8010854:	7ffb      	ldrb	r3, [r7, #31]
 8010856:	3301      	adds	r3, #1
 8010858:	77fb      	strb	r3, [r7, #31]
 801085a:	7ffb      	ldrb	r3, [r7, #31]
 801085c:	2b06      	cmp	r3, #6
 801085e:	d9f3      	bls.n	8010848 <lv_label_signal+0x160>
 8010860:	e000      	b.n	8010864 <lv_label_signal+0x17c>
            if(buf->type[i] == NULL) break;
 8010862:	bf00      	nop
        }
        buf->type[i] = "lv_label";
 8010864:	7ffa      	ldrb	r2, [r7, #31]
 8010866:	697b      	ldr	r3, [r7, #20]
 8010868:	4904      	ldr	r1, [pc, #16]	; (801087c <lv_label_signal+0x194>)
 801086a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    return res;
 801086e:	7fbb      	ldrb	r3, [r7, #30]
}
 8010870:	4618      	mov	r0, r3
 8010872:	3724      	adds	r7, #36	; 0x24
 8010874:	46bd      	mov	sp, r7
 8010876:	bd90      	pop	{r4, r7, pc}
 8010878:	200082dc 	.word	0x200082dc
 801087c:	0801392c 	.word	0x0801392c

08010880 <lv_label_refr_text>:
/**
 * Refresh the label with its text stored in its extended data
 * @param label pointer to a label object
 */
static void lv_label_refr_text(lv_obj_t * label)
{
 8010880:	b590      	push	{r4, r7, lr}
 8010882:	b09f      	sub	sp, #124	; 0x7c
 8010884:	af04      	add	r7, sp, #16
 8010886:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8010888:	6878      	ldr	r0, [r7, #4]
 801088a:	f7f2 f89b 	bl	80029c4 <lv_obj_get_ext_attr>
 801088e:	6538      	str	r0, [r7, #80]	; 0x50

    if(ext->text == NULL) return;
 8010890:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010892:	681b      	ldr	r3, [r3, #0]
 8010894:	2b00      	cmp	r3, #0
 8010896:	f000 82d1 	beq.w	8010e3c <lv_label_refr_text+0x5bc>
#if LV_LABEL_LONG_TXT_HINT
    ext->hint.line_start = -1; /*The hint is invalid if the text changes*/
#endif

    lv_coord_t max_w         = lv_obj_get_width(label);
 801089a:	6878      	ldr	r0, [r7, #4]
 801089c:	f7f1 febc 	bl	8002618 <lv_obj_get_width>
 80108a0:	4603      	mov	r3, r0
 80108a2:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
    const lv_style_t * style = lv_obj_get_style(label);
 80108a6:	6878      	ldr	r0, [r7, #4]
 80108a8:	f7f1 ff52 	bl	8002750 <lv_obj_get_style>
 80108ac:	64f8      	str	r0, [r7, #76]	; 0x4c
    const lv_font_t * font   = style->text.font;
 80108ae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80108b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80108b2:	64bb      	str	r3, [r7, #72]	; 0x48

    /*If the width will be expanded set the max length to very big */
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
 80108b4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80108b6:	7c1b      	ldrb	r3, [r3, #16]
 80108b8:	f003 0307 	and.w	r3, r3, #7
 80108bc:	b2db      	uxtb	r3, r3
 80108be:	2b00      	cmp	r3, #0
 80108c0:	d103      	bne.n	80108ca <lv_label_refr_text+0x4a>
        max_w = LV_COORD_MAX;
 80108c2:	f647 4318 	movw	r3, #31768	; 0x7c18
 80108c6:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
    }

    /*Calc. the height and longest line*/
    lv_point_t size;
    lv_txt_flag_t flag = LV_TXT_FLAG_NONE;
 80108ca:	2300      	movs	r3, #0
 80108cc:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 80108d0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80108d2:	7c1b      	ldrb	r3, [r3, #16]
 80108d4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80108d8:	b2db      	uxtb	r3, r3
 80108da:	2b00      	cmp	r3, #0
 80108dc:	d005      	beq.n	80108ea <lv_label_refr_text+0x6a>
 80108de:	f897 3065 	ldrb.w	r3, [r7, #101]	; 0x65
 80108e2:	f043 0301 	orr.w	r3, r3, #1
 80108e6:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 80108ea:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80108ec:	7c1b      	ldrb	r3, [r3, #16]
 80108ee:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80108f2:	b2db      	uxtb	r3, r3
 80108f4:	2b00      	cmp	r3, #0
 80108f6:	d005      	beq.n	8010904 <lv_label_refr_text+0x84>
 80108f8:	f897 3065 	ldrb.w	r3, [r7, #101]	; 0x65
 80108fc:	f043 0302 	orr.w	r3, r3, #2
 8010900:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
    lv_txt_get_size(&size, ext->text, font, style->text.letter_space, style->text.line_space, max_w, flag);
 8010904:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010906:	6819      	ldr	r1, [r3, #0]
 8010908:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801090a:	f9b3 4028 	ldrsh.w	r4, [r3, #40]	; 0x28
 801090e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010910:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8010914:	f107 0038 	add.w	r0, r7, #56	; 0x38
 8010918:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 801091c:	9202      	str	r2, [sp, #8]
 801091e:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 8010922:	9201      	str	r2, [sp, #4]
 8010924:	9300      	str	r3, [sp, #0]
 8010926:	4623      	mov	r3, r4
 8010928:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801092a:	f7fc fdd3 	bl	800d4d4 <lv_txt_get_size>

    /*Set the full size in expand mode*/
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
 801092e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010930:	7c1b      	ldrb	r3, [r3, #16]
 8010932:	f003 0307 	and.w	r3, r3, #7
 8010936:	b2db      	uxtb	r3, r3
 8010938:	2b00      	cmp	r3, #0
 801093a:	d108      	bne.n	801094e <lv_label_refr_text+0xce>
        lv_obj_set_size(label, size.x, size.y);
 801093c:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8010940:	f9b7 203a 	ldrsh.w	r2, [r7, #58]	; 0x3a
 8010944:	4619      	mov	r1, r3
 8010946:	6878      	ldr	r0, [r7, #4]
 8010948:	f7f0 fd28 	bl	800139c <lv_obj_set_size>
 801094c:	e272      	b.n	8010e34 <lv_label_refr_text+0x5b4>
    }
    /*In roll mode keep the size but start offset animations*/
    else if(ext->long_mode == LV_LABEL_LONG_SROLL) {
 801094e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010950:	7c1b      	ldrb	r3, [r3, #16]
 8010952:	f003 0307 	and.w	r3, r3, #7
 8010956:	b2db      	uxtb	r3, r3
 8010958:	2b03      	cmp	r3, #3
 801095a:	f040 809f 	bne.w	8010a9c <lv_label_refr_text+0x21c>
#if LV_USE_ANIMATION
        lv_anim_t anim;
        anim.var      = label;
 801095e:	687b      	ldr	r3, [r7, #4]
 8010960:	60fb      	str	r3, [r7, #12]
        anim.repeat   = 1;
 8010962:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8010966:	f043 0302 	orr.w	r3, r3, #2
 801096a:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.playback = 1;
 801096e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8010972:	f043 0301 	orr.w	r3, r3, #1
 8010976:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.start    = 0;
 801097a:	2300      	movs	r3, #0
 801097c:	61fb      	str	r3, [r7, #28]
        anim.ready_cb = NULL;
 801097e:	2300      	movs	r3, #0
 8010980:	61bb      	str	r3, [r7, #24]
        anim.path_cb  = lv_anim_path_linear;
 8010982:	4bb9      	ldr	r3, [pc, #740]	; (8010c68 <lv_label_refr_text+0x3e8>)
 8010984:	617b      	str	r3, [r7, #20]
        anim.playback_pause =
            (((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 8010986:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010988:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801098a:	2220      	movs	r2, #32
 801098c:	2120      	movs	r1, #32
 801098e:	4618      	mov	r0, r3
 8010990:	f7fa f920 	bl	800abd4 <lv_font_get_glyph_width>
 8010994:	4603      	mov	r3, r0
 8010996:	461a      	mov	r2, r3
 8010998:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801099a:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 801099e:	4413      	add	r3, r2
 80109a0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80109a4:	fb02 f303 	mul.w	r3, r2, r3
             ext->anim_speed) *
 80109a8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80109aa:	89d2      	ldrh	r2, [r2, #14]
            (((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 80109ac:	fb93 f3f2 	sdiv	r3, r3, r2
        anim.playback_pause =
 80109b0:	b29b      	uxth	r3, r3
 80109b2:	461a      	mov	r2, r3
 80109b4:	0052      	lsls	r2, r2, #1
 80109b6:	4413      	add	r3, r2
 80109b8:	b29b      	uxth	r3, r3
 80109ba:	853b      	strh	r3, [r7, #40]	; 0x28
            LV_LABEL_WAIT_CHAR_COUNT;
        anim.repeat_pause = anim.playback_pause;
 80109bc:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80109be:	857b      	strh	r3, [r7, #42]	; 0x2a
        anim.act_time     = -anim.playback_pause;
 80109c0:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80109c2:	425b      	negs	r3, r3
 80109c4:	b29b      	uxth	r3, r3
 80109c6:	b21b      	sxth	r3, r3
 80109c8:	84fb      	strh	r3, [r7, #38]	; 0x26

        bool hor_anim = false;
 80109ca:	2300      	movs	r3, #0
 80109cc:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
        if(size.x > lv_obj_get_width(label)) {
 80109d0:	f9b7 4038 	ldrsh.w	r4, [r7, #56]	; 0x38
 80109d4:	6878      	ldr	r0, [r7, #4]
 80109d6:	f7f1 fe1f 	bl	8002618 <lv_obj_get_width>
 80109da:	4603      	mov	r3, r0
 80109dc:	429c      	cmp	r4, r3
 80109de:	dd1e      	ble.n	8010a1e <lv_label_refr_text+0x19e>
            anim.end     = lv_obj_get_width(label) - size.x;
 80109e0:	6878      	ldr	r0, [r7, #4]
 80109e2:	f7f1 fe19 	bl	8002618 <lv_obj_get_width>
 80109e6:	4603      	mov	r3, r0
 80109e8:	461a      	mov	r2, r3
 80109ea:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80109ee:	1ad3      	subs	r3, r2, r3
 80109f0:	623b      	str	r3, [r7, #32]
            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_x;
 80109f2:	4b9e      	ldr	r3, [pc, #632]	; (8010c6c <lv_label_refr_text+0x3ec>)
 80109f4:	613b      	str	r3, [r7, #16]
            anim.time    = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 80109f6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80109f8:	89db      	ldrh	r3, [r3, #14]
 80109fa:	69fa      	ldr	r2, [r7, #28]
 80109fc:	b211      	sxth	r1, r2
 80109fe:	6a3a      	ldr	r2, [r7, #32]
 8010a00:	b212      	sxth	r2, r2
 8010a02:	4618      	mov	r0, r3
 8010a04:	f7fb f9a0 	bl	800bd48 <lv_anim_speed_to_time>
 8010a08:	4603      	mov	r3, r0
 8010a0a:	84bb      	strh	r3, [r7, #36]	; 0x24
            lv_anim_create(&anim);
 8010a0c:	f107 030c 	add.w	r3, r7, #12
 8010a10:	4618      	mov	r0, r3
 8010a12:	f7fb f911 	bl	800bc38 <lv_anim_create>
            hor_anim = true;
 8010a16:	2301      	movs	r3, #1
 8010a18:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
 8010a1c:	e006      	b.n	8010a2c <lv_label_refr_text+0x1ac>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 8010a1e:	4993      	ldr	r1, [pc, #588]	; (8010c6c <lv_label_refr_text+0x3ec>)
 8010a20:	6878      	ldr	r0, [r7, #4]
 8010a22:	f7fb f959 	bl	800bcd8 <lv_anim_del>
            ext->offset.x = 0;
 8010a26:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010a28:	2200      	movs	r2, #0
 8010a2a:	815a      	strh	r2, [r3, #10]
        }

        if(size.y > lv_obj_get_height(label) && hor_anim == false) {
 8010a2c:	f9b7 403a 	ldrsh.w	r4, [r7, #58]	; 0x3a
 8010a30:	6878      	ldr	r0, [r7, #4]
 8010a32:	f7f1 fe13 	bl	800265c <lv_obj_get_height>
 8010a36:	4603      	mov	r3, r0
 8010a38:	429c      	cmp	r4, r3
 8010a3a:	dd27      	ble.n	8010a8c <lv_label_refr_text+0x20c>
 8010a3c:	f897 3064 	ldrb.w	r3, [r7, #100]	; 0x64
 8010a40:	f083 0301 	eor.w	r3, r3, #1
 8010a44:	b2db      	uxtb	r3, r3
 8010a46:	2b00      	cmp	r3, #0
 8010a48:	d020      	beq.n	8010a8c <lv_label_refr_text+0x20c>
            anim.end     = lv_obj_get_height(label) - size.y - (lv_font_get_line_height(font));
 8010a4a:	6878      	ldr	r0, [r7, #4]
 8010a4c:	f7f1 fe06 	bl	800265c <lv_obj_get_height>
 8010a50:	4603      	mov	r3, r0
 8010a52:	461a      	mov	r2, r3
 8010a54:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8010a58:	1ad4      	subs	r4, r2, r3
 8010a5a:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8010a5c:	f7fe fdfe 	bl	800f65c <lv_font_get_line_height>
 8010a60:	4603      	mov	r3, r0
 8010a62:	1ae3      	subs	r3, r4, r3
 8010a64:	623b      	str	r3, [r7, #32]
            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_y;
 8010a66:	4b82      	ldr	r3, [pc, #520]	; (8010c70 <lv_label_refr_text+0x3f0>)
 8010a68:	613b      	str	r3, [r7, #16]

            anim.time = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 8010a6a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010a6c:	89db      	ldrh	r3, [r3, #14]
 8010a6e:	69fa      	ldr	r2, [r7, #28]
 8010a70:	b211      	sxth	r1, r2
 8010a72:	6a3a      	ldr	r2, [r7, #32]
 8010a74:	b212      	sxth	r2, r2
 8010a76:	4618      	mov	r0, r3
 8010a78:	f7fb f966 	bl	800bd48 <lv_anim_speed_to_time>
 8010a7c:	4603      	mov	r3, r0
 8010a7e:	84bb      	strh	r3, [r7, #36]	; 0x24
            lv_anim_create(&anim);
 8010a80:	f107 030c 	add.w	r3, r7, #12
 8010a84:	4618      	mov	r0, r3
 8010a86:	f7fb f8d7 	bl	800bc38 <lv_anim_create>
 8010a8a:	e1d3      	b.n	8010e34 <lv_label_refr_text+0x5b4>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 8010a8c:	4978      	ldr	r1, [pc, #480]	; (8010c70 <lv_label_refr_text+0x3f0>)
 8010a8e:	6878      	ldr	r0, [r7, #4]
 8010a90:	f7fb f922 	bl	800bcd8 <lv_anim_del>
            ext->offset.y = 0;
 8010a94:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010a96:	2200      	movs	r2, #0
 8010a98:	819a      	strh	r2, [r3, #12]
 8010a9a:	e1cb      	b.n	8010e34 <lv_label_refr_text+0x5b4>
        }
#endif
    }
    /*In roll inf. mode keep the size but start offset animations*/
    else if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
 8010a9c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010a9e:	7c1b      	ldrb	r3, [r3, #16]
 8010aa0:	f003 0307 	and.w	r3, r3, #7
 8010aa4:	b2db      	uxtb	r3, r3
 8010aa6:	2b04      	cmp	r3, #4
 8010aa8:	f040 80c8 	bne.w	8010c3c <lv_label_refr_text+0x3bc>
#if LV_USE_ANIMATION
        lv_label_align_t align = lv_label_get_align(label);
 8010aac:	6878      	ldr	r0, [r7, #4]
 8010aae:	f7ff f9e5 	bl	800fe7c <lv_label_get_align>
 8010ab2:	4603      	mov	r3, r0
 8010ab4:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

        lv_anim_t anim;
        anim.var      = label;
 8010ab8:	687b      	ldr	r3, [r7, #4]
 8010aba:	60fb      	str	r3, [r7, #12]
        anim.repeat   = 1;
 8010abc:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8010ac0:	f043 0302 	orr.w	r3, r3, #2
 8010ac4:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.playback = 0;
 8010ac8:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8010acc:	f36f 0300 	bfc	r3, #0, #1
 8010ad0:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.act_time = -(((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 8010ad4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010ad6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010ad8:	2220      	movs	r2, #32
 8010ada:	2120      	movs	r1, #32
 8010adc:	4618      	mov	r0, r3
 8010ade:	f7fa f879 	bl	800abd4 <lv_font_get_glyph_width>
 8010ae2:	4603      	mov	r3, r0
 8010ae4:	461a      	mov	r2, r3
 8010ae6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010ae8:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8010aec:	4413      	add	r3, r2
 8010aee:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8010af2:	fb02 f303 	mul.w	r3, r2, r3
                          ext->anim_speed) *
 8010af6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8010af8:	89d2      	ldrh	r2, [r2, #14]
        anim.act_time = -(((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 8010afa:	fb93 f3f2 	sdiv	r3, r3, r2
 8010afe:	b29b      	uxth	r3, r3
 8010b00:	461a      	mov	r2, r3
 8010b02:	009b      	lsls	r3, r3, #2
 8010b04:	1ad3      	subs	r3, r2, r3
 8010b06:	b29b      	uxth	r3, r3
 8010b08:	b21b      	sxth	r3, r3
 8010b0a:	84fb      	strh	r3, [r7, #38]	; 0x26
                        LV_LABEL_WAIT_CHAR_COUNT;
        anim.ready_cb       = NULL;
 8010b0c:	2300      	movs	r3, #0
 8010b0e:	61bb      	str	r3, [r7, #24]
        anim.path_cb        = lv_anim_path_linear;
 8010b10:	4b55      	ldr	r3, [pc, #340]	; (8010c68 <lv_label_refr_text+0x3e8>)
 8010b12:	617b      	str	r3, [r7, #20]
        anim.playback_pause = 0;
 8010b14:	2300      	movs	r3, #0
 8010b16:	853b      	strh	r3, [r7, #40]	; 0x28
        anim.repeat_pause   = 0;
 8010b18:	2300      	movs	r3, #0
 8010b1a:	857b      	strh	r3, [r7, #42]	; 0x2a

        bool hor_anim = false;
 8010b1c:	2300      	movs	r3, #0
 8010b1e:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
        if(size.x > lv_obj_get_width(label)) {
 8010b22:	f9b7 4038 	ldrsh.w	r4, [r7, #56]	; 0x38
 8010b26:	6878      	ldr	r0, [r7, #4]
 8010b28:	f7f1 fd76 	bl	8002618 <lv_obj_get_width>
 8010b2c:	4603      	mov	r3, r0
 8010b2e:	429c      	cmp	r4, r3
 8010b30:	dd38      	ble.n	8010ba4 <lv_label_refr_text+0x324>
            if(align == LV_LABEL_ALIGN_RIGHT) {
 8010b32:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8010b36:	2b02      	cmp	r3, #2
 8010b38:	d10f      	bne.n	8010b5a <lv_label_refr_text+0x2da>
                anim.end    = 0;
 8010b3a:	2300      	movs	r3, #0
 8010b3c:	623b      	str	r3, [r7, #32]
                anim.start     = -size.x - lv_font_get_glyph_width(font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
 8010b3e:	2220      	movs	r2, #32
 8010b40:	2120      	movs	r1, #32
 8010b42:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8010b44:	f7fa f846 	bl	800abd4 <lv_font_get_glyph_width>
 8010b48:	4603      	mov	r3, r0
 8010b4a:	461a      	mov	r2, r3
 8010b4c:	009b      	lsls	r3, r3, #2
 8010b4e:	1ad3      	subs	r3, r2, r3
 8010b50:	f9b7 2038 	ldrsh.w	r2, [r7, #56]	; 0x38
 8010b54:	1a9b      	subs	r3, r3, r2
 8010b56:	61fb      	str	r3, [r7, #28]
 8010b58:	e00e      	b.n	8010b78 <lv_label_refr_text+0x2f8>
            } else {
                anim.start    = 0;
 8010b5a:	2300      	movs	r3, #0
 8010b5c:	61fb      	str	r3, [r7, #28]
                anim.end     = -size.x - lv_font_get_glyph_width(font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
 8010b5e:	2220      	movs	r2, #32
 8010b60:	2120      	movs	r1, #32
 8010b62:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8010b64:	f7fa f836 	bl	800abd4 <lv_font_get_glyph_width>
 8010b68:	4603      	mov	r3, r0
 8010b6a:	461a      	mov	r2, r3
 8010b6c:	009b      	lsls	r3, r3, #2
 8010b6e:	1ad3      	subs	r3, r2, r3
 8010b70:	f9b7 2038 	ldrsh.w	r2, [r7, #56]	; 0x38
 8010b74:	1a9b      	subs	r3, r3, r2
 8010b76:	623b      	str	r3, [r7, #32]
            }

            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_x;
 8010b78:	4b3c      	ldr	r3, [pc, #240]	; (8010c6c <lv_label_refr_text+0x3ec>)
 8010b7a:	613b      	str	r3, [r7, #16]
            anim.time    = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 8010b7c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010b7e:	89db      	ldrh	r3, [r3, #14]
 8010b80:	69fa      	ldr	r2, [r7, #28]
 8010b82:	b211      	sxth	r1, r2
 8010b84:	6a3a      	ldr	r2, [r7, #32]
 8010b86:	b212      	sxth	r2, r2
 8010b88:	4618      	mov	r0, r3
 8010b8a:	f7fb f8dd 	bl	800bd48 <lv_anim_speed_to_time>
 8010b8e:	4603      	mov	r3, r0
 8010b90:	84bb      	strh	r3, [r7, #36]	; 0x24
            lv_anim_create(&anim);
 8010b92:	f107 030c 	add.w	r3, r7, #12
 8010b96:	4618      	mov	r0, r3
 8010b98:	f7fb f84e 	bl	800bc38 <lv_anim_create>
            hor_anim = true;
 8010b9c:	2301      	movs	r3, #1
 8010b9e:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
 8010ba2:	e006      	b.n	8010bb2 <lv_label_refr_text+0x332>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 8010ba4:	4931      	ldr	r1, [pc, #196]	; (8010c6c <lv_label_refr_text+0x3ec>)
 8010ba6:	6878      	ldr	r0, [r7, #4]
 8010ba8:	f7fb f896 	bl	800bcd8 <lv_anim_del>
            ext->offset.x = 0;
 8010bac:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010bae:	2200      	movs	r2, #0
 8010bb0:	815a      	strh	r2, [r3, #10]
        }

        if(size.y > lv_obj_get_height(label) && hor_anim == false) {
 8010bb2:	f9b7 403a 	ldrsh.w	r4, [r7, #58]	; 0x3a
 8010bb6:	6878      	ldr	r0, [r7, #4]
 8010bb8:	f7f1 fd50 	bl	800265c <lv_obj_get_height>
 8010bbc:	4603      	mov	r3, r0
 8010bbe:	429c      	cmp	r4, r3
 8010bc0:	dd34      	ble.n	8010c2c <lv_label_refr_text+0x3ac>
 8010bc2:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 8010bc6:	f083 0301 	eor.w	r3, r3, #1
 8010bca:	b2db      	uxtb	r3, r3
 8010bcc:	2b00      	cmp	r3, #0
 8010bce:	d02d      	beq.n	8010c2c <lv_label_refr_text+0x3ac>
            if(align == LV_LABEL_ALIGN_RIGHT) {
 8010bd0:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8010bd4:	2b02      	cmp	r3, #2
 8010bd6:	d10b      	bne.n	8010bf0 <lv_label_refr_text+0x370>
                  anim.end    = 0;
 8010bd8:	2300      	movs	r3, #0
 8010bda:	623b      	str	r3, [r7, #32]
                  anim.start     = -size.y - (lv_font_get_line_height(font));
 8010bdc:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8010be0:	425c      	negs	r4, r3
 8010be2:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8010be4:	f7fe fd3a 	bl	800f65c <lv_font_get_line_height>
 8010be8:	4603      	mov	r3, r0
 8010bea:	1ae3      	subs	r3, r4, r3
 8010bec:	61fb      	str	r3, [r7, #28]
 8010bee:	e00a      	b.n	8010c06 <lv_label_refr_text+0x386>
              } else {
                  anim.start    = 0;
 8010bf0:	2300      	movs	r3, #0
 8010bf2:	61fb      	str	r3, [r7, #28]
                  anim.end     = -size.y - (lv_font_get_line_height(font));
 8010bf4:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8010bf8:	425c      	negs	r4, r3
 8010bfa:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8010bfc:	f7fe fd2e 	bl	800f65c <lv_font_get_line_height>
 8010c00:	4603      	mov	r3, r0
 8010c02:	1ae3      	subs	r3, r4, r3
 8010c04:	623b      	str	r3, [r7, #32]
              }

            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_y;
 8010c06:	4b1a      	ldr	r3, [pc, #104]	; (8010c70 <lv_label_refr_text+0x3f0>)
 8010c08:	613b      	str	r3, [r7, #16]
            anim.time    = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 8010c0a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010c0c:	89db      	ldrh	r3, [r3, #14]
 8010c0e:	69fa      	ldr	r2, [r7, #28]
 8010c10:	b211      	sxth	r1, r2
 8010c12:	6a3a      	ldr	r2, [r7, #32]
 8010c14:	b212      	sxth	r2, r2
 8010c16:	4618      	mov	r0, r3
 8010c18:	f7fb f896 	bl	800bd48 <lv_anim_speed_to_time>
 8010c1c:	4603      	mov	r3, r0
 8010c1e:	84bb      	strh	r3, [r7, #36]	; 0x24
            lv_anim_create(&anim);
 8010c20:	f107 030c 	add.w	r3, r7, #12
 8010c24:	4618      	mov	r0, r3
 8010c26:	f7fb f807 	bl	800bc38 <lv_anim_create>
 8010c2a:	e103      	b.n	8010e34 <lv_label_refr_text+0x5b4>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 8010c2c:	4910      	ldr	r1, [pc, #64]	; (8010c70 <lv_label_refr_text+0x3f0>)
 8010c2e:	6878      	ldr	r0, [r7, #4]
 8010c30:	f7fb f852 	bl	800bcd8 <lv_anim_del>
            ext->offset.y = 0;
 8010c34:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010c36:	2200      	movs	r2, #0
 8010c38:	819a      	strh	r2, [r3, #12]
 8010c3a:	e0fb      	b.n	8010e34 <lv_label_refr_text+0x5b4>
        }
#endif
    } else if(ext->long_mode == LV_LABEL_LONG_DOT) {
 8010c3c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010c3e:	7c1b      	ldrb	r3, [r3, #16]
 8010c40:	f003 0307 	and.w	r3, r3, #7
 8010c44:	b2db      	uxtb	r3, r3
 8010c46:	2b02      	cmp	r3, #2
 8010c48:	f040 80e7 	bne.w	8010e1a <lv_label_refr_text+0x59a>
        if(size.y <= lv_obj_get_height(label)) { /*No dots are required, the text is short enough*/
 8010c4c:	f9b7 403a 	ldrsh.w	r4, [r7, #58]	; 0x3a
 8010c50:	6878      	ldr	r0, [r7, #4]
 8010c52:	f7f1 fd03 	bl	800265c <lv_obj_get_height>
 8010c56:	4603      	mov	r3, r0
 8010c58:	429c      	cmp	r4, r3
 8010c5a:	dc0b      	bgt.n	8010c74 <lv_label_refr_text+0x3f4>
            ext->dot_end = LV_LABEL_DOT_END_INV;
 8010c5c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010c5e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010c62:	811a      	strh	r2, [r3, #8]
 8010c64:	e0e6      	b.n	8010e34 <lv_label_refr_text+0x5b4>
 8010c66:	bf00      	nop
 8010c68:	0800bda9 	.word	0x0800bda9
 8010c6c:	08010f09 	.word	0x08010f09
 8010c70:	08010f31 	.word	0x08010f31
        } else if(lv_txt_get_encoded_length(ext->text) <= LV_LABEL_DOT_NUM) { /*Don't turn to dots all the characters*/
 8010c74:	4b73      	ldr	r3, [pc, #460]	; (8010e44 <lv_label_refr_text+0x5c4>)
 8010c76:	681b      	ldr	r3, [r3, #0]
 8010c78:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8010c7a:	6812      	ldr	r2, [r2, #0]
 8010c7c:	4610      	mov	r0, r2
 8010c7e:	4798      	blx	r3
 8010c80:	4603      	mov	r3, r0
 8010c82:	2b03      	cmp	r3, #3
 8010c84:	d804      	bhi.n	8010c90 <lv_label_refr_text+0x410>
            ext->dot_end = LV_LABEL_DOT_END_INV;
 8010c86:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010c88:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010c8c:	811a      	strh	r2, [r3, #8]
 8010c8e:	e0d1      	b.n	8010e34 <lv_label_refr_text+0x5b4>
        } else {
            lv_point_t p;
            p.x = lv_obj_get_width(label) -
 8010c90:	6878      	ldr	r0, [r7, #4]
 8010c92:	f7f1 fcc1 	bl	8002618 <lv_obj_get_width>
 8010c96:	4603      	mov	r3, r0
 8010c98:	b29c      	uxth	r4, r3
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
 8010c9a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010c9c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010c9e:	222e      	movs	r2, #46	; 0x2e
 8010ca0:	212e      	movs	r1, #46	; 0x2e
 8010ca2:	4618      	mov	r0, r3
 8010ca4:	f7f9 ff96 	bl	800abd4 <lv_font_get_glyph_width>
 8010ca8:	4603      	mov	r3, r0
 8010caa:	461a      	mov	r2, r3
 8010cac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010cae:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8010cb2:	4413      	add	r3, r2
            p.x = lv_obj_get_width(label) -
 8010cb4:	b29b      	uxth	r3, r3
 8010cb6:	461a      	mov	r2, r3
 8010cb8:	009b      	lsls	r3, r3, #2
 8010cba:	1ad3      	subs	r3, r2, r3
 8010cbc:	b29b      	uxth	r3, r3
 8010cbe:	4423      	add	r3, r4
 8010cc0:	b29b      	uxth	r3, r3
 8010cc2:	b21b      	sxth	r3, r3
 8010cc4:	86bb      	strh	r3, [r7, #52]	; 0x34
                      LV_LABEL_DOT_NUM; /*Shrink with dots*/
            p.y = lv_obj_get_height(label);
 8010cc6:	6878      	ldr	r0, [r7, #4]
 8010cc8:	f7f1 fcc8 	bl	800265c <lv_obj_get_height>
 8010ccc:	4603      	mov	r3, r0
 8010cce:	86fb      	strh	r3, [r7, #54]	; 0x36
            p.y -= p.y %
 8010cd0:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8010cd4:	461c      	mov	r4, r3
                   (lv_font_get_line_height(style->text.font) + style->text.line_space); /*Round down to the last line*/
 8010cd6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010cd8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010cda:	4618      	mov	r0, r3
 8010cdc:	f7fe fcbe 	bl	800f65c <lv_font_get_line_height>
 8010ce0:	4603      	mov	r3, r0
 8010ce2:	461a      	mov	r2, r3
 8010ce4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010ce6:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8010cea:	4413      	add	r3, r2
            p.y -= p.y %
 8010cec:	fb94 f2f3 	sdiv	r2, r4, r3
 8010cf0:	fb03 f302 	mul.w	r3, r3, r2
 8010cf4:	1ae3      	subs	r3, r4, r3
 8010cf6:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 8010cfa:	b292      	uxth	r2, r2
 8010cfc:	b29b      	uxth	r3, r3
 8010cfe:	1ad3      	subs	r3, r2, r3
 8010d00:	b29b      	uxth	r3, r3
 8010d02:	b21b      	sxth	r3, r3
 8010d04:	86fb      	strh	r3, [r7, #54]	; 0x36
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
 8010d06:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8010d0a:	b29a      	uxth	r2, r3
 8010d0c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010d0e:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8010d12:	b29b      	uxth	r3, r3
 8010d14:	1ad3      	subs	r3, r2, r3
 8010d16:	b29b      	uxth	r3, r3
 8010d18:	b21b      	sxth	r3, r3
 8010d1a:	86fb      	strh	r3, [r7, #54]	; 0x36
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
 8010d1c:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8010d20:	4619      	mov	r1, r3
 8010d22:	6878      	ldr	r0, [r7, #4]
 8010d24:	f7ff f92a 	bl	800ff7c <lv_label_get_letter_on>
 8010d28:	4603      	mov	r3, r0
 8010d2a:	65fb      	str	r3, [r7, #92]	; 0x5c


            /*Be sure there is space for the dots*/
            size_t txt_len = strlen(ext->text);
 8010d2c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010d2e:	681b      	ldr	r3, [r3, #0]
 8010d30:	4618      	mov	r0, r3
 8010d32:	f7ef fa59 	bl	80001e8 <strlen>
 8010d36:	6478      	str	r0, [r7, #68]	; 0x44
            uint32_t byte_id     = lv_txt_encoded_get_byte_id(ext->text, letter_id);
 8010d38:	4b43      	ldr	r3, [pc, #268]	; (8010e48 <lv_label_refr_text+0x5c8>)
 8010d3a:	681b      	ldr	r3, [r3, #0]
 8010d3c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8010d3e:	6812      	ldr	r2, [r2, #0]
 8010d40:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8010d42:	4610      	mov	r0, r2
 8010d44:	4798      	blx	r3
 8010d46:	4603      	mov	r3, r0
 8010d48:	633b      	str	r3, [r7, #48]	; 0x30
            while(byte_id + LV_LABEL_DOT_NUM > txt_len) {
 8010d4a:	e00f      	b.n	8010d6c <lv_label_refr_text+0x4ec>
                byte_id -= lv_txt_encoded_size(&ext->text[byte_id]);
 8010d4c:	4b3f      	ldr	r3, [pc, #252]	; (8010e4c <lv_label_refr_text+0x5cc>)
 8010d4e:	681b      	ldr	r3, [r3, #0]
 8010d50:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8010d52:	6811      	ldr	r1, [r2, #0]
 8010d54:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010d56:	440a      	add	r2, r1
 8010d58:	4610      	mov	r0, r2
 8010d5a:	4798      	blx	r3
 8010d5c:	4603      	mov	r3, r0
 8010d5e:	461a      	mov	r2, r3
 8010d60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010d62:	1a9b      	subs	r3, r3, r2
 8010d64:	633b      	str	r3, [r7, #48]	; 0x30
                letter_id--;
 8010d66:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010d68:	3b01      	subs	r3, #1
 8010d6a:	65fb      	str	r3, [r7, #92]	; 0x5c
            while(byte_id + LV_LABEL_DOT_NUM > txt_len) {
 8010d6c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010d6e:	3303      	adds	r3, #3
 8010d70:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8010d72:	429a      	cmp	r2, r3
 8010d74:	d3ea      	bcc.n	8010d4c <lv_label_refr_text+0x4cc>
            }

            /*Save letters under the dots and replace them with dots*/
            uint32_t byte_id_ori = byte_id;
 8010d76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010d78:	643b      	str	r3, [r7, #64]	; 0x40
            uint32_t i;
            uint8_t len          = 0;
 8010d7a:	2300      	movs	r3, #0
 8010d7c:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
 8010d80:	2300      	movs	r3, #0
 8010d82:	65bb      	str	r3, [r7, #88]	; 0x58
 8010d84:	e019      	b.n	8010dba <lv_label_refr_text+0x53a>
                len += lv_txt_encoded_size(&ext->text[byte_id]);
 8010d86:	4b31      	ldr	r3, [pc, #196]	; (8010e4c <lv_label_refr_text+0x5cc>)
 8010d88:	681b      	ldr	r3, [r3, #0]
 8010d8a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8010d8c:	6811      	ldr	r1, [r2, #0]
 8010d8e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010d90:	440a      	add	r2, r1
 8010d92:	4610      	mov	r0, r2
 8010d94:	4798      	blx	r3
 8010d96:	4603      	mov	r3, r0
 8010d98:	461a      	mov	r2, r3
 8010d9a:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8010d9e:	4413      	add	r3, r2
 8010da0:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
                lv_txt_encoded_next(ext->text, &byte_id);
 8010da4:	4b2a      	ldr	r3, [pc, #168]	; (8010e50 <lv_label_refr_text+0x5d0>)
 8010da6:	681b      	ldr	r3, [r3, #0]
 8010da8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8010daa:	6812      	ldr	r2, [r2, #0]
 8010dac:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8010db0:	4610      	mov	r0, r2
 8010db2:	4798      	blx	r3
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
 8010db4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010db6:	3301      	adds	r3, #1
 8010db8:	65bb      	str	r3, [r7, #88]	; 0x58
 8010dba:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010dbc:	2b03      	cmp	r3, #3
 8010dbe:	d9e2      	bls.n	8010d86 <lv_label_refr_text+0x506>
            }

            if(lv_label_set_dot_tmp(label, &ext->text[byte_id_ori], len)) {
 8010dc0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010dc2:	681a      	ldr	r2, [r3, #0]
 8010dc4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010dc6:	4413      	add	r3, r2
 8010dc8:	f897 2057 	ldrb.w	r2, [r7, #87]	; 0x57
 8010dcc:	b292      	uxth	r2, r2
 8010dce:	4619      	mov	r1, r3
 8010dd0:	6878      	ldr	r0, [r7, #4]
 8010dd2:	f000 f8c1 	bl	8010f58 <lv_label_set_dot_tmp>
 8010dd6:	4603      	mov	r3, r0
 8010dd8:	2b00      	cmp	r3, #0
 8010dda:	d02b      	beq.n	8010e34 <lv_label_refr_text+0x5b4>
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
 8010ddc:	2300      	movs	r3, #0
 8010dde:	65bb      	str	r3, [r7, #88]	; 0x58
 8010de0:	e00a      	b.n	8010df8 <lv_label_refr_text+0x578>
                    ext->text[byte_id_ori + i] = '.';
 8010de2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010de4:	681a      	ldr	r2, [r3, #0]
 8010de6:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8010de8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010dea:	440b      	add	r3, r1
 8010dec:	4413      	add	r3, r2
 8010dee:	222e      	movs	r2, #46	; 0x2e
 8010df0:	701a      	strb	r2, [r3, #0]
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
 8010df2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010df4:	3301      	adds	r3, #1
 8010df6:	65bb      	str	r3, [r7, #88]	; 0x58
 8010df8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010dfa:	2b02      	cmp	r3, #2
 8010dfc:	d9f1      	bls.n	8010de2 <lv_label_refr_text+0x562>
                }
                ext->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
 8010dfe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010e00:	681a      	ldr	r2, [r3, #0]
 8010e02:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010e04:	3303      	adds	r3, #3
 8010e06:	4413      	add	r3, r2
 8010e08:	2200      	movs	r2, #0
 8010e0a:	701a      	strb	r2, [r3, #0]
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
 8010e0c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010e0e:	b29b      	uxth	r3, r3
 8010e10:	3303      	adds	r3, #3
 8010e12:	b29a      	uxth	r2, r3
 8010e14:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010e16:	811a      	strh	r2, [r3, #8]
 8010e18:	e00c      	b.n	8010e34 <lv_label_refr_text+0x5b4>
            }
        }
    }
    /*In break mode only the height can change*/
    else if(ext->long_mode == LV_LABEL_LONG_BREAK) {
 8010e1a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010e1c:	7c1b      	ldrb	r3, [r3, #16]
 8010e1e:	f003 0307 	and.w	r3, r3, #7
 8010e22:	b2db      	uxtb	r3, r3
 8010e24:	2b01      	cmp	r3, #1
 8010e26:	d105      	bne.n	8010e34 <lv_label_refr_text+0x5b4>
        lv_obj_set_height(label, size.y);
 8010e28:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8010e2c:	4619      	mov	r1, r3
 8010e2e:	6878      	ldr	r0, [r7, #4]
 8010e30:	f7f0 fb54 	bl	80014dc <lv_obj_set_height>
    /*Do not set the size in Clip mode*/
    else if(ext->long_mode == LV_LABEL_LONG_CROP) {
        /*Do nothing*/
    }

    lv_obj_invalidate(label);
 8010e34:	6878      	ldr	r0, [r7, #4]
 8010e36:	f7f0 f931 	bl	800109c <lv_obj_invalidate>
 8010e3a:	e000      	b.n	8010e3e <lv_label_refr_text+0x5be>
    if(ext->text == NULL) return;
 8010e3c:	bf00      	nop
}
 8010e3e:	376c      	adds	r7, #108	; 0x6c
 8010e40:	46bd      	mov	sp, r7
 8010e42:	bd90      	pop	{r4, r7, pc}
 8010e44:	20000064 	.word	0x20000064
 8010e48:	2000005c 	.word	0x2000005c
 8010e4c:	20000050 	.word	0x20000050
 8010e50:	20000054 	.word	0x20000054

08010e54 <lv_label_revert_dots>:

static void lv_label_revert_dots(lv_obj_t * label)
{
 8010e54:	b580      	push	{r7, lr}
 8010e56:	b088      	sub	sp, #32
 8010e58:	af00      	add	r7, sp, #0
 8010e5a:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8010e5c:	6878      	ldr	r0, [r7, #4]
 8010e5e:	f7f1 fdb1 	bl	80029c4 <lv_obj_get_ext_attr>
 8010e62:	61b8      	str	r0, [r7, #24]
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
 8010e64:	69bb      	ldr	r3, [r7, #24]
 8010e66:	7c1b      	ldrb	r3, [r3, #16]
 8010e68:	f003 0307 	and.w	r3, r3, #7
 8010e6c:	b2db      	uxtb	r3, r3
 8010e6e:	2b02      	cmp	r3, #2
 8010e70:	d142      	bne.n	8010ef8 <lv_label_revert_dots+0xa4>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
 8010e72:	69bb      	ldr	r3, [r7, #24]
 8010e74:	891b      	ldrh	r3, [r3, #8]
 8010e76:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010e7a:	4293      	cmp	r3, r2
 8010e7c:	d03e      	beq.n	8010efc <lv_label_revert_dots+0xa8>
    uint32_t letter_i = ext->dot_end - LV_LABEL_DOT_NUM;
 8010e7e:	69bb      	ldr	r3, [r7, #24]
 8010e80:	891b      	ldrh	r3, [r3, #8]
 8010e82:	3b03      	subs	r3, #3
 8010e84:	617b      	str	r3, [r7, #20]
    uint32_t byte_i   = lv_txt_encoded_get_byte_id(ext->text, letter_i);
 8010e86:	4b1f      	ldr	r3, [pc, #124]	; (8010f04 <lv_label_revert_dots+0xb0>)
 8010e88:	681b      	ldr	r3, [r3, #0]
 8010e8a:	69ba      	ldr	r2, [r7, #24]
 8010e8c:	6812      	ldr	r2, [r2, #0]
 8010e8e:	6979      	ldr	r1, [r7, #20]
 8010e90:	4610      	mov	r0, r2
 8010e92:	4798      	blx	r3
 8010e94:	6138      	str	r0, [r7, #16]

    /*Restore the characters*/
    uint8_t i      = 0;
 8010e96:	2300      	movs	r3, #0
 8010e98:	77fb      	strb	r3, [r7, #31]
    char * dot_tmp = lv_label_get_dot_tmp(label);
 8010e9a:	6878      	ldr	r0, [r7, #4]
 8010e9c:	f000 f89f 	bl	8010fde <lv_label_get_dot_tmp>
 8010ea0:	60f8      	str	r0, [r7, #12]
    while(ext->text[byte_i + i] != '\0') {
 8010ea2:	e00d      	b.n	8010ec0 <lv_label_revert_dots+0x6c>
        ext->text[byte_i + i] = dot_tmp[i];
 8010ea4:	7ffb      	ldrb	r3, [r7, #31]
 8010ea6:	68fa      	ldr	r2, [r7, #12]
 8010ea8:	441a      	add	r2, r3
 8010eaa:	69bb      	ldr	r3, [r7, #24]
 8010eac:	6819      	ldr	r1, [r3, #0]
 8010eae:	7ff8      	ldrb	r0, [r7, #31]
 8010eb0:	693b      	ldr	r3, [r7, #16]
 8010eb2:	4403      	add	r3, r0
 8010eb4:	440b      	add	r3, r1
 8010eb6:	7812      	ldrb	r2, [r2, #0]
 8010eb8:	701a      	strb	r2, [r3, #0]
        i++;
 8010eba:	7ffb      	ldrb	r3, [r7, #31]
 8010ebc:	3301      	adds	r3, #1
 8010ebe:	77fb      	strb	r3, [r7, #31]
    while(ext->text[byte_i + i] != '\0') {
 8010ec0:	69bb      	ldr	r3, [r7, #24]
 8010ec2:	681a      	ldr	r2, [r3, #0]
 8010ec4:	7ff9      	ldrb	r1, [r7, #31]
 8010ec6:	693b      	ldr	r3, [r7, #16]
 8010ec8:	440b      	add	r3, r1
 8010eca:	4413      	add	r3, r2
 8010ecc:	781b      	ldrb	r3, [r3, #0]
 8010ece:	2b00      	cmp	r3, #0
 8010ed0:	d1e8      	bne.n	8010ea4 <lv_label_revert_dots+0x50>
    }
    ext->text[byte_i + i] = dot_tmp[i];
 8010ed2:	7ffb      	ldrb	r3, [r7, #31]
 8010ed4:	68fa      	ldr	r2, [r7, #12]
 8010ed6:	441a      	add	r2, r3
 8010ed8:	69bb      	ldr	r3, [r7, #24]
 8010eda:	6819      	ldr	r1, [r3, #0]
 8010edc:	7ff8      	ldrb	r0, [r7, #31]
 8010ede:	693b      	ldr	r3, [r7, #16]
 8010ee0:	4403      	add	r3, r0
 8010ee2:	440b      	add	r3, r1
 8010ee4:	7812      	ldrb	r2, [r2, #0]
 8010ee6:	701a      	strb	r2, [r3, #0]
    lv_label_dot_tmp_free(label);
 8010ee8:	6878      	ldr	r0, [r7, #4]
 8010eea:	f000 f890 	bl	801100e <lv_label_dot_tmp_free>

    ext->dot_end = LV_LABEL_DOT_END_INV;
 8010eee:	69bb      	ldr	r3, [r7, #24]
 8010ef0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8010ef4:	811a      	strh	r2, [r3, #8]
 8010ef6:	e002      	b.n	8010efe <lv_label_revert_dots+0xaa>
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
 8010ef8:	bf00      	nop
 8010efa:	e000      	b.n	8010efe <lv_label_revert_dots+0xaa>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
 8010efc:	bf00      	nop
}
 8010efe:	3720      	adds	r7, #32
 8010f00:	46bd      	mov	sp, r7
 8010f02:	bd80      	pop	{r7, pc}
 8010f04:	2000005c 	.word	0x2000005c

08010f08 <lv_label_set_offset_x>:

#if LV_USE_ANIMATION
static void lv_label_set_offset_x(lv_obj_t * label, lv_coord_t x)
{
 8010f08:	b580      	push	{r7, lr}
 8010f0a:	b084      	sub	sp, #16
 8010f0c:	af00      	add	r7, sp, #0
 8010f0e:	6078      	str	r0, [r7, #4]
 8010f10:	460b      	mov	r3, r1
 8010f12:	807b      	strh	r3, [r7, #2]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8010f14:	6878      	ldr	r0, [r7, #4]
 8010f16:	f7f1 fd55 	bl	80029c4 <lv_obj_get_ext_attr>
 8010f1a:	60f8      	str	r0, [r7, #12]
    ext->offset.x        = x;
 8010f1c:	68fb      	ldr	r3, [r7, #12]
 8010f1e:	887a      	ldrh	r2, [r7, #2]
 8010f20:	815a      	strh	r2, [r3, #10]
    lv_obj_invalidate(label);
 8010f22:	6878      	ldr	r0, [r7, #4]
 8010f24:	f7f0 f8ba 	bl	800109c <lv_obj_invalidate>
}
 8010f28:	bf00      	nop
 8010f2a:	3710      	adds	r7, #16
 8010f2c:	46bd      	mov	sp, r7
 8010f2e:	bd80      	pop	{r7, pc}

08010f30 <lv_label_set_offset_y>:

static void lv_label_set_offset_y(lv_obj_t * label, lv_coord_t y)
{
 8010f30:	b580      	push	{r7, lr}
 8010f32:	b084      	sub	sp, #16
 8010f34:	af00      	add	r7, sp, #0
 8010f36:	6078      	str	r0, [r7, #4]
 8010f38:	460b      	mov	r3, r1
 8010f3a:	807b      	strh	r3, [r7, #2]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8010f3c:	6878      	ldr	r0, [r7, #4]
 8010f3e:	f7f1 fd41 	bl	80029c4 <lv_obj_get_ext_attr>
 8010f42:	60f8      	str	r0, [r7, #12]
    ext->offset.y        = y;
 8010f44:	68fb      	ldr	r3, [r7, #12]
 8010f46:	887a      	ldrh	r2, [r7, #2]
 8010f48:	819a      	strh	r2, [r3, #12]
    lv_obj_invalidate(label);
 8010f4a:	6878      	ldr	r0, [r7, #4]
 8010f4c:	f7f0 f8a6 	bl	800109c <lv_obj_invalidate>
}
 8010f50:	bf00      	nop
 8010f52:	3710      	adds	r7, #16
 8010f54:	46bd      	mov	sp, r7
 8010f56:	bd80      	pop	{r7, pc}

08010f58 <lv_label_set_dot_tmp>:
 * @param label pointer to label object
 * @param len Number of characters to store.
 * @return true on success.
 */
static bool lv_label_set_dot_tmp(lv_obj_t * label, char * data, uint16_t len)
{
 8010f58:	b580      	push	{r7, lr}
 8010f5a:	b086      	sub	sp, #24
 8010f5c:	af00      	add	r7, sp, #0
 8010f5e:	60f8      	str	r0, [r7, #12]
 8010f60:	60b9      	str	r1, [r7, #8]
 8010f62:	4613      	mov	r3, r2
 8010f64:	80fb      	strh	r3, [r7, #6]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8010f66:	68f8      	ldr	r0, [r7, #12]
 8010f68:	f7f1 fd2c 	bl	80029c4 <lv_obj_get_ext_attr>
 8010f6c:	6178      	str	r0, [r7, #20]
    lv_label_dot_tmp_free(label); /* Deallocate any existing space */
 8010f6e:	68f8      	ldr	r0, [r7, #12]
 8010f70:	f000 f84d 	bl	801100e <lv_label_dot_tmp_free>
    if(len > sizeof(char *)) {
 8010f74:	88fb      	ldrh	r3, [r7, #6]
 8010f76:	2b04      	cmp	r3, #4
 8010f78:	d920      	bls.n	8010fbc <lv_label_set_dot_tmp+0x64>
        /* Memory needs to be allocated. Allocates an additional byte
         * for a NULL-terminator so it can be copied. */
        ext->dot.tmp_ptr = lv_mem_alloc(len + 1);
 8010f7a:	88fb      	ldrh	r3, [r7, #6]
 8010f7c:	3301      	adds	r3, #1
 8010f7e:	4618      	mov	r0, r3
 8010f80:	f7fb fe44 	bl	800cc0c <lv_mem_alloc>
 8010f84:	4602      	mov	r2, r0
 8010f86:	697b      	ldr	r3, [r7, #20]
 8010f88:	605a      	str	r2, [r3, #4]
        if(ext->dot.tmp_ptr == NULL) {
 8010f8a:	697b      	ldr	r3, [r7, #20]
 8010f8c:	685b      	ldr	r3, [r3, #4]
 8010f8e:	2b00      	cmp	r3, #0
 8010f90:	d101      	bne.n	8010f96 <lv_label_set_dot_tmp+0x3e>
            LV_LOG_ERROR("Failed to allocate memory for dot_tmp_ptr");
            return false;
 8010f92:	2300      	movs	r3, #0
 8010f94:	e01f      	b.n	8010fd6 <lv_label_set_dot_tmp+0x7e>
        }
        memcpy(ext->dot.tmp_ptr, data, len);
 8010f96:	697b      	ldr	r3, [r7, #20]
 8010f98:	685b      	ldr	r3, [r3, #4]
 8010f9a:	88fa      	ldrh	r2, [r7, #6]
 8010f9c:	68b9      	ldr	r1, [r7, #8]
 8010f9e:	4618      	mov	r0, r3
 8010fa0:	f002 fbd2 	bl	8013748 <memcpy>
        ext->dot.tmp_ptr[len] = '\0';
 8010fa4:	697b      	ldr	r3, [r7, #20]
 8010fa6:	685a      	ldr	r2, [r3, #4]
 8010fa8:	88fb      	ldrh	r3, [r7, #6]
 8010faa:	4413      	add	r3, r2
 8010fac:	2200      	movs	r2, #0
 8010fae:	701a      	strb	r2, [r3, #0]
        ext->dot_tmp_alloc    = true;
 8010fb0:	697a      	ldr	r2, [r7, #20]
 8010fb2:	7c53      	ldrb	r3, [r2, #17]
 8010fb4:	f043 0302 	orr.w	r3, r3, #2
 8010fb8:	7453      	strb	r3, [r2, #17]
 8010fba:	e00b      	b.n	8010fd4 <lv_label_set_dot_tmp+0x7c>
    } else {
        /* Characters can be directly stored in object */
        ext->dot_tmp_alloc = false;
 8010fbc:	697a      	ldr	r2, [r7, #20]
 8010fbe:	7c53      	ldrb	r3, [r2, #17]
 8010fc0:	f36f 0341 	bfc	r3, #1, #1
 8010fc4:	7453      	strb	r3, [r2, #17]
        memcpy(ext->dot.tmp, data, len);
 8010fc6:	697b      	ldr	r3, [r7, #20]
 8010fc8:	3304      	adds	r3, #4
 8010fca:	88fa      	ldrh	r2, [r7, #6]
 8010fcc:	68b9      	ldr	r1, [r7, #8]
 8010fce:	4618      	mov	r0, r3
 8010fd0:	f002 fbba 	bl	8013748 <memcpy>
    }
    return true;
 8010fd4:	2301      	movs	r3, #1
}
 8010fd6:	4618      	mov	r0, r3
 8010fd8:	3718      	adds	r7, #24
 8010fda:	46bd      	mov	sp, r7
 8010fdc:	bd80      	pop	{r7, pc}

08010fde <lv_label_get_dot_tmp>:
 * Get the stored dot_tmp characters
 * @param label pointer to label object
 * @return char pointer to a stored characters. Is *not* necessarily NULL-terminated.
 */
static char * lv_label_get_dot_tmp(lv_obj_t * label)
{
 8010fde:	b580      	push	{r7, lr}
 8010fe0:	b084      	sub	sp, #16
 8010fe2:	af00      	add	r7, sp, #0
 8010fe4:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8010fe6:	6878      	ldr	r0, [r7, #4]
 8010fe8:	f7f1 fcec 	bl	80029c4 <lv_obj_get_ext_attr>
 8010fec:	60f8      	str	r0, [r7, #12]
    if(ext->dot_tmp_alloc) {
 8010fee:	68fb      	ldr	r3, [r7, #12]
 8010ff0:	7c5b      	ldrb	r3, [r3, #17]
 8010ff2:	f003 0302 	and.w	r3, r3, #2
 8010ff6:	b2db      	uxtb	r3, r3
 8010ff8:	2b00      	cmp	r3, #0
 8010ffa:	d002      	beq.n	8011002 <lv_label_get_dot_tmp+0x24>
        return ext->dot.tmp_ptr;
 8010ffc:	68fb      	ldr	r3, [r7, #12]
 8010ffe:	685b      	ldr	r3, [r3, #4]
 8011000:	e001      	b.n	8011006 <lv_label_get_dot_tmp+0x28>
    } else {
        return ext->dot.tmp;
 8011002:	68fb      	ldr	r3, [r7, #12]
 8011004:	3304      	adds	r3, #4
    }
}
 8011006:	4618      	mov	r0, r3
 8011008:	3710      	adds	r7, #16
 801100a:	46bd      	mov	sp, r7
 801100c:	bd80      	pop	{r7, pc}

0801100e <lv_label_dot_tmp_free>:
 * Free the dot_tmp_ptr field if it was previously allocated.
 * Always clears the field
 * @param label pointer to label object.
 */
static void lv_label_dot_tmp_free(lv_obj_t * label)
{
 801100e:	b580      	push	{r7, lr}
 8011010:	b084      	sub	sp, #16
 8011012:	af00      	add	r7, sp, #0
 8011014:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8011016:	6878      	ldr	r0, [r7, #4]
 8011018:	f7f1 fcd4 	bl	80029c4 <lv_obj_get_ext_attr>
 801101c:	60f8      	str	r0, [r7, #12]
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
 801101e:	68fb      	ldr	r3, [r7, #12]
 8011020:	7c5b      	ldrb	r3, [r3, #17]
 8011022:	f003 0302 	and.w	r3, r3, #2
 8011026:	b2db      	uxtb	r3, r3
 8011028:	2b00      	cmp	r3, #0
 801102a:	d008      	beq.n	801103e <lv_label_dot_tmp_free+0x30>
 801102c:	68fb      	ldr	r3, [r7, #12]
 801102e:	685b      	ldr	r3, [r3, #4]
 8011030:	2b00      	cmp	r3, #0
 8011032:	d004      	beq.n	801103e <lv_label_dot_tmp_free+0x30>
        lv_mem_free(ext->dot.tmp_ptr);
 8011034:	68fb      	ldr	r3, [r7, #12]
 8011036:	685b      	ldr	r3, [r3, #4]
 8011038:	4618      	mov	r0, r3
 801103a:	f7fb fe19 	bl	800cc70 <lv_mem_free>
    }
    ext->dot_tmp_alloc = false;
 801103e:	68fa      	ldr	r2, [r7, #12]
 8011040:	7c53      	ldrb	r3, [r2, #17]
 8011042:	f36f 0341 	bfc	r3, #1, #1
 8011046:	7453      	strb	r3, [r2, #17]
    ext->dot.tmp_ptr   = NULL;
 8011048:	68fb      	ldr	r3, [r7, #12]
 801104a:	2200      	movs	r2, #0
 801104c:	605a      	str	r2, [r3, #4]
}
 801104e:	bf00      	nop
 8011050:	3710      	adds	r7, #16
 8011052:	46bd      	mov	sp, r7
 8011054:	bd80      	pop	{r7, pc}
	...

08011058 <lv_theme_get_current>:
/**
 * Get the current system theme.
 * @return pointer to the current system theme. NULL if not set.
 */
lv_theme_t * lv_theme_get_current(void)
{
 8011058:	b480      	push	{r7}
 801105a:	af00      	add	r7, sp, #0
#if LV_THEME_LIVE_UPDATE == 0
    return current_theme;
 801105c:	4b03      	ldr	r3, [pc, #12]	; (801106c <lv_theme_get_current+0x14>)
 801105e:	681b      	ldr	r3, [r3, #0]
    if(!inited)
        return NULL;
    else
        return &current_theme;
#endif
}
 8011060:	4618      	mov	r0, r3
 8011062:	46bd      	mov	sp, r7
 8011064:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011068:	4770      	bx	lr
 801106a:	bf00      	nop
 801106c:	200082e0 	.word	0x200082e0

08011070 <lv_color_to32>:
    return ret.full;
#endif                         
}

static inline uint32_t lv_color_to32(lv_color_t color)
{
 8011070:	b480      	push	{r7}
 8011072:	b085      	sub	sp, #20
 8011074:	af00      	add	r7, sp, #0
 8011076:	80b8      	strh	r0, [r7, #4]
     *       4          64     48        3       255
     *       5         129     33        1       255
     *       6         259      3        0       255
     */
    lv_color32_t ret;
    LV_COLOR_SET_R32(ret, (LV_COLOR_GET_R(color) * 263 + 7 ) >> 5);
 8011078:	797b      	ldrb	r3, [r7, #5]
 801107a:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801107e:	b2db      	uxtb	r3, r3
 8011080:	461a      	mov	r2, r3
 8011082:	4613      	mov	r3, r2
 8011084:	015b      	lsls	r3, r3, #5
 8011086:	4413      	add	r3, r2
 8011088:	00db      	lsls	r3, r3, #3
 801108a:	1a9b      	subs	r3, r3, r2
 801108c:	3307      	adds	r3, #7
 801108e:	115b      	asrs	r3, r3, #5
 8011090:	b2db      	uxtb	r3, r3
 8011092:	73bb      	strb	r3, [r7, #14]
    LV_COLOR_SET_G32(ret, (LV_COLOR_GET_G(color) * 259 + 3 ) >> 6);
 8011094:	88bb      	ldrh	r3, [r7, #4]
 8011096:	f3c3 1345 	ubfx	r3, r3, #5, #6
 801109a:	b2db      	uxtb	r3, r3
 801109c:	461a      	mov	r2, r3
 801109e:	4613      	mov	r3, r2
 80110a0:	01db      	lsls	r3, r3, #7
 80110a2:	4413      	add	r3, r2
 80110a4:	005b      	lsls	r3, r3, #1
 80110a6:	4413      	add	r3, r2
 80110a8:	3303      	adds	r3, #3
 80110aa:	119b      	asrs	r3, r3, #6
 80110ac:	b2db      	uxtb	r3, r3
 80110ae:	737b      	strb	r3, [r7, #13]
    LV_COLOR_SET_B32(ret, (LV_COLOR_GET_B(color) * 263 + 7 ) >> 5);
 80110b0:	793b      	ldrb	r3, [r7, #4]
 80110b2:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80110b6:	b2db      	uxtb	r3, r3
 80110b8:	461a      	mov	r2, r3
 80110ba:	4613      	mov	r3, r2
 80110bc:	015b      	lsls	r3, r3, #5
 80110be:	4413      	add	r3, r2
 80110c0:	00db      	lsls	r3, r3, #3
 80110c2:	1a9b      	subs	r3, r3, r2
 80110c4:	3307      	adds	r3, #7
 80110c6:	115b      	asrs	r3, r3, #5
 80110c8:	b2db      	uxtb	r3, r3
 80110ca:	733b      	strb	r3, [r7, #12]
    LV_COLOR_SET_A32(ret, 0xFF);
 80110cc:	23ff      	movs	r3, #255	; 0xff
 80110ce:	73fb      	strb	r3, [r7, #15]
    return ret.full;
 80110d0:	68fb      	ldr	r3, [r7, #12]
#elif LV_COLOR_DEPTH == 32
    return color.full;
#endif
}
 80110d2:	4618      	mov	r0, r3
 80110d4:	3714      	adds	r7, #20
 80110d6:	46bd      	mov	sp, r7
 80110d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80110dc:	4770      	bx	lr

080110de <LCD_Init>:
#define ABS(X)  ((X) > 0 ? (X) : -(X))

static __IO u32 TextColor = 0x000000, BackColor = 0xFFFFFF;

void LCD_Init(void)
{
 80110de:	b580      	push	{r7, lr}
 80110e0:	af00      	add	r7, sp, #0
	LCD_ILI9341_Reset();
 80110e2:	f000 f804 	bl	80110ee <LCD_ILI9341_Reset>
	LCD_ILI9341_Init();
 80110e6:	f000 f824 	bl	8011132 <LCD_ILI9341_Init>
}
 80110ea:	bf00      	nop
 80110ec:	bd80      	pop	{r7, pc}

080110ee <LCD_ILI9341_Reset>:

void LCD_ILI9341_Reset(void)
{
 80110ee:	b580      	push	{r7, lr}
 80110f0:	af00      	add	r7, sp, #0
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
 80110f2:	2201      	movs	r2, #1
 80110f4:	f44f 7180 	mov.w	r1, #256	; 0x100
 80110f8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80110fc:	f001 f97c 	bl	80123f8 <HAL_GPIO_WritePin>
	HAL_Delay(1);
 8011100:	2001      	movs	r0, #1
 8011102:	f000 fe0d 	bl	8011d20 <HAL_Delay>

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);
 8011106:	2200      	movs	r2, #0
 8011108:	f44f 7180 	mov.w	r1, #256	; 0x100
 801110c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8011110:	f001 f972 	bl	80123f8 <HAL_GPIO_WritePin>
	HAL_Delay(10);
 8011114:	200a      	movs	r0, #10
 8011116:	f000 fe03 	bl	8011d20 <HAL_Delay>

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
 801111a:	2201      	movs	r2, #1
 801111c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8011120:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8011124:	f001 f968 	bl	80123f8 <HAL_GPIO_WritePin>
	HAL_Delay(50);
 8011128:	2032      	movs	r0, #50	; 0x32
 801112a:	f000 fdf9 	bl	8011d20 <HAL_Delay>
}
 801112e:	bf00      	nop
 8011130:	bd80      	pop	{r7, pc}

08011132 <LCD_ILI9341_Init>:

void LCD_ILI9341_Init(void)
{
 8011132:	b580      	push	{r7, lr}
 8011134:	af00      	add	r7, sp, #0
	LCD_ILI9341_CMD(0xEF);  //
 8011136:	20ef      	movs	r0, #239	; 0xef
 8011138:	f000 f91a 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x03);
 801113c:	2003      	movs	r0, #3
 801113e:	f000 f945 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x80);
 8011142:	2080      	movs	r0, #128	; 0x80
 8011144:	f000 f942 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x02);
 8011148:	2002      	movs	r0, #2
 801114a:	f000 f93f 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xCF);
 801114e:	20cf      	movs	r0, #207	; 0xcf
 8011150:	f000 f90e 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x00);
 8011154:	2000      	movs	r0, #0
 8011156:	f000 f939 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0xAA);
 801115a:	20aa      	movs	r0, #170	; 0xaa
 801115c:	f000 f936 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0xB0);
 8011160:	20b0      	movs	r0, #176	; 0xb0
 8011162:	f000 f933 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xED);
 8011166:	20ed      	movs	r0, #237	; 0xed
 8011168:	f000 f902 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x67);
 801116c:	2067      	movs	r0, #103	; 0x67
 801116e:	f000 f92d 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x03);
 8011172:	2003      	movs	r0, #3
 8011174:	f000 f92a 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x12);
 8011178:	2012      	movs	r0, #18
 801117a:	f000 f927 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x81);
 801117e:	2081      	movs	r0, #129	; 0x81
 8011180:	f000 f924 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xE8);  //
 8011184:	20e8      	movs	r0, #232	; 0xe8
 8011186:	f000 f8f3 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x85);
 801118a:	2085      	movs	r0, #133	; 0x85
 801118c:	f000 f91e 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x11);
 8011190:	2011      	movs	r0, #17
 8011192:	f000 f91b 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x78);
 8011196:	2078      	movs	r0, #120	; 0x78
 8011198:	f000 f918 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xF6);  //interface control
 801119c:	20f6      	movs	r0, #246	; 0xf6
 801119e:	f000 f8e7 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x01);
 80111a2:	2001      	movs	r0, #1
 80111a4:	f000 f912 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x30);
 80111a8:	2030      	movs	r0, #48	; 0x30
 80111aa:	f000 f90f 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x00);
 80111ae:	2000      	movs	r0, #0
 80111b0:	f000 f90c 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xCB);  //
 80111b4:	20cb      	movs	r0, #203	; 0xcb
 80111b6:	f000 f8db 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x39);
 80111ba:	2039      	movs	r0, #57	; 0x39
 80111bc:	f000 f906 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x2C);
 80111c0:	202c      	movs	r0, #44	; 0x2c
 80111c2:	f000 f903 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x00);
 80111c6:	2000      	movs	r0, #0
 80111c8:	f000 f900 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x34);
 80111cc:	2034      	movs	r0, #52	; 0x34
 80111ce:	f000 f8fd 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x02);
 80111d2:	2002      	movs	r0, #2
 80111d4:	f000 f8fa 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xF7);
 80111d8:	20f7      	movs	r0, #247	; 0xf7
 80111da:	f000 f8c9 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x20);
 80111de:	2020      	movs	r0, #32
 80111e0:	f000 f8f4 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xEA);  //
 80111e4:	20ea      	movs	r0, #234	; 0xea
 80111e6:	f000 f8c3 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x00);
 80111ea:	2000      	movs	r0, #0
 80111ec:	f000 f8ee 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x00);
 80111f0:	2000      	movs	r0, #0
 80111f2:	f000 f8eb 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xB6);  // display function control
 80111f6:	20b6      	movs	r0, #182	; 0xb6
 80111f8:	f000 f8ba 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x0A);
 80111fc:	200a      	movs	r0, #10
 80111fe:	f000 f8e5 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x82);
 8011202:	2082      	movs	r0, #130	; 0x82
 8011204:	f000 f8e2 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x27);
 8011208:	2027      	movs	r0, #39	; 0x27
 801120a:	f000 f8df 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xC0);  //Power control
 801120e:	20c0      	movs	r0, #192	; 0xc0
 8011210:	f000 f8ae 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x21);     //VRH[5:0] 0x05
 8011214:	2021      	movs	r0, #33	; 0x21
 8011216:	f000 f8d9 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xC1);  //Power control
 801121a:	20c1      	movs	r0, #193	; 0xc1
 801121c:	f000 f8a8 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x11);     //SAP[2:0];BT[3:0]
 8011220:	2011      	movs	r0, #17
 8011222:	f000 f8d3 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xc5);  //Vcom control 1
 8011226:	20c5      	movs	r0, #197	; 0xc5
 8011228:	f000 f8a2 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x24);  // 0x24
 801122c:	2024      	movs	r0, #36	; 0x24
 801122e:	f000 f8cd 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x3c);  // 0x3C
 8011232:	203c      	movs	r0, #60	; 0x3c
 8011234:	f000 f8ca 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xc7); // Vcom control 2
 8011238:	20c7      	movs	r0, #199	; 0xc7
 801123a:	f000 f899 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0xc8);    //0xc8
 801123e:	20c8      	movs	r0, #200	; 0xc8
 8011240:	f000 f8c4 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0x36);  // Memory Access Control
 8011244:	2036      	movs	r0, #54	; 0x36
 8011246:	f000 f893 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x48);
 801124a:	2048      	movs	r0, #72	; 0x48
 801124c:	f000 f8be 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0x3A);
 8011250:	203a      	movs	r0, #58	; 0x3a
 8011252:	f000 f88d 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x55);
 8011256:	2055      	movs	r0, #85	; 0x55
 8011258:	f000 f8b8 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xB1); // frame rate control
 801125c:	20b1      	movs	r0, #177	; 0xb1
 801125e:	f000 f887 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x00);
 8011262:	2000      	movs	r0, #0
 8011264:	f000 f8b2 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x13);  //
 8011268:	2013      	movs	r0, #19
 801126a:	f000 f8af 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xB4); // display inversion control
 801126e:	20b4      	movs	r0, #180	; 0xb4
 8011270:	f000 f87e 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x02);
 8011274:	2002      	movs	r0, #2
 8011276:	f000 f8a9 	bl	80113cc <LCD_ILI9341_DATA>
	//LCD_ILI9341_DATA(0x00);

	LCD_ILI9341_CMD(0xF2);   // 3Gamma Function Disable
 801127a:	20f2      	movs	r0, #242	; 0xf2
 801127c:	f000 f878 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x00);
 8011280:	2000      	movs	r0, #0
 8011282:	f000 f8a3 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0x26);  //Gamma curve selected
 8011286:	2026      	movs	r0, #38	; 0x26
 8011288:	f000 f872 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x01);
 801128c:	2001      	movs	r0, #1
 801128e:	f000 f89d 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xE0);  //Gamma setting
 8011292:	20e0      	movs	r0, #224	; 0xe0
 8011294:	f000 f86c 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x0F);
 8011298:	200f      	movs	r0, #15
 801129a:	f000 f897 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x1B);
 801129e:	201b      	movs	r0, #27
 80112a0:	f000 f894 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x19);
 80112a4:	2019      	movs	r0, #25
 80112a6:	f000 f891 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x0C);
 80112aa:	200c      	movs	r0, #12
 80112ac:	f000 f88e 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x0D);
 80112b0:	200d      	movs	r0, #13
 80112b2:	f000 f88b 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x07);
 80112b6:	2007      	movs	r0, #7
 80112b8:	f000 f888 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x44);
 80112bc:	2044      	movs	r0, #68	; 0x44
 80112be:	f000 f885 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0xA9);
 80112c2:	20a9      	movs	r0, #169	; 0xa9
 80112c4:	f000 f882 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x2F);
 80112c8:	202f      	movs	r0, #47	; 0x2f
 80112ca:	f000 f87f 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x08);
 80112ce:	2008      	movs	r0, #8
 80112d0:	f000 f87c 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x0D);
 80112d4:	200d      	movs	r0, #13
 80112d6:	f000 f879 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x03);
 80112da:	2003      	movs	r0, #3
 80112dc:	f000 f876 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x10);
 80112e0:	2010      	movs	r0, #16
 80112e2:	f000 f873 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x0B);
 80112e6:	200b      	movs	r0, #11
 80112e8:	f000 f870 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x00);
 80112ec:	2000      	movs	r0, #0
 80112ee:	f000 f86d 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0xE1);   //Gamma setting
 80112f2:	20e1      	movs	r0, #225	; 0xe1
 80112f4:	f000 f83c 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA(0x00);
 80112f8:	2000      	movs	r0, #0
 80112fa:	f000 f867 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x24);
 80112fe:	2024      	movs	r0, #36	; 0x24
 8011300:	f000 f864 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x26);
 8011304:	2026      	movs	r0, #38	; 0x26
 8011306:	f000 f861 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x03);
 801130a:	2003      	movs	r0, #3
 801130c:	f000 f85e 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x12);
 8011310:	2012      	movs	r0, #18
 8011312:	f000 f85b 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x08);
 8011316:	2008      	movs	r0, #8
 8011318:	f000 f858 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x3C);
 801131c:	203c      	movs	r0, #60	; 0x3c
 801131e:	f000 f855 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x56);
 8011322:	2056      	movs	r0, #86	; 0x56
 8011324:	f000 f852 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x50);
 8011328:	2050      	movs	r0, #80	; 0x50
 801132a:	f000 f84f 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x07);
 801132e:	2007      	movs	r0, #7
 8011330:	f000 f84c 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x12);
 8011334:	2012      	movs	r0, #18
 8011336:	f000 f849 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x0C);
 801133a:	200c      	movs	r0, #12
 801133c:	f000 f846 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x2F);
 8011340:	202f      	movs	r0, #47	; 0x2f
 8011342:	f000 f843 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x34);
 8011346:	2034      	movs	r0, #52	; 0x34
 8011348:	f000 f840 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA(0x0F);
 801134c:	200f      	movs	r0, #15
 801134e:	f000 f83d 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0x11); //Exit Sleep
 8011352:	2011      	movs	r0, #17
 8011354:	f000 f80c 	bl	8011370 <LCD_ILI9341_CMD>
	HAL_Delay(120);
 8011358:	2078      	movs	r0, #120	; 0x78
 801135a:	f000 fce1 	bl	8011d20 <HAL_Delay>
	LCD_ILI9341_CMD(0x29); //Display on
 801135e:	2029      	movs	r0, #41	; 0x29
 8011360:	f000 f806 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_CMD(0x2C); //write data to RAM
 8011364:	202c      	movs	r0, #44	; 0x2c
 8011366:	f000 f803 	bl	8011370 <LCD_ILI9341_CMD>
}
 801136a:	bf00      	nop
 801136c:	bd80      	pop	{r7, pc}
	...

08011370 <LCD_ILI9341_CMD>:
	TextColor = _TextColor;
	BackColor = _BackColor;
}

void LCD_ILI9341_CMD( uint8_t cmd )
{
 8011370:	b580      	push	{r7, lr}
 8011372:	b082      	sub	sp, #8
 8011374:	af00      	add	r7, sp, #0
 8011376:	4603      	mov	r3, r0
 8011378:	71fb      	strb	r3, [r7, #7]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, GPIO_PIN_RESET); // Confirmed in datasheet (low = cmd)
 801137a:	2200      	movs	r2, #0
 801137c:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8011380:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8011384:	f001 f838 	bl	80123f8 <HAL_GPIO_WritePin>

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET); // Chip Select
 8011388:	2200      	movs	r2, #0
 801138a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 801138e:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8011392:	f001 f831 	bl	80123f8 <HAL_GPIO_WritePin>

	HAL_SPI_Transmit(&hspi2, &cmd, 1, 10);
 8011396:	1df9      	adds	r1, r7, #7
 8011398:	230a      	movs	r3, #10
 801139a:	2201      	movs	r2, #1
 801139c:	480a      	ldr	r0, [pc, #40]	; (80113c8 <LCD_ILI9341_CMD+0x58>)
 801139e:	f001 ff1d 	bl	80131dc <HAL_SPI_Transmit>
	while(HAL_SPI_GetState(&hspi2) != HAL_SPI_STATE_READY);
 80113a2:	bf00      	nop
 80113a4:	4808      	ldr	r0, [pc, #32]	; (80113c8 <LCD_ILI9341_CMD+0x58>)
 80113a6:	f002 f87f 	bl	80134a8 <HAL_SPI_GetState>
 80113aa:	4603      	mov	r3, r0
 80113ac:	2b01      	cmp	r3, #1
 80113ae:	d1f9      	bne.n	80113a4 <LCD_ILI9341_CMD+0x34>

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET); // Chip Select
 80113b0:	2201      	movs	r2, #1
 80113b2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80113b6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80113ba:	f001 f81d 	bl	80123f8 <HAL_GPIO_WritePin>
}
 80113be:	bf00      	nop
 80113c0:	3708      	adds	r7, #8
 80113c2:	46bd      	mov	sp, r7
 80113c4:	bd80      	pop	{r7, pc}
 80113c6:	bf00      	nop
 80113c8:	200099ac 	.word	0x200099ac

080113cc <LCD_ILI9341_DATA>:

void LCD_ILI9341_DATA( uint8_t data )
{
 80113cc:	b580      	push	{r7, lr}
 80113ce:	b082      	sub	sp, #8
 80113d0:	af00      	add	r7, sp, #0
 80113d2:	4603      	mov	r3, r0
 80113d4:	71fb      	strb	r3, [r7, #7]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, GPIO_PIN_SET); // Confirmed in datasheet (high = data)
 80113d6:	2201      	movs	r2, #1
 80113d8:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80113dc:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80113e0:	f001 f80a 	bl	80123f8 <HAL_GPIO_WritePin>

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET); // Chip Select
 80113e4:	2200      	movs	r2, #0
 80113e6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80113ea:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80113ee:	f001 f803 	bl	80123f8 <HAL_GPIO_WritePin>

	HAL_SPI_Transmit(&hspi2, &data, 1, 10);
 80113f2:	1df9      	adds	r1, r7, #7
 80113f4:	230a      	movs	r3, #10
 80113f6:	2201      	movs	r2, #1
 80113f8:	480a      	ldr	r0, [pc, #40]	; (8011424 <LCD_ILI9341_DATA+0x58>)
 80113fa:	f001 feef 	bl	80131dc <HAL_SPI_Transmit>
	while(HAL_SPI_GetState(&hspi2) != HAL_SPI_STATE_READY);
 80113fe:	bf00      	nop
 8011400:	4808      	ldr	r0, [pc, #32]	; (8011424 <LCD_ILI9341_DATA+0x58>)
 8011402:	f002 f851 	bl	80134a8 <HAL_SPI_GetState>
 8011406:	4603      	mov	r3, r0
 8011408:	2b01      	cmp	r3, #1
 801140a:	d1f9      	bne.n	8011400 <LCD_ILI9341_DATA+0x34>

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET); // Chip Select
 801140c:	2201      	movs	r2, #1
 801140e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8011412:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8011416:	f000 ffef 	bl	80123f8 <HAL_GPIO_WritePin>
}
 801141a:	bf00      	nop
 801141c:	3708      	adds	r7, #8
 801141e:	46bd      	mov	sp, r7
 8011420:	bd80      	pop	{r7, pc}
 8011422:	bf00      	nop
 8011424:	200099ac 	.word	0x200099ac

08011428 <LCD_OpenWindow>:

void LCD_OpenWindow(u16 x, u16 y, u16 width, u16 height)
{
 8011428:	b590      	push	{r4, r7, lr}
 801142a:	b083      	sub	sp, #12
 801142c:	af00      	add	r7, sp, #0
 801142e:	4604      	mov	r4, r0
 8011430:	4608      	mov	r0, r1
 8011432:	4611      	mov	r1, r2
 8011434:	461a      	mov	r2, r3
 8011436:	4623      	mov	r3, r4
 8011438:	80fb      	strh	r3, [r7, #6]
 801143a:	4603      	mov	r3, r0
 801143c:	80bb      	strh	r3, [r7, #4]
 801143e:	460b      	mov	r3, r1
 8011440:	807b      	strh	r3, [r7, #2]
 8011442:	4613      	mov	r3, r2
 8011444:	803b      	strh	r3, [r7, #0]
	LCD_ILI9341_CMD(0x2A); 				/* ÉèÖÃX×ø±ê */
 8011446:	202a      	movs	r0, #42	; 0x2a
 8011448:	f7ff ff92 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA( x >> 8 );	 			/* ÏÈ¸ß8Î»£¬È»ºóµÍ8Î» */
 801144c:	88fb      	ldrh	r3, [r7, #6]
 801144e:	0a1b      	lsrs	r3, r3, #8
 8011450:	b29b      	uxth	r3, r3
 8011452:	b2db      	uxtb	r3, r3
 8011454:	4618      	mov	r0, r3
 8011456:	f7ff ffb9 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA( x & 0x00FF );	 		/* ÉèÖÃÆðÊ¼µãºÍ½áÊøµã*/
 801145a:	88fb      	ldrh	r3, [r7, #6]
 801145c:	b2db      	uxtb	r3, r3
 801145e:	4618      	mov	r0, r3
 8011460:	f7ff ffb4 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA( (x+width-1) >> 8 );
 8011464:	88fa      	ldrh	r2, [r7, #6]
 8011466:	887b      	ldrh	r3, [r7, #2]
 8011468:	4413      	add	r3, r2
 801146a:	3b01      	subs	r3, #1
 801146c:	121b      	asrs	r3, r3, #8
 801146e:	b2db      	uxtb	r3, r3
 8011470:	4618      	mov	r0, r3
 8011472:	f7ff ffab 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA( (x+width-1) & 0x00FF );
 8011476:	88fb      	ldrh	r3, [r7, #6]
 8011478:	b2da      	uxtb	r2, r3
 801147a:	887b      	ldrh	r3, [r7, #2]
 801147c:	b2db      	uxtb	r3, r3
 801147e:	4413      	add	r3, r2
 8011480:	b2db      	uxtb	r3, r3
 8011482:	3b01      	subs	r3, #1
 8011484:	b2db      	uxtb	r3, r3
 8011486:	4618      	mov	r0, r3
 8011488:	f7ff ffa0 	bl	80113cc <LCD_ILI9341_DATA>

	LCD_ILI9341_CMD(0x2B); 			 	/* ÉèÖÃY×ø±ê*/
 801148c:	202b      	movs	r0, #43	; 0x2b
 801148e:	f7ff ff6f 	bl	8011370 <LCD_ILI9341_CMD>
	LCD_ILI9341_DATA( y >> 8 );
 8011492:	88bb      	ldrh	r3, [r7, #4]
 8011494:	0a1b      	lsrs	r3, r3, #8
 8011496:	b29b      	uxth	r3, r3
 8011498:	b2db      	uxtb	r3, r3
 801149a:	4618      	mov	r0, r3
 801149c:	f7ff ff96 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA( y & 0x00FF );
 80114a0:	88bb      	ldrh	r3, [r7, #4]
 80114a2:	b2db      	uxtb	r3, r3
 80114a4:	4618      	mov	r0, r3
 80114a6:	f7ff ff91 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA( (y+height-1) >> 8);
 80114aa:	88ba      	ldrh	r2, [r7, #4]
 80114ac:	883b      	ldrh	r3, [r7, #0]
 80114ae:	4413      	add	r3, r2
 80114b0:	3b01      	subs	r3, #1
 80114b2:	121b      	asrs	r3, r3, #8
 80114b4:	b2db      	uxtb	r3, r3
 80114b6:	4618      	mov	r0, r3
 80114b8:	f7ff ff88 	bl	80113cc <LCD_ILI9341_DATA>
	LCD_ILI9341_DATA( (y+height-1) & 0x00FF);
 80114bc:	88bb      	ldrh	r3, [r7, #4]
 80114be:	b2da      	uxtb	r2, r3
 80114c0:	883b      	ldrh	r3, [r7, #0]
 80114c2:	b2db      	uxtb	r3, r3
 80114c4:	4413      	add	r3, r2
 80114c6:	b2db      	uxtb	r3, r3
 80114c8:	3b01      	subs	r3, #1
 80114ca:	b2db      	uxtb	r3, r3
 80114cc:	4618      	mov	r0, r3
 80114ce:	f7ff ff7d 	bl	80113cc <LCD_ILI9341_DATA>
}
 80114d2:	bf00      	nop
 80114d4:	370c      	adds	r7, #12
 80114d6:	46bd      	mov	sp, r7
 80114d8:	bd90      	pop	{r4, r7, pc}
	...

080114dc <my_disp_flush>:
}

// ------------------------------ LGVL PORT

void my_disp_flush(lv_disp_t * disp, const lv_area_t * area, lv_color_t * color_p)
{
 80114dc:	b580      	push	{r7, lr}
 80114de:	b08a      	sub	sp, #40	; 0x28
 80114e0:	af00      	add	r7, sp, #0
 80114e2:	60f8      	str	r0, [r7, #12]
 80114e4:	60b9      	str	r1, [r7, #8]
 80114e6:	607a      	str	r2, [r7, #4]
	u16 x = area->x1;
 80114e8:	68bb      	ldr	r3, [r7, #8]
 80114ea:	f9b3 3000 	ldrsh.w	r3, [r3]
 80114ee:	837b      	strh	r3, [r7, #26]
	u16 y = area->y1;
 80114f0:	68bb      	ldr	r3, [r7, #8]
 80114f2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80114f6:	833b      	strh	r3, [r7, #24]
	u16 height = (area->y2-area->y1)+1;
 80114f8:	68bb      	ldr	r3, [r7, #8]
 80114fa:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80114fe:	b29a      	uxth	r2, r3
 8011500:	68bb      	ldr	r3, [r7, #8]
 8011502:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8011506:	b29b      	uxth	r3, r3
 8011508:	1ad3      	subs	r3, r2, r3
 801150a:	b29b      	uxth	r3, r3
 801150c:	3301      	adds	r3, #1
 801150e:	82fb      	strh	r3, [r7, #22]
	u16 width =  (area->x2-area->x1)+1;
 8011510:	68bb      	ldr	r3, [r7, #8]
 8011512:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8011516:	b29a      	uxth	r2, r3
 8011518:	68bb      	ldr	r3, [r7, #8]
 801151a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801151e:	b29b      	uxth	r3, r3
 8011520:	1ad3      	subs	r3, r2, r3
 8011522:	b29b      	uxth	r3, r3
 8011524:	3301      	adds	r3, #1
 8011526:	82bb      	strh	r3, [r7, #20]

	u16 color;
	LCD_OpenWindow(x, y,width, height);
 8011528:	8afb      	ldrh	r3, [r7, #22]
 801152a:	8aba      	ldrh	r2, [r7, #20]
 801152c:	8b39      	ldrh	r1, [r7, #24]
 801152e:	8b78      	ldrh	r0, [r7, #26]
 8011530:	f7ff ff7a 	bl	8011428 <LCD_OpenWindow>

	LCD_ILI9341_CMD(0x2C);
 8011534:	202c      	movs	r0, #44	; 0x2c
 8011536:	f7ff ff1b 	bl	8011370 <LCD_ILI9341_CMD>
	int y_count = 0;
 801153a:	2300      	movs	r3, #0
 801153c:	627b      	str	r3, [r7, #36]	; 0x24
	int k = 0;
 801153e:	2300      	movs	r3, #0
 8011540:	623b      	str	r3, [r7, #32]
	for (int i=0; i<width*height; i++)
 8011542:	2300      	movs	r3, #0
 8011544:	61fb      	str	r3, [r7, #28]
 8011546:	e030      	b.n	80115aa <my_disp_flush+0xce>
	{
		if (i%240 == 0)
 8011548:	69fa      	ldr	r2, [r7, #28]
 801154a:	4b1f      	ldr	r3, [pc, #124]	; (80115c8 <my_disp_flush+0xec>)
 801154c:	fb83 1302 	smull	r1, r3, r3, r2
 8011550:	4413      	add	r3, r2
 8011552:	11d9      	asrs	r1, r3, #7
 8011554:	17d3      	asrs	r3, r2, #31
 8011556:	1ac9      	subs	r1, r1, r3
 8011558:	460b      	mov	r3, r1
 801155a:	011b      	lsls	r3, r3, #4
 801155c:	1a5b      	subs	r3, r3, r1
 801155e:	011b      	lsls	r3, r3, #4
 8011560:	1ad1      	subs	r1, r2, r3
 8011562:	2900      	cmp	r1, #0
 8011564:	d102      	bne.n	801156c <my_disp_flush+0x90>
		{
			y_count = y_count + 1;
 8011566:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011568:	3301      	adds	r3, #1
 801156a:	627b      	str	r3, [r7, #36]	; 0x24
		}

		if (y > 300)
 801156c:	8b3b      	ldrh	r3, [r7, #24]
 801156e:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8011572:	d902      	bls.n	801157a <my_disp_flush+0x9e>
		{
			k++;
 8011574:	6a3b      	ldr	r3, [r7, #32]
 8011576:	3301      	adds	r3, #1
 8011578:	623b      	str	r3, [r7, #32]
		}

		color = (u16) lv_color_to32(*color_p);
 801157a:	687b      	ldr	r3, [r7, #4]
 801157c:	8818      	ldrh	r0, [r3, #0]
 801157e:	f7ff fd77 	bl	8011070 <lv_color_to32>
 8011582:	4603      	mov	r3, r0
 8011584:	827b      	strh	r3, [r7, #18]

		LCD_ILI9341_DATA( color >> 8 );
 8011586:	8a7b      	ldrh	r3, [r7, #18]
 8011588:	0a1b      	lsrs	r3, r3, #8
 801158a:	b29b      	uxth	r3, r3
 801158c:	b2db      	uxtb	r3, r3
 801158e:	4618      	mov	r0, r3
 8011590:	f7ff ff1c 	bl	80113cc <LCD_ILI9341_DATA>
		LCD_ILI9341_DATA( color &0xFF);
 8011594:	8a7b      	ldrh	r3, [r7, #18]
 8011596:	b2db      	uxtb	r3, r3
 8011598:	4618      	mov	r0, r3
 801159a:	f7ff ff17 	bl	80113cc <LCD_ILI9341_DATA>

		color_p++;
 801159e:	687b      	ldr	r3, [r7, #4]
 80115a0:	3302      	adds	r3, #2
 80115a2:	607b      	str	r3, [r7, #4]
	for (int i=0; i<width*height; i++)
 80115a4:	69fb      	ldr	r3, [r7, #28]
 80115a6:	3301      	adds	r3, #1
 80115a8:	61fb      	str	r3, [r7, #28]
 80115aa:	8abb      	ldrh	r3, [r7, #20]
 80115ac:	8afa      	ldrh	r2, [r7, #22]
 80115ae:	fb02 f303 	mul.w	r3, r2, r3
 80115b2:	69fa      	ldr	r2, [r7, #28]
 80115b4:	429a      	cmp	r2, r3
 80115b6:	dbc7      	blt.n	8011548 <my_disp_flush+0x6c>
	}

    lv_disp_flush_ready(disp);         /* Indicate you are ready with the flushing*/
 80115b8:	68f8      	ldr	r0, [r7, #12]
 80115ba:	f7fa fa68 	bl	800ba8e <lv_disp_flush_ready>
}
 80115be:	bf00      	nop
 80115c0:	3728      	adds	r7, #40	; 0x28
 80115c2:	46bd      	mov	sp, r7
 80115c4:	bd80      	pop	{r7, pc}
 80115c6:	bf00      	nop
 80115c8:	88888889 	.word	0x88888889

080115cc <lv_color_make>:
#elif LV_COLOR_DEPTH == 32
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8, g8, r8, 0xff}}) /*Fix 0xff alpha*/
#endif

static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
 80115cc:	b490      	push	{r4, r7}
 80115ce:	b082      	sub	sp, #8
 80115d0:	af00      	add	r7, sp, #0
 80115d2:	4604      	mov	r4, r0
 80115d4:	4608      	mov	r0, r1
 80115d6:	4611      	mov	r1, r2
 80115d8:	4622      	mov	r2, r4
 80115da:	71fa      	strb	r2, [r7, #7]
 80115dc:	4602      	mov	r2, r0
 80115de:	71ba      	strb	r2, [r7, #6]
 80115e0:	460a      	mov	r2, r1
 80115e2:	717a      	strb	r2, [r7, #5]
    return LV_COLOR_MAKE(r, g, b);
 80115e4:	797a      	ldrb	r2, [r7, #5]
 80115e6:	08d2      	lsrs	r2, r2, #3
 80115e8:	b2d2      	uxtb	r2, r2
 80115ea:	f002 021f 	and.w	r2, r2, #31
 80115ee:	b2d0      	uxtb	r0, r2
 80115f0:	79ba      	ldrb	r2, [r7, #6]
 80115f2:	0892      	lsrs	r2, r2, #2
 80115f4:	b2d2      	uxtb	r2, r2
 80115f6:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 80115fa:	b2d1      	uxtb	r1, r2
 80115fc:	79fa      	ldrb	r2, [r7, #7]
 80115fe:	08d2      	lsrs	r2, r2, #3
 8011600:	b2d2      	uxtb	r2, r2
 8011602:	f002 021f 	and.w	r2, r2, #31
 8011606:	b2d2      	uxtb	r2, r2
 8011608:	f360 0304 	bfi	r3, r0, #0, #5
 801160c:	f361 134a 	bfi	r3, r1, #5, #6
 8011610:	f362 23cf 	bfi	r3, r2, #11, #5
}
 8011614:	4618      	mov	r0, r3
 8011616:	3708      	adds	r7, #8
 8011618:	46bd      	mov	sp, r7
 801161a:	bc90      	pop	{r4, r7}
 801161c:	4770      	bx	lr

0801161e <lv_scr_act>:
/**
 * Get the active screen of the default display
 * @return pointer to the active screen
 */
static inline lv_obj_t * lv_scr_act(void)
{
 801161e:	b580      	push	{r7, lr}
 8011620:	af00      	add	r7, sp, #0
    return lv_disp_get_scr_act(lv_disp_get_default());
 8011622:	f7fa f9c9 	bl	800b9b8 <lv_disp_get_default>
 8011626:	4603      	mov	r3, r0
 8011628:	4618      	mov	r0, r3
 801162a:	f7ee fe9f 	bl	800036c <lv_disp_get_scr_act>
 801162e:	4603      	mov	r3, r0
}
 8011630:	4618      	mov	r0, r3
 8011632:	bd80      	pop	{r7, pc}

08011634 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8011634:	b580      	push	{r7, lr}
 8011636:	b090      	sub	sp, #64	; 0x40
 8011638:	af00      	add	r7, sp, #0
  

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 801163a:	f000 fb00 	bl	8011c3e <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 801163e:	f000 f887 	bl	8011750 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8011642:	f000 f937 	bl	80118b4 <MX_GPIO_Init>
  MX_SPI2_Init();
 8011646:	f000 f8f7 	bl	8011838 <MX_SPI2_Init>
  MX_CRC_Init();
 801164a:	f000 f8d3 	bl	80117f4 <MX_CRC_Init>
 
 

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET); // Chip Select
 801164e:	2201      	movs	r2, #1
 8011650:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8011654:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8011658:	f000 fece 	bl	80123f8 <HAL_GPIO_WritePin>

  // Init graphics
  lv_init();
 801165c:	f7ef f95a 	bl	8000914 <lv_init>

  /*Initialize the display buffer*/
  lv_disp_buf_init(&disp_buf, buf, NULL, LV_HOR_RES_MAX * 10);
 8011660:	f44f 6316 	mov.w	r3, #2400	; 0x960
 8011664:	2200      	movs	r2, #0
 8011666:	4934      	ldr	r1, [pc, #208]	; (8011738 <main+0x104>)
 8011668:	4834      	ldr	r0, [pc, #208]	; (801173c <main+0x108>)
 801166a:	f7fa f8d4 	bl	800b816 <lv_disp_buf_init>

  // Initializing the display driver
  lv_disp_drv_t disp_drv;               /*Descriptor of a display driver*/
  lv_disp_drv_init(&disp_drv);          /*Basic initialization*/
 801166e:	f107 0310 	add.w	r3, r7, #16
 8011672:	4618      	mov	r0, r3
 8011674:	f7fa f88f 	bl	800b796 <lv_disp_drv_init>
  disp_drv.flush_cb = my_disp_flush;    /*Set your driver function*/
 8011678:	4b31      	ldr	r3, [pc, #196]	; (8011740 <main+0x10c>)
 801167a:	61fb      	str	r3, [r7, #28]
  disp_drv.buffer = &disp_buf;          /*Assign the buffer to the display*/
 801167c:	4b2f      	ldr	r3, [pc, #188]	; (801173c <main+0x108>)
 801167e:	617b      	str	r3, [r7, #20]
  lv_disp_drv_register(&disp_drv);      /*Finally register the driver*/
 8011680:	f107 0310 	add.w	r3, r7, #16
 8011684:	4618      	mov	r0, r3
 8011686:	f7fa f8e3 	bl	800b850 <lv_disp_drv_register>

  // Init LCD
  LCD_Init();
 801168a:	f7ff fd28 	bl	80110de <LCD_Init>

  // Create button
  lv_obj_t * btn = lv_btn_create(lv_scr_act(), NULL);     /*Add a button the current screen*/
 801168e:	f7ff ffc6 	bl	801161e <lv_scr_act>
 8011692:	4603      	mov	r3, r0
 8011694:	2100      	movs	r1, #0
 8011696:	4618      	mov	r0, r3
 8011698:	f7fc fc84 	bl	800dfa4 <lv_btn_create>
 801169c:	63f8      	str	r0, [r7, #60]	; 0x3c
  lv_obj_set_pos(btn, 10, 10);                            /*Set its position*/
 801169e:	220a      	movs	r2, #10
 80116a0:	210a      	movs	r1, #10
 80116a2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80116a4:	f7ef fd86 	bl	80011b4 <lv_obj_set_pos>
  lv_obj_set_size(btn, 100, 50);                          /*Set its size*/
 80116a8:	2232      	movs	r2, #50	; 0x32
 80116aa:	2164      	movs	r1, #100	; 0x64
 80116ac:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80116ae:	f7ef fe75 	bl	800139c <lv_obj_set_size>

  lv_obj_t * label = lv_label_create(btn, NULL);          /*Add a label to the button*/
 80116b2:	2100      	movs	r1, #0
 80116b4:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80116b6:	f7fe f829 	bl	800f70c <lv_label_create>
 80116ba:	63b8      	str	r0, [r7, #56]	; 0x38
  lv_label_set_text(label, "Button");                     /*Set the labels text*/
 80116bc:	4921      	ldr	r1, [pc, #132]	; (8011744 <main+0x110>)
 80116be:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80116c0:	f7fe f978 	bl	800f9b4 <lv_label_set_text>

  // Initialize colors
  lv_color_t emerald = lv_color_make(2, 46, 3);
 80116c4:	2203      	movs	r2, #3
 80116c6:	212e      	movs	r1, #46	; 0x2e
 80116c8:	2002      	movs	r0, #2
 80116ca:	f7ff ff7f 	bl	80115cc <lv_color_make>
 80116ce:	4603      	mov	r3, r0
 80116d0:	81bb      	strh	r3, [r7, #12]
  lv_color_t gold = lv_color_make(26, 43, 4);
 80116d2:	2204      	movs	r2, #4
 80116d4:	212b      	movs	r1, #43	; 0x2b
 80116d6:	201a      	movs	r0, #26
 80116d8:	f7ff ff78 	bl	80115cc <lv_color_make>
 80116dc:	4603      	mov	r3, r0
 80116de:	813b      	strh	r3, [r7, #8]
  lv_color_t white = lv_color_make(31, 63, 31);
 80116e0:	221f      	movs	r2, #31
 80116e2:	213f      	movs	r1, #63	; 0x3f
 80116e4:	201f      	movs	r0, #31
 80116e6:	f7ff ff71 	bl	80115cc <lv_color_make>
 80116ea:	4603      	mov	r3, r0
 80116ec:	80bb      	strh	r3, [r7, #4]

  // Set button style
  static lv_style_t style_btn_rel;                        /*A variable to store the released style*/
  lv_style_copy(&style_btn_rel, &lv_style_plain);         /*Initialize from a built-in style*/
 80116ee:	4916      	ldr	r1, [pc, #88]	; (8011748 <main+0x114>)
 80116f0:	4816      	ldr	r0, [pc, #88]	; (801174c <main+0x118>)
 80116f2:	f7f2 fba1 	bl	8003e38 <lv_style_copy>
  style_btn_rel.body.border.color = gold;
 80116f6:	4a15      	ldr	r2, [pc, #84]	; (801174c <main+0x118>)
 80116f8:	893b      	ldrh	r3, [r7, #8]
 80116fa:	8153      	strh	r3, [r2, #10]
  style_btn_rel.body.border.width = 1;
 80116fc:	4b13      	ldr	r3, [pc, #76]	; (801174c <main+0x118>)
 80116fe:	2201      	movs	r2, #1
 8011700:	819a      	strh	r2, [r3, #12]
  style_btn_rel.body.main_color = white;
 8011702:	4a12      	ldr	r2, [pc, #72]	; (801174c <main+0x118>)
 8011704:	88bb      	ldrh	r3, [r7, #4]
 8011706:	8053      	strh	r3, [r2, #2]
  style_btn_rel.body.grad_color = white;
 8011708:	4a10      	ldr	r2, [pc, #64]	; (801174c <main+0x118>)
 801170a:	88bb      	ldrh	r3, [r7, #4]
 801170c:	8093      	strh	r3, [r2, #4]
  style_btn_rel.body.radius = LV_RADIUS_CIRCLE;
 801170e:	4b0f      	ldr	r3, [pc, #60]	; (801174c <main+0x118>)
 8011710:	f647 4218 	movw	r2, #31768	; 0x7c18
 8011714:	80da      	strh	r2, [r3, #6]
  style_btn_rel.text.color = gold;
 8011716:	4a0d      	ldr	r2, [pc, #52]	; (801174c <main+0x118>)
 8011718:	893b      	ldrh	r3, [r7, #8]
 801171a:	8413      	strh	r3, [r2, #32]

  lv_btn_set_style(btn, LV_BTN_STYLE_REL, &style_btn_rel);    /*Set the button's released style*/
 801171c:	4a0b      	ldr	r2, [pc, #44]	; (801174c <main+0x118>)
 801171e:	2100      	movs	r1, #0
 8011720:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8011722:	f7fc fd6b 	bl	800e1fc <lv_btn_set_style>
//	HAL_Delay(30);
//
//	LCD_Clear(0,0,240,320,LCD_COLOR_BLUE);		//BLUE
//	HAL_Delay(30);

	HAL_Delay(10);
 8011726:	200a      	movs	r0, #10
 8011728:	f000 fafa 	bl	8011d20 <HAL_Delay>
	lv_tick_inc(10);
 801172c:	200a      	movs	r0, #10
 801172e:	f7fa fa1b 	bl	800bb68 <lv_tick_inc>
	lv_task_handler();
 8011732:	f7fb fbfd 	bl	800cf30 <lv_task_handler>
	HAL_Delay(10);
 8011736:	e7f6      	b.n	8011726 <main+0xf2>
 8011738:	20008300 	.word	0x20008300
 801173c:	200082e4 	.word	0x200082e4
 8011740:	080114dd 	.word	0x080114dd
 8011744:	08013938 	.word	0x08013938
 8011748:	20009800 	.word	0x20009800
 801174c:	200095c0 	.word	0x200095c0

08011750 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8011750:	b580      	push	{r7, lr}
 8011752:	b096      	sub	sp, #88	; 0x58
 8011754:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8011756:	f107 0314 	add.w	r3, r7, #20
 801175a:	2244      	movs	r2, #68	; 0x44
 801175c:	2100      	movs	r1, #0
 801175e:	4618      	mov	r0, r3
 8011760:	f001 fffd 	bl	801375e <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8011764:	463b      	mov	r3, r7
 8011766:	2200      	movs	r2, #0
 8011768:	601a      	str	r2, [r3, #0]
 801176a:	605a      	str	r2, [r3, #4]
 801176c:	609a      	str	r2, [r3, #8]
 801176e:	60da      	str	r2, [r3, #12]
 8011770:	611a      	str	r2, [r3, #16]

  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8011772:	2302      	movs	r3, #2
 8011774:	617b      	str	r3, [r7, #20]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8011776:	f44f 7380 	mov.w	r3, #256	; 0x100
 801177a:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 801177c:	2340      	movs	r3, #64	; 0x40
 801177e:	627b      	str	r3, [r7, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8011780:	2302      	movs	r3, #2
 8011782:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8011784:	2302      	movs	r3, #2
 8011786:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLM = 1;
 8011788:	2301      	movs	r3, #1
 801178a:	647b      	str	r3, [r7, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLN = 10;
 801178c:	230a      	movs	r3, #10
 801178e:	64bb      	str	r3, [r7, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 8011790:	2307      	movs	r3, #7
 8011792:	64fb      	str	r3, [r7, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 8011794:	2302      	movs	r3, #2
 8011796:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 8011798:	2302      	movs	r3, #2
 801179a:	657b      	str	r3, [r7, #84]	; 0x54
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 801179c:	f107 0314 	add.w	r3, r7, #20
 80117a0:	4618      	mov	r0, r3
 80117a2:	f000 fea5 	bl	80124f0 <HAL_RCC_OscConfig>
 80117a6:	4603      	mov	r3, r0
 80117a8:	2b00      	cmp	r3, #0
 80117aa:	d001      	beq.n	80117b0 <SystemClock_Config+0x60>
  {
    Error_Handler();
 80117ac:	f000 f90c 	bl	80119c8 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80117b0:	230f      	movs	r3, #15
 80117b2:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80117b4:	2303      	movs	r3, #3
 80117b6:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80117b8:	2300      	movs	r3, #0
 80117ba:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80117bc:	2300      	movs	r3, #0
 80117be:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80117c0:	2300      	movs	r3, #0
 80117c2:	613b      	str	r3, [r7, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80117c4:	463b      	mov	r3, r7
 80117c6:	2104      	movs	r1, #4
 80117c8:	4618      	mov	r0, r3
 80117ca:	f001 fab1 	bl	8012d30 <HAL_RCC_ClockConfig>
 80117ce:	4603      	mov	r3, r0
 80117d0:	2b00      	cmp	r3, #0
 80117d2:	d001      	beq.n	80117d8 <SystemClock_Config+0x88>
  {
    Error_Handler();
 80117d4:	f000 f8f8 	bl	80119c8 <Error_Handler>
  }
  /** Configure the main internal regulator output voltage 
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 80117d8:	f44f 7000 	mov.w	r0, #512	; 0x200
 80117dc:	f000 fe32 	bl	8012444 <HAL_PWREx_ControlVoltageScaling>
 80117e0:	4603      	mov	r3, r0
 80117e2:	2b00      	cmp	r3, #0
 80117e4:	d001      	beq.n	80117ea <SystemClock_Config+0x9a>
  {
    Error_Handler();
 80117e6:	f000 f8ef 	bl	80119c8 <Error_Handler>
  }
}
 80117ea:	bf00      	nop
 80117ec:	3758      	adds	r7, #88	; 0x58
 80117ee:	46bd      	mov	sp, r7
 80117f0:	bd80      	pop	{r7, pc}
	...

080117f4 <MX_CRC_Init>:
  * @brief CRC Initialization Function
  * @param None
  * @retval None
  */
static void MX_CRC_Init(void)
{
 80117f4:	b580      	push	{r7, lr}
 80117f6:	af00      	add	r7, sp, #0
  /* USER CODE END CRC_Init 0 */

  /* USER CODE BEGIN CRC_Init 1 */

  /* USER CODE END CRC_Init 1 */
  hcrc.Instance = CRC;
 80117f8:	4b0d      	ldr	r3, [pc, #52]	; (8011830 <MX_CRC_Init+0x3c>)
 80117fa:	4a0e      	ldr	r2, [pc, #56]	; (8011834 <MX_CRC_Init+0x40>)
 80117fc:	601a      	str	r2, [r3, #0]
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 80117fe:	4b0c      	ldr	r3, [pc, #48]	; (8011830 <MX_CRC_Init+0x3c>)
 8011800:	2200      	movs	r2, #0
 8011802:	711a      	strb	r2, [r3, #4]
  hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
 8011804:	4b0a      	ldr	r3, [pc, #40]	; (8011830 <MX_CRC_Init+0x3c>)
 8011806:	2200      	movs	r2, #0
 8011808:	715a      	strb	r2, [r3, #5]
  hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
 801180a:	4b09      	ldr	r3, [pc, #36]	; (8011830 <MX_CRC_Init+0x3c>)
 801180c:	2200      	movs	r2, #0
 801180e:	615a      	str	r2, [r3, #20]
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 8011810:	4b07      	ldr	r3, [pc, #28]	; (8011830 <MX_CRC_Init+0x3c>)
 8011812:	2200      	movs	r2, #0
 8011814:	619a      	str	r2, [r3, #24]
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
 8011816:	4b06      	ldr	r3, [pc, #24]	; (8011830 <MX_CRC_Init+0x3c>)
 8011818:	2201      	movs	r2, #1
 801181a:	621a      	str	r2, [r3, #32]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 801181c:	4804      	ldr	r0, [pc, #16]	; (8011830 <MX_CRC_Init+0x3c>)
 801181e:	f000 fb87 	bl	8011f30 <HAL_CRC_Init>
 8011822:	4603      	mov	r3, r0
 8011824:	2b00      	cmp	r3, #0
 8011826:	d001      	beq.n	801182c <MX_CRC_Init+0x38>
  {
    Error_Handler();
 8011828:	f000 f8ce 	bl	80119c8 <Error_Handler>
  }
  /* USER CODE BEGIN CRC_Init 2 */

  /* USER CODE END CRC_Init 2 */

}
 801182c:	bf00      	nop
 801182e:	bd80      	pop	{r7, pc}
 8011830:	20009a10 	.word	0x20009a10
 8011834:	40023000 	.word	0x40023000

08011838 <MX_SPI2_Init>:
  * @brief SPI2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI2_Init(void)
{
 8011838:	b580      	push	{r7, lr}
 801183a:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */
  /* SPI2 parameter configuration*/
  hspi2.Instance = SPI2;
 801183c:	4b1b      	ldr	r3, [pc, #108]	; (80118ac <MX_SPI2_Init+0x74>)
 801183e:	4a1c      	ldr	r2, [pc, #112]	; (80118b0 <MX_SPI2_Init+0x78>)
 8011840:	601a      	str	r2, [r3, #0]
  hspi2.Init.Mode = SPI_MODE_MASTER;
 8011842:	4b1a      	ldr	r3, [pc, #104]	; (80118ac <MX_SPI2_Init+0x74>)
 8011844:	f44f 7282 	mov.w	r2, #260	; 0x104
 8011848:	605a      	str	r2, [r3, #4]
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
 801184a:	4b18      	ldr	r3, [pc, #96]	; (80118ac <MX_SPI2_Init+0x74>)
 801184c:	2200      	movs	r2, #0
 801184e:	609a      	str	r2, [r3, #8]
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 8011850:	4b16      	ldr	r3, [pc, #88]	; (80118ac <MX_SPI2_Init+0x74>)
 8011852:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 8011856:	60da      	str	r2, [r3, #12]
  hspi2.Init.CLKPolarity = SPI_POLARITY_HIGH;
 8011858:	4b14      	ldr	r3, [pc, #80]	; (80118ac <MX_SPI2_Init+0x74>)
 801185a:	2202      	movs	r2, #2
 801185c:	611a      	str	r2, [r3, #16]
  hspi2.Init.CLKPhase = SPI_PHASE_2EDGE;
 801185e:	4b13      	ldr	r3, [pc, #76]	; (80118ac <MX_SPI2_Init+0x74>)
 8011860:	2201      	movs	r2, #1
 8011862:	615a      	str	r2, [r3, #20]
  hspi2.Init.NSS = SPI_NSS_SOFT;
 8011864:	4b11      	ldr	r3, [pc, #68]	; (80118ac <MX_SPI2_Init+0x74>)
 8011866:	f44f 7200 	mov.w	r2, #512	; 0x200
 801186a:	619a      	str	r2, [r3, #24]
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 801186c:	4b0f      	ldr	r3, [pc, #60]	; (80118ac <MX_SPI2_Init+0x74>)
 801186e:	2200      	movs	r2, #0
 8011870:	61da      	str	r2, [r3, #28]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8011872:	4b0e      	ldr	r3, [pc, #56]	; (80118ac <MX_SPI2_Init+0x74>)
 8011874:	2200      	movs	r2, #0
 8011876:	621a      	str	r2, [r3, #32]
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
 8011878:	4b0c      	ldr	r3, [pc, #48]	; (80118ac <MX_SPI2_Init+0x74>)
 801187a:	2200      	movs	r2, #0
 801187c:	625a      	str	r2, [r3, #36]	; 0x24
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 801187e:	4b0b      	ldr	r3, [pc, #44]	; (80118ac <MX_SPI2_Init+0x74>)
 8011880:	2200      	movs	r2, #0
 8011882:	629a      	str	r2, [r3, #40]	; 0x28
  hspi2.Init.CRCPolynomial = 7;
 8011884:	4b09      	ldr	r3, [pc, #36]	; (80118ac <MX_SPI2_Init+0x74>)
 8011886:	2207      	movs	r2, #7
 8011888:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 801188a:	4b08      	ldr	r3, [pc, #32]	; (80118ac <MX_SPI2_Init+0x74>)
 801188c:	2200      	movs	r2, #0
 801188e:	631a      	str	r2, [r3, #48]	; 0x30
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
 8011890:	4b06      	ldr	r3, [pc, #24]	; (80118ac <MX_SPI2_Init+0x74>)
 8011892:	2200      	movs	r2, #0
 8011894:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 8011896:	4805      	ldr	r0, [pc, #20]	; (80118ac <MX_SPI2_Init+0x74>)
 8011898:	f001 fc16 	bl	80130c8 <HAL_SPI_Init>
 801189c:	4603      	mov	r3, r0
 801189e:	2b00      	cmp	r3, #0
 80118a0:	d001      	beq.n	80118a6 <MX_SPI2_Init+0x6e>
  {
    Error_Handler();
 80118a2:	f000 f891 	bl	80119c8 <Error_Handler>
  }
  /* USER CODE BEGIN SPI2_Init 2 */

  /* USER CODE END SPI2_Init 2 */

}
 80118a6:	bf00      	nop
 80118a8:	bd80      	pop	{r7, pc}
 80118aa:	bf00      	nop
 80118ac:	200099ac 	.word	0x200099ac
 80118b0:	40003800 	.word	0x40003800

080118b4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 80118b4:	b580      	push	{r7, lr}
 80118b6:	b08a      	sub	sp, #40	; 0x28
 80118b8:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80118ba:	f107 0314 	add.w	r3, r7, #20
 80118be:	2200      	movs	r2, #0
 80118c0:	601a      	str	r2, [r3, #0]
 80118c2:	605a      	str	r2, [r3, #4]
 80118c4:	609a      	str	r2, [r3, #8]
 80118c6:	60da      	str	r2, [r3, #12]
 80118c8:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80118ca:	4b3c      	ldr	r3, [pc, #240]	; (80119bc <MX_GPIO_Init+0x108>)
 80118cc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80118ce:	4a3b      	ldr	r2, [pc, #236]	; (80119bc <MX_GPIO_Init+0x108>)
 80118d0:	f043 0304 	orr.w	r3, r3, #4
 80118d4:	64d3      	str	r3, [r2, #76]	; 0x4c
 80118d6:	4b39      	ldr	r3, [pc, #228]	; (80119bc <MX_GPIO_Init+0x108>)
 80118d8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80118da:	f003 0304 	and.w	r3, r3, #4
 80118de:	613b      	str	r3, [r7, #16]
 80118e0:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80118e2:	4b36      	ldr	r3, [pc, #216]	; (80119bc <MX_GPIO_Init+0x108>)
 80118e4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80118e6:	4a35      	ldr	r2, [pc, #212]	; (80119bc <MX_GPIO_Init+0x108>)
 80118e8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80118ec:	64d3      	str	r3, [r2, #76]	; 0x4c
 80118ee:	4b33      	ldr	r3, [pc, #204]	; (80119bc <MX_GPIO_Init+0x108>)
 80118f0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80118f2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80118f6:	60fb      	str	r3, [r7, #12]
 80118f8:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80118fa:	4b30      	ldr	r3, [pc, #192]	; (80119bc <MX_GPIO_Init+0x108>)
 80118fc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80118fe:	4a2f      	ldr	r2, [pc, #188]	; (80119bc <MX_GPIO_Init+0x108>)
 8011900:	f043 0301 	orr.w	r3, r3, #1
 8011904:	64d3      	str	r3, [r2, #76]	; 0x4c
 8011906:	4b2d      	ldr	r3, [pc, #180]	; (80119bc <MX_GPIO_Init+0x108>)
 8011908:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801190a:	f003 0301 	and.w	r3, r3, #1
 801190e:	60bb      	str	r3, [r7, #8]
 8011910:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8011912:	4b2a      	ldr	r3, [pc, #168]	; (80119bc <MX_GPIO_Init+0x108>)
 8011914:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011916:	4a29      	ldr	r2, [pc, #164]	; (80119bc <MX_GPIO_Init+0x108>)
 8011918:	f043 0302 	orr.w	r3, r3, #2
 801191c:	64d3      	str	r3, [r2, #76]	; 0x4c
 801191e:	4b27      	ldr	r3, [pc, #156]	; (80119bc <MX_GPIO_Init+0x108>)
 8011920:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011922:	f003 0302 	and.w	r3, r3, #2
 8011926:	607b      	str	r3, [r7, #4]
 8011928:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, LD4_Pin|GPIO_PIN_8|GPIO_PIN_10|GPIO_PIN_11, GPIO_PIN_RESET);
 801192a:	2200      	movs	r2, #0
 801192c:	f44f 6152 	mov.w	r1, #3360	; 0xd20
 8011930:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8011934:	f000 fd60 	bl	80123f8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
 8011938:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 801193c:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 801193e:	4b20      	ldr	r3, [pc, #128]	; (80119c0 <MX_GPIO_Init+0x10c>)
 8011940:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011942:	2300      	movs	r3, #0
 8011944:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8011946:	f107 0314 	add.w	r3, r7, #20
 801194a:	4619      	mov	r1, r3
 801194c:	481d      	ldr	r0, [pc, #116]	; (80119c4 <MX_GPIO_Init+0x110>)
 801194e:	f000 fbd9 	bl	8012104 <HAL_GPIO_Init>

  /*Configure GPIO pins : USART_TX_Pin USART_RX_Pin */
  GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
 8011952:	230c      	movs	r3, #12
 8011954:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011956:	2302      	movs	r3, #2
 8011958:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801195a:	2300      	movs	r3, #0
 801195c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801195e:	2303      	movs	r3, #3
 8011960:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8011962:	2307      	movs	r3, #7
 8011964:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011966:	f107 0314 	add.w	r3, r7, #20
 801196a:	4619      	mov	r1, r3
 801196c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8011970:	f000 fbc8 	bl	8012104 <HAL_GPIO_Init>

  /*Configure GPIO pins : LD4_Pin PA8 */
  GPIO_InitStruct.Pin = LD4_Pin|GPIO_PIN_8;
 8011974:	f44f 7390 	mov.w	r3, #288	; 0x120
 8011978:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 801197a:	2301      	movs	r3, #1
 801197c:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801197e:	2300      	movs	r3, #0
 8011980:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011982:	2300      	movs	r3, #0
 8011984:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011986:	f107 0314 	add.w	r3, r7, #20
 801198a:	4619      	mov	r1, r3
 801198c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8011990:	f000 fbb8 	bl	8012104 <HAL_GPIO_Init>

  /*Configure GPIO pins : PA10 PA11 */
  GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 8011994:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8011998:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 801199a:	2301      	movs	r3, #1
 801199c:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801199e:	2300      	movs	r3, #0
 80119a0:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80119a2:	2303      	movs	r3, #3
 80119a4:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80119a6:	f107 0314 	add.w	r3, r7, #20
 80119aa:	4619      	mov	r1, r3
 80119ac:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80119b0:	f000 fba8 	bl	8012104 <HAL_GPIO_Init>

}
 80119b4:	bf00      	nop
 80119b6:	3728      	adds	r7, #40	; 0x28
 80119b8:	46bd      	mov	sp, r7
 80119ba:	bd80      	pop	{r7, pc}
 80119bc:	40021000 	.word	0x40021000
 80119c0:	10210000 	.word	0x10210000
 80119c4:	48000800 	.word	0x48000800

080119c8 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80119c8:	b480      	push	{r7}
 80119ca:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 80119cc:	bf00      	nop
 80119ce:	46bd      	mov	sp, r7
 80119d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80119d4:	4770      	bx	lr
	...

080119d8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80119d8:	b480      	push	{r7}
 80119da:	b083      	sub	sp, #12
 80119dc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80119de:	4b0f      	ldr	r3, [pc, #60]	; (8011a1c <HAL_MspInit+0x44>)
 80119e0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80119e2:	4a0e      	ldr	r2, [pc, #56]	; (8011a1c <HAL_MspInit+0x44>)
 80119e4:	f043 0301 	orr.w	r3, r3, #1
 80119e8:	6613      	str	r3, [r2, #96]	; 0x60
 80119ea:	4b0c      	ldr	r3, [pc, #48]	; (8011a1c <HAL_MspInit+0x44>)
 80119ec:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80119ee:	f003 0301 	and.w	r3, r3, #1
 80119f2:	607b      	str	r3, [r7, #4]
 80119f4:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 80119f6:	4b09      	ldr	r3, [pc, #36]	; (8011a1c <HAL_MspInit+0x44>)
 80119f8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80119fa:	4a08      	ldr	r2, [pc, #32]	; (8011a1c <HAL_MspInit+0x44>)
 80119fc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8011a00:	6593      	str	r3, [r2, #88]	; 0x58
 8011a02:	4b06      	ldr	r3, [pc, #24]	; (8011a1c <HAL_MspInit+0x44>)
 8011a04:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8011a06:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8011a0a:	603b      	str	r3, [r7, #0]
 8011a0c:	683b      	ldr	r3, [r7, #0]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8011a0e:	bf00      	nop
 8011a10:	370c      	adds	r7, #12
 8011a12:	46bd      	mov	sp, r7
 8011a14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011a18:	4770      	bx	lr
 8011a1a:	bf00      	nop
 8011a1c:	40021000 	.word	0x40021000

08011a20 <HAL_CRC_MspInit>:
* This function configures the hardware resources used in this example
* @param hcrc: CRC handle pointer
* @retval None
*/
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
 8011a20:	b480      	push	{r7}
 8011a22:	b085      	sub	sp, #20
 8011a24:	af00      	add	r7, sp, #0
 8011a26:	6078      	str	r0, [r7, #4]
  if(hcrc->Instance==CRC)
 8011a28:	687b      	ldr	r3, [r7, #4]
 8011a2a:	681b      	ldr	r3, [r3, #0]
 8011a2c:	4a0a      	ldr	r2, [pc, #40]	; (8011a58 <HAL_CRC_MspInit+0x38>)
 8011a2e:	4293      	cmp	r3, r2
 8011a30:	d10b      	bne.n	8011a4a <HAL_CRC_MspInit+0x2a>
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 8011a32:	4b0a      	ldr	r3, [pc, #40]	; (8011a5c <HAL_CRC_MspInit+0x3c>)
 8011a34:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011a36:	4a09      	ldr	r2, [pc, #36]	; (8011a5c <HAL_CRC_MspInit+0x3c>)
 8011a38:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8011a3c:	6493      	str	r3, [r2, #72]	; 0x48
 8011a3e:	4b07      	ldr	r3, [pc, #28]	; (8011a5c <HAL_CRC_MspInit+0x3c>)
 8011a40:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011a42:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8011a46:	60fb      	str	r3, [r7, #12]
 8011a48:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }

}
 8011a4a:	bf00      	nop
 8011a4c:	3714      	adds	r7, #20
 8011a4e:	46bd      	mov	sp, r7
 8011a50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011a54:	4770      	bx	lr
 8011a56:	bf00      	nop
 8011a58:	40023000 	.word	0x40023000
 8011a5c:	40021000 	.word	0x40021000

08011a60 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8011a60:	b580      	push	{r7, lr}
 8011a62:	b08a      	sub	sp, #40	; 0x28
 8011a64:	af00      	add	r7, sp, #0
 8011a66:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8011a68:	f107 0314 	add.w	r3, r7, #20
 8011a6c:	2200      	movs	r2, #0
 8011a6e:	601a      	str	r2, [r3, #0]
 8011a70:	605a      	str	r2, [r3, #4]
 8011a72:	609a      	str	r2, [r3, #8]
 8011a74:	60da      	str	r2, [r3, #12]
 8011a76:	611a      	str	r2, [r3, #16]
  if(hspi->Instance==SPI2)
 8011a78:	687b      	ldr	r3, [r7, #4]
 8011a7a:	681b      	ldr	r3, [r3, #0]
 8011a7c:	4a25      	ldr	r2, [pc, #148]	; (8011b14 <HAL_SPI_MspInit+0xb4>)
 8011a7e:	4293      	cmp	r3, r2
 8011a80:	d144      	bne.n	8011b0c <HAL_SPI_MspInit+0xac>
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();
 8011a82:	4b25      	ldr	r3, [pc, #148]	; (8011b18 <HAL_SPI_MspInit+0xb8>)
 8011a84:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8011a86:	4a24      	ldr	r2, [pc, #144]	; (8011b18 <HAL_SPI_MspInit+0xb8>)
 8011a88:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8011a8c:	6593      	str	r3, [r2, #88]	; 0x58
 8011a8e:	4b22      	ldr	r3, [pc, #136]	; (8011b18 <HAL_SPI_MspInit+0xb8>)
 8011a90:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8011a92:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8011a96:	613b      	str	r3, [r7, #16]
 8011a98:	693b      	ldr	r3, [r7, #16]
  
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8011a9a:	4b1f      	ldr	r3, [pc, #124]	; (8011b18 <HAL_SPI_MspInit+0xb8>)
 8011a9c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011a9e:	4a1e      	ldr	r2, [pc, #120]	; (8011b18 <HAL_SPI_MspInit+0xb8>)
 8011aa0:	f043 0304 	orr.w	r3, r3, #4
 8011aa4:	64d3      	str	r3, [r2, #76]	; 0x4c
 8011aa6:	4b1c      	ldr	r3, [pc, #112]	; (8011b18 <HAL_SPI_MspInit+0xb8>)
 8011aa8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011aaa:	f003 0304 	and.w	r3, r3, #4
 8011aae:	60fb      	str	r3, [r7, #12]
 8011ab0:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8011ab2:	4b19      	ldr	r3, [pc, #100]	; (8011b18 <HAL_SPI_MspInit+0xb8>)
 8011ab4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011ab6:	4a18      	ldr	r2, [pc, #96]	; (8011b18 <HAL_SPI_MspInit+0xb8>)
 8011ab8:	f043 0302 	orr.w	r3, r3, #2
 8011abc:	64d3      	str	r3, [r2, #76]	; 0x4c
 8011abe:	4b16      	ldr	r3, [pc, #88]	; (8011b18 <HAL_SPI_MspInit+0xb8>)
 8011ac0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011ac2:	f003 0302 	and.w	r3, r3, #2
 8011ac6:	60bb      	str	r3, [r7, #8]
 8011ac8:	68bb      	ldr	r3, [r7, #8]
    /**SPI2 GPIO Configuration    
    PC2     ------> SPI2_MISO
    PC3     ------> SPI2_MOSI
    PB10     ------> SPI2_SCK 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 8011aca:	230c      	movs	r3, #12
 8011acc:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011ace:	2302      	movs	r3, #2
 8011ad0:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011ad2:	2300      	movs	r3, #0
 8011ad4:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8011ad6:	2303      	movs	r3, #3
 8011ad8:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8011ada:	2305      	movs	r3, #5
 8011adc:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8011ade:	f107 0314 	add.w	r3, r7, #20
 8011ae2:	4619      	mov	r1, r3
 8011ae4:	480d      	ldr	r0, [pc, #52]	; (8011b1c <HAL_SPI_MspInit+0xbc>)
 8011ae6:	f000 fb0d 	bl	8012104 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8011aea:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8011aee:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011af0:	2302      	movs	r3, #2
 8011af2:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011af4:	2300      	movs	r3, #0
 8011af6:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8011af8:	2303      	movs	r3, #3
 8011afa:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8011afc:	2305      	movs	r3, #5
 8011afe:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8011b00:	f107 0314 	add.w	r3, r7, #20
 8011b04:	4619      	mov	r1, r3
 8011b06:	4806      	ldr	r0, [pc, #24]	; (8011b20 <HAL_SPI_MspInit+0xc0>)
 8011b08:	f000 fafc 	bl	8012104 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }

}
 8011b0c:	bf00      	nop
 8011b0e:	3728      	adds	r7, #40	; 0x28
 8011b10:	46bd      	mov	sp, r7
 8011b12:	bd80      	pop	{r7, pc}
 8011b14:	40003800 	.word	0x40003800
 8011b18:	40021000 	.word	0x40021000
 8011b1c:	48000800 	.word	0x48000800
 8011b20:	48000400 	.word	0x48000400

08011b24 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8011b24:	b480      	push	{r7}
 8011b26:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8011b28:	bf00      	nop
 8011b2a:	46bd      	mov	sp, r7
 8011b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b30:	4770      	bx	lr

08011b32 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8011b32:	b480      	push	{r7}
 8011b34:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8011b36:	e7fe      	b.n	8011b36 <HardFault_Handler+0x4>

08011b38 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8011b38:	b480      	push	{r7}
 8011b3a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8011b3c:	e7fe      	b.n	8011b3c <MemManage_Handler+0x4>

08011b3e <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8011b3e:	b480      	push	{r7}
 8011b40:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8011b42:	e7fe      	b.n	8011b42 <BusFault_Handler+0x4>

08011b44 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8011b44:	b480      	push	{r7}
 8011b46:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8011b48:	e7fe      	b.n	8011b48 <UsageFault_Handler+0x4>

08011b4a <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8011b4a:	b480      	push	{r7}
 8011b4c:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8011b4e:	bf00      	nop
 8011b50:	46bd      	mov	sp, r7
 8011b52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b56:	4770      	bx	lr

08011b58 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8011b58:	b480      	push	{r7}
 8011b5a:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8011b5c:	bf00      	nop
 8011b5e:	46bd      	mov	sp, r7
 8011b60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b64:	4770      	bx	lr

08011b66 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8011b66:	b480      	push	{r7}
 8011b68:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8011b6a:	bf00      	nop
 8011b6c:	46bd      	mov	sp, r7
 8011b6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b72:	4770      	bx	lr

08011b74 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8011b74:	b580      	push	{r7, lr}
 8011b76:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8011b78:	f000 f8b4 	bl	8011ce4 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8011b7c:	bf00      	nop
 8011b7e:	bd80      	pop	{r7, pc}

08011b80 <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 8011b80:	b480      	push	{r7}
 8011b82:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8011b84:	4b17      	ldr	r3, [pc, #92]	; (8011be4 <SystemInit+0x64>)
 8011b86:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8011b8a:	4a16      	ldr	r2, [pc, #88]	; (8011be4 <SystemInit+0x64>)
 8011b8c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8011b90:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8011b94:	4b14      	ldr	r3, [pc, #80]	; (8011be8 <SystemInit+0x68>)
 8011b96:	681b      	ldr	r3, [r3, #0]
 8011b98:	4a13      	ldr	r2, [pc, #76]	; (8011be8 <SystemInit+0x68>)
 8011b9a:	f043 0301 	orr.w	r3, r3, #1
 8011b9e:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 8011ba0:	4b11      	ldr	r3, [pc, #68]	; (8011be8 <SystemInit+0x68>)
 8011ba2:	2200      	movs	r2, #0
 8011ba4:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 8011ba6:	4b10      	ldr	r3, [pc, #64]	; (8011be8 <SystemInit+0x68>)
 8011ba8:	681b      	ldr	r3, [r3, #0]
 8011baa:	4a0f      	ldr	r2, [pc, #60]	; (8011be8 <SystemInit+0x68>)
 8011bac:	f023 53a8 	bic.w	r3, r3, #352321536	; 0x15000000
 8011bb0:	f423 2310 	bic.w	r3, r3, #589824	; 0x90000
 8011bb4:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 8011bb6:	4b0c      	ldr	r3, [pc, #48]	; (8011be8 <SystemInit+0x68>)
 8011bb8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8011bbc:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8011bbe:	4b0a      	ldr	r3, [pc, #40]	; (8011be8 <SystemInit+0x68>)
 8011bc0:	681b      	ldr	r3, [r3, #0]
 8011bc2:	4a09      	ldr	r2, [pc, #36]	; (8011be8 <SystemInit+0x68>)
 8011bc4:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8011bc8:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 8011bca:	4b07      	ldr	r3, [pc, #28]	; (8011be8 <SystemInit+0x68>)
 8011bcc:	2200      	movs	r2, #0
 8011bce:	619a      	str	r2, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8011bd0:	4b04      	ldr	r3, [pc, #16]	; (8011be4 <SystemInit+0x64>)
 8011bd2:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8011bd6:	609a      	str	r2, [r3, #8]
#endif
}
 8011bd8:	bf00      	nop
 8011bda:	46bd      	mov	sp, r7
 8011bdc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011be0:	4770      	bx	lr
 8011be2:	bf00      	nop
 8011be4:	e000ed00 	.word	0xe000ed00
 8011be8:	40021000 	.word	0x40021000

08011bec <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Set stack pointer */
 8011bec:	f8df d034 	ldr.w	sp, [pc, #52]	; 8011c24 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8011bf0:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8011bf2:	e003      	b.n	8011bfc <LoopCopyDataInit>

08011bf4 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8011bf4:	4b0c      	ldr	r3, [pc, #48]	; (8011c28 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8011bf6:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8011bf8:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8011bfa:	3104      	adds	r1, #4

08011bfc <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8011bfc:	480b      	ldr	r0, [pc, #44]	; (8011c2c <LoopForever+0xa>)
	ldr	r3, =_edata
 8011bfe:	4b0c      	ldr	r3, [pc, #48]	; (8011c30 <LoopForever+0xe>)
	adds	r2, r0, r1
 8011c00:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8011c02:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8011c04:	d3f6      	bcc.n	8011bf4 <CopyDataInit>
	ldr	r2, =_sbss
 8011c06:	4a0b      	ldr	r2, [pc, #44]	; (8011c34 <LoopForever+0x12>)
	b	LoopFillZerobss
 8011c08:	e002      	b.n	8011c10 <LoopFillZerobss>

08011c0a <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8011c0a:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8011c0c:	f842 3b04 	str.w	r3, [r2], #4

08011c10 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8011c10:	4b09      	ldr	r3, [pc, #36]	; (8011c38 <LoopForever+0x16>)
	cmp	r2, r3
 8011c12:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8011c14:	d3f9      	bcc.n	8011c0a <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8011c16:	f7ff ffb3 	bl	8011b80 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8011c1a:	f001 fd71 	bl	8013700 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8011c1e:	f7ff fd09 	bl	8011634 <main>

08011c22 <LoopForever>:

LoopForever:
    b LoopForever
 8011c22:	e7fe      	b.n	8011c22 <LoopForever>
  ldr   sp, =_estack    /* Set stack pointer */
 8011c24:	20028000 	.word	0x20028000
	ldr	r3, =_sidata
 8011c28:	08016dcc 	.word	0x08016dcc
	ldr	r0, =_sdata
 8011c2c:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8011c30:	20000074 	.word	0x20000074
	ldr	r2, =_sbss
 8011c34:	20000074 	.word	0x20000074
	ldr	r3, = _ebss
 8011c38:	20009a38 	.word	0x20009a38

08011c3c <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8011c3c:	e7fe      	b.n	8011c3c <ADC1_IRQHandler>

08011c3e <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8011c3e:	b580      	push	{r7, lr}
 8011c40:	b082      	sub	sp, #8
 8011c42:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 8011c44:	2300      	movs	r3, #0
 8011c46:	71fb      	strb	r3, [r7, #7]
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8011c48:	2003      	movs	r0, #3
 8011c4a:	f000 f93d 	bl	8011ec8 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8011c4e:	2000      	movs	r0, #0
 8011c50:	f000 f80e 	bl	8011c70 <HAL_InitTick>
 8011c54:	4603      	mov	r3, r0
 8011c56:	2b00      	cmp	r3, #0
 8011c58:	d002      	beq.n	8011c60 <HAL_Init+0x22>
  {
    status = HAL_ERROR;
 8011c5a:	2301      	movs	r3, #1
 8011c5c:	71fb      	strb	r3, [r7, #7]
 8011c5e:	e001      	b.n	8011c64 <HAL_Init+0x26>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 8011c60:	f7ff feba 	bl	80119d8 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 8011c64:	79fb      	ldrb	r3, [r7, #7]
}
 8011c66:	4618      	mov	r0, r3
 8011c68:	3708      	adds	r7, #8
 8011c6a:	46bd      	mov	sp, r7
 8011c6c:	bd80      	pop	{r7, pc}
	...

08011c70 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8011c70:	b580      	push	{r7, lr}
 8011c72:	b084      	sub	sp, #16
 8011c74:	af00      	add	r7, sp, #0
 8011c76:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 8011c78:	2300      	movs	r3, #0
 8011c7a:	73fb      	strb	r3, [r7, #15]

  if (uwTickFreq != 0U)
 8011c7c:	4b16      	ldr	r3, [pc, #88]	; (8011cd8 <HAL_InitTick+0x68>)
 8011c7e:	681b      	ldr	r3, [r3, #0]
 8011c80:	2b00      	cmp	r3, #0
 8011c82:	d022      	beq.n	8011cca <HAL_InitTick+0x5a>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
 8011c84:	4b15      	ldr	r3, [pc, #84]	; (8011cdc <HAL_InitTick+0x6c>)
 8011c86:	681a      	ldr	r2, [r3, #0]
 8011c88:	4b13      	ldr	r3, [pc, #76]	; (8011cd8 <HAL_InitTick+0x68>)
 8011c8a:	681b      	ldr	r3, [r3, #0]
 8011c8c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8011c90:	fbb1 f3f3 	udiv	r3, r1, r3
 8011c94:	fbb2 f3f3 	udiv	r3, r2, r3
 8011c98:	4618      	mov	r0, r3
 8011c9a:	f000 f93c 	bl	8011f16 <HAL_SYSTICK_Config>
 8011c9e:	4603      	mov	r3, r0
 8011ca0:	2b00      	cmp	r3, #0
 8011ca2:	d10f      	bne.n	8011cc4 <HAL_InitTick+0x54>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8011ca4:	687b      	ldr	r3, [r7, #4]
 8011ca6:	2b0f      	cmp	r3, #15
 8011ca8:	d809      	bhi.n	8011cbe <HAL_InitTick+0x4e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8011caa:	2200      	movs	r2, #0
 8011cac:	6879      	ldr	r1, [r7, #4]
 8011cae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8011cb2:	f000 f914 	bl	8011ede <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8011cb6:	4a0a      	ldr	r2, [pc, #40]	; (8011ce0 <HAL_InitTick+0x70>)
 8011cb8:	687b      	ldr	r3, [r7, #4]
 8011cba:	6013      	str	r3, [r2, #0]
 8011cbc:	e007      	b.n	8011cce <HAL_InitTick+0x5e>
      }
      else
      {
        status = HAL_ERROR;
 8011cbe:	2301      	movs	r3, #1
 8011cc0:	73fb      	strb	r3, [r7, #15]
 8011cc2:	e004      	b.n	8011cce <HAL_InitTick+0x5e>
      }
    }
    else
    {
      status = HAL_ERROR;
 8011cc4:	2301      	movs	r3, #1
 8011cc6:	73fb      	strb	r3, [r7, #15]
 8011cc8:	e001      	b.n	8011cce <HAL_InitTick+0x5e>
    }
  }
  else
  {
    status = HAL_ERROR;
 8011cca:	2301      	movs	r3, #1
 8011ccc:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
 8011cce:	7bfb      	ldrb	r3, [r7, #15]
}
 8011cd0:	4618      	mov	r0, r3
 8011cd2:	3710      	adds	r7, #16
 8011cd4:	46bd      	mov	sp, r7
 8011cd6:	bd80      	pop	{r7, pc}
 8011cd8:	20000070 	.word	0x20000070
 8011cdc:	20000068 	.word	0x20000068
 8011ce0:	2000006c 	.word	0x2000006c

08011ce4 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8011ce4:	b480      	push	{r7}
 8011ce6:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8011ce8:	4b05      	ldr	r3, [pc, #20]	; (8011d00 <HAL_IncTick+0x1c>)
 8011cea:	681a      	ldr	r2, [r3, #0]
 8011cec:	4b05      	ldr	r3, [pc, #20]	; (8011d04 <HAL_IncTick+0x20>)
 8011cee:	681b      	ldr	r3, [r3, #0]
 8011cf0:	4413      	add	r3, r2
 8011cf2:	4a03      	ldr	r2, [pc, #12]	; (8011d00 <HAL_IncTick+0x1c>)
 8011cf4:	6013      	str	r3, [r2, #0]
}
 8011cf6:	bf00      	nop
 8011cf8:	46bd      	mov	sp, r7
 8011cfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011cfe:	4770      	bx	lr
 8011d00:	20009a34 	.word	0x20009a34
 8011d04:	20000070 	.word	0x20000070

08011d08 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8011d08:	b480      	push	{r7}
 8011d0a:	af00      	add	r7, sp, #0
  return uwTick;
 8011d0c:	4b03      	ldr	r3, [pc, #12]	; (8011d1c <HAL_GetTick+0x14>)
 8011d0e:	681b      	ldr	r3, [r3, #0]
}
 8011d10:	4618      	mov	r0, r3
 8011d12:	46bd      	mov	sp, r7
 8011d14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011d18:	4770      	bx	lr
 8011d1a:	bf00      	nop
 8011d1c:	20009a34 	.word	0x20009a34

08011d20 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8011d20:	b580      	push	{r7, lr}
 8011d22:	b084      	sub	sp, #16
 8011d24:	af00      	add	r7, sp, #0
 8011d26:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8011d28:	f7ff ffee 	bl	8011d08 <HAL_GetTick>
 8011d2c:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8011d2e:	687b      	ldr	r3, [r7, #4]
 8011d30:	60fb      	str	r3, [r7, #12]

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8011d32:	68fb      	ldr	r3, [r7, #12]
 8011d34:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8011d38:	d004      	beq.n	8011d44 <HAL_Delay+0x24>
  {
    wait += (uint32_t)(uwTickFreq);
 8011d3a:	4b09      	ldr	r3, [pc, #36]	; (8011d60 <HAL_Delay+0x40>)
 8011d3c:	681b      	ldr	r3, [r3, #0]
 8011d3e:	68fa      	ldr	r2, [r7, #12]
 8011d40:	4413      	add	r3, r2
 8011d42:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 8011d44:	bf00      	nop
 8011d46:	f7ff ffdf 	bl	8011d08 <HAL_GetTick>
 8011d4a:	4602      	mov	r2, r0
 8011d4c:	68bb      	ldr	r3, [r7, #8]
 8011d4e:	1ad3      	subs	r3, r2, r3
 8011d50:	68fa      	ldr	r2, [r7, #12]
 8011d52:	429a      	cmp	r2, r3
 8011d54:	d8f7      	bhi.n	8011d46 <HAL_Delay+0x26>
  {
  }
}
 8011d56:	bf00      	nop
 8011d58:	3710      	adds	r7, #16
 8011d5a:	46bd      	mov	sp, r7
 8011d5c:	bd80      	pop	{r7, pc}
 8011d5e:	bf00      	nop
 8011d60:	20000070 	.word	0x20000070

08011d64 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8011d64:	b480      	push	{r7}
 8011d66:	b085      	sub	sp, #20
 8011d68:	af00      	add	r7, sp, #0
 8011d6a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8011d6c:	687b      	ldr	r3, [r7, #4]
 8011d6e:	f003 0307 	and.w	r3, r3, #7
 8011d72:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8011d74:	4b0c      	ldr	r3, [pc, #48]	; (8011da8 <__NVIC_SetPriorityGrouping+0x44>)
 8011d76:	68db      	ldr	r3, [r3, #12]
 8011d78:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8011d7a:	68ba      	ldr	r2, [r7, #8]
 8011d7c:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8011d80:	4013      	ands	r3, r2
 8011d82:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8011d84:	68fb      	ldr	r3, [r7, #12]
 8011d86:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8011d88:	68bb      	ldr	r3, [r7, #8]
 8011d8a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8011d8c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8011d90:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8011d94:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8011d96:	4a04      	ldr	r2, [pc, #16]	; (8011da8 <__NVIC_SetPriorityGrouping+0x44>)
 8011d98:	68bb      	ldr	r3, [r7, #8]
 8011d9a:	60d3      	str	r3, [r2, #12]
}
 8011d9c:	bf00      	nop
 8011d9e:	3714      	adds	r7, #20
 8011da0:	46bd      	mov	sp, r7
 8011da2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011da6:	4770      	bx	lr
 8011da8:	e000ed00 	.word	0xe000ed00

08011dac <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8011dac:	b480      	push	{r7}
 8011dae:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8011db0:	4b04      	ldr	r3, [pc, #16]	; (8011dc4 <__NVIC_GetPriorityGrouping+0x18>)
 8011db2:	68db      	ldr	r3, [r3, #12]
 8011db4:	0a1b      	lsrs	r3, r3, #8
 8011db6:	f003 0307 	and.w	r3, r3, #7
}
 8011dba:	4618      	mov	r0, r3
 8011dbc:	46bd      	mov	sp, r7
 8011dbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011dc2:	4770      	bx	lr
 8011dc4:	e000ed00 	.word	0xe000ed00

08011dc8 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8011dc8:	b480      	push	{r7}
 8011dca:	b083      	sub	sp, #12
 8011dcc:	af00      	add	r7, sp, #0
 8011dce:	4603      	mov	r3, r0
 8011dd0:	6039      	str	r1, [r7, #0]
 8011dd2:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8011dd4:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8011dd8:	2b00      	cmp	r3, #0
 8011dda:	db0a      	blt.n	8011df2 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8011ddc:	683b      	ldr	r3, [r7, #0]
 8011dde:	b2da      	uxtb	r2, r3
 8011de0:	490c      	ldr	r1, [pc, #48]	; (8011e14 <__NVIC_SetPriority+0x4c>)
 8011de2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8011de6:	0112      	lsls	r2, r2, #4
 8011de8:	b2d2      	uxtb	r2, r2
 8011dea:	440b      	add	r3, r1
 8011dec:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8011df0:	e00a      	b.n	8011e08 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8011df2:	683b      	ldr	r3, [r7, #0]
 8011df4:	b2da      	uxtb	r2, r3
 8011df6:	4908      	ldr	r1, [pc, #32]	; (8011e18 <__NVIC_SetPriority+0x50>)
 8011df8:	79fb      	ldrb	r3, [r7, #7]
 8011dfa:	f003 030f 	and.w	r3, r3, #15
 8011dfe:	3b04      	subs	r3, #4
 8011e00:	0112      	lsls	r2, r2, #4
 8011e02:	b2d2      	uxtb	r2, r2
 8011e04:	440b      	add	r3, r1
 8011e06:	761a      	strb	r2, [r3, #24]
}
 8011e08:	bf00      	nop
 8011e0a:	370c      	adds	r7, #12
 8011e0c:	46bd      	mov	sp, r7
 8011e0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e12:	4770      	bx	lr
 8011e14:	e000e100 	.word	0xe000e100
 8011e18:	e000ed00 	.word	0xe000ed00

08011e1c <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8011e1c:	b480      	push	{r7}
 8011e1e:	b089      	sub	sp, #36	; 0x24
 8011e20:	af00      	add	r7, sp, #0
 8011e22:	60f8      	str	r0, [r7, #12]
 8011e24:	60b9      	str	r1, [r7, #8]
 8011e26:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8011e28:	68fb      	ldr	r3, [r7, #12]
 8011e2a:	f003 0307 	and.w	r3, r3, #7
 8011e2e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8011e30:	69fb      	ldr	r3, [r7, #28]
 8011e32:	f1c3 0307 	rsb	r3, r3, #7
 8011e36:	2b04      	cmp	r3, #4
 8011e38:	bf28      	it	cs
 8011e3a:	2304      	movcs	r3, #4
 8011e3c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8011e3e:	69fb      	ldr	r3, [r7, #28]
 8011e40:	3304      	adds	r3, #4
 8011e42:	2b06      	cmp	r3, #6
 8011e44:	d902      	bls.n	8011e4c <NVIC_EncodePriority+0x30>
 8011e46:	69fb      	ldr	r3, [r7, #28]
 8011e48:	3b03      	subs	r3, #3
 8011e4a:	e000      	b.n	8011e4e <NVIC_EncodePriority+0x32>
 8011e4c:	2300      	movs	r3, #0
 8011e4e:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8011e50:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8011e54:	69bb      	ldr	r3, [r7, #24]
 8011e56:	fa02 f303 	lsl.w	r3, r2, r3
 8011e5a:	43da      	mvns	r2, r3
 8011e5c:	68bb      	ldr	r3, [r7, #8]
 8011e5e:	401a      	ands	r2, r3
 8011e60:	697b      	ldr	r3, [r7, #20]
 8011e62:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8011e64:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8011e68:	697b      	ldr	r3, [r7, #20]
 8011e6a:	fa01 f303 	lsl.w	r3, r1, r3
 8011e6e:	43d9      	mvns	r1, r3
 8011e70:	687b      	ldr	r3, [r7, #4]
 8011e72:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8011e74:	4313      	orrs	r3, r2
         );
}
 8011e76:	4618      	mov	r0, r3
 8011e78:	3724      	adds	r7, #36	; 0x24
 8011e7a:	46bd      	mov	sp, r7
 8011e7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e80:	4770      	bx	lr
	...

08011e84 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8011e84:	b580      	push	{r7, lr}
 8011e86:	b082      	sub	sp, #8
 8011e88:	af00      	add	r7, sp, #0
 8011e8a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8011e8c:	687b      	ldr	r3, [r7, #4]
 8011e8e:	3b01      	subs	r3, #1
 8011e90:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8011e94:	d301      	bcc.n	8011e9a <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8011e96:	2301      	movs	r3, #1
 8011e98:	e00f      	b.n	8011eba <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8011e9a:	4a0a      	ldr	r2, [pc, #40]	; (8011ec4 <SysTick_Config+0x40>)
 8011e9c:	687b      	ldr	r3, [r7, #4]
 8011e9e:	3b01      	subs	r3, #1
 8011ea0:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8011ea2:	210f      	movs	r1, #15
 8011ea4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8011ea8:	f7ff ff8e 	bl	8011dc8 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8011eac:	4b05      	ldr	r3, [pc, #20]	; (8011ec4 <SysTick_Config+0x40>)
 8011eae:	2200      	movs	r2, #0
 8011eb0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8011eb2:	4b04      	ldr	r3, [pc, #16]	; (8011ec4 <SysTick_Config+0x40>)
 8011eb4:	2207      	movs	r2, #7
 8011eb6:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8011eb8:	2300      	movs	r3, #0
}
 8011eba:	4618      	mov	r0, r3
 8011ebc:	3708      	adds	r7, #8
 8011ebe:	46bd      	mov	sp, r7
 8011ec0:	bd80      	pop	{r7, pc}
 8011ec2:	bf00      	nop
 8011ec4:	e000e010 	.word	0xe000e010

08011ec8 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8011ec8:	b580      	push	{r7, lr}
 8011eca:	b082      	sub	sp, #8
 8011ecc:	af00      	add	r7, sp, #0
 8011ece:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8011ed0:	6878      	ldr	r0, [r7, #4]
 8011ed2:	f7ff ff47 	bl	8011d64 <__NVIC_SetPriorityGrouping>
}
 8011ed6:	bf00      	nop
 8011ed8:	3708      	adds	r7, #8
 8011eda:	46bd      	mov	sp, r7
 8011edc:	bd80      	pop	{r7, pc}

08011ede <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8011ede:	b580      	push	{r7, lr}
 8011ee0:	b086      	sub	sp, #24
 8011ee2:	af00      	add	r7, sp, #0
 8011ee4:	4603      	mov	r3, r0
 8011ee6:	60b9      	str	r1, [r7, #8]
 8011ee8:	607a      	str	r2, [r7, #4]
 8011eea:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
 8011eec:	2300      	movs	r3, #0
 8011eee:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 8011ef0:	f7ff ff5c 	bl	8011dac <__NVIC_GetPriorityGrouping>
 8011ef4:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8011ef6:	687a      	ldr	r2, [r7, #4]
 8011ef8:	68b9      	ldr	r1, [r7, #8]
 8011efa:	6978      	ldr	r0, [r7, #20]
 8011efc:	f7ff ff8e 	bl	8011e1c <NVIC_EncodePriority>
 8011f00:	4602      	mov	r2, r0
 8011f02:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8011f06:	4611      	mov	r1, r2
 8011f08:	4618      	mov	r0, r3
 8011f0a:	f7ff ff5d 	bl	8011dc8 <__NVIC_SetPriority>
}
 8011f0e:	bf00      	nop
 8011f10:	3718      	adds	r7, #24
 8011f12:	46bd      	mov	sp, r7
 8011f14:	bd80      	pop	{r7, pc}

08011f16 <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8011f16:	b580      	push	{r7, lr}
 8011f18:	b082      	sub	sp, #8
 8011f1a:	af00      	add	r7, sp, #0
 8011f1c:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8011f1e:	6878      	ldr	r0, [r7, #4]
 8011f20:	f7ff ffb0 	bl	8011e84 <SysTick_Config>
 8011f24:	4603      	mov	r3, r0
}
 8011f26:	4618      	mov	r0, r3
 8011f28:	3708      	adds	r7, #8
 8011f2a:	46bd      	mov	sp, r7
 8011f2c:	bd80      	pop	{r7, pc}
	...

08011f30 <HAL_CRC_Init>:
  *         parameters in the CRC_InitTypeDef and create the associated handle.
  * @param  hcrc CRC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
 8011f30:	b580      	push	{r7, lr}
 8011f32:	b082      	sub	sp, #8
 8011f34:	af00      	add	r7, sp, #0
 8011f36:	6078      	str	r0, [r7, #4]
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 8011f38:	687b      	ldr	r3, [r7, #4]
 8011f3a:	2b00      	cmp	r3, #0
 8011f3c:	d101      	bne.n	8011f42 <HAL_CRC_Init+0x12>
  {
    return HAL_ERROR;
 8011f3e:	2301      	movs	r3, #1
 8011f40:	e054      	b.n	8011fec <HAL_CRC_Init+0xbc>
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if (hcrc->State == HAL_CRC_STATE_RESET)
 8011f42:	687b      	ldr	r3, [r7, #4]
 8011f44:	7f5b      	ldrb	r3, [r3, #29]
 8011f46:	b2db      	uxtb	r3, r3
 8011f48:	2b00      	cmp	r3, #0
 8011f4a:	d105      	bne.n	8011f58 <HAL_CRC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
 8011f4c:	687b      	ldr	r3, [r7, #4]
 8011f4e:	2200      	movs	r2, #0
 8011f50:	771a      	strb	r2, [r3, #28]
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
 8011f52:	6878      	ldr	r0, [r7, #4]
 8011f54:	f7ff fd64 	bl	8011a20 <HAL_CRC_MspInit>
  }

  hcrc->State = HAL_CRC_STATE_BUSY;
 8011f58:	687b      	ldr	r3, [r7, #4]
 8011f5a:	2202      	movs	r2, #2
 8011f5c:	775a      	strb	r2, [r3, #29]

  /* check whether or not non-default generating polynomial has been
   * picked up by user */
  assert_param(IS_DEFAULT_POLYNOMIAL(hcrc->Init.DefaultPolynomialUse));
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 8011f5e:	687b      	ldr	r3, [r7, #4]
 8011f60:	791b      	ldrb	r3, [r3, #4]
 8011f62:	2b00      	cmp	r3, #0
 8011f64:	d10c      	bne.n	8011f80 <HAL_CRC_Init+0x50>
  {
    /* initialize peripheral with default generating polynomial */
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 8011f66:	687b      	ldr	r3, [r7, #4]
 8011f68:	681b      	ldr	r3, [r3, #0]
 8011f6a:	4a22      	ldr	r2, [pc, #136]	; (8011ff4 <HAL_CRC_Init+0xc4>)
 8011f6c:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8011f6e:	687b      	ldr	r3, [r7, #4]
 8011f70:	681b      	ldr	r3, [r3, #0]
 8011f72:	689a      	ldr	r2, [r3, #8]
 8011f74:	687b      	ldr	r3, [r7, #4]
 8011f76:	681b      	ldr	r3, [r3, #0]
 8011f78:	f022 0218 	bic.w	r2, r2, #24
 8011f7c:	609a      	str	r2, [r3, #8]
 8011f7e:	e00c      	b.n	8011f9a <HAL_CRC_Init+0x6a>
  }
  else
  {
    /* initialize CRC peripheral with generating polynomial defined by user */
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 8011f80:	687b      	ldr	r3, [r7, #4]
 8011f82:	6899      	ldr	r1, [r3, #8]
 8011f84:	687b      	ldr	r3, [r7, #4]
 8011f86:	68db      	ldr	r3, [r3, #12]
 8011f88:	461a      	mov	r2, r3
 8011f8a:	6878      	ldr	r0, [r7, #4]
 8011f8c:	f000 f834 	bl	8011ff8 <HAL_CRCEx_Polynomial_Set>
 8011f90:	4603      	mov	r3, r0
 8011f92:	2b00      	cmp	r3, #0
 8011f94:	d001      	beq.n	8011f9a <HAL_CRC_Init+0x6a>
    {
      return HAL_ERROR;
 8011f96:	2301      	movs	r3, #1
 8011f98:	e028      	b.n	8011fec <HAL_CRC_Init+0xbc>
  }

  /* check whether or not non-default CRC initial value has been
   * picked up by user */
  assert_param(IS_DEFAULT_INIT_VALUE(hcrc->Init.DefaultInitValueUse));
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 8011f9a:	687b      	ldr	r3, [r7, #4]
 8011f9c:	795b      	ldrb	r3, [r3, #5]
 8011f9e:	2b00      	cmp	r3, #0
 8011fa0:	d105      	bne.n	8011fae <HAL_CRC_Init+0x7e>
  {
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 8011fa2:	687b      	ldr	r3, [r7, #4]
 8011fa4:	681b      	ldr	r3, [r3, #0]
 8011fa6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8011faa:	611a      	str	r2, [r3, #16]
 8011fac:	e004      	b.n	8011fb8 <HAL_CRC_Init+0x88>
  }
  else
  {
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 8011fae:	687b      	ldr	r3, [r7, #4]
 8011fb0:	681b      	ldr	r3, [r3, #0]
 8011fb2:	687a      	ldr	r2, [r7, #4]
 8011fb4:	6912      	ldr	r2, [r2, #16]
 8011fb6:	611a      	str	r2, [r3, #16]
  }


  /* set input data inversion mode */
  assert_param(IS_CRC_INPUTDATA_INVERSION_MODE(hcrc->Init.InputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 8011fb8:	687b      	ldr	r3, [r7, #4]
 8011fba:	681b      	ldr	r3, [r3, #0]
 8011fbc:	689b      	ldr	r3, [r3, #8]
 8011fbe:	f023 0160 	bic.w	r1, r3, #96	; 0x60
 8011fc2:	687b      	ldr	r3, [r7, #4]
 8011fc4:	695a      	ldr	r2, [r3, #20]
 8011fc6:	687b      	ldr	r3, [r7, #4]
 8011fc8:	681b      	ldr	r3, [r3, #0]
 8011fca:	430a      	orrs	r2, r1
 8011fcc:	609a      	str	r2, [r3, #8]

  /* set output data inversion mode */
  assert_param(IS_CRC_OUTPUTDATA_INVERSION_MODE(hcrc->Init.OutputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 8011fce:	687b      	ldr	r3, [r7, #4]
 8011fd0:	681b      	ldr	r3, [r3, #0]
 8011fd2:	689b      	ldr	r3, [r3, #8]
 8011fd4:	f023 0180 	bic.w	r1, r3, #128	; 0x80
 8011fd8:	687b      	ldr	r3, [r7, #4]
 8011fda:	699a      	ldr	r2, [r3, #24]
 8011fdc:	687b      	ldr	r3, [r7, #4]
 8011fde:	681b      	ldr	r3, [r3, #0]
 8011fe0:	430a      	orrs	r2, r1
 8011fe2:	609a      	str	r2, [r3, #8]
  /* makes sure the input data format (bytes, halfwords or words stream)
   * is properly specified by user */
  assert_param(IS_CRC_INPUTDATA_FORMAT(hcrc->InputDataFormat));

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 8011fe4:	687b      	ldr	r3, [r7, #4]
 8011fe6:	2201      	movs	r2, #1
 8011fe8:	775a      	strb	r2, [r3, #29]

  /* Return function status */
  return HAL_OK;
 8011fea:	2300      	movs	r3, #0
}
 8011fec:	4618      	mov	r0, r3
 8011fee:	3708      	adds	r7, #8
 8011ff0:	46bd      	mov	sp, r7
 8011ff2:	bd80      	pop	{r7, pc}
 8011ff4:	04c11db7 	.word	0x04c11db7

08011ff8 <HAL_CRCEx_Polynomial_Set>:
  *          @arg @ref CRC_POLYLENGTH_16B 16-bit long CRC (generating polynomial of degree 16)
  *          @arg @ref CRC_POLYLENGTH_32B 32-bit long CRC (generating polynomial of degree 32)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 8011ff8:	b480      	push	{r7}
 8011ffa:	b087      	sub	sp, #28
 8011ffc:	af00      	add	r7, sp, #0
 8011ffe:	60f8      	str	r0, [r7, #12]
 8012000:	60b9      	str	r1, [r7, #8]
 8012002:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8012004:	2300      	movs	r3, #0
 8012006:	75fb      	strb	r3, [r7, #23]
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 8012008:	231f      	movs	r3, #31
 801200a:	613b      	str	r3, [r7, #16]
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 801200c:	bf00      	nop
 801200e:	693b      	ldr	r3, [r7, #16]
 8012010:	1e5a      	subs	r2, r3, #1
 8012012:	613a      	str	r2, [r7, #16]
 8012014:	2b00      	cmp	r3, #0
 8012016:	d009      	beq.n	801202c <HAL_CRCEx_Polynomial_Set+0x34>
 8012018:	693b      	ldr	r3, [r7, #16]
 801201a:	f003 031f 	and.w	r3, r3, #31
 801201e:	68ba      	ldr	r2, [r7, #8]
 8012020:	fa22 f303 	lsr.w	r3, r2, r3
 8012024:	f003 0301 	and.w	r3, r3, #1
 8012028:	2b00      	cmp	r3, #0
 801202a:	d0f0      	beq.n	801200e <HAL_CRCEx_Polynomial_Set+0x16>
  {
  }

  switch (PolyLength)
 801202c:	687b      	ldr	r3, [r7, #4]
 801202e:	2b18      	cmp	r3, #24
 8012030:	d846      	bhi.n	80120c0 <HAL_CRCEx_Polynomial_Set+0xc8>
 8012032:	a201      	add	r2, pc, #4	; (adr r2, 8012038 <HAL_CRCEx_Polynomial_Set+0x40>)
 8012034:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012038:	080120c7 	.word	0x080120c7
 801203c:	080120c1 	.word	0x080120c1
 8012040:	080120c1 	.word	0x080120c1
 8012044:	080120c1 	.word	0x080120c1
 8012048:	080120c1 	.word	0x080120c1
 801204c:	080120c1 	.word	0x080120c1
 8012050:	080120c1 	.word	0x080120c1
 8012054:	080120c1 	.word	0x080120c1
 8012058:	080120b5 	.word	0x080120b5
 801205c:	080120c1 	.word	0x080120c1
 8012060:	080120c1 	.word	0x080120c1
 8012064:	080120c1 	.word	0x080120c1
 8012068:	080120c1 	.word	0x080120c1
 801206c:	080120c1 	.word	0x080120c1
 8012070:	080120c1 	.word	0x080120c1
 8012074:	080120c1 	.word	0x080120c1
 8012078:	080120a9 	.word	0x080120a9
 801207c:	080120c1 	.word	0x080120c1
 8012080:	080120c1 	.word	0x080120c1
 8012084:	080120c1 	.word	0x080120c1
 8012088:	080120c1 	.word	0x080120c1
 801208c:	080120c1 	.word	0x080120c1
 8012090:	080120c1 	.word	0x080120c1
 8012094:	080120c1 	.word	0x080120c1
 8012098:	0801209d 	.word	0x0801209d
  {
    case CRC_POLYLENGTH_7B:
      if (msb >= HAL_CRC_LENGTH_7B)
 801209c:	693b      	ldr	r3, [r7, #16]
 801209e:	2b06      	cmp	r3, #6
 80120a0:	d913      	bls.n	80120ca <HAL_CRCEx_Polynomial_Set+0xd2>
      {
        status =   HAL_ERROR;
 80120a2:	2301      	movs	r3, #1
 80120a4:	75fb      	strb	r3, [r7, #23]
      }
      break;
 80120a6:	e010      	b.n	80120ca <HAL_CRCEx_Polynomial_Set+0xd2>
    case CRC_POLYLENGTH_8B:
      if (msb >= HAL_CRC_LENGTH_8B)
 80120a8:	693b      	ldr	r3, [r7, #16]
 80120aa:	2b07      	cmp	r3, #7
 80120ac:	d90f      	bls.n	80120ce <HAL_CRCEx_Polynomial_Set+0xd6>
      {
        status =   HAL_ERROR;
 80120ae:	2301      	movs	r3, #1
 80120b0:	75fb      	strb	r3, [r7, #23]
      }
      break;
 80120b2:	e00c      	b.n	80120ce <HAL_CRCEx_Polynomial_Set+0xd6>
    case CRC_POLYLENGTH_16B:
      if (msb >= HAL_CRC_LENGTH_16B)
 80120b4:	693b      	ldr	r3, [r7, #16]
 80120b6:	2b0f      	cmp	r3, #15
 80120b8:	d90b      	bls.n	80120d2 <HAL_CRCEx_Polynomial_Set+0xda>
      {
        status =   HAL_ERROR;
 80120ba:	2301      	movs	r3, #1
 80120bc:	75fb      	strb	r3, [r7, #23]
      }
      break;
 80120be:	e008      	b.n	80120d2 <HAL_CRCEx_Polynomial_Set+0xda>

    case CRC_POLYLENGTH_32B:
      /* no polynomial definition vs. polynomial length issue possible */
      break;
    default:
      status =  HAL_ERROR;
 80120c0:	2301      	movs	r3, #1
 80120c2:	75fb      	strb	r3, [r7, #23]
      break;
 80120c4:	e006      	b.n	80120d4 <HAL_CRCEx_Polynomial_Set+0xdc>
      break;
 80120c6:	bf00      	nop
 80120c8:	e004      	b.n	80120d4 <HAL_CRCEx_Polynomial_Set+0xdc>
      break;
 80120ca:	bf00      	nop
 80120cc:	e002      	b.n	80120d4 <HAL_CRCEx_Polynomial_Set+0xdc>
      break;
 80120ce:	bf00      	nop
 80120d0:	e000      	b.n	80120d4 <HAL_CRCEx_Polynomial_Set+0xdc>
      break;
 80120d2:	bf00      	nop
  }
  if (status == HAL_OK)
 80120d4:	7dfb      	ldrb	r3, [r7, #23]
 80120d6:	2b00      	cmp	r3, #0
 80120d8:	d10d      	bne.n	80120f6 <HAL_CRCEx_Polynomial_Set+0xfe>
  {
    /* set generating polynomial */
    WRITE_REG(hcrc->Instance->POL, Pol);
 80120da:	68fb      	ldr	r3, [r7, #12]
 80120dc:	681b      	ldr	r3, [r3, #0]
 80120de:	68ba      	ldr	r2, [r7, #8]
 80120e0:	615a      	str	r2, [r3, #20]

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 80120e2:	68fb      	ldr	r3, [r7, #12]
 80120e4:	681b      	ldr	r3, [r3, #0]
 80120e6:	689b      	ldr	r3, [r3, #8]
 80120e8:	f023 0118 	bic.w	r1, r3, #24
 80120ec:	68fb      	ldr	r3, [r7, #12]
 80120ee:	681b      	ldr	r3, [r3, #0]
 80120f0:	687a      	ldr	r2, [r7, #4]
 80120f2:	430a      	orrs	r2, r1
 80120f4:	609a      	str	r2, [r3, #8]
  }
  /* Return function status */
  return status;
 80120f6:	7dfb      	ldrb	r3, [r7, #23]
}
 80120f8:	4618      	mov	r0, r3
 80120fa:	371c      	adds	r7, #28
 80120fc:	46bd      	mov	sp, r7
 80120fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012102:	4770      	bx	lr

08012104 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8012104:	b480      	push	{r7}
 8012106:	b087      	sub	sp, #28
 8012108:	af00      	add	r7, sp, #0
 801210a:	6078      	str	r0, [r7, #4]
 801210c:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 801210e:	2300      	movs	r3, #0
 8012110:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8012112:	e154      	b.n	80123be <HAL_GPIO_Init+0x2ba>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8012114:	683b      	ldr	r3, [r7, #0]
 8012116:	681a      	ldr	r2, [r3, #0]
 8012118:	2101      	movs	r1, #1
 801211a:	697b      	ldr	r3, [r7, #20]
 801211c:	fa01 f303 	lsl.w	r3, r1, r3
 8012120:	4013      	ands	r3, r2
 8012122:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 8012124:	68fb      	ldr	r3, [r7, #12]
 8012126:	2b00      	cmp	r3, #0
 8012128:	f000 8146 	beq.w	80123b8 <HAL_GPIO_Init+0x2b4>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 801212c:	683b      	ldr	r3, [r7, #0]
 801212e:	685b      	ldr	r3, [r3, #4]
 8012130:	2b01      	cmp	r3, #1
 8012132:	d00b      	beq.n	801214c <HAL_GPIO_Init+0x48>
 8012134:	683b      	ldr	r3, [r7, #0]
 8012136:	685b      	ldr	r3, [r3, #4]
 8012138:	2b02      	cmp	r3, #2
 801213a:	d007      	beq.n	801214c <HAL_GPIO_Init+0x48>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 801213c:	683b      	ldr	r3, [r7, #0]
 801213e:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8012140:	2b11      	cmp	r3, #17
 8012142:	d003      	beq.n	801214c <HAL_GPIO_Init+0x48>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8012144:	683b      	ldr	r3, [r7, #0]
 8012146:	685b      	ldr	r3, [r3, #4]
 8012148:	2b12      	cmp	r3, #18
 801214a:	d130      	bne.n	80121ae <HAL_GPIO_Init+0xaa>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 801214c:	687b      	ldr	r3, [r7, #4]
 801214e:	689b      	ldr	r3, [r3, #8]
 8012150:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 8012152:	697b      	ldr	r3, [r7, #20]
 8012154:	005b      	lsls	r3, r3, #1
 8012156:	2203      	movs	r2, #3
 8012158:	fa02 f303 	lsl.w	r3, r2, r3
 801215c:	43db      	mvns	r3, r3
 801215e:	693a      	ldr	r2, [r7, #16]
 8012160:	4013      	ands	r3, r2
 8012162:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
 8012164:	683b      	ldr	r3, [r7, #0]
 8012166:	68da      	ldr	r2, [r3, #12]
 8012168:	697b      	ldr	r3, [r7, #20]
 801216a:	005b      	lsls	r3, r3, #1
 801216c:	fa02 f303 	lsl.w	r3, r2, r3
 8012170:	693a      	ldr	r2, [r7, #16]
 8012172:	4313      	orrs	r3, r2
 8012174:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 8012176:	687b      	ldr	r3, [r7, #4]
 8012178:	693a      	ldr	r2, [r7, #16]
 801217a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 801217c:	687b      	ldr	r3, [r7, #4]
 801217e:	685b      	ldr	r3, [r3, #4]
 8012180:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8012182:	2201      	movs	r2, #1
 8012184:	697b      	ldr	r3, [r7, #20]
 8012186:	fa02 f303 	lsl.w	r3, r2, r3
 801218a:	43db      	mvns	r3, r3
 801218c:	693a      	ldr	r2, [r7, #16]
 801218e:	4013      	ands	r3, r2
 8012190:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 8012192:	683b      	ldr	r3, [r7, #0]
 8012194:	685b      	ldr	r3, [r3, #4]
 8012196:	091b      	lsrs	r3, r3, #4
 8012198:	f003 0201 	and.w	r2, r3, #1
 801219c:	697b      	ldr	r3, [r7, #20]
 801219e:	fa02 f303 	lsl.w	r3, r2, r3
 80121a2:	693a      	ldr	r2, [r7, #16]
 80121a4:	4313      	orrs	r3, r2
 80121a6:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 80121a8:	687b      	ldr	r3, [r7, #4]
 80121aa:	693a      	ldr	r2, [r7, #16]
 80121ac:	605a      	str	r2, [r3, #4]
      }

#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 80121ae:	687b      	ldr	r3, [r7, #4]
 80121b0:	68db      	ldr	r3, [r3, #12]
 80121b2:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 80121b4:	697b      	ldr	r3, [r7, #20]
 80121b6:	005b      	lsls	r3, r3, #1
 80121b8:	2203      	movs	r2, #3
 80121ba:	fa02 f303 	lsl.w	r3, r2, r3
 80121be:	43db      	mvns	r3, r3
 80121c0:	693a      	ldr	r2, [r7, #16]
 80121c2:	4013      	ands	r3, r2
 80121c4:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 80121c6:	683b      	ldr	r3, [r7, #0]
 80121c8:	689a      	ldr	r2, [r3, #8]
 80121ca:	697b      	ldr	r3, [r7, #20]
 80121cc:	005b      	lsls	r3, r3, #1
 80121ce:	fa02 f303 	lsl.w	r3, r2, r3
 80121d2:	693a      	ldr	r2, [r7, #16]
 80121d4:	4313      	orrs	r3, r2
 80121d6:	613b      	str	r3, [r7, #16]
      GPIOx->PUPDR = temp;
 80121d8:	687b      	ldr	r3, [r7, #4]
 80121da:	693a      	ldr	r2, [r7, #16]
 80121dc:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80121de:	683b      	ldr	r3, [r7, #0]
 80121e0:	685b      	ldr	r3, [r3, #4]
 80121e2:	2b02      	cmp	r3, #2
 80121e4:	d003      	beq.n	80121ee <HAL_GPIO_Init+0xea>
 80121e6:	683b      	ldr	r3, [r7, #0]
 80121e8:	685b      	ldr	r3, [r3, #4]
 80121ea:	2b12      	cmp	r3, #18
 80121ec:	d123      	bne.n	8012236 <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
 80121ee:	697b      	ldr	r3, [r7, #20]
 80121f0:	08da      	lsrs	r2, r3, #3
 80121f2:	687b      	ldr	r3, [r7, #4]
 80121f4:	3208      	adds	r2, #8
 80121f6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80121fa:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80121fc:	697b      	ldr	r3, [r7, #20]
 80121fe:	f003 0307 	and.w	r3, r3, #7
 8012202:	009b      	lsls	r3, r3, #2
 8012204:	220f      	movs	r2, #15
 8012206:	fa02 f303 	lsl.w	r3, r2, r3
 801220a:	43db      	mvns	r3, r3
 801220c:	693a      	ldr	r2, [r7, #16]
 801220e:	4013      	ands	r3, r2
 8012210:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 8012212:	683b      	ldr	r3, [r7, #0]
 8012214:	691a      	ldr	r2, [r3, #16]
 8012216:	697b      	ldr	r3, [r7, #20]
 8012218:	f003 0307 	and.w	r3, r3, #7
 801221c:	009b      	lsls	r3, r3, #2
 801221e:	fa02 f303 	lsl.w	r3, r2, r3
 8012222:	693a      	ldr	r2, [r7, #16]
 8012224:	4313      	orrs	r3, r2
 8012226:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
 8012228:	697b      	ldr	r3, [r7, #20]
 801222a:	08da      	lsrs	r2, r3, #3
 801222c:	687b      	ldr	r3, [r7, #4]
 801222e:	3208      	adds	r2, #8
 8012230:	6939      	ldr	r1, [r7, #16]
 8012232:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8012236:	687b      	ldr	r3, [r7, #4]
 8012238:	681b      	ldr	r3, [r3, #0]
 801223a:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 801223c:	697b      	ldr	r3, [r7, #20]
 801223e:	005b      	lsls	r3, r3, #1
 8012240:	2203      	movs	r2, #3
 8012242:	fa02 f303 	lsl.w	r3, r2, r3
 8012246:	43db      	mvns	r3, r3
 8012248:	693a      	ldr	r2, [r7, #16]
 801224a:	4013      	ands	r3, r2
 801224c:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 801224e:	683b      	ldr	r3, [r7, #0]
 8012250:	685b      	ldr	r3, [r3, #4]
 8012252:	f003 0203 	and.w	r2, r3, #3
 8012256:	697b      	ldr	r3, [r7, #20]
 8012258:	005b      	lsls	r3, r3, #1
 801225a:	fa02 f303 	lsl.w	r3, r2, r3
 801225e:	693a      	ldr	r2, [r7, #16]
 8012260:	4313      	orrs	r3, r2
 8012262:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 8012264:	687b      	ldr	r3, [r7, #4]
 8012266:	693a      	ldr	r2, [r7, #16]
 8012268:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 801226a:	683b      	ldr	r3, [r7, #0]
 801226c:	685b      	ldr	r3, [r3, #4]
 801226e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8012272:	2b00      	cmp	r3, #0
 8012274:	f000 80a0 	beq.w	80123b8 <HAL_GPIO_Init+0x2b4>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8012278:	4b58      	ldr	r3, [pc, #352]	; (80123dc <HAL_GPIO_Init+0x2d8>)
 801227a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 801227c:	4a57      	ldr	r2, [pc, #348]	; (80123dc <HAL_GPIO_Init+0x2d8>)
 801227e:	f043 0301 	orr.w	r3, r3, #1
 8012282:	6613      	str	r3, [r2, #96]	; 0x60
 8012284:	4b55      	ldr	r3, [pc, #340]	; (80123dc <HAL_GPIO_Init+0x2d8>)
 8012286:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8012288:	f003 0301 	and.w	r3, r3, #1
 801228c:	60bb      	str	r3, [r7, #8]
 801228e:	68bb      	ldr	r3, [r7, #8]

        temp = SYSCFG->EXTICR[position >> 2u];
 8012290:	4a53      	ldr	r2, [pc, #332]	; (80123e0 <HAL_GPIO_Init+0x2dc>)
 8012292:	697b      	ldr	r3, [r7, #20]
 8012294:	089b      	lsrs	r3, r3, #2
 8012296:	3302      	adds	r3, #2
 8012298:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801229c:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 801229e:	697b      	ldr	r3, [r7, #20]
 80122a0:	f003 0303 	and.w	r3, r3, #3
 80122a4:	009b      	lsls	r3, r3, #2
 80122a6:	220f      	movs	r2, #15
 80122a8:	fa02 f303 	lsl.w	r3, r2, r3
 80122ac:	43db      	mvns	r3, r3
 80122ae:	693a      	ldr	r2, [r7, #16]
 80122b0:	4013      	ands	r3, r2
 80122b2:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 80122b4:	687b      	ldr	r3, [r7, #4]
 80122b6:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
 80122ba:	d019      	beq.n	80122f0 <HAL_GPIO_Init+0x1ec>
 80122bc:	687b      	ldr	r3, [r7, #4]
 80122be:	4a49      	ldr	r2, [pc, #292]	; (80123e4 <HAL_GPIO_Init+0x2e0>)
 80122c0:	4293      	cmp	r3, r2
 80122c2:	d013      	beq.n	80122ec <HAL_GPIO_Init+0x1e8>
 80122c4:	687b      	ldr	r3, [r7, #4]
 80122c6:	4a48      	ldr	r2, [pc, #288]	; (80123e8 <HAL_GPIO_Init+0x2e4>)
 80122c8:	4293      	cmp	r3, r2
 80122ca:	d00d      	beq.n	80122e8 <HAL_GPIO_Init+0x1e4>
 80122cc:	687b      	ldr	r3, [r7, #4]
 80122ce:	4a47      	ldr	r2, [pc, #284]	; (80123ec <HAL_GPIO_Init+0x2e8>)
 80122d0:	4293      	cmp	r3, r2
 80122d2:	d007      	beq.n	80122e4 <HAL_GPIO_Init+0x1e0>
 80122d4:	687b      	ldr	r3, [r7, #4]
 80122d6:	4a46      	ldr	r2, [pc, #280]	; (80123f0 <HAL_GPIO_Init+0x2ec>)
 80122d8:	4293      	cmp	r3, r2
 80122da:	d101      	bne.n	80122e0 <HAL_GPIO_Init+0x1dc>
 80122dc:	2304      	movs	r3, #4
 80122de:	e008      	b.n	80122f2 <HAL_GPIO_Init+0x1ee>
 80122e0:	2307      	movs	r3, #7
 80122e2:	e006      	b.n	80122f2 <HAL_GPIO_Init+0x1ee>
 80122e4:	2303      	movs	r3, #3
 80122e6:	e004      	b.n	80122f2 <HAL_GPIO_Init+0x1ee>
 80122e8:	2302      	movs	r3, #2
 80122ea:	e002      	b.n	80122f2 <HAL_GPIO_Init+0x1ee>
 80122ec:	2301      	movs	r3, #1
 80122ee:	e000      	b.n	80122f2 <HAL_GPIO_Init+0x1ee>
 80122f0:	2300      	movs	r3, #0
 80122f2:	697a      	ldr	r2, [r7, #20]
 80122f4:	f002 0203 	and.w	r2, r2, #3
 80122f8:	0092      	lsls	r2, r2, #2
 80122fa:	4093      	lsls	r3, r2
 80122fc:	693a      	ldr	r2, [r7, #16]
 80122fe:	4313      	orrs	r3, r2
 8012300:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2u] = temp;
 8012302:	4937      	ldr	r1, [pc, #220]	; (80123e0 <HAL_GPIO_Init+0x2dc>)
 8012304:	697b      	ldr	r3, [r7, #20]
 8012306:	089b      	lsrs	r3, r3, #2
 8012308:	3302      	adds	r3, #2
 801230a:	693a      	ldr	r2, [r7, #16]
 801230c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8012310:	4b38      	ldr	r3, [pc, #224]	; (80123f4 <HAL_GPIO_Init+0x2f0>)
 8012312:	681b      	ldr	r3, [r3, #0]
 8012314:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8012316:	68fb      	ldr	r3, [r7, #12]
 8012318:	43db      	mvns	r3, r3
 801231a:	693a      	ldr	r2, [r7, #16]
 801231c:	4013      	ands	r3, r2
 801231e:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8012320:	683b      	ldr	r3, [r7, #0]
 8012322:	685b      	ldr	r3, [r3, #4]
 8012324:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8012328:	2b00      	cmp	r3, #0
 801232a:	d003      	beq.n	8012334 <HAL_GPIO_Init+0x230>
        {
          temp |= iocurrent;
 801232c:	693a      	ldr	r2, [r7, #16]
 801232e:	68fb      	ldr	r3, [r7, #12]
 8012330:	4313      	orrs	r3, r2
 8012332:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
 8012334:	4a2f      	ldr	r2, [pc, #188]	; (80123f4 <HAL_GPIO_Init+0x2f0>)
 8012336:	693b      	ldr	r3, [r7, #16]
 8012338:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR1;
 801233a:	4b2e      	ldr	r3, [pc, #184]	; (80123f4 <HAL_GPIO_Init+0x2f0>)
 801233c:	685b      	ldr	r3, [r3, #4]
 801233e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8012340:	68fb      	ldr	r3, [r7, #12]
 8012342:	43db      	mvns	r3, r3
 8012344:	693a      	ldr	r2, [r7, #16]
 8012346:	4013      	ands	r3, r2
 8012348:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 801234a:	683b      	ldr	r3, [r7, #0]
 801234c:	685b      	ldr	r3, [r3, #4]
 801234e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8012352:	2b00      	cmp	r3, #0
 8012354:	d003      	beq.n	801235e <HAL_GPIO_Init+0x25a>
        {
          temp |= iocurrent;
 8012356:	693a      	ldr	r2, [r7, #16]
 8012358:	68fb      	ldr	r3, [r7, #12]
 801235a:	4313      	orrs	r3, r2
 801235c:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
 801235e:	4a25      	ldr	r2, [pc, #148]	; (80123f4 <HAL_GPIO_Init+0x2f0>)
 8012360:	693b      	ldr	r3, [r7, #16]
 8012362:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8012364:	4b23      	ldr	r3, [pc, #140]	; (80123f4 <HAL_GPIO_Init+0x2f0>)
 8012366:	689b      	ldr	r3, [r3, #8]
 8012368:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 801236a:	68fb      	ldr	r3, [r7, #12]
 801236c:	43db      	mvns	r3, r3
 801236e:	693a      	ldr	r2, [r7, #16]
 8012370:	4013      	ands	r3, r2
 8012372:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8012374:	683b      	ldr	r3, [r7, #0]
 8012376:	685b      	ldr	r3, [r3, #4]
 8012378:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 801237c:	2b00      	cmp	r3, #0
 801237e:	d003      	beq.n	8012388 <HAL_GPIO_Init+0x284>
        {
          temp |= iocurrent;
 8012380:	693a      	ldr	r2, [r7, #16]
 8012382:	68fb      	ldr	r3, [r7, #12]
 8012384:	4313      	orrs	r3, r2
 8012386:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 8012388:	4a1a      	ldr	r2, [pc, #104]	; (80123f4 <HAL_GPIO_Init+0x2f0>)
 801238a:	693b      	ldr	r3, [r7, #16]
 801238c:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR1;
 801238e:	4b19      	ldr	r3, [pc, #100]	; (80123f4 <HAL_GPIO_Init+0x2f0>)
 8012390:	68db      	ldr	r3, [r3, #12]
 8012392:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8012394:	68fb      	ldr	r3, [r7, #12]
 8012396:	43db      	mvns	r3, r3
 8012398:	693a      	ldr	r2, [r7, #16]
 801239a:	4013      	ands	r3, r2
 801239c:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 801239e:	683b      	ldr	r3, [r7, #0]
 80123a0:	685b      	ldr	r3, [r3, #4]
 80123a2:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80123a6:	2b00      	cmp	r3, #0
 80123a8:	d003      	beq.n	80123b2 <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
 80123aa:	693a      	ldr	r2, [r7, #16]
 80123ac:	68fb      	ldr	r3, [r7, #12]
 80123ae:	4313      	orrs	r3, r2
 80123b0:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 80123b2:	4a10      	ldr	r2, [pc, #64]	; (80123f4 <HAL_GPIO_Init+0x2f0>)
 80123b4:	693b      	ldr	r3, [r7, #16]
 80123b6:	60d3      	str	r3, [r2, #12]
      }
    }

    position++;
 80123b8:	697b      	ldr	r3, [r7, #20]
 80123ba:	3301      	adds	r3, #1
 80123bc:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80123be:	683b      	ldr	r3, [r7, #0]
 80123c0:	681a      	ldr	r2, [r3, #0]
 80123c2:	697b      	ldr	r3, [r7, #20]
 80123c4:	fa22 f303 	lsr.w	r3, r2, r3
 80123c8:	2b00      	cmp	r3, #0
 80123ca:	f47f aea3 	bne.w	8012114 <HAL_GPIO_Init+0x10>
  }
}
 80123ce:	bf00      	nop
 80123d0:	371c      	adds	r7, #28
 80123d2:	46bd      	mov	sp, r7
 80123d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80123d8:	4770      	bx	lr
 80123da:	bf00      	nop
 80123dc:	40021000 	.word	0x40021000
 80123e0:	40010000 	.word	0x40010000
 80123e4:	48000400 	.word	0x48000400
 80123e8:	48000800 	.word	0x48000800
 80123ec:	48000c00 	.word	0x48000c00
 80123f0:	48001000 	.word	0x48001000
 80123f4:	40010400 	.word	0x40010400

080123f8 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 80123f8:	b480      	push	{r7}
 80123fa:	b083      	sub	sp, #12
 80123fc:	af00      	add	r7, sp, #0
 80123fe:	6078      	str	r0, [r7, #4]
 8012400:	460b      	mov	r3, r1
 8012402:	807b      	strh	r3, [r7, #2]
 8012404:	4613      	mov	r3, r2
 8012406:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8012408:	787b      	ldrb	r3, [r7, #1]
 801240a:	2b00      	cmp	r3, #0
 801240c:	d003      	beq.n	8012416 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 801240e:	887a      	ldrh	r2, [r7, #2]
 8012410:	687b      	ldr	r3, [r7, #4]
 8012412:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 8012414:	e002      	b.n	801241c <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8012416:	887a      	ldrh	r2, [r7, #2]
 8012418:	687b      	ldr	r3, [r7, #4]
 801241a:	629a      	str	r2, [r3, #40]	; 0x28
}
 801241c:	bf00      	nop
 801241e:	370c      	adds	r7, #12
 8012420:	46bd      	mov	sp, r7
 8012422:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012426:	4770      	bx	lr

08012428 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2
  *         or PWR_REGULATOR_VOLTAGE_SCALE1_BOOST when applicable)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 8012428:	b480      	push	{r7}
 801242a:	af00      	add	r7, sp, #0
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
 801242c:	4b04      	ldr	r3, [pc, #16]	; (8012440 <HAL_PWREx_GetVoltageRange+0x18>)
 801242e:	681b      	ldr	r3, [r3, #0]
 8012430:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
#endif
}
 8012434:	4618      	mov	r0, r3
 8012436:	46bd      	mov	sp, r7
 8012438:	f85d 7b04 	ldr.w	r7, [sp], #4
 801243c:	4770      	bx	lr
 801243e:	bf00      	nop
 8012440:	40007000 	.word	0x40007000

08012444 <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8012444:	b480      	push	{r7}
 8012446:	b085      	sub	sp, #20
 8012448:	af00      	add	r7, sp, #0
 801244a:	6078      	str	r0, [r7, #4]
  }

#else

  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 801244c:	687b      	ldr	r3, [r7, #4]
 801244e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8012452:	d130      	bne.n	80124b6 <HAL_PWREx_ControlVoltageScaling+0x72>
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8012454:	4b23      	ldr	r3, [pc, #140]	; (80124e4 <HAL_PWREx_ControlVoltageScaling+0xa0>)
 8012456:	681b      	ldr	r3, [r3, #0]
 8012458:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 801245c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8012460:	d038      	beq.n	80124d4 <HAL_PWREx_ControlVoltageScaling+0x90>
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8012462:	4b20      	ldr	r3, [pc, #128]	; (80124e4 <HAL_PWREx_ControlVoltageScaling+0xa0>)
 8012464:	681b      	ldr	r3, [r3, #0]
 8012466:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 801246a:	4a1e      	ldr	r2, [pc, #120]	; (80124e4 <HAL_PWREx_ControlVoltageScaling+0xa0>)
 801246c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8012470:	6013      	str	r3, [r2, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8012472:	4b1d      	ldr	r3, [pc, #116]	; (80124e8 <HAL_PWREx_ControlVoltageScaling+0xa4>)
 8012474:	681b      	ldr	r3, [r3, #0]
 8012476:	2232      	movs	r2, #50	; 0x32
 8012478:	fb02 f303 	mul.w	r3, r2, r3
 801247c:	4a1b      	ldr	r2, [pc, #108]	; (80124ec <HAL_PWREx_ControlVoltageScaling+0xa8>)
 801247e:	fba2 2303 	umull	r2, r3, r2, r3
 8012482:	0c9b      	lsrs	r3, r3, #18
 8012484:	3301      	adds	r3, #1
 8012486:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8012488:	e002      	b.n	8012490 <HAL_PWREx_ControlVoltageScaling+0x4c>
      {
        wait_loop_index--;
 801248a:	68fb      	ldr	r3, [r7, #12]
 801248c:	3b01      	subs	r3, #1
 801248e:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8012490:	4b14      	ldr	r3, [pc, #80]	; (80124e4 <HAL_PWREx_ControlVoltageScaling+0xa0>)
 8012492:	695b      	ldr	r3, [r3, #20]
 8012494:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8012498:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 801249c:	d102      	bne.n	80124a4 <HAL_PWREx_ControlVoltageScaling+0x60>
 801249e:	68fb      	ldr	r3, [r7, #12]
 80124a0:	2b00      	cmp	r3, #0
 80124a2:	d1f2      	bne.n	801248a <HAL_PWREx_ControlVoltageScaling+0x46>
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 80124a4:	4b0f      	ldr	r3, [pc, #60]	; (80124e4 <HAL_PWREx_ControlVoltageScaling+0xa0>)
 80124a6:	695b      	ldr	r3, [r3, #20]
 80124a8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80124ac:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80124b0:	d110      	bne.n	80124d4 <HAL_PWREx_ControlVoltageScaling+0x90>
      {
        return HAL_TIMEOUT;
 80124b2:	2303      	movs	r3, #3
 80124b4:	e00f      	b.n	80124d6 <HAL_PWREx_ControlVoltageScaling+0x92>
      }
    }
  }
  else
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 80124b6:	4b0b      	ldr	r3, [pc, #44]	; (80124e4 <HAL_PWREx_ControlVoltageScaling+0xa0>)
 80124b8:	681b      	ldr	r3, [r3, #0]
 80124ba:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 80124be:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80124c2:	d007      	beq.n	80124d4 <HAL_PWREx_ControlVoltageScaling+0x90>
    {
      /* Set Range 2 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 80124c4:	4b07      	ldr	r3, [pc, #28]	; (80124e4 <HAL_PWREx_ControlVoltageScaling+0xa0>)
 80124c6:	681b      	ldr	r3, [r3, #0]
 80124c8:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 80124cc:	4a05      	ldr	r2, [pc, #20]	; (80124e4 <HAL_PWREx_ControlVoltageScaling+0xa0>)
 80124ce:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80124d2:	6013      	str	r3, [r2, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif

  return HAL_OK;
 80124d4:	2300      	movs	r3, #0
}
 80124d6:	4618      	mov	r0, r3
 80124d8:	3714      	adds	r7, #20
 80124da:	46bd      	mov	sp, r7
 80124dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80124e0:	4770      	bx	lr
 80124e2:	bf00      	nop
 80124e4:	40007000 	.word	0x40007000
 80124e8:	20000068 	.word	0x20000068
 80124ec:	431bde83 	.word	0x431bde83

080124f0 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80124f0:	b580      	push	{r7, lr}
 80124f2:	b088      	sub	sp, #32
 80124f4:	af00      	add	r7, sp, #0
 80124f6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80124f8:	687b      	ldr	r3, [r7, #4]
 80124fa:	2b00      	cmp	r3, #0
 80124fc:	d102      	bne.n	8012504 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 80124fe:	2301      	movs	r3, #1
 8012500:	f000 bc11 	b.w	8012d26 <HAL_RCC_OscConfig+0x836>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8012504:	4ba0      	ldr	r3, [pc, #640]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012506:	689b      	ldr	r3, [r3, #8]
 8012508:	f003 030c 	and.w	r3, r3, #12
 801250c:	61bb      	str	r3, [r7, #24]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 801250e:	4b9e      	ldr	r3, [pc, #632]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012510:	68db      	ldr	r3, [r3, #12]
 8012512:	f003 0303 	and.w	r3, r3, #3
 8012516:	617b      	str	r3, [r7, #20]

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8012518:	687b      	ldr	r3, [r7, #4]
 801251a:	681b      	ldr	r3, [r3, #0]
 801251c:	f003 0310 	and.w	r3, r3, #16
 8012520:	2b00      	cmp	r3, #0
 8012522:	f000 80e4 	beq.w	80126ee <HAL_RCC_OscConfig+0x1fe>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* Check if MSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8012526:	69bb      	ldr	r3, [r7, #24]
 8012528:	2b00      	cmp	r3, #0
 801252a:	d007      	beq.n	801253c <HAL_RCC_OscConfig+0x4c>
 801252c:	69bb      	ldr	r3, [r7, #24]
 801252e:	2b0c      	cmp	r3, #12
 8012530:	f040 808b 	bne.w	801264a <HAL_RCC_OscConfig+0x15a>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
 8012534:	697b      	ldr	r3, [r7, #20]
 8012536:	2b01      	cmp	r3, #1
 8012538:	f040 8087 	bne.w	801264a <HAL_RCC_OscConfig+0x15a>
    {
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 801253c:	4b92      	ldr	r3, [pc, #584]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 801253e:	681b      	ldr	r3, [r3, #0]
 8012540:	f003 0302 	and.w	r3, r3, #2
 8012544:	2b00      	cmp	r3, #0
 8012546:	d005      	beq.n	8012554 <HAL_RCC_OscConfig+0x64>
 8012548:	687b      	ldr	r3, [r7, #4]
 801254a:	699b      	ldr	r3, [r3, #24]
 801254c:	2b00      	cmp	r3, #0
 801254e:	d101      	bne.n	8012554 <HAL_RCC_OscConfig+0x64>
      {
        return HAL_ERROR;
 8012550:	2301      	movs	r3, #1
 8012552:	e3e8      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8012554:	687b      	ldr	r3, [r7, #4]
 8012556:	6a1a      	ldr	r2, [r3, #32]
 8012558:	4b8b      	ldr	r3, [pc, #556]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 801255a:	681b      	ldr	r3, [r3, #0]
 801255c:	f003 0308 	and.w	r3, r3, #8
 8012560:	2b00      	cmp	r3, #0
 8012562:	d004      	beq.n	801256e <HAL_RCC_OscConfig+0x7e>
 8012564:	4b88      	ldr	r3, [pc, #544]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012566:	681b      	ldr	r3, [r3, #0]
 8012568:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 801256c:	e005      	b.n	801257a <HAL_RCC_OscConfig+0x8a>
 801256e:	4b86      	ldr	r3, [pc, #536]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012570:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8012574:	091b      	lsrs	r3, r3, #4
 8012576:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 801257a:	4293      	cmp	r3, r2
 801257c:	d223      	bcs.n	80125c6 <HAL_RCC_OscConfig+0xd6>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 801257e:	687b      	ldr	r3, [r7, #4]
 8012580:	6a1b      	ldr	r3, [r3, #32]
 8012582:	4618      	mov	r0, r3
 8012584:	f000 fd40 	bl	8013008 <RCC_SetFlashLatencyFromMSIRange>
 8012588:	4603      	mov	r3, r0
 801258a:	2b00      	cmp	r3, #0
 801258c:	d001      	beq.n	8012592 <HAL_RCC_OscConfig+0xa2>
          {
            return HAL_ERROR;
 801258e:	2301      	movs	r3, #1
 8012590:	e3c9      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8012592:	4b7d      	ldr	r3, [pc, #500]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012594:	681b      	ldr	r3, [r3, #0]
 8012596:	4a7c      	ldr	r2, [pc, #496]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012598:	f043 0308 	orr.w	r3, r3, #8
 801259c:	6013      	str	r3, [r2, #0]
 801259e:	4b7a      	ldr	r3, [pc, #488]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80125a0:	681b      	ldr	r3, [r3, #0]
 80125a2:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80125a6:	687b      	ldr	r3, [r7, #4]
 80125a8:	6a1b      	ldr	r3, [r3, #32]
 80125aa:	4977      	ldr	r1, [pc, #476]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80125ac:	4313      	orrs	r3, r2
 80125ae:	600b      	str	r3, [r1, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80125b0:	4b75      	ldr	r3, [pc, #468]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80125b2:	685b      	ldr	r3, [r3, #4]
 80125b4:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 80125b8:	687b      	ldr	r3, [r7, #4]
 80125ba:	69db      	ldr	r3, [r3, #28]
 80125bc:	021b      	lsls	r3, r3, #8
 80125be:	4972      	ldr	r1, [pc, #456]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80125c0:	4313      	orrs	r3, r2
 80125c2:	604b      	str	r3, [r1, #4]
 80125c4:	e025      	b.n	8012612 <HAL_RCC_OscConfig+0x122>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80125c6:	4b70      	ldr	r3, [pc, #448]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80125c8:	681b      	ldr	r3, [r3, #0]
 80125ca:	4a6f      	ldr	r2, [pc, #444]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80125cc:	f043 0308 	orr.w	r3, r3, #8
 80125d0:	6013      	str	r3, [r2, #0]
 80125d2:	4b6d      	ldr	r3, [pc, #436]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80125d4:	681b      	ldr	r3, [r3, #0]
 80125d6:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80125da:	687b      	ldr	r3, [r7, #4]
 80125dc:	6a1b      	ldr	r3, [r3, #32]
 80125de:	496a      	ldr	r1, [pc, #424]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80125e0:	4313      	orrs	r3, r2
 80125e2:	600b      	str	r3, [r1, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80125e4:	4b68      	ldr	r3, [pc, #416]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80125e6:	685b      	ldr	r3, [r3, #4]
 80125e8:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 80125ec:	687b      	ldr	r3, [r7, #4]
 80125ee:	69db      	ldr	r3, [r3, #28]
 80125f0:	021b      	lsls	r3, r3, #8
 80125f2:	4965      	ldr	r1, [pc, #404]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80125f4:	4313      	orrs	r3, r2
 80125f6:	604b      	str	r3, [r1, #4]

          /* Decrease number of wait states update if necessary */
          /* Only possible when MSI is the System clock source  */
          if(sysclk_source == RCC_CFGR_SWS_MSI)
 80125f8:	69bb      	ldr	r3, [r7, #24]
 80125fa:	2b00      	cmp	r3, #0
 80125fc:	d109      	bne.n	8012612 <HAL_RCC_OscConfig+0x122>
          {
            if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80125fe:	687b      	ldr	r3, [r7, #4]
 8012600:	6a1b      	ldr	r3, [r3, #32]
 8012602:	4618      	mov	r0, r3
 8012604:	f000 fd00 	bl	8013008 <RCC_SetFlashLatencyFromMSIRange>
 8012608:	4603      	mov	r3, r0
 801260a:	2b00      	cmp	r3, #0
 801260c:	d001      	beq.n	8012612 <HAL_RCC_OscConfig+0x122>
            {
              return HAL_ERROR;
 801260e:	2301      	movs	r3, #1
 8012610:	e389      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
            }
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8012612:	f000 fc6f 	bl	8012ef4 <HAL_RCC_GetSysClockFreq>
 8012616:	4601      	mov	r1, r0
 8012618:	4b5b      	ldr	r3, [pc, #364]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 801261a:	689b      	ldr	r3, [r3, #8]
 801261c:	091b      	lsrs	r3, r3, #4
 801261e:	f003 030f 	and.w	r3, r3, #15
 8012622:	4a5a      	ldr	r2, [pc, #360]	; (801278c <HAL_RCC_OscConfig+0x29c>)
 8012624:	5cd3      	ldrb	r3, [r2, r3]
 8012626:	f003 031f 	and.w	r3, r3, #31
 801262a:	fa21 f303 	lsr.w	r3, r1, r3
 801262e:	4a58      	ldr	r2, [pc, #352]	; (8012790 <HAL_RCC_OscConfig+0x2a0>)
 8012630:	6013      	str	r3, [r2, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick(uwTickPrio);
 8012632:	4b58      	ldr	r3, [pc, #352]	; (8012794 <HAL_RCC_OscConfig+0x2a4>)
 8012634:	681b      	ldr	r3, [r3, #0]
 8012636:	4618      	mov	r0, r3
 8012638:	f7ff fb1a 	bl	8011c70 <HAL_InitTick>
 801263c:	4603      	mov	r3, r0
 801263e:	73fb      	strb	r3, [r7, #15]
        if(status != HAL_OK)
 8012640:	7bfb      	ldrb	r3, [r7, #15]
 8012642:	2b00      	cmp	r3, #0
 8012644:	d052      	beq.n	80126ec <HAL_RCC_OscConfig+0x1fc>
        {
          return status;
 8012646:	7bfb      	ldrb	r3, [r7, #15]
 8012648:	e36d      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 801264a:	687b      	ldr	r3, [r7, #4]
 801264c:	699b      	ldr	r3, [r3, #24]
 801264e:	2b00      	cmp	r3, #0
 8012650:	d032      	beq.n	80126b8 <HAL_RCC_OscConfig+0x1c8>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8012652:	4b4d      	ldr	r3, [pc, #308]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012654:	681b      	ldr	r3, [r3, #0]
 8012656:	4a4c      	ldr	r2, [pc, #304]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012658:	f043 0301 	orr.w	r3, r3, #1
 801265c:	6013      	str	r3, [r2, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 801265e:	f7ff fb53 	bl	8011d08 <HAL_GetTick>
 8012662:	6138      	str	r0, [r7, #16]

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8012664:	e008      	b.n	8012678 <HAL_RCC_OscConfig+0x188>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8012666:	f7ff fb4f 	bl	8011d08 <HAL_GetTick>
 801266a:	4602      	mov	r2, r0
 801266c:	693b      	ldr	r3, [r7, #16]
 801266e:	1ad3      	subs	r3, r2, r3
 8012670:	2b02      	cmp	r3, #2
 8012672:	d901      	bls.n	8012678 <HAL_RCC_OscConfig+0x188>
          {
            return HAL_TIMEOUT;
 8012674:	2303      	movs	r3, #3
 8012676:	e356      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8012678:	4b43      	ldr	r3, [pc, #268]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 801267a:	681b      	ldr	r3, [r3, #0]
 801267c:	f003 0302 	and.w	r3, r3, #2
 8012680:	2b00      	cmp	r3, #0
 8012682:	d0f0      	beq.n	8012666 <HAL_RCC_OscConfig+0x176>
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8012684:	4b40      	ldr	r3, [pc, #256]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012686:	681b      	ldr	r3, [r3, #0]
 8012688:	4a3f      	ldr	r2, [pc, #252]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 801268a:	f043 0308 	orr.w	r3, r3, #8
 801268e:	6013      	str	r3, [r2, #0]
 8012690:	4b3d      	ldr	r3, [pc, #244]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012692:	681b      	ldr	r3, [r3, #0]
 8012694:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8012698:	687b      	ldr	r3, [r7, #4]
 801269a:	6a1b      	ldr	r3, [r3, #32]
 801269c:	493a      	ldr	r1, [pc, #232]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 801269e:	4313      	orrs	r3, r2
 80126a0:	600b      	str	r3, [r1, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80126a2:	4b39      	ldr	r3, [pc, #228]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80126a4:	685b      	ldr	r3, [r3, #4]
 80126a6:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 80126aa:	687b      	ldr	r3, [r7, #4]
 80126ac:	69db      	ldr	r3, [r3, #28]
 80126ae:	021b      	lsls	r3, r3, #8
 80126b0:	4935      	ldr	r1, [pc, #212]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80126b2:	4313      	orrs	r3, r2
 80126b4:	604b      	str	r3, [r1, #4]
 80126b6:	e01a      	b.n	80126ee <HAL_RCC_OscConfig+0x1fe>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 80126b8:	4b33      	ldr	r3, [pc, #204]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80126ba:	681b      	ldr	r3, [r3, #0]
 80126bc:	4a32      	ldr	r2, [pc, #200]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80126be:	f023 0301 	bic.w	r3, r3, #1
 80126c2:	6013      	str	r3, [r2, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 80126c4:	f7ff fb20 	bl	8011d08 <HAL_GetTick>
 80126c8:	6138      	str	r0, [r7, #16]

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 80126ca:	e008      	b.n	80126de <HAL_RCC_OscConfig+0x1ee>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80126cc:	f7ff fb1c 	bl	8011d08 <HAL_GetTick>
 80126d0:	4602      	mov	r2, r0
 80126d2:	693b      	ldr	r3, [r7, #16]
 80126d4:	1ad3      	subs	r3, r2, r3
 80126d6:	2b02      	cmp	r3, #2
 80126d8:	d901      	bls.n	80126de <HAL_RCC_OscConfig+0x1ee>
          {
            return HAL_TIMEOUT;
 80126da:	2303      	movs	r3, #3
 80126dc:	e323      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 80126de:	4b2a      	ldr	r3, [pc, #168]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 80126e0:	681b      	ldr	r3, [r3, #0]
 80126e2:	f003 0302 	and.w	r3, r3, #2
 80126e6:	2b00      	cmp	r3, #0
 80126e8:	d1f0      	bne.n	80126cc <HAL_RCC_OscConfig+0x1dc>
 80126ea:	e000      	b.n	80126ee <HAL_RCC_OscConfig+0x1fe>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 80126ec:	bf00      	nop
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80126ee:	687b      	ldr	r3, [r7, #4]
 80126f0:	681b      	ldr	r3, [r3, #0]
 80126f2:	f003 0301 	and.w	r3, r3, #1
 80126f6:	2b00      	cmp	r3, #0
 80126f8:	d073      	beq.n	80127e2 <HAL_RCC_OscConfig+0x2f2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 80126fa:	69bb      	ldr	r3, [r7, #24]
 80126fc:	2b08      	cmp	r3, #8
 80126fe:	d005      	beq.n	801270c <HAL_RCC_OscConfig+0x21c>
 8012700:	69bb      	ldr	r3, [r7, #24]
 8012702:	2b0c      	cmp	r3, #12
 8012704:	d10e      	bne.n	8012724 <HAL_RCC_OscConfig+0x234>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
 8012706:	697b      	ldr	r3, [r7, #20]
 8012708:	2b03      	cmp	r3, #3
 801270a:	d10b      	bne.n	8012724 <HAL_RCC_OscConfig+0x234>
    {
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 801270c:	4b1e      	ldr	r3, [pc, #120]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 801270e:	681b      	ldr	r3, [r3, #0]
 8012710:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8012714:	2b00      	cmp	r3, #0
 8012716:	d063      	beq.n	80127e0 <HAL_RCC_OscConfig+0x2f0>
 8012718:	687b      	ldr	r3, [r7, #4]
 801271a:	685b      	ldr	r3, [r3, #4]
 801271c:	2b00      	cmp	r3, #0
 801271e:	d15f      	bne.n	80127e0 <HAL_RCC_OscConfig+0x2f0>
      {
        return HAL_ERROR;
 8012720:	2301      	movs	r3, #1
 8012722:	e300      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8012724:	687b      	ldr	r3, [r7, #4]
 8012726:	685b      	ldr	r3, [r3, #4]
 8012728:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 801272c:	d106      	bne.n	801273c <HAL_RCC_OscConfig+0x24c>
 801272e:	4b16      	ldr	r3, [pc, #88]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012730:	681b      	ldr	r3, [r3, #0]
 8012732:	4a15      	ldr	r2, [pc, #84]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012734:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8012738:	6013      	str	r3, [r2, #0]
 801273a:	e01d      	b.n	8012778 <HAL_RCC_OscConfig+0x288>
 801273c:	687b      	ldr	r3, [r7, #4]
 801273e:	685b      	ldr	r3, [r3, #4]
 8012740:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8012744:	d10c      	bne.n	8012760 <HAL_RCC_OscConfig+0x270>
 8012746:	4b10      	ldr	r3, [pc, #64]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012748:	681b      	ldr	r3, [r3, #0]
 801274a:	4a0f      	ldr	r2, [pc, #60]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 801274c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8012750:	6013      	str	r3, [r2, #0]
 8012752:	4b0d      	ldr	r3, [pc, #52]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012754:	681b      	ldr	r3, [r3, #0]
 8012756:	4a0c      	ldr	r2, [pc, #48]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012758:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 801275c:	6013      	str	r3, [r2, #0]
 801275e:	e00b      	b.n	8012778 <HAL_RCC_OscConfig+0x288>
 8012760:	4b09      	ldr	r3, [pc, #36]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012762:	681b      	ldr	r3, [r3, #0]
 8012764:	4a08      	ldr	r2, [pc, #32]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012766:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801276a:	6013      	str	r3, [r2, #0]
 801276c:	4b06      	ldr	r3, [pc, #24]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 801276e:	681b      	ldr	r3, [r3, #0]
 8012770:	4a05      	ldr	r2, [pc, #20]	; (8012788 <HAL_RCC_OscConfig+0x298>)
 8012772:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8012776:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8012778:	687b      	ldr	r3, [r7, #4]
 801277a:	685b      	ldr	r3, [r3, #4]
 801277c:	2b00      	cmp	r3, #0
 801277e:	d01b      	beq.n	80127b8 <HAL_RCC_OscConfig+0x2c8>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8012780:	f7ff fac2 	bl	8011d08 <HAL_GetTick>
 8012784:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8012786:	e010      	b.n	80127aa <HAL_RCC_OscConfig+0x2ba>
 8012788:	40021000 	.word	0x40021000
 801278c:	08016d84 	.word	0x08016d84
 8012790:	20000068 	.word	0x20000068
 8012794:	2000006c 	.word	0x2000006c
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8012798:	f7ff fab6 	bl	8011d08 <HAL_GetTick>
 801279c:	4602      	mov	r2, r0
 801279e:	693b      	ldr	r3, [r7, #16]
 80127a0:	1ad3      	subs	r3, r2, r3
 80127a2:	2b64      	cmp	r3, #100	; 0x64
 80127a4:	d901      	bls.n	80127aa <HAL_RCC_OscConfig+0x2ba>
          {
            return HAL_TIMEOUT;
 80127a6:	2303      	movs	r3, #3
 80127a8:	e2bd      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80127aa:	4baf      	ldr	r3, [pc, #700]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80127ac:	681b      	ldr	r3, [r3, #0]
 80127ae:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80127b2:	2b00      	cmp	r3, #0
 80127b4:	d0f0      	beq.n	8012798 <HAL_RCC_OscConfig+0x2a8>
 80127b6:	e014      	b.n	80127e2 <HAL_RCC_OscConfig+0x2f2>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80127b8:	f7ff faa6 	bl	8011d08 <HAL_GetTick>
 80127bc:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 80127be:	e008      	b.n	80127d2 <HAL_RCC_OscConfig+0x2e2>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80127c0:	f7ff faa2 	bl	8011d08 <HAL_GetTick>
 80127c4:	4602      	mov	r2, r0
 80127c6:	693b      	ldr	r3, [r7, #16]
 80127c8:	1ad3      	subs	r3, r2, r3
 80127ca:	2b64      	cmp	r3, #100	; 0x64
 80127cc:	d901      	bls.n	80127d2 <HAL_RCC_OscConfig+0x2e2>
          {
            return HAL_TIMEOUT;
 80127ce:	2303      	movs	r3, #3
 80127d0:	e2a9      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 80127d2:	4ba5      	ldr	r3, [pc, #660]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80127d4:	681b      	ldr	r3, [r3, #0]
 80127d6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80127da:	2b00      	cmp	r3, #0
 80127dc:	d1f0      	bne.n	80127c0 <HAL_RCC_OscConfig+0x2d0>
 80127de:	e000      	b.n	80127e2 <HAL_RCC_OscConfig+0x2f2>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80127e0:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80127e2:	687b      	ldr	r3, [r7, #4]
 80127e4:	681b      	ldr	r3, [r3, #0]
 80127e6:	f003 0302 	and.w	r3, r3, #2
 80127ea:	2b00      	cmp	r3, #0
 80127ec:	d060      	beq.n	80128b0 <HAL_RCC_OscConfig+0x3c0>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 80127ee:	69bb      	ldr	r3, [r7, #24]
 80127f0:	2b04      	cmp	r3, #4
 80127f2:	d005      	beq.n	8012800 <HAL_RCC_OscConfig+0x310>
 80127f4:	69bb      	ldr	r3, [r7, #24]
 80127f6:	2b0c      	cmp	r3, #12
 80127f8:	d119      	bne.n	801282e <HAL_RCC_OscConfig+0x33e>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
 80127fa:	697b      	ldr	r3, [r7, #20]
 80127fc:	2b02      	cmp	r3, #2
 80127fe:	d116      	bne.n	801282e <HAL_RCC_OscConfig+0x33e>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8012800:	4b99      	ldr	r3, [pc, #612]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012802:	681b      	ldr	r3, [r3, #0]
 8012804:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8012808:	2b00      	cmp	r3, #0
 801280a:	d005      	beq.n	8012818 <HAL_RCC_OscConfig+0x328>
 801280c:	687b      	ldr	r3, [r7, #4]
 801280e:	68db      	ldr	r3, [r3, #12]
 8012810:	2b00      	cmp	r3, #0
 8012812:	d101      	bne.n	8012818 <HAL_RCC_OscConfig+0x328>
      {
        return HAL_ERROR;
 8012814:	2301      	movs	r3, #1
 8012816:	e286      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8012818:	4b93      	ldr	r3, [pc, #588]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 801281a:	685b      	ldr	r3, [r3, #4]
 801281c:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 8012820:	687b      	ldr	r3, [r7, #4]
 8012822:	691b      	ldr	r3, [r3, #16]
 8012824:	061b      	lsls	r3, r3, #24
 8012826:	4990      	ldr	r1, [pc, #576]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012828:	4313      	orrs	r3, r2
 801282a:	604b      	str	r3, [r1, #4]
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 801282c:	e040      	b.n	80128b0 <HAL_RCC_OscConfig+0x3c0>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 801282e:	687b      	ldr	r3, [r7, #4]
 8012830:	68db      	ldr	r3, [r3, #12]
 8012832:	2b00      	cmp	r3, #0
 8012834:	d023      	beq.n	801287e <HAL_RCC_OscConfig+0x38e>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8012836:	4b8c      	ldr	r3, [pc, #560]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012838:	681b      	ldr	r3, [r3, #0]
 801283a:	4a8b      	ldr	r2, [pc, #556]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 801283c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8012840:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8012842:	f7ff fa61 	bl	8011d08 <HAL_GetTick>
 8012846:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8012848:	e008      	b.n	801285c <HAL_RCC_OscConfig+0x36c>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 801284a:	f7ff fa5d 	bl	8011d08 <HAL_GetTick>
 801284e:	4602      	mov	r2, r0
 8012850:	693b      	ldr	r3, [r7, #16]
 8012852:	1ad3      	subs	r3, r2, r3
 8012854:	2b02      	cmp	r3, #2
 8012856:	d901      	bls.n	801285c <HAL_RCC_OscConfig+0x36c>
          {
            return HAL_TIMEOUT;
 8012858:	2303      	movs	r3, #3
 801285a:	e264      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 801285c:	4b82      	ldr	r3, [pc, #520]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 801285e:	681b      	ldr	r3, [r3, #0]
 8012860:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8012864:	2b00      	cmp	r3, #0
 8012866:	d0f0      	beq.n	801284a <HAL_RCC_OscConfig+0x35a>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8012868:	4b7f      	ldr	r3, [pc, #508]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 801286a:	685b      	ldr	r3, [r3, #4]
 801286c:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 8012870:	687b      	ldr	r3, [r7, #4]
 8012872:	691b      	ldr	r3, [r3, #16]
 8012874:	061b      	lsls	r3, r3, #24
 8012876:	497c      	ldr	r1, [pc, #496]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012878:	4313      	orrs	r3, r2
 801287a:	604b      	str	r3, [r1, #4]
 801287c:	e018      	b.n	80128b0 <HAL_RCC_OscConfig+0x3c0>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 801287e:	4b7a      	ldr	r3, [pc, #488]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012880:	681b      	ldr	r3, [r3, #0]
 8012882:	4a79      	ldr	r2, [pc, #484]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012884:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8012888:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 801288a:	f7ff fa3d 	bl	8011d08 <HAL_GetTick>
 801288e:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8012890:	e008      	b.n	80128a4 <HAL_RCC_OscConfig+0x3b4>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8012892:	f7ff fa39 	bl	8011d08 <HAL_GetTick>
 8012896:	4602      	mov	r2, r0
 8012898:	693b      	ldr	r3, [r7, #16]
 801289a:	1ad3      	subs	r3, r2, r3
 801289c:	2b02      	cmp	r3, #2
 801289e:	d901      	bls.n	80128a4 <HAL_RCC_OscConfig+0x3b4>
          {
            return HAL_TIMEOUT;
 80128a0:	2303      	movs	r3, #3
 80128a2:	e240      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 80128a4:	4b70      	ldr	r3, [pc, #448]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80128a6:	681b      	ldr	r3, [r3, #0]
 80128a8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80128ac:	2b00      	cmp	r3, #0
 80128ae:	d1f0      	bne.n	8012892 <HAL_RCC_OscConfig+0x3a2>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80128b0:	687b      	ldr	r3, [r7, #4]
 80128b2:	681b      	ldr	r3, [r3, #0]
 80128b4:	f003 0308 	and.w	r3, r3, #8
 80128b8:	2b00      	cmp	r3, #0
 80128ba:	d03c      	beq.n	8012936 <HAL_RCC_OscConfig+0x446>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80128bc:	687b      	ldr	r3, [r7, #4]
 80128be:	695b      	ldr	r3, [r3, #20]
 80128c0:	2b00      	cmp	r3, #0
 80128c2:	d01c      	beq.n	80128fe <HAL_RCC_OscConfig+0x40e>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPREDIV, RCC_OscInitStruct->LSIDiv);
      }
#endif /* RCC_CSR_LSIPREDIV */

      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80128c4:	4b68      	ldr	r3, [pc, #416]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80128c6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80128ca:	4a67      	ldr	r2, [pc, #412]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80128cc:	f043 0301 	orr.w	r3, r3, #1
 80128d0:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80128d4:	f7ff fa18 	bl	8011d08 <HAL_GetTick>
 80128d8:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 80128da:	e008      	b.n	80128ee <HAL_RCC_OscConfig+0x3fe>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80128dc:	f7ff fa14 	bl	8011d08 <HAL_GetTick>
 80128e0:	4602      	mov	r2, r0
 80128e2:	693b      	ldr	r3, [r7, #16]
 80128e4:	1ad3      	subs	r3, r2, r3
 80128e6:	2b02      	cmp	r3, #2
 80128e8:	d901      	bls.n	80128ee <HAL_RCC_OscConfig+0x3fe>
        {
          return HAL_TIMEOUT;
 80128ea:	2303      	movs	r3, #3
 80128ec:	e21b      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 80128ee:	4b5e      	ldr	r3, [pc, #376]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80128f0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80128f4:	f003 0302 	and.w	r3, r3, #2
 80128f8:	2b00      	cmp	r3, #0
 80128fa:	d0ef      	beq.n	80128dc <HAL_RCC_OscConfig+0x3ec>
 80128fc:	e01b      	b.n	8012936 <HAL_RCC_OscConfig+0x446>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80128fe:	4b5a      	ldr	r3, [pc, #360]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012900:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8012904:	4a58      	ldr	r2, [pc, #352]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012906:	f023 0301 	bic.w	r3, r3, #1
 801290a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 801290e:	f7ff f9fb 	bl	8011d08 <HAL_GetTick>
 8012912:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is disabled */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8012914:	e008      	b.n	8012928 <HAL_RCC_OscConfig+0x438>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8012916:	f7ff f9f7 	bl	8011d08 <HAL_GetTick>
 801291a:	4602      	mov	r2, r0
 801291c:	693b      	ldr	r3, [r7, #16]
 801291e:	1ad3      	subs	r3, r2, r3
 8012920:	2b02      	cmp	r3, #2
 8012922:	d901      	bls.n	8012928 <HAL_RCC_OscConfig+0x438>
        {
          return HAL_TIMEOUT;
 8012924:	2303      	movs	r3, #3
 8012926:	e1fe      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8012928:	4b4f      	ldr	r3, [pc, #316]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 801292a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801292e:	f003 0302 	and.w	r3, r3, #2
 8012932:	2b00      	cmp	r3, #0
 8012934:	d1ef      	bne.n	8012916 <HAL_RCC_OscConfig+0x426>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8012936:	687b      	ldr	r3, [r7, #4]
 8012938:	681b      	ldr	r3, [r3, #0]
 801293a:	f003 0304 	and.w	r3, r3, #4
 801293e:	2b00      	cmp	r3, #0
 8012940:	f000 80a6 	beq.w	8012a90 <HAL_RCC_OscConfig+0x5a0>
  {
    FlagStatus       pwrclkchanged = RESET;
 8012944:	2300      	movs	r3, #0
 8012946:	77fb      	strb	r3, [r7, #31]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8012948:	4b47      	ldr	r3, [pc, #284]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 801294a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801294c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8012950:	2b00      	cmp	r3, #0
 8012952:	d10d      	bne.n	8012970 <HAL_RCC_OscConfig+0x480>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8012954:	4b44      	ldr	r3, [pc, #272]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012956:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8012958:	4a43      	ldr	r2, [pc, #268]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 801295a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 801295e:	6593      	str	r3, [r2, #88]	; 0x58
 8012960:	4b41      	ldr	r3, [pc, #260]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012962:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8012964:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8012968:	60bb      	str	r3, [r7, #8]
 801296a:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 801296c:	2301      	movs	r3, #1
 801296e:	77fb      	strb	r3, [r7, #31]
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8012970:	4b3e      	ldr	r3, [pc, #248]	; (8012a6c <HAL_RCC_OscConfig+0x57c>)
 8012972:	681b      	ldr	r3, [r3, #0]
 8012974:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8012978:	2b00      	cmp	r3, #0
 801297a:	d118      	bne.n	80129ae <HAL_RCC_OscConfig+0x4be>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 801297c:	4b3b      	ldr	r3, [pc, #236]	; (8012a6c <HAL_RCC_OscConfig+0x57c>)
 801297e:	681b      	ldr	r3, [r3, #0]
 8012980:	4a3a      	ldr	r2, [pc, #232]	; (8012a6c <HAL_RCC_OscConfig+0x57c>)
 8012982:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8012986:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8012988:	f7ff f9be 	bl	8011d08 <HAL_GetTick>
 801298c:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 801298e:	e008      	b.n	80129a2 <HAL_RCC_OscConfig+0x4b2>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8012990:	f7ff f9ba 	bl	8011d08 <HAL_GetTick>
 8012994:	4602      	mov	r2, r0
 8012996:	693b      	ldr	r3, [r7, #16]
 8012998:	1ad3      	subs	r3, r2, r3
 801299a:	2b02      	cmp	r3, #2
 801299c:	d901      	bls.n	80129a2 <HAL_RCC_OscConfig+0x4b2>
        {
          return HAL_TIMEOUT;
 801299e:	2303      	movs	r3, #3
 80129a0:	e1c1      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80129a2:	4b32      	ldr	r3, [pc, #200]	; (8012a6c <HAL_RCC_OscConfig+0x57c>)
 80129a4:	681b      	ldr	r3, [r3, #0]
 80129a6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80129aa:	2b00      	cmp	r3, #0
 80129ac:	d0f0      	beq.n	8012990 <HAL_RCC_OscConfig+0x4a0>
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
    }
#else
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80129ae:	687b      	ldr	r3, [r7, #4]
 80129b0:	689b      	ldr	r3, [r3, #8]
 80129b2:	2b01      	cmp	r3, #1
 80129b4:	d108      	bne.n	80129c8 <HAL_RCC_OscConfig+0x4d8>
 80129b6:	4b2c      	ldr	r3, [pc, #176]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80129b8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80129bc:	4a2a      	ldr	r2, [pc, #168]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80129be:	f043 0301 	orr.w	r3, r3, #1
 80129c2:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 80129c6:	e024      	b.n	8012a12 <HAL_RCC_OscConfig+0x522>
 80129c8:	687b      	ldr	r3, [r7, #4]
 80129ca:	689b      	ldr	r3, [r3, #8]
 80129cc:	2b05      	cmp	r3, #5
 80129ce:	d110      	bne.n	80129f2 <HAL_RCC_OscConfig+0x502>
 80129d0:	4b25      	ldr	r3, [pc, #148]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80129d2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80129d6:	4a24      	ldr	r2, [pc, #144]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80129d8:	f043 0304 	orr.w	r3, r3, #4
 80129dc:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 80129e0:	4b21      	ldr	r3, [pc, #132]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80129e2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80129e6:	4a20      	ldr	r2, [pc, #128]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80129e8:	f043 0301 	orr.w	r3, r3, #1
 80129ec:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 80129f0:	e00f      	b.n	8012a12 <HAL_RCC_OscConfig+0x522>
 80129f2:	4b1d      	ldr	r3, [pc, #116]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80129f4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80129f8:	4a1b      	ldr	r2, [pc, #108]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 80129fa:	f023 0301 	bic.w	r3, r3, #1
 80129fe:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8012a02:	4b19      	ldr	r3, [pc, #100]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012a04:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8012a08:	4a17      	ldr	r2, [pc, #92]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012a0a:	f023 0304 	bic.w	r3, r3, #4
 8012a0e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif /* RCC_BDCR_LSESYSDIS */

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8012a12:	687b      	ldr	r3, [r7, #4]
 8012a14:	689b      	ldr	r3, [r3, #8]
 8012a16:	2b00      	cmp	r3, #0
 8012a18:	d016      	beq.n	8012a48 <HAL_RCC_OscConfig+0x558>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8012a1a:	f7ff f975 	bl	8011d08 <HAL_GetTick>
 8012a1e:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8012a20:	e00a      	b.n	8012a38 <HAL_RCC_OscConfig+0x548>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012a22:	f7ff f971 	bl	8011d08 <HAL_GetTick>
 8012a26:	4602      	mov	r2, r0
 8012a28:	693b      	ldr	r3, [r7, #16]
 8012a2a:	1ad3      	subs	r3, r2, r3
 8012a2c:	f241 3288 	movw	r2, #5000	; 0x1388
 8012a30:	4293      	cmp	r3, r2
 8012a32:	d901      	bls.n	8012a38 <HAL_RCC_OscConfig+0x548>
        {
          return HAL_TIMEOUT;
 8012a34:	2303      	movs	r3, #3
 8012a36:	e176      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8012a38:	4b0b      	ldr	r3, [pc, #44]	; (8012a68 <HAL_RCC_OscConfig+0x578>)
 8012a3a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8012a3e:	f003 0302 	and.w	r3, r3, #2
 8012a42:	2b00      	cmp	r3, #0
 8012a44:	d0ed      	beq.n	8012a22 <HAL_RCC_OscConfig+0x532>
 8012a46:	e01a      	b.n	8012a7e <HAL_RCC_OscConfig+0x58e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8012a48:	f7ff f95e 	bl	8011d08 <HAL_GetTick>
 8012a4c:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8012a4e:	e00f      	b.n	8012a70 <HAL_RCC_OscConfig+0x580>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012a50:	f7ff f95a 	bl	8011d08 <HAL_GetTick>
 8012a54:	4602      	mov	r2, r0
 8012a56:	693b      	ldr	r3, [r7, #16]
 8012a58:	1ad3      	subs	r3, r2, r3
 8012a5a:	f241 3288 	movw	r2, #5000	; 0x1388
 8012a5e:	4293      	cmp	r3, r2
 8012a60:	d906      	bls.n	8012a70 <HAL_RCC_OscConfig+0x580>
        {
          return HAL_TIMEOUT;
 8012a62:	2303      	movs	r3, #3
 8012a64:	e15f      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
 8012a66:	bf00      	nop
 8012a68:	40021000 	.word	0x40021000
 8012a6c:	40007000 	.word	0x40007000
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8012a70:	4baa      	ldr	r3, [pc, #680]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012a72:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8012a76:	f003 0302 	and.w	r3, r3, #2
 8012a7a:	2b00      	cmp	r3, #0
 8012a7c:	d1e8      	bne.n	8012a50 <HAL_RCC_OscConfig+0x560>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSDIS);
#endif /* RCC_BDCR_LSESYSDIS */
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8012a7e:	7ffb      	ldrb	r3, [r7, #31]
 8012a80:	2b01      	cmp	r3, #1
 8012a82:	d105      	bne.n	8012a90 <HAL_RCC_OscConfig+0x5a0>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8012a84:	4ba5      	ldr	r3, [pc, #660]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012a86:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8012a88:	4aa4      	ldr	r2, [pc, #656]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012a8a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8012a8e:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }
#if defined(RCC_HSI48_SUPPORT)
  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8012a90:	687b      	ldr	r3, [r7, #4]
 8012a92:	681b      	ldr	r3, [r3, #0]
 8012a94:	f003 0320 	and.w	r3, r3, #32
 8012a98:	2b00      	cmp	r3, #0
 8012a9a:	d03c      	beq.n	8012b16 <HAL_RCC_OscConfig+0x626>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the LSI State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8012a9c:	687b      	ldr	r3, [r7, #4]
 8012a9e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012aa0:	2b00      	cmp	r3, #0
 8012aa2:	d01c      	beq.n	8012ade <HAL_RCC_OscConfig+0x5ee>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 8012aa4:	4b9d      	ldr	r3, [pc, #628]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012aa6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8012aaa:	4a9c      	ldr	r2, [pc, #624]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012aac:	f043 0301 	orr.w	r3, r3, #1
 8012ab0:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8012ab4:	f7ff f928 	bl	8011d08 <HAL_GetTick>
 8012ab8:	6138      	str	r0, [r7, #16]

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8012aba:	e008      	b.n	8012ace <HAL_RCC_OscConfig+0x5de>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8012abc:	f7ff f924 	bl	8011d08 <HAL_GetTick>
 8012ac0:	4602      	mov	r2, r0
 8012ac2:	693b      	ldr	r3, [r7, #16]
 8012ac4:	1ad3      	subs	r3, r2, r3
 8012ac6:	2b02      	cmp	r3, #2
 8012ac8:	d901      	bls.n	8012ace <HAL_RCC_OscConfig+0x5de>
        {
          return HAL_TIMEOUT;
 8012aca:	2303      	movs	r3, #3
 8012acc:	e12b      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8012ace:	4b93      	ldr	r3, [pc, #588]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012ad0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8012ad4:	f003 0302 	and.w	r3, r3, #2
 8012ad8:	2b00      	cmp	r3, #0
 8012ada:	d0ef      	beq.n	8012abc <HAL_RCC_OscConfig+0x5cc>
 8012adc:	e01b      	b.n	8012b16 <HAL_RCC_OscConfig+0x626>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 8012ade:	4b8f      	ldr	r3, [pc, #572]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012ae0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8012ae4:	4a8d      	ldr	r2, [pc, #564]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012ae6:	f023 0301 	bic.w	r3, r3, #1
 8012aea:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8012aee:	f7ff f90b 	bl	8011d08 <HAL_GetTick>
 8012af2:	6138      	str	r0, [r7, #16]

      /* Wait till HSI48 is disabled */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8012af4:	e008      	b.n	8012b08 <HAL_RCC_OscConfig+0x618>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8012af6:	f7ff f907 	bl	8011d08 <HAL_GetTick>
 8012afa:	4602      	mov	r2, r0
 8012afc:	693b      	ldr	r3, [r7, #16]
 8012afe:	1ad3      	subs	r3, r2, r3
 8012b00:	2b02      	cmp	r3, #2
 8012b02:	d901      	bls.n	8012b08 <HAL_RCC_OscConfig+0x618>
        {
          return HAL_TIMEOUT;
 8012b04:	2303      	movs	r3, #3
 8012b06:	e10e      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8012b08:	4b84      	ldr	r3, [pc, #528]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012b0a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8012b0e:	f003 0302 	and.w	r3, r3, #2
 8012b12:	2b00      	cmp	r3, #0
 8012b14:	d1ef      	bne.n	8012af6 <HAL_RCC_OscConfig+0x606>
#endif /* RCC_HSI48_SUPPORT */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8012b16:	687b      	ldr	r3, [r7, #4]
 8012b18:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012b1a:	2b00      	cmp	r3, #0
 8012b1c:	f000 8102 	beq.w	8012d24 <HAL_RCC_OscConfig+0x834>
  {
    /* PLL On ? */
    if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8012b20:	687b      	ldr	r3, [r7, #4]
 8012b22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012b24:	2b02      	cmp	r3, #2
 8012b26:	f040 80c5 	bne.w	8012cb4 <HAL_RCC_OscConfig+0x7c4>
#endif /* RCC_PLLP_SUPPORT */
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

      /* Do nothing if PLL configuration is the unchanged */
      pll_config = RCC->PLLCFGR;
 8012b2a:	4b7c      	ldr	r3, [pc, #496]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012b2c:	68db      	ldr	r3, [r3, #12]
 8012b2e:	617b      	str	r3, [r7, #20]
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8012b30:	697b      	ldr	r3, [r7, #20]
 8012b32:	f003 0203 	and.w	r2, r3, #3
 8012b36:	687b      	ldr	r3, [r7, #4]
 8012b38:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012b3a:	429a      	cmp	r2, r3
 8012b3c:	d12c      	bne.n	8012b98 <HAL_RCC_OscConfig+0x6a8>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8012b3e:	697b      	ldr	r3, [r7, #20]
 8012b40:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8012b44:	687b      	ldr	r3, [r7, #4]
 8012b46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012b48:	3b01      	subs	r3, #1
 8012b4a:	011b      	lsls	r3, r3, #4
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8012b4c:	429a      	cmp	r2, r3
 8012b4e:	d123      	bne.n	8012b98 <HAL_RCC_OscConfig+0x6a8>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8012b50:	697b      	ldr	r3, [r7, #20]
 8012b52:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 8012b56:	687b      	ldr	r3, [r7, #4]
 8012b58:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012b5a:	021b      	lsls	r3, r3, #8
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8012b5c:	429a      	cmp	r2, r3
 8012b5e:	d11b      	bne.n	8012b98 <HAL_RCC_OscConfig+0x6a8>
#if defined(RCC_PLLP_SUPPORT)
#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8012b60:	697b      	ldr	r3, [r7, #20]
 8012b62:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
 8012b66:	687b      	ldr	r3, [r7, #4]
 8012b68:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012b6a:	06db      	lsls	r3, r3, #27
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8012b6c:	429a      	cmp	r2, r3
 8012b6e:	d113      	bne.n	8012b98 <HAL_RCC_OscConfig+0x6a8>
#else
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLP)    != ((RCC_OscInitStruct->PLL.PLLP == RCC_PLLP_DIV7) ? 0U : 1U)) ||
#endif
#endif
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8012b70:	697b      	ldr	r3, [r7, #20]
 8012b72:	f403 02c0 	and.w	r2, r3, #6291456	; 0x600000
 8012b76:	687b      	ldr	r3, [r7, #4]
 8012b78:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012b7a:	085b      	lsrs	r3, r3, #1
 8012b7c:	3b01      	subs	r3, #1
 8012b7e:	055b      	lsls	r3, r3, #21
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8012b80:	429a      	cmp	r2, r3
 8012b82:	d109      	bne.n	8012b98 <HAL_RCC_OscConfig+0x6a8>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 8012b84:	697b      	ldr	r3, [r7, #20]
 8012b86:	f003 62c0 	and.w	r2, r3, #100663296	; 0x6000000
 8012b8a:	687b      	ldr	r3, [r7, #4]
 8012b8c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8012b8e:	085b      	lsrs	r3, r3, #1
 8012b90:	3b01      	subs	r3, #1
 8012b92:	065b      	lsls	r3, r3, #25
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8012b94:	429a      	cmp	r2, r3
 8012b96:	d067      	beq.n	8012c68 <HAL_RCC_OscConfig+0x778>
      {
        /* Check if the PLL is used as system clock or not */
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 8012b98:	69bb      	ldr	r3, [r7, #24]
 8012b9a:	2b0c      	cmp	r3, #12
 8012b9c:	d062      	beq.n	8012c64 <HAL_RCC_OscConfig+0x774>
        {
#if defined(RCC_PLLSAI1_SUPPORT) || defined(RCC_PLLSAI2_SUPPORT)
          /* Check if main PLL can be updated */
          /* Not possible if the source is shared by other enabled PLLSAIx */
          if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 8012b9e:	4b5f      	ldr	r3, [pc, #380]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012ba0:	681b      	ldr	r3, [r3, #0]
 8012ba2:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8012ba6:	2b00      	cmp	r3, #0
 8012ba8:	d001      	beq.n	8012bae <HAL_RCC_OscConfig+0x6be>
#if defined(RCC_PLLSAI2_SUPPORT)
             || (READ_BIT(RCC->CR, RCC_CR_PLLSAI2ON) != 0U)
#endif
            )
          {
            return HAL_ERROR;
 8012baa:	2301      	movs	r3, #1
 8012bac:	e0bb      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
          }
          else
#endif /* RCC_PLLSAI1_SUPPORT || RCC_PLLSAI2_SUPPORT */
          {
            /* Disable the main PLL. */
            __HAL_RCC_PLL_DISABLE();
 8012bae:	4b5b      	ldr	r3, [pc, #364]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012bb0:	681b      	ldr	r3, [r3, #0]
 8012bb2:	4a5a      	ldr	r2, [pc, #360]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012bb4:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8012bb8:	6013      	str	r3, [r2, #0]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8012bba:	f7ff f8a5 	bl	8011d08 <HAL_GetTick>
 8012bbe:	6138      	str	r0, [r7, #16]

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8012bc0:	e008      	b.n	8012bd4 <HAL_RCC_OscConfig+0x6e4>
            {
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8012bc2:	f7ff f8a1 	bl	8011d08 <HAL_GetTick>
 8012bc6:	4602      	mov	r2, r0
 8012bc8:	693b      	ldr	r3, [r7, #16]
 8012bca:	1ad3      	subs	r3, r2, r3
 8012bcc:	2b02      	cmp	r3, #2
 8012bce:	d901      	bls.n	8012bd4 <HAL_RCC_OscConfig+0x6e4>
              {
                return HAL_TIMEOUT;
 8012bd0:	2303      	movs	r3, #3
 8012bd2:	e0a8      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8012bd4:	4b51      	ldr	r3, [pc, #324]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012bd6:	681b      	ldr	r3, [r3, #0]
 8012bd8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8012bdc:	2b00      	cmp	r3, #0
 8012bde:	d1f0      	bne.n	8012bc2 <HAL_RCC_OscConfig+0x6d2>
              }
            }

            /* Configure the main PLL clock source, multiplication and division factors. */
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8012be0:	4b4e      	ldr	r3, [pc, #312]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012be2:	68da      	ldr	r2, [r3, #12]
 8012be4:	4b4e      	ldr	r3, [pc, #312]	; (8012d20 <HAL_RCC_OscConfig+0x830>)
 8012be6:	4013      	ands	r3, r2
 8012be8:	687a      	ldr	r2, [r7, #4]
 8012bea:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8012bec:	687a      	ldr	r2, [r7, #4]
 8012bee:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8012bf0:	3a01      	subs	r2, #1
 8012bf2:	0112      	lsls	r2, r2, #4
 8012bf4:	4311      	orrs	r1, r2
 8012bf6:	687a      	ldr	r2, [r7, #4]
 8012bf8:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8012bfa:	0212      	lsls	r2, r2, #8
 8012bfc:	4311      	orrs	r1, r2
 8012bfe:	687a      	ldr	r2, [r7, #4]
 8012c00:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8012c02:	0852      	lsrs	r2, r2, #1
 8012c04:	3a01      	subs	r2, #1
 8012c06:	0552      	lsls	r2, r2, #21
 8012c08:	4311      	orrs	r1, r2
 8012c0a:	687a      	ldr	r2, [r7, #4]
 8012c0c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8012c0e:	0852      	lsrs	r2, r2, #1
 8012c10:	3a01      	subs	r2, #1
 8012c12:	0652      	lsls	r2, r2, #25
 8012c14:	4311      	orrs	r1, r2
 8012c16:	687a      	ldr	r2, [r7, #4]
 8012c18:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8012c1a:	06d2      	lsls	r2, r2, #27
 8012c1c:	430a      	orrs	r2, r1
 8012c1e:	493f      	ldr	r1, [pc, #252]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012c20:	4313      	orrs	r3, r2
 8012c22:	60cb      	str	r3, [r1, #12]
#endif
                                 RCC_OscInitStruct->PLL.PLLQ,
                                 RCC_OscInitStruct->PLL.PLLR);

            /* Enable the main PLL. */
            __HAL_RCC_PLL_ENABLE();
 8012c24:	4b3d      	ldr	r3, [pc, #244]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012c26:	681b      	ldr	r3, [r3, #0]
 8012c28:	4a3c      	ldr	r2, [pc, #240]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012c2a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8012c2e:	6013      	str	r3, [r2, #0]

            /* Enable PLL System Clock output. */
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8012c30:	4b3a      	ldr	r3, [pc, #232]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012c32:	68db      	ldr	r3, [r3, #12]
 8012c34:	4a39      	ldr	r2, [pc, #228]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012c36:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8012c3a:	60d3      	str	r3, [r2, #12]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8012c3c:	f7ff f864 	bl	8011d08 <HAL_GetTick>
 8012c40:	6138      	str	r0, [r7, #16]

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012c42:	e008      	b.n	8012c56 <HAL_RCC_OscConfig+0x766>
            {
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8012c44:	f7ff f860 	bl	8011d08 <HAL_GetTick>
 8012c48:	4602      	mov	r2, r0
 8012c4a:	693b      	ldr	r3, [r7, #16]
 8012c4c:	1ad3      	subs	r3, r2, r3
 8012c4e:	2b02      	cmp	r3, #2
 8012c50:	d901      	bls.n	8012c56 <HAL_RCC_OscConfig+0x766>
              {
                return HAL_TIMEOUT;
 8012c52:	2303      	movs	r3, #3
 8012c54:	e067      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012c56:	4b31      	ldr	r3, [pc, #196]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012c58:	681b      	ldr	r3, [r3, #0]
 8012c5a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8012c5e:	2b00      	cmp	r3, #0
 8012c60:	d0f0      	beq.n	8012c44 <HAL_RCC_OscConfig+0x754>
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 8012c62:	e05f      	b.n	8012d24 <HAL_RCC_OscConfig+0x834>
          }
        }
        else
        {
          /* PLL is already used as System core clock */
          return HAL_ERROR;
 8012c64:	2301      	movs	r3, #1
 8012c66:	e05e      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
      }
      else
      {
        /* PLL configuration is unchanged */
        /* Re-enable PLL if it was disabled (ie. low power mode) */
        if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012c68:	4b2c      	ldr	r3, [pc, #176]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012c6a:	681b      	ldr	r3, [r3, #0]
 8012c6c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8012c70:	2b00      	cmp	r3, #0
 8012c72:	d157      	bne.n	8012d24 <HAL_RCC_OscConfig+0x834>
        {
          /* Enable the main PLL. */
          __HAL_RCC_PLL_ENABLE();
 8012c74:	4b29      	ldr	r3, [pc, #164]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012c76:	681b      	ldr	r3, [r3, #0]
 8012c78:	4a28      	ldr	r2, [pc, #160]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012c7a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8012c7e:	6013      	str	r3, [r2, #0]

          /* Enable PLL System Clock output. */
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8012c80:	4b26      	ldr	r3, [pc, #152]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012c82:	68db      	ldr	r3, [r3, #12]
 8012c84:	4a25      	ldr	r2, [pc, #148]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012c86:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8012c8a:	60d3      	str	r3, [r2, #12]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8012c8c:	f7ff f83c 	bl	8011d08 <HAL_GetTick>
 8012c90:	6138      	str	r0, [r7, #16]

          /* Wait till PLL is ready */
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012c92:	e008      	b.n	8012ca6 <HAL_RCC_OscConfig+0x7b6>
          {
            if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8012c94:	f7ff f838 	bl	8011d08 <HAL_GetTick>
 8012c98:	4602      	mov	r2, r0
 8012c9a:	693b      	ldr	r3, [r7, #16]
 8012c9c:	1ad3      	subs	r3, r2, r3
 8012c9e:	2b02      	cmp	r3, #2
 8012ca0:	d901      	bls.n	8012ca6 <HAL_RCC_OscConfig+0x7b6>
            {
              return HAL_TIMEOUT;
 8012ca2:	2303      	movs	r3, #3
 8012ca4:	e03f      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012ca6:	4b1d      	ldr	r3, [pc, #116]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012ca8:	681b      	ldr	r3, [r3, #0]
 8012caa:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8012cae:	2b00      	cmp	r3, #0
 8012cb0:	d0f0      	beq.n	8012c94 <HAL_RCC_OscConfig+0x7a4>
 8012cb2:	e037      	b.n	8012d24 <HAL_RCC_OscConfig+0x834>
      }
    }
    else
    {
      /* Check that PLL is not used as system clock or not */
      if(sysclk_source != RCC_CFGR_SWS_PLL)
 8012cb4:	69bb      	ldr	r3, [r7, #24]
 8012cb6:	2b0c      	cmp	r3, #12
 8012cb8:	d02d      	beq.n	8012d16 <HAL_RCC_OscConfig+0x826>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8012cba:	4b18      	ldr	r3, [pc, #96]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012cbc:	681b      	ldr	r3, [r3, #0]
 8012cbe:	4a17      	ldr	r2, [pc, #92]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012cc0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8012cc4:	6013      	str	r3, [r2, #0]
        if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
        {
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
        }
#elif defined(RCC_PLLSAI1_SUPPORT)
        if(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8012cc6:	4b15      	ldr	r3, [pc, #84]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012cc8:	681b      	ldr	r3, [r3, #0]
 8012cca:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8012cce:	2b00      	cmp	r3, #0
 8012cd0:	d105      	bne.n	8012cde <HAL_RCC_OscConfig+0x7ee>
        {
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8012cd2:	4b12      	ldr	r3, [pc, #72]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012cd4:	68db      	ldr	r3, [r3, #12]
 8012cd6:	4a11      	ldr	r2, [pc, #68]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012cd8:	f023 0303 	bic.w	r3, r3, #3
 8012cdc:	60d3      	str	r3, [r2, #12]
#endif /* RCC_PLLSAI1_SUPPORT && RCC_CR_PLLSAI2RDY */

#if defined(RCC_PLLSAI2_SUPPORT)
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
#elif defined(RCC_PLLSAI1_SUPPORT)
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI2CLK);
 8012cde:	4b0f      	ldr	r3, [pc, #60]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012ce0:	68db      	ldr	r3, [r3, #12]
 8012ce2:	4a0e      	ldr	r2, [pc, #56]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012ce4:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8012ce8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8012cec:	60d3      	str	r3, [r2, #12]
#else
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK);
#endif /* RCC_PLLSAI2_SUPPORT */

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8012cee:	f7ff f80b 	bl	8011d08 <HAL_GetTick>
 8012cf2:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8012cf4:	e008      	b.n	8012d08 <HAL_RCC_OscConfig+0x818>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8012cf6:	f7ff f807 	bl	8011d08 <HAL_GetTick>
 8012cfa:	4602      	mov	r2, r0
 8012cfc:	693b      	ldr	r3, [r7, #16]
 8012cfe:	1ad3      	subs	r3, r2, r3
 8012d00:	2b02      	cmp	r3, #2
 8012d02:	d901      	bls.n	8012d08 <HAL_RCC_OscConfig+0x818>
          {
            return HAL_TIMEOUT;
 8012d04:	2303      	movs	r3, #3
 8012d06:	e00e      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8012d08:	4b04      	ldr	r3, [pc, #16]	; (8012d1c <HAL_RCC_OscConfig+0x82c>)
 8012d0a:	681b      	ldr	r3, [r3, #0]
 8012d0c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8012d10:	2b00      	cmp	r3, #0
 8012d12:	d1f0      	bne.n	8012cf6 <HAL_RCC_OscConfig+0x806>
 8012d14:	e006      	b.n	8012d24 <HAL_RCC_OscConfig+0x834>
        }
      }
      else
      {
        /* PLL is already used as System core clock */
        return HAL_ERROR;
 8012d16:	2301      	movs	r3, #1
 8012d18:	e005      	b.n	8012d26 <HAL_RCC_OscConfig+0x836>
 8012d1a:	bf00      	nop
 8012d1c:	40021000 	.word	0x40021000
 8012d20:	019d808c 	.word	0x019d808c
      }
    }
  }
  return HAL_OK;
 8012d24:	2300      	movs	r3, #0
}
 8012d26:	4618      	mov	r0, r3
 8012d28:	3720      	adds	r7, #32
 8012d2a:	46bd      	mov	sp, r7
 8012d2c:	bd80      	pop	{r7, pc}
 8012d2e:	bf00      	nop

08012d30 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8012d30:	b580      	push	{r7, lr}
 8012d32:	b084      	sub	sp, #16
 8012d34:	af00      	add	r7, sp, #0
 8012d36:	6078      	str	r0, [r7, #4]
 8012d38:	6039      	str	r1, [r7, #0]
  uint32_t hpre = RCC_SYSCLK_DIV1;
#endif
  HAL_StatusTypeDef status;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 8012d3a:	687b      	ldr	r3, [r7, #4]
 8012d3c:	2b00      	cmp	r3, #0
 8012d3e:	d101      	bne.n	8012d44 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8012d40:	2301      	movs	r3, #1
 8012d42:	e0c8      	b.n	8012ed6 <HAL_RCC_ClockConfig+0x1a6>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8012d44:	4b66      	ldr	r3, [pc, #408]	; (8012ee0 <HAL_RCC_ClockConfig+0x1b0>)
 8012d46:	681b      	ldr	r3, [r3, #0]
 8012d48:	f003 0307 	and.w	r3, r3, #7
 8012d4c:	683a      	ldr	r2, [r7, #0]
 8012d4e:	429a      	cmp	r2, r3
 8012d50:	d910      	bls.n	8012d74 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8012d52:	4b63      	ldr	r3, [pc, #396]	; (8012ee0 <HAL_RCC_ClockConfig+0x1b0>)
 8012d54:	681b      	ldr	r3, [r3, #0]
 8012d56:	f023 0207 	bic.w	r2, r3, #7
 8012d5a:	4961      	ldr	r1, [pc, #388]	; (8012ee0 <HAL_RCC_ClockConfig+0x1b0>)
 8012d5c:	683b      	ldr	r3, [r7, #0]
 8012d5e:	4313      	orrs	r3, r2
 8012d60:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8012d62:	4b5f      	ldr	r3, [pc, #380]	; (8012ee0 <HAL_RCC_ClockConfig+0x1b0>)
 8012d64:	681b      	ldr	r3, [r3, #0]
 8012d66:	f003 0307 	and.w	r3, r3, #7
 8012d6a:	683a      	ldr	r2, [r7, #0]
 8012d6c:	429a      	cmp	r2, r3
 8012d6e:	d001      	beq.n	8012d74 <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
 8012d70:	2301      	movs	r3, #1
 8012d72:	e0b0      	b.n	8012ed6 <HAL_RCC_ClockConfig+0x1a6>
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8012d74:	687b      	ldr	r3, [r7, #4]
 8012d76:	681b      	ldr	r3, [r3, #0]
 8012d78:	f003 0301 	and.w	r3, r3, #1
 8012d7c:	2b00      	cmp	r3, #0
 8012d7e:	d04c      	beq.n	8012e1a <HAL_RCC_ClockConfig+0xea>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* PLL is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8012d80:	687b      	ldr	r3, [r7, #4]
 8012d82:	685b      	ldr	r3, [r3, #4]
 8012d84:	2b03      	cmp	r3, #3
 8012d86:	d107      	bne.n	8012d98 <HAL_RCC_ClockConfig+0x68>
    {
      /* Check the PLL ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012d88:	4b56      	ldr	r3, [pc, #344]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012d8a:	681b      	ldr	r3, [r3, #0]
 8012d8c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8012d90:	2b00      	cmp	r3, #0
 8012d92:	d121      	bne.n	8012dd8 <HAL_RCC_ClockConfig+0xa8>
      {
        return HAL_ERROR;
 8012d94:	2301      	movs	r3, #1
 8012d96:	e09e      	b.n	8012ed6 <HAL_RCC_ClockConfig+0x1a6>
#endif
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8012d98:	687b      	ldr	r3, [r7, #4]
 8012d9a:	685b      	ldr	r3, [r3, #4]
 8012d9c:	2b02      	cmp	r3, #2
 8012d9e:	d107      	bne.n	8012db0 <HAL_RCC_ClockConfig+0x80>
      {
        /* Check the HSE ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8012da0:	4b50      	ldr	r3, [pc, #320]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012da2:	681b      	ldr	r3, [r3, #0]
 8012da4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8012da8:	2b00      	cmp	r3, #0
 8012daa:	d115      	bne.n	8012dd8 <HAL_RCC_ClockConfig+0xa8>
        {
          return HAL_ERROR;
 8012dac:	2301      	movs	r3, #1
 8012dae:	e092      	b.n	8012ed6 <HAL_RCC_ClockConfig+0x1a6>
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8012db0:	687b      	ldr	r3, [r7, #4]
 8012db2:	685b      	ldr	r3, [r3, #4]
 8012db4:	2b00      	cmp	r3, #0
 8012db6:	d107      	bne.n	8012dc8 <HAL_RCC_ClockConfig+0x98>
      {
        /* Check the MSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8012db8:	4b4a      	ldr	r3, [pc, #296]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012dba:	681b      	ldr	r3, [r3, #0]
 8012dbc:	f003 0302 	and.w	r3, r3, #2
 8012dc0:	2b00      	cmp	r3, #0
 8012dc2:	d109      	bne.n	8012dd8 <HAL_RCC_ClockConfig+0xa8>
        {
          return HAL_ERROR;
 8012dc4:	2301      	movs	r3, #1
 8012dc6:	e086      	b.n	8012ed6 <HAL_RCC_ClockConfig+0x1a6>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8012dc8:	4b46      	ldr	r3, [pc, #280]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012dca:	681b      	ldr	r3, [r3, #0]
 8012dcc:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8012dd0:	2b00      	cmp	r3, #0
 8012dd2:	d101      	bne.n	8012dd8 <HAL_RCC_ClockConfig+0xa8>
        {
          return HAL_ERROR;
 8012dd4:	2301      	movs	r3, #1
 8012dd6:	e07e      	b.n	8012ed6 <HAL_RCC_ClockConfig+0x1a6>
      }
#endif

    }

    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8012dd8:	4b42      	ldr	r3, [pc, #264]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012dda:	689b      	ldr	r3, [r3, #8]
 8012ddc:	f023 0203 	bic.w	r2, r3, #3
 8012de0:	687b      	ldr	r3, [r7, #4]
 8012de2:	685b      	ldr	r3, [r3, #4]
 8012de4:	493f      	ldr	r1, [pc, #252]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012de6:	4313      	orrs	r3, r2
 8012de8:	608b      	str	r3, [r1, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8012dea:	f7fe ff8d 	bl	8011d08 <HAL_GetTick>
 8012dee:	60f8      	str	r0, [r7, #12]

    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8012df0:	e00a      	b.n	8012e08 <HAL_RCC_ClockConfig+0xd8>
    {
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012df2:	f7fe ff89 	bl	8011d08 <HAL_GetTick>
 8012df6:	4602      	mov	r2, r0
 8012df8:	68fb      	ldr	r3, [r7, #12]
 8012dfa:	1ad3      	subs	r3, r2, r3
 8012dfc:	f241 3288 	movw	r2, #5000	; 0x1388
 8012e00:	4293      	cmp	r3, r2
 8012e02:	d901      	bls.n	8012e08 <HAL_RCC_ClockConfig+0xd8>
      {
        return HAL_TIMEOUT;
 8012e04:	2303      	movs	r3, #3
 8012e06:	e066      	b.n	8012ed6 <HAL_RCC_ClockConfig+0x1a6>
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8012e08:	4b36      	ldr	r3, [pc, #216]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012e0a:	689b      	ldr	r3, [r3, #8]
 8012e0c:	f003 020c 	and.w	r2, r3, #12
 8012e10:	687b      	ldr	r3, [r7, #4]
 8012e12:	685b      	ldr	r3, [r3, #4]
 8012e14:	009b      	lsls	r3, r3, #2
 8012e16:	429a      	cmp	r2, r3
 8012e18:	d1eb      	bne.n	8012df2 <HAL_RCC_ClockConfig+0xc2>
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8012e1a:	687b      	ldr	r3, [r7, #4]
 8012e1c:	681b      	ldr	r3, [r3, #0]
 8012e1e:	f003 0302 	and.w	r3, r3, #2
 8012e22:	2b00      	cmp	r3, #0
 8012e24:	d008      	beq.n	8012e38 <HAL_RCC_ClockConfig+0x108>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8012e26:	4b2f      	ldr	r3, [pc, #188]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012e28:	689b      	ldr	r3, [r3, #8]
 8012e2a:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8012e2e:	687b      	ldr	r3, [r7, #4]
 8012e30:	689b      	ldr	r3, [r3, #8]
 8012e32:	492c      	ldr	r1, [pc, #176]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012e34:	4313      	orrs	r3, r2
 8012e36:	608b      	str	r3, [r1, #8]
    }
  }
#endif

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8012e38:	4b29      	ldr	r3, [pc, #164]	; (8012ee0 <HAL_RCC_ClockConfig+0x1b0>)
 8012e3a:	681b      	ldr	r3, [r3, #0]
 8012e3c:	f003 0307 	and.w	r3, r3, #7
 8012e40:	683a      	ldr	r2, [r7, #0]
 8012e42:	429a      	cmp	r2, r3
 8012e44:	d210      	bcs.n	8012e68 <HAL_RCC_ClockConfig+0x138>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8012e46:	4b26      	ldr	r3, [pc, #152]	; (8012ee0 <HAL_RCC_ClockConfig+0x1b0>)
 8012e48:	681b      	ldr	r3, [r3, #0]
 8012e4a:	f023 0207 	bic.w	r2, r3, #7
 8012e4e:	4924      	ldr	r1, [pc, #144]	; (8012ee0 <HAL_RCC_ClockConfig+0x1b0>)
 8012e50:	683b      	ldr	r3, [r7, #0]
 8012e52:	4313      	orrs	r3, r2
 8012e54:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8012e56:	4b22      	ldr	r3, [pc, #136]	; (8012ee0 <HAL_RCC_ClockConfig+0x1b0>)
 8012e58:	681b      	ldr	r3, [r3, #0]
 8012e5a:	f003 0307 	and.w	r3, r3, #7
 8012e5e:	683a      	ldr	r2, [r7, #0]
 8012e60:	429a      	cmp	r2, r3
 8012e62:	d001      	beq.n	8012e68 <HAL_RCC_ClockConfig+0x138>
    {
      return HAL_ERROR;
 8012e64:	2301      	movs	r3, #1
 8012e66:	e036      	b.n	8012ed6 <HAL_RCC_ClockConfig+0x1a6>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8012e68:	687b      	ldr	r3, [r7, #4]
 8012e6a:	681b      	ldr	r3, [r3, #0]
 8012e6c:	f003 0304 	and.w	r3, r3, #4
 8012e70:	2b00      	cmp	r3, #0
 8012e72:	d008      	beq.n	8012e86 <HAL_RCC_ClockConfig+0x156>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8012e74:	4b1b      	ldr	r3, [pc, #108]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012e76:	689b      	ldr	r3, [r3, #8]
 8012e78:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8012e7c:	687b      	ldr	r3, [r7, #4]
 8012e7e:	68db      	ldr	r3, [r3, #12]
 8012e80:	4918      	ldr	r1, [pc, #96]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012e82:	4313      	orrs	r3, r2
 8012e84:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8012e86:	687b      	ldr	r3, [r7, #4]
 8012e88:	681b      	ldr	r3, [r3, #0]
 8012e8a:	f003 0308 	and.w	r3, r3, #8
 8012e8e:	2b00      	cmp	r3, #0
 8012e90:	d009      	beq.n	8012ea6 <HAL_RCC_ClockConfig+0x176>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8012e92:	4b14      	ldr	r3, [pc, #80]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012e94:	689b      	ldr	r3, [r3, #8]
 8012e96:	f423 5260 	bic.w	r2, r3, #14336	; 0x3800
 8012e9a:	687b      	ldr	r3, [r7, #4]
 8012e9c:	691b      	ldr	r3, [r3, #16]
 8012e9e:	00db      	lsls	r3, r3, #3
 8012ea0:	4910      	ldr	r1, [pc, #64]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012ea2:	4313      	orrs	r3, r2
 8012ea4:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8012ea6:	f000 f825 	bl	8012ef4 <HAL_RCC_GetSysClockFreq>
 8012eaa:	4601      	mov	r1, r0
 8012eac:	4b0d      	ldr	r3, [pc, #52]	; (8012ee4 <HAL_RCC_ClockConfig+0x1b4>)
 8012eae:	689b      	ldr	r3, [r3, #8]
 8012eb0:	091b      	lsrs	r3, r3, #4
 8012eb2:	f003 030f 	and.w	r3, r3, #15
 8012eb6:	4a0c      	ldr	r2, [pc, #48]	; (8012ee8 <HAL_RCC_ClockConfig+0x1b8>)
 8012eb8:	5cd3      	ldrb	r3, [r2, r3]
 8012eba:	f003 031f 	and.w	r3, r3, #31
 8012ebe:	fa21 f303 	lsr.w	r3, r1, r3
 8012ec2:	4a0a      	ldr	r2, [pc, #40]	; (8012eec <HAL_RCC_ClockConfig+0x1bc>)
 8012ec4:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 8012ec6:	4b0a      	ldr	r3, [pc, #40]	; (8012ef0 <HAL_RCC_ClockConfig+0x1c0>)
 8012ec8:	681b      	ldr	r3, [r3, #0]
 8012eca:	4618      	mov	r0, r3
 8012ecc:	f7fe fed0 	bl	8011c70 <HAL_InitTick>
 8012ed0:	4603      	mov	r3, r0
 8012ed2:	72fb      	strb	r3, [r7, #11]

  return status;
 8012ed4:	7afb      	ldrb	r3, [r7, #11]
}
 8012ed6:	4618      	mov	r0, r3
 8012ed8:	3710      	adds	r7, #16
 8012eda:	46bd      	mov	sp, r7
 8012edc:	bd80      	pop	{r7, pc}
 8012ede:	bf00      	nop
 8012ee0:	40022000 	.word	0x40022000
 8012ee4:	40021000 	.word	0x40021000
 8012ee8:	08016d84 	.word	0x08016d84
 8012eec:	20000068 	.word	0x20000068
 8012ef0:	2000006c 	.word	0x2000006c

08012ef4 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8012ef4:	b480      	push	{r7}
 8012ef6:	b089      	sub	sp, #36	; 0x24
 8012ef8:	af00      	add	r7, sp, #0
  uint32_t msirange = 0U, sysclockfreq = 0U;
 8012efa:	2300      	movs	r3, #0
 8012efc:	61fb      	str	r3, [r7, #28]
 8012efe:	2300      	movs	r3, #0
 8012f00:	61bb      	str	r3, [r7, #24]
  uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
  uint32_t sysclk_source, pll_oscsource;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8012f02:	4b3d      	ldr	r3, [pc, #244]	; (8012ff8 <HAL_RCC_GetSysClockFreq+0x104>)
 8012f04:	689b      	ldr	r3, [r3, #8]
 8012f06:	f003 030c 	and.w	r3, r3, #12
 8012f0a:	613b      	str	r3, [r7, #16]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8012f0c:	4b3a      	ldr	r3, [pc, #232]	; (8012ff8 <HAL_RCC_GetSysClockFreq+0x104>)
 8012f0e:	68db      	ldr	r3, [r3, #12]
 8012f10:	f003 0303 	and.w	r3, r3, #3
 8012f14:	60fb      	str	r3, [r7, #12]

  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8012f16:	693b      	ldr	r3, [r7, #16]
 8012f18:	2b00      	cmp	r3, #0
 8012f1a:	d005      	beq.n	8012f28 <HAL_RCC_GetSysClockFreq+0x34>
 8012f1c:	693b      	ldr	r3, [r7, #16]
 8012f1e:	2b0c      	cmp	r3, #12
 8012f20:	d121      	bne.n	8012f66 <HAL_RCC_GetSysClockFreq+0x72>
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8012f22:	68fb      	ldr	r3, [r7, #12]
 8012f24:	2b01      	cmp	r3, #1
 8012f26:	d11e      	bne.n	8012f66 <HAL_RCC_GetSysClockFreq+0x72>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8012f28:	4b33      	ldr	r3, [pc, #204]	; (8012ff8 <HAL_RCC_GetSysClockFreq+0x104>)
 8012f2a:	681b      	ldr	r3, [r3, #0]
 8012f2c:	f003 0308 	and.w	r3, r3, #8
 8012f30:	2b00      	cmp	r3, #0
 8012f32:	d107      	bne.n	8012f44 <HAL_RCC_GetSysClockFreq+0x50>
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8012f34:	4b30      	ldr	r3, [pc, #192]	; (8012ff8 <HAL_RCC_GetSysClockFreq+0x104>)
 8012f36:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8012f3a:	0a1b      	lsrs	r3, r3, #8
 8012f3c:	f003 030f 	and.w	r3, r3, #15
 8012f40:	61fb      	str	r3, [r7, #28]
 8012f42:	e005      	b.n	8012f50 <HAL_RCC_GetSysClockFreq+0x5c>
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8012f44:	4b2c      	ldr	r3, [pc, #176]	; (8012ff8 <HAL_RCC_GetSysClockFreq+0x104>)
 8012f46:	681b      	ldr	r3, [r3, #0]
 8012f48:	091b      	lsrs	r3, r3, #4
 8012f4a:	f003 030f 	and.w	r3, r3, #15
 8012f4e:	61fb      	str	r3, [r7, #28]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8012f50:	4a2a      	ldr	r2, [pc, #168]	; (8012ffc <HAL_RCC_GetSysClockFreq+0x108>)
 8012f52:	69fb      	ldr	r3, [r7, #28]
 8012f54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012f58:	61fb      	str	r3, [r7, #28]

    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8012f5a:	693b      	ldr	r3, [r7, #16]
 8012f5c:	2b00      	cmp	r3, #0
 8012f5e:	d10d      	bne.n	8012f7c <HAL_RCC_GetSysClockFreq+0x88>
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 8012f60:	69fb      	ldr	r3, [r7, #28]
 8012f62:	61bb      	str	r3, [r7, #24]
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8012f64:	e00a      	b.n	8012f7c <HAL_RCC_GetSysClockFreq+0x88>
    }
  }
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 8012f66:	693b      	ldr	r3, [r7, #16]
 8012f68:	2b04      	cmp	r3, #4
 8012f6a:	d102      	bne.n	8012f72 <HAL_RCC_GetSysClockFreq+0x7e>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8012f6c:	4b24      	ldr	r3, [pc, #144]	; (8013000 <HAL_RCC_GetSysClockFreq+0x10c>)
 8012f6e:	61bb      	str	r3, [r7, #24]
 8012f70:	e004      	b.n	8012f7c <HAL_RCC_GetSysClockFreq+0x88>
  }
  else if(sysclk_source == RCC_CFGR_SWS_HSE)
 8012f72:	693b      	ldr	r3, [r7, #16]
 8012f74:	2b08      	cmp	r3, #8
 8012f76:	d101      	bne.n	8012f7c <HAL_RCC_GetSysClockFreq+0x88>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 8012f78:	4b22      	ldr	r3, [pc, #136]	; (8013004 <HAL_RCC_GetSysClockFreq+0x110>)
 8012f7a:	61bb      	str	r3, [r7, #24]
  else
  {
    /* unexpected case: sysclockfreq at 0 */
  }

  if(sysclk_source == RCC_CFGR_SWS_PLL)
 8012f7c:	693b      	ldr	r3, [r7, #16]
 8012f7e:	2b0c      	cmp	r3, #12
 8012f80:	d133      	bne.n	8012fea <HAL_RCC_GetSysClockFreq+0xf6>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE) * PLLN / PLLM
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8012f82:	4b1d      	ldr	r3, [pc, #116]	; (8012ff8 <HAL_RCC_GetSysClockFreq+0x104>)
 8012f84:	68db      	ldr	r3, [r3, #12]
 8012f86:	f003 0303 	and.w	r3, r3, #3
 8012f8a:	60bb      	str	r3, [r7, #8]

    switch (pllsource)
 8012f8c:	68bb      	ldr	r3, [r7, #8]
 8012f8e:	2b02      	cmp	r3, #2
 8012f90:	d002      	beq.n	8012f98 <HAL_RCC_GetSysClockFreq+0xa4>
 8012f92:	2b03      	cmp	r3, #3
 8012f94:	d003      	beq.n	8012f9e <HAL_RCC_GetSysClockFreq+0xaa>
 8012f96:	e005      	b.n	8012fa4 <HAL_RCC_GetSysClockFreq+0xb0>
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = HSI_VALUE;
 8012f98:	4b19      	ldr	r3, [pc, #100]	; (8013000 <HAL_RCC_GetSysClockFreq+0x10c>)
 8012f9a:	617b      	str	r3, [r7, #20]
      break;
 8012f9c:	e005      	b.n	8012faa <HAL_RCC_GetSysClockFreq+0xb6>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = HSE_VALUE;
 8012f9e:	4b19      	ldr	r3, [pc, #100]	; (8013004 <HAL_RCC_GetSysClockFreq+0x110>)
 8012fa0:	617b      	str	r3, [r7, #20]
      break;
 8012fa2:	e002      	b.n	8012faa <HAL_RCC_GetSysClockFreq+0xb6>

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = msirange;
 8012fa4:	69fb      	ldr	r3, [r7, #28]
 8012fa6:	617b      	str	r3, [r7, #20]
      break;
 8012fa8:	bf00      	nop
    }
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8012faa:	4b13      	ldr	r3, [pc, #76]	; (8012ff8 <HAL_RCC_GetSysClockFreq+0x104>)
 8012fac:	68db      	ldr	r3, [r3, #12]
 8012fae:	091b      	lsrs	r3, r3, #4
 8012fb0:	f003 0307 	and.w	r3, r3, #7
 8012fb4:	3301      	adds	r3, #1
 8012fb6:	607b      	str	r3, [r7, #4]
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8012fb8:	4b0f      	ldr	r3, [pc, #60]	; (8012ff8 <HAL_RCC_GetSysClockFreq+0x104>)
 8012fba:	68db      	ldr	r3, [r3, #12]
 8012fbc:	0a1b      	lsrs	r3, r3, #8
 8012fbe:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012fc2:	697a      	ldr	r2, [r7, #20]
 8012fc4:	fb02 f203 	mul.w	r2, r2, r3
 8012fc8:	687b      	ldr	r3, [r7, #4]
 8012fca:	fbb2 f3f3 	udiv	r3, r2, r3
 8012fce:	617b      	str	r3, [r7, #20]
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8012fd0:	4b09      	ldr	r3, [pc, #36]	; (8012ff8 <HAL_RCC_GetSysClockFreq+0x104>)
 8012fd2:	68db      	ldr	r3, [r3, #12]
 8012fd4:	0e5b      	lsrs	r3, r3, #25
 8012fd6:	f003 0303 	and.w	r3, r3, #3
 8012fda:	3301      	adds	r3, #1
 8012fdc:	005b      	lsls	r3, r3, #1
 8012fde:	603b      	str	r3, [r7, #0]
    sysclockfreq = pllvco / pllr;
 8012fe0:	697a      	ldr	r2, [r7, #20]
 8012fe2:	683b      	ldr	r3, [r7, #0]
 8012fe4:	fbb2 f3f3 	udiv	r3, r2, r3
 8012fe8:	61bb      	str	r3, [r7, #24]
  }

  return sysclockfreq;
 8012fea:	69bb      	ldr	r3, [r7, #24]
}
 8012fec:	4618      	mov	r0, r3
 8012fee:	3724      	adds	r7, #36	; 0x24
 8012ff0:	46bd      	mov	sp, r7
 8012ff2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012ff6:	4770      	bx	lr
 8012ff8:	40021000 	.word	0x40021000
 8012ffc:	08016d94 	.word	0x08016d94
 8013000:	00f42400 	.word	0x00f42400
 8013004:	007a1200 	.word	0x007a1200

08013008 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8013008:	b580      	push	{r7, lr}
 801300a:	b086      	sub	sp, #24
 801300c:	af00      	add	r7, sp, #0
 801300e:	6078      	str	r0, [r7, #4]
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8013010:	2300      	movs	r3, #0
 8013012:	613b      	str	r3, [r7, #16]

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8013014:	4b2a      	ldr	r3, [pc, #168]	; (80130c0 <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 8013016:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8013018:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 801301c:	2b00      	cmp	r3, #0
 801301e:	d003      	beq.n	8013028 <RCC_SetFlashLatencyFromMSIRange+0x20>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8013020:	f7ff fa02 	bl	8012428 <HAL_PWREx_GetVoltageRange>
 8013024:	6178      	str	r0, [r7, #20]
 8013026:	e014      	b.n	8013052 <RCC_SetFlashLatencyFromMSIRange+0x4a>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 8013028:	4b25      	ldr	r3, [pc, #148]	; (80130c0 <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 801302a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801302c:	4a24      	ldr	r2, [pc, #144]	; (80130c0 <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 801302e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8013032:	6593      	str	r3, [r2, #88]	; 0x58
 8013034:	4b22      	ldr	r3, [pc, #136]	; (80130c0 <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 8013036:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8013038:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 801303c:	60fb      	str	r3, [r7, #12]
 801303e:	68fb      	ldr	r3, [r7, #12]
    vos = HAL_PWREx_GetVoltageRange();
 8013040:	f7ff f9f2 	bl	8012428 <HAL_PWREx_GetVoltageRange>
 8013044:	6178      	str	r0, [r7, #20]
    __HAL_RCC_PWR_CLK_DISABLE();
 8013046:	4b1e      	ldr	r3, [pc, #120]	; (80130c0 <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 8013048:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801304a:	4a1d      	ldr	r2, [pc, #116]	; (80130c0 <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 801304c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8013050:	6593      	str	r3, [r2, #88]	; 0x58
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8013052:	697b      	ldr	r3, [r7, #20]
 8013054:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8013058:	d10b      	bne.n	8013072 <RCC_SetFlashLatencyFromMSIRange+0x6a>
  {
    if(msirange > RCC_MSIRANGE_8)
 801305a:	687b      	ldr	r3, [r7, #4]
 801305c:	2b80      	cmp	r3, #128	; 0x80
 801305e:	d919      	bls.n	8013094 <RCC_SetFlashLatencyFromMSIRange+0x8c>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 8013060:	687b      	ldr	r3, [r7, #4]
 8013062:	2ba0      	cmp	r3, #160	; 0xa0
 8013064:	d902      	bls.n	801306c <RCC_SetFlashLatencyFromMSIRange+0x64>
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 8013066:	2302      	movs	r3, #2
 8013068:	613b      	str	r3, [r7, #16]
 801306a:	e013      	b.n	8013094 <RCC_SetFlashLatencyFromMSIRange+0x8c>
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 801306c:	2301      	movs	r3, #1
 801306e:	613b      	str	r3, [r7, #16]
 8013070:	e010      	b.n	8013094 <RCC_SetFlashLatencyFromMSIRange+0x8c>
        latency = FLASH_LATENCY_1; /* 1WS */
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#else
    if(msirange > RCC_MSIRANGE_8)
 8013072:	687b      	ldr	r3, [r7, #4]
 8013074:	2b80      	cmp	r3, #128	; 0x80
 8013076:	d902      	bls.n	801307e <RCC_SetFlashLatencyFromMSIRange+0x76>
    {
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
 8013078:	2303      	movs	r3, #3
 801307a:	613b      	str	r3, [r7, #16]
 801307c:	e00a      	b.n	8013094 <RCC_SetFlashLatencyFromMSIRange+0x8c>
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 801307e:	687b      	ldr	r3, [r7, #4]
 8013080:	2b80      	cmp	r3, #128	; 0x80
 8013082:	d102      	bne.n	801308a <RCC_SetFlashLatencyFromMSIRange+0x82>
      {
        /* MSI 16Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 8013084:	2302      	movs	r3, #2
 8013086:	613b      	str	r3, [r7, #16]
 8013088:	e004      	b.n	8013094 <RCC_SetFlashLatencyFromMSIRange+0x8c>
      }
      else if(msirange == RCC_MSIRANGE_7)
 801308a:	687b      	ldr	r3, [r7, #4]
 801308c:	2b70      	cmp	r3, #112	; 0x70
 801308e:	d101      	bne.n	8013094 <RCC_SetFlashLatencyFromMSIRange+0x8c>
      {
        /* MSI 8Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 8013090:	2301      	movs	r3, #1
 8013092:	613b      	str	r3, [r7, #16]
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8013094:	4b0b      	ldr	r3, [pc, #44]	; (80130c4 <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 8013096:	681b      	ldr	r3, [r3, #0]
 8013098:	f023 0207 	bic.w	r2, r3, #7
 801309c:	4909      	ldr	r1, [pc, #36]	; (80130c4 <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 801309e:	693b      	ldr	r3, [r7, #16]
 80130a0:	4313      	orrs	r3, r2
 80130a2:	600b      	str	r3, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 80130a4:	4b07      	ldr	r3, [pc, #28]	; (80130c4 <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 80130a6:	681b      	ldr	r3, [r3, #0]
 80130a8:	f003 0307 	and.w	r3, r3, #7
 80130ac:	693a      	ldr	r2, [r7, #16]
 80130ae:	429a      	cmp	r2, r3
 80130b0:	d001      	beq.n	80130b6 <RCC_SetFlashLatencyFromMSIRange+0xae>
  {
    return HAL_ERROR;
 80130b2:	2301      	movs	r3, #1
 80130b4:	e000      	b.n	80130b8 <RCC_SetFlashLatencyFromMSIRange+0xb0>
  }

  return HAL_OK;
 80130b6:	2300      	movs	r3, #0
}
 80130b8:	4618      	mov	r0, r3
 80130ba:	3718      	adds	r7, #24
 80130bc:	46bd      	mov	sp, r7
 80130be:	bd80      	pop	{r7, pc}
 80130c0:	40021000 	.word	0x40021000
 80130c4:	40022000 	.word	0x40022000

080130c8 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80130c8:	b580      	push	{r7, lr}
 80130ca:	b084      	sub	sp, #16
 80130cc:	af00      	add	r7, sp, #0
 80130ce:	6078      	str	r0, [r7, #4]
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 80130d0:	687b      	ldr	r3, [r7, #4]
 80130d2:	2b00      	cmp	r3, #0
 80130d4:	d101      	bne.n	80130da <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 80130d6:	2301      	movs	r3, #1
 80130d8:	e07c      	b.n	80131d4 <HAL_SPI_Init+0x10c>
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80130da:	687b      	ldr	r3, [r7, #4]
 80130dc:	2200      	movs	r2, #0
 80130de:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 80130e0:	687b      	ldr	r3, [r7, #4]
 80130e2:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 80130e6:	b2db      	uxtb	r3, r3
 80130e8:	2b00      	cmp	r3, #0
 80130ea:	d106      	bne.n	80130fa <HAL_SPI_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 80130ec:	687b      	ldr	r3, [r7, #4]
 80130ee:	2200      	movs	r2, #0
 80130f0:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 80130f4:	6878      	ldr	r0, [r7, #4]
 80130f6:	f7fe fcb3 	bl	8011a60 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 80130fa:	687b      	ldr	r3, [r7, #4]
 80130fc:	2202      	movs	r2, #2
 80130fe:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8013102:	687b      	ldr	r3, [r7, #4]
 8013104:	681b      	ldr	r3, [r3, #0]
 8013106:	681a      	ldr	r2, [r3, #0]
 8013108:	687b      	ldr	r3, [r7, #4]
 801310a:	681b      	ldr	r3, [r3, #0]
 801310c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8013110:	601a      	str	r2, [r3, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8013112:	687b      	ldr	r3, [r7, #4]
 8013114:	68db      	ldr	r3, [r3, #12]
 8013116:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 801311a:	d902      	bls.n	8013122 <HAL_SPI_Init+0x5a>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 801311c:	2300      	movs	r3, #0
 801311e:	60fb      	str	r3, [r7, #12]
 8013120:	e002      	b.n	8013128 <HAL_SPI_Init+0x60>
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8013122:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8013126:	60fb      	str	r3, [r7, #12]
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8013128:	687b      	ldr	r3, [r7, #4]
 801312a:	68db      	ldr	r3, [r3, #12]
 801312c:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 8013130:	d007      	beq.n	8013142 <HAL_SPI_Init+0x7a>
 8013132:	687b      	ldr	r3, [r7, #4]
 8013134:	68db      	ldr	r3, [r3, #12]
 8013136:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 801313a:	d002      	beq.n	8013142 <HAL_SPI_Init+0x7a>
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 801313c:	687b      	ldr	r3, [r7, #4]
 801313e:	2200      	movs	r2, #0
 8013140:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Align the CRC Length on the data size */
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8013142:	687b      	ldr	r3, [r7, #4]
 8013144:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013146:	2b00      	cmp	r3, #0
 8013148:	d10b      	bne.n	8013162 <HAL_SPI_Init+0x9a>
  {
    /* CRC Length aligned on the data size : value set by default */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 801314a:	687b      	ldr	r3, [r7, #4]
 801314c:	68db      	ldr	r3, [r3, #12]
 801314e:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8013152:	d903      	bls.n	801315c <HAL_SPI_Init+0x94>
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8013154:	687b      	ldr	r3, [r7, #4]
 8013156:	2202      	movs	r2, #2
 8013158:	631a      	str	r2, [r3, #48]	; 0x30
 801315a:	e002      	b.n	8013162 <HAL_SPI_Init+0x9a>
    }
    else
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 801315c:	687b      	ldr	r3, [r7, #4]
 801315e:	2201      	movs	r2, #1
 8013160:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8013162:	687b      	ldr	r3, [r7, #4]
 8013164:	685a      	ldr	r2, [r3, #4]
 8013166:	687b      	ldr	r3, [r7, #4]
 8013168:	689b      	ldr	r3, [r3, #8]
 801316a:	431a      	orrs	r2, r3
 801316c:	687b      	ldr	r3, [r7, #4]
 801316e:	691b      	ldr	r3, [r3, #16]
 8013170:	431a      	orrs	r2, r3
 8013172:	687b      	ldr	r3, [r7, #4]
 8013174:	695b      	ldr	r3, [r3, #20]
 8013176:	431a      	orrs	r2, r3
 8013178:	687b      	ldr	r3, [r7, #4]
 801317a:	699b      	ldr	r3, [r3, #24]
 801317c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8013180:	431a      	orrs	r2, r3
 8013182:	687b      	ldr	r3, [r7, #4]
 8013184:	69db      	ldr	r3, [r3, #28]
 8013186:	431a      	orrs	r2, r3
 8013188:	687b      	ldr	r3, [r7, #4]
 801318a:	6a1b      	ldr	r3, [r3, #32]
 801318c:	ea42 0103 	orr.w	r1, r2, r3
 8013190:	687b      	ldr	r3, [r7, #4]
 8013192:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8013194:	687b      	ldr	r3, [r7, #4]
 8013196:	681b      	ldr	r3, [r3, #0]
 8013198:	430a      	orrs	r2, r1
 801319a:	601a      	str	r2, [r3, #0]
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 801319c:	687b      	ldr	r3, [r7, #4]
 801319e:	699b      	ldr	r3, [r3, #24]
 80131a0:	0c1b      	lsrs	r3, r3, #16
 80131a2:	f003 0204 	and.w	r2, r3, #4
 80131a6:	687b      	ldr	r3, [r7, #4]
 80131a8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80131aa:	431a      	orrs	r2, r3
 80131ac:	687b      	ldr	r3, [r7, #4]
 80131ae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80131b0:	431a      	orrs	r2, r3
 80131b2:	687b      	ldr	r3, [r7, #4]
 80131b4:	68db      	ldr	r3, [r3, #12]
 80131b6:	ea42 0103 	orr.w	r1, r2, r3
 80131ba:	687b      	ldr	r3, [r7, #4]
 80131bc:	681b      	ldr	r3, [r3, #0]
 80131be:	68fa      	ldr	r2, [r7, #12]
 80131c0:	430a      	orrs	r2, r1
 80131c2:	605a      	str	r2, [r3, #4]
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80131c4:	687b      	ldr	r3, [r7, #4]
 80131c6:	2200      	movs	r2, #0
 80131c8:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 80131ca:	687b      	ldr	r3, [r7, #4]
 80131cc:	2201      	movs	r2, #1
 80131ce:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  return HAL_OK;
 80131d2:	2300      	movs	r3, #0
}
 80131d4:	4618      	mov	r0, r3
 80131d6:	3710      	adds	r7, #16
 80131d8:	46bd      	mov	sp, r7
 80131da:	bd80      	pop	{r7, pc}

080131dc <HAL_SPI_Transmit>:
  * @param  Size amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80131dc:	b580      	push	{r7, lr}
 80131de:	b088      	sub	sp, #32
 80131e0:	af00      	add	r7, sp, #0
 80131e2:	60f8      	str	r0, [r7, #12]
 80131e4:	60b9      	str	r1, [r7, #8]
 80131e6:	603b      	str	r3, [r7, #0]
 80131e8:	4613      	mov	r3, r2
 80131ea:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;
  HAL_StatusTypeDef errorcode = HAL_OK;
 80131ec:	2300      	movs	r3, #0
 80131ee:	77fb      	strb	r3, [r7, #31]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 80131f0:	68fb      	ldr	r3, [r7, #12]
 80131f2:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80131f6:	2b01      	cmp	r3, #1
 80131f8:	d101      	bne.n	80131fe <HAL_SPI_Transmit+0x22>
 80131fa:	2302      	movs	r3, #2
 80131fc:	e150      	b.n	80134a0 <HAL_SPI_Transmit+0x2c4>
 80131fe:	68fb      	ldr	r3, [r7, #12]
 8013200:	2201      	movs	r2, #1
 8013202:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8013206:	f7fe fd7f 	bl	8011d08 <HAL_GetTick>
 801320a:	61b8      	str	r0, [r7, #24]
  initial_TxXferCount = Size;
 801320c:	88fb      	ldrh	r3, [r7, #6]
 801320e:	82fb      	strh	r3, [r7, #22]

  if (hspi->State != HAL_SPI_STATE_READY)
 8013210:	68fb      	ldr	r3, [r7, #12]
 8013212:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8013216:	b2db      	uxtb	r3, r3
 8013218:	2b01      	cmp	r3, #1
 801321a:	d002      	beq.n	8013222 <HAL_SPI_Transmit+0x46>
  {
    errorcode = HAL_BUSY;
 801321c:	2302      	movs	r3, #2
 801321e:	77fb      	strb	r3, [r7, #31]
    goto error;
 8013220:	e135      	b.n	801348e <HAL_SPI_Transmit+0x2b2>
  }

  if ((pData == NULL) || (Size == 0U))
 8013222:	68bb      	ldr	r3, [r7, #8]
 8013224:	2b00      	cmp	r3, #0
 8013226:	d002      	beq.n	801322e <HAL_SPI_Transmit+0x52>
 8013228:	88fb      	ldrh	r3, [r7, #6]
 801322a:	2b00      	cmp	r3, #0
 801322c:	d102      	bne.n	8013234 <HAL_SPI_Transmit+0x58>
  {
    errorcode = HAL_ERROR;
 801322e:	2301      	movs	r3, #1
 8013230:	77fb      	strb	r3, [r7, #31]
    goto error;
 8013232:	e12c      	b.n	801348e <HAL_SPI_Transmit+0x2b2>
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8013234:	68fb      	ldr	r3, [r7, #12]
 8013236:	2203      	movs	r2, #3
 8013238:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 801323c:	68fb      	ldr	r3, [r7, #12]
 801323e:	2200      	movs	r2, #0
 8013240:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8013242:	68fb      	ldr	r3, [r7, #12]
 8013244:	68ba      	ldr	r2, [r7, #8]
 8013246:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8013248:	68fb      	ldr	r3, [r7, #12]
 801324a:	88fa      	ldrh	r2, [r7, #6]
 801324c:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->TxXferCount = Size;
 801324e:	68fb      	ldr	r3, [r7, #12]
 8013250:	88fa      	ldrh	r2, [r7, #6]
 8013252:	87da      	strh	r2, [r3, #62]	; 0x3e

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8013254:	68fb      	ldr	r3, [r7, #12]
 8013256:	2200      	movs	r2, #0
 8013258:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->RxXferSize  = 0U;
 801325a:	68fb      	ldr	r3, [r7, #12]
 801325c:	2200      	movs	r2, #0
 801325e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  hspi->RxXferCount = 0U;
 8013262:	68fb      	ldr	r3, [r7, #12]
 8013264:	2200      	movs	r2, #0
 8013266:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
  hspi->TxISR       = NULL;
 801326a:	68fb      	ldr	r3, [r7, #12]
 801326c:	2200      	movs	r2, #0
 801326e:	651a      	str	r2, [r3, #80]	; 0x50
  hspi->RxISR       = NULL;
 8013270:	68fb      	ldr	r3, [r7, #12]
 8013272:	2200      	movs	r2, #0
 8013274:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8013276:	68fb      	ldr	r3, [r7, #12]
 8013278:	689b      	ldr	r3, [r3, #8]
 801327a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 801327e:	d107      	bne.n	8013290 <HAL_SPI_Transmit+0xb4>
  {
    SPI_1LINE_TX(hspi);
 8013280:	68fb      	ldr	r3, [r7, #12]
 8013282:	681b      	ldr	r3, [r3, #0]
 8013284:	681a      	ldr	r2, [r3, #0]
 8013286:	68fb      	ldr	r3, [r7, #12]
 8013288:	681b      	ldr	r3, [r3, #0]
 801328a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 801328e:	601a      	str	r2, [r3, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8013290:	68fb      	ldr	r3, [r7, #12]
 8013292:	681b      	ldr	r3, [r3, #0]
 8013294:	681b      	ldr	r3, [r3, #0]
 8013296:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801329a:	2b40      	cmp	r3, #64	; 0x40
 801329c:	d007      	beq.n	80132ae <HAL_SPI_Transmit+0xd2>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 801329e:	68fb      	ldr	r3, [r7, #12]
 80132a0:	681b      	ldr	r3, [r3, #0]
 80132a2:	681a      	ldr	r2, [r3, #0]
 80132a4:	68fb      	ldr	r3, [r7, #12]
 80132a6:	681b      	ldr	r3, [r3, #0]
 80132a8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80132ac:	601a      	str	r2, [r3, #0]
  }

  /* Transmit data in 16 Bit mode */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80132ae:	68fb      	ldr	r3, [r7, #12]
 80132b0:	68db      	ldr	r3, [r3, #12]
 80132b2:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 80132b6:	d94b      	bls.n	8013350 <HAL_SPI_Transmit+0x174>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80132b8:	68fb      	ldr	r3, [r7, #12]
 80132ba:	685b      	ldr	r3, [r3, #4]
 80132bc:	2b00      	cmp	r3, #0
 80132be:	d002      	beq.n	80132c6 <HAL_SPI_Transmit+0xea>
 80132c0:	8afb      	ldrh	r3, [r7, #22]
 80132c2:	2b01      	cmp	r3, #1
 80132c4:	d13e      	bne.n	8013344 <HAL_SPI_Transmit+0x168>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80132c6:	68fb      	ldr	r3, [r7, #12]
 80132c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80132ca:	881a      	ldrh	r2, [r3, #0]
 80132cc:	68fb      	ldr	r3, [r7, #12]
 80132ce:	681b      	ldr	r3, [r3, #0]
 80132d0:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 80132d2:	68fb      	ldr	r3, [r7, #12]
 80132d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80132d6:	1c9a      	adds	r2, r3, #2
 80132d8:	68fb      	ldr	r3, [r7, #12]
 80132da:	639a      	str	r2, [r3, #56]	; 0x38
      hspi->TxXferCount--;
 80132dc:	68fb      	ldr	r3, [r7, #12]
 80132de:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80132e0:	b29b      	uxth	r3, r3
 80132e2:	3b01      	subs	r3, #1
 80132e4:	b29a      	uxth	r2, r3
 80132e6:	68fb      	ldr	r3, [r7, #12]
 80132e8:	87da      	strh	r2, [r3, #62]	; 0x3e
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 80132ea:	e02b      	b.n	8013344 <HAL_SPI_Transmit+0x168>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80132ec:	68fb      	ldr	r3, [r7, #12]
 80132ee:	681b      	ldr	r3, [r3, #0]
 80132f0:	689b      	ldr	r3, [r3, #8]
 80132f2:	f003 0302 	and.w	r3, r3, #2
 80132f6:	2b02      	cmp	r3, #2
 80132f8:	d112      	bne.n	8013320 <HAL_SPI_Transmit+0x144>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80132fa:	68fb      	ldr	r3, [r7, #12]
 80132fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80132fe:	881a      	ldrh	r2, [r3, #0]
 8013300:	68fb      	ldr	r3, [r7, #12]
 8013302:	681b      	ldr	r3, [r3, #0]
 8013304:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8013306:	68fb      	ldr	r3, [r7, #12]
 8013308:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801330a:	1c9a      	adds	r2, r3, #2
 801330c:	68fb      	ldr	r3, [r7, #12]
 801330e:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 8013310:	68fb      	ldr	r3, [r7, #12]
 8013312:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8013314:	b29b      	uxth	r3, r3
 8013316:	3b01      	subs	r3, #1
 8013318:	b29a      	uxth	r2, r3
 801331a:	68fb      	ldr	r3, [r7, #12]
 801331c:	87da      	strh	r2, [r3, #62]	; 0x3e
 801331e:	e011      	b.n	8013344 <HAL_SPI_Transmit+0x168>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8013320:	f7fe fcf2 	bl	8011d08 <HAL_GetTick>
 8013324:	4602      	mov	r2, r0
 8013326:	69bb      	ldr	r3, [r7, #24]
 8013328:	1ad3      	subs	r3, r2, r3
 801332a:	683a      	ldr	r2, [r7, #0]
 801332c:	429a      	cmp	r2, r3
 801332e:	d803      	bhi.n	8013338 <HAL_SPI_Transmit+0x15c>
 8013330:	683b      	ldr	r3, [r7, #0]
 8013332:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8013336:	d102      	bne.n	801333e <HAL_SPI_Transmit+0x162>
 8013338:	683b      	ldr	r3, [r7, #0]
 801333a:	2b00      	cmp	r3, #0
 801333c:	d102      	bne.n	8013344 <HAL_SPI_Transmit+0x168>
        {
          errorcode = HAL_TIMEOUT;
 801333e:	2303      	movs	r3, #3
 8013340:	77fb      	strb	r3, [r7, #31]
          goto error;
 8013342:	e0a4      	b.n	801348e <HAL_SPI_Transmit+0x2b2>
    while (hspi->TxXferCount > 0U)
 8013344:	68fb      	ldr	r3, [r7, #12]
 8013346:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8013348:	b29b      	uxth	r3, r3
 801334a:	2b00      	cmp	r3, #0
 801334c:	d1ce      	bne.n	80132ec <HAL_SPI_Transmit+0x110>
 801334e:	e07c      	b.n	801344a <HAL_SPI_Transmit+0x26e>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8013350:	68fb      	ldr	r3, [r7, #12]
 8013352:	685b      	ldr	r3, [r3, #4]
 8013354:	2b00      	cmp	r3, #0
 8013356:	d002      	beq.n	801335e <HAL_SPI_Transmit+0x182>
 8013358:	8afb      	ldrh	r3, [r7, #22]
 801335a:	2b01      	cmp	r3, #1
 801335c:	d170      	bne.n	8013440 <HAL_SPI_Transmit+0x264>
    {
      if (hspi->TxXferCount > 1U)
 801335e:	68fb      	ldr	r3, [r7, #12]
 8013360:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8013362:	b29b      	uxth	r3, r3
 8013364:	2b01      	cmp	r3, #1
 8013366:	d912      	bls.n	801338e <HAL_SPI_Transmit+0x1b2>
      {
        /* write on the data register in packing mode */
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8013368:	68fb      	ldr	r3, [r7, #12]
 801336a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801336c:	881a      	ldrh	r2, [r3, #0]
 801336e:	68fb      	ldr	r3, [r7, #12]
 8013370:	681b      	ldr	r3, [r3, #0]
 8013372:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8013374:	68fb      	ldr	r3, [r7, #12]
 8013376:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8013378:	1c9a      	adds	r2, r3, #2
 801337a:	68fb      	ldr	r3, [r7, #12]
 801337c:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount -= 2U;
 801337e:	68fb      	ldr	r3, [r7, #12]
 8013380:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8013382:	b29b      	uxth	r3, r3
 8013384:	3b02      	subs	r3, #2
 8013386:	b29a      	uxth	r2, r3
 8013388:	68fb      	ldr	r3, [r7, #12]
 801338a:	87da      	strh	r2, [r3, #62]	; 0x3e
 801338c:	e058      	b.n	8013440 <HAL_SPI_Transmit+0x264>
      }
      else
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 801338e:	68fb      	ldr	r3, [r7, #12]
 8013390:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8013392:	68fb      	ldr	r3, [r7, #12]
 8013394:	681b      	ldr	r3, [r3, #0]
 8013396:	330c      	adds	r3, #12
 8013398:	7812      	ldrb	r2, [r2, #0]
 801339a:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr ++;
 801339c:	68fb      	ldr	r3, [r7, #12]
 801339e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80133a0:	1c5a      	adds	r2, r3, #1
 80133a2:	68fb      	ldr	r3, [r7, #12]
 80133a4:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 80133a6:	68fb      	ldr	r3, [r7, #12]
 80133a8:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80133aa:	b29b      	uxth	r3, r3
 80133ac:	3b01      	subs	r3, #1
 80133ae:	b29a      	uxth	r2, r3
 80133b0:	68fb      	ldr	r3, [r7, #12]
 80133b2:	87da      	strh	r2, [r3, #62]	; 0x3e
      }
    }
    while (hspi->TxXferCount > 0U)
 80133b4:	e044      	b.n	8013440 <HAL_SPI_Transmit+0x264>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80133b6:	68fb      	ldr	r3, [r7, #12]
 80133b8:	681b      	ldr	r3, [r3, #0]
 80133ba:	689b      	ldr	r3, [r3, #8]
 80133bc:	f003 0302 	and.w	r3, r3, #2
 80133c0:	2b02      	cmp	r3, #2
 80133c2:	d12b      	bne.n	801341c <HAL_SPI_Transmit+0x240>
      {
        if (hspi->TxXferCount > 1U)
 80133c4:	68fb      	ldr	r3, [r7, #12]
 80133c6:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80133c8:	b29b      	uxth	r3, r3
 80133ca:	2b01      	cmp	r3, #1
 80133cc:	d912      	bls.n	80133f4 <HAL_SPI_Transmit+0x218>
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80133ce:	68fb      	ldr	r3, [r7, #12]
 80133d0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80133d2:	881a      	ldrh	r2, [r3, #0]
 80133d4:	68fb      	ldr	r3, [r7, #12]
 80133d6:	681b      	ldr	r3, [r3, #0]
 80133d8:	60da      	str	r2, [r3, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
 80133da:	68fb      	ldr	r3, [r7, #12]
 80133dc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80133de:	1c9a      	adds	r2, r3, #2
 80133e0:	68fb      	ldr	r3, [r7, #12]
 80133e2:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 80133e4:	68fb      	ldr	r3, [r7, #12]
 80133e6:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80133e8:	b29b      	uxth	r3, r3
 80133ea:	3b02      	subs	r3, #2
 80133ec:	b29a      	uxth	r2, r3
 80133ee:	68fb      	ldr	r3, [r7, #12]
 80133f0:	87da      	strh	r2, [r3, #62]	; 0x3e
 80133f2:	e025      	b.n	8013440 <HAL_SPI_Transmit+0x264>
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 80133f4:	68fb      	ldr	r3, [r7, #12]
 80133f6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80133f8:	68fb      	ldr	r3, [r7, #12]
 80133fa:	681b      	ldr	r3, [r3, #0]
 80133fc:	330c      	adds	r3, #12
 80133fe:	7812      	ldrb	r2, [r2, #0]
 8013400:	701a      	strb	r2, [r3, #0]
          hspi->pTxBuffPtr++;
 8013402:	68fb      	ldr	r3, [r7, #12]
 8013404:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8013406:	1c5a      	adds	r2, r3, #1
 8013408:	68fb      	ldr	r3, [r7, #12]
 801340a:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount--;
 801340c:	68fb      	ldr	r3, [r7, #12]
 801340e:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8013410:	b29b      	uxth	r3, r3
 8013412:	3b01      	subs	r3, #1
 8013414:	b29a      	uxth	r2, r3
 8013416:	68fb      	ldr	r3, [r7, #12]
 8013418:	87da      	strh	r2, [r3, #62]	; 0x3e
 801341a:	e011      	b.n	8013440 <HAL_SPI_Transmit+0x264>
        }
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 801341c:	f7fe fc74 	bl	8011d08 <HAL_GetTick>
 8013420:	4602      	mov	r2, r0
 8013422:	69bb      	ldr	r3, [r7, #24]
 8013424:	1ad3      	subs	r3, r2, r3
 8013426:	683a      	ldr	r2, [r7, #0]
 8013428:	429a      	cmp	r2, r3
 801342a:	d803      	bhi.n	8013434 <HAL_SPI_Transmit+0x258>
 801342c:	683b      	ldr	r3, [r7, #0]
 801342e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8013432:	d102      	bne.n	801343a <HAL_SPI_Transmit+0x25e>
 8013434:	683b      	ldr	r3, [r7, #0]
 8013436:	2b00      	cmp	r3, #0
 8013438:	d102      	bne.n	8013440 <HAL_SPI_Transmit+0x264>
        {
          errorcode = HAL_TIMEOUT;
 801343a:	2303      	movs	r3, #3
 801343c:	77fb      	strb	r3, [r7, #31]
          goto error;
 801343e:	e026      	b.n	801348e <HAL_SPI_Transmit+0x2b2>
    while (hspi->TxXferCount > 0U)
 8013440:	68fb      	ldr	r3, [r7, #12]
 8013442:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8013444:	b29b      	uxth	r3, r3
 8013446:	2b00      	cmp	r3, #0
 8013448:	d1b5      	bne.n	80133b6 <HAL_SPI_Transmit+0x1da>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 801344a:	69ba      	ldr	r2, [r7, #24]
 801344c:	6839      	ldr	r1, [r7, #0]
 801344e:	68f8      	ldr	r0, [r7, #12]
 8013450:	f000 f90f 	bl	8013672 <SPI_EndRxTxTransaction>
 8013454:	4603      	mov	r3, r0
 8013456:	2b00      	cmp	r3, #0
 8013458:	d002      	beq.n	8013460 <HAL_SPI_Transmit+0x284>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 801345a:	68fb      	ldr	r3, [r7, #12]
 801345c:	2220      	movs	r2, #32
 801345e:	661a      	str	r2, [r3, #96]	; 0x60
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8013460:	68fb      	ldr	r3, [r7, #12]
 8013462:	689b      	ldr	r3, [r3, #8]
 8013464:	2b00      	cmp	r3, #0
 8013466:	d10a      	bne.n	801347e <HAL_SPI_Transmit+0x2a2>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8013468:	2300      	movs	r3, #0
 801346a:	613b      	str	r3, [r7, #16]
 801346c:	68fb      	ldr	r3, [r7, #12]
 801346e:	681b      	ldr	r3, [r3, #0]
 8013470:	68db      	ldr	r3, [r3, #12]
 8013472:	613b      	str	r3, [r7, #16]
 8013474:	68fb      	ldr	r3, [r7, #12]
 8013476:	681b      	ldr	r3, [r3, #0]
 8013478:	689b      	ldr	r3, [r3, #8]
 801347a:	613b      	str	r3, [r7, #16]
 801347c:	693b      	ldr	r3, [r7, #16]
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 801347e:	68fb      	ldr	r3, [r7, #12]
 8013480:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8013482:	2b00      	cmp	r3, #0
 8013484:	d002      	beq.n	801348c <HAL_SPI_Transmit+0x2b0>
  {
    errorcode = HAL_ERROR;
 8013486:	2301      	movs	r3, #1
 8013488:	77fb      	strb	r3, [r7, #31]
 801348a:	e000      	b.n	801348e <HAL_SPI_Transmit+0x2b2>
  }

error:
 801348c:	bf00      	nop
  hspi->State = HAL_SPI_STATE_READY;
 801348e:	68fb      	ldr	r3, [r7, #12]
 8013490:	2201      	movs	r2, #1
 8013492:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 8013496:	68fb      	ldr	r3, [r7, #12]
 8013498:	2200      	movs	r2, #0
 801349a:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  return errorcode;
 801349e:	7ffb      	ldrb	r3, [r7, #31]
}
 80134a0:	4618      	mov	r0, r3
 80134a2:	3720      	adds	r7, #32
 80134a4:	46bd      	mov	sp, r7
 80134a6:	bd80      	pop	{r7, pc}

080134a8 <HAL_SPI_GetState>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval SPI state
  */
HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
{
 80134a8:	b480      	push	{r7}
 80134aa:	b083      	sub	sp, #12
 80134ac:	af00      	add	r7, sp, #0
 80134ae:	6078      	str	r0, [r7, #4]
  /* Return SPI handle state */
  return hspi->State;
 80134b0:	687b      	ldr	r3, [r7, #4]
 80134b2:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 80134b6:	b2db      	uxtb	r3, r3
}
 80134b8:	4618      	mov	r0, r3
 80134ba:	370c      	adds	r7, #12
 80134bc:	46bd      	mov	sp, r7
 80134be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80134c2:	4770      	bx	lr

080134c4 <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 80134c4:	b580      	push	{r7, lr}
 80134c6:	b084      	sub	sp, #16
 80134c8:	af00      	add	r7, sp, #0
 80134ca:	60f8      	str	r0, [r7, #12]
 80134cc:	60b9      	str	r1, [r7, #8]
 80134ce:	603b      	str	r3, [r7, #0]
 80134d0:	4613      	mov	r3, r2
 80134d2:	71fb      	strb	r3, [r7, #7]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80134d4:	e04c      	b.n	8013570 <SPI_WaitFlagStateUntilTimeout+0xac>
  {
    if (Timeout != HAL_MAX_DELAY)
 80134d6:	683b      	ldr	r3, [r7, #0]
 80134d8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80134dc:	d048      	beq.n	8013570 <SPI_WaitFlagStateUntilTimeout+0xac>
    {
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 80134de:	f7fe fc13 	bl	8011d08 <HAL_GetTick>
 80134e2:	4602      	mov	r2, r0
 80134e4:	69bb      	ldr	r3, [r7, #24]
 80134e6:	1ad3      	subs	r3, r2, r3
 80134e8:	683a      	ldr	r2, [r7, #0]
 80134ea:	429a      	cmp	r2, r3
 80134ec:	d902      	bls.n	80134f4 <SPI_WaitFlagStateUntilTimeout+0x30>
 80134ee:	683b      	ldr	r3, [r7, #0]
 80134f0:	2b00      	cmp	r3, #0
 80134f2:	d13d      	bne.n	8013570 <SPI_WaitFlagStateUntilTimeout+0xac>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80134f4:	68fb      	ldr	r3, [r7, #12]
 80134f6:	681b      	ldr	r3, [r3, #0]
 80134f8:	685a      	ldr	r2, [r3, #4]
 80134fa:	68fb      	ldr	r3, [r7, #12]
 80134fc:	681b      	ldr	r3, [r3, #0]
 80134fe:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8013502:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8013504:	68fb      	ldr	r3, [r7, #12]
 8013506:	685b      	ldr	r3, [r3, #4]
 8013508:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 801350c:	d111      	bne.n	8013532 <SPI_WaitFlagStateUntilTimeout+0x6e>
 801350e:	68fb      	ldr	r3, [r7, #12]
 8013510:	689b      	ldr	r3, [r3, #8]
 8013512:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8013516:	d004      	beq.n	8013522 <SPI_WaitFlagStateUntilTimeout+0x5e>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8013518:	68fb      	ldr	r3, [r7, #12]
 801351a:	689b      	ldr	r3, [r3, #8]
 801351c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8013520:	d107      	bne.n	8013532 <SPI_WaitFlagStateUntilTimeout+0x6e>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8013522:	68fb      	ldr	r3, [r7, #12]
 8013524:	681b      	ldr	r3, [r3, #0]
 8013526:	681a      	ldr	r2, [r3, #0]
 8013528:	68fb      	ldr	r3, [r7, #12]
 801352a:	681b      	ldr	r3, [r3, #0]
 801352c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8013530:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8013532:	68fb      	ldr	r3, [r7, #12]
 8013534:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013536:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 801353a:	d10f      	bne.n	801355c <SPI_WaitFlagStateUntilTimeout+0x98>
        {
          SPI_RESET_CRC(hspi);
 801353c:	68fb      	ldr	r3, [r7, #12]
 801353e:	681b      	ldr	r3, [r3, #0]
 8013540:	681a      	ldr	r2, [r3, #0]
 8013542:	68fb      	ldr	r3, [r7, #12]
 8013544:	681b      	ldr	r3, [r3, #0]
 8013546:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 801354a:	601a      	str	r2, [r3, #0]
 801354c:	68fb      	ldr	r3, [r7, #12]
 801354e:	681b      	ldr	r3, [r3, #0]
 8013550:	681a      	ldr	r2, [r3, #0]
 8013552:	68fb      	ldr	r3, [r7, #12]
 8013554:	681b      	ldr	r3, [r3, #0]
 8013556:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 801355a:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 801355c:	68fb      	ldr	r3, [r7, #12]
 801355e:	2201      	movs	r2, #1
 8013560:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8013564:	68fb      	ldr	r3, [r7, #12]
 8013566:	2200      	movs	r2, #0
 8013568:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

        return HAL_TIMEOUT;
 801356c:	2303      	movs	r3, #3
 801356e:	e00f      	b.n	8013590 <SPI_WaitFlagStateUntilTimeout+0xcc>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8013570:	68fb      	ldr	r3, [r7, #12]
 8013572:	681b      	ldr	r3, [r3, #0]
 8013574:	689a      	ldr	r2, [r3, #8]
 8013576:	68bb      	ldr	r3, [r7, #8]
 8013578:	4013      	ands	r3, r2
 801357a:	68ba      	ldr	r2, [r7, #8]
 801357c:	429a      	cmp	r2, r3
 801357e:	bf0c      	ite	eq
 8013580:	2301      	moveq	r3, #1
 8013582:	2300      	movne	r3, #0
 8013584:	b2db      	uxtb	r3, r3
 8013586:	461a      	mov	r2, r3
 8013588:	79fb      	ldrb	r3, [r7, #7]
 801358a:	429a      	cmp	r2, r3
 801358c:	d1a3      	bne.n	80134d6 <SPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }

  return HAL_OK;
 801358e:	2300      	movs	r3, #0
}
 8013590:	4618      	mov	r0, r3
 8013592:	3710      	adds	r7, #16
 8013594:	46bd      	mov	sp, r7
 8013596:	bd80      	pop	{r7, pc}

08013598 <SPI_WaitFifoStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8013598:	b580      	push	{r7, lr}
 801359a:	b084      	sub	sp, #16
 801359c:	af00      	add	r7, sp, #0
 801359e:	60f8      	str	r0, [r7, #12]
 80135a0:	60b9      	str	r1, [r7, #8]
 80135a2:	607a      	str	r2, [r7, #4]
 80135a4:	603b      	str	r3, [r7, #0]
  while ((hspi->Instance->SR & Fifo) != State)
 80135a6:	e057      	b.n	8013658 <SPI_WaitFifoStateUntilTimeout+0xc0>
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 80135a8:	68bb      	ldr	r3, [r7, #8]
 80135aa:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 80135ae:	d106      	bne.n	80135be <SPI_WaitFifoStateUntilTimeout+0x26>
 80135b0:	687b      	ldr	r3, [r7, #4]
 80135b2:	2b00      	cmp	r3, #0
 80135b4:	d103      	bne.n	80135be <SPI_WaitFifoStateUntilTimeout+0x26>
    {
      /* Read 8bit CRC to flush Data Register */
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 80135b6:	68fb      	ldr	r3, [r7, #12]
 80135b8:	681b      	ldr	r3, [r3, #0]
 80135ba:	330c      	adds	r3, #12
 80135bc:	781b      	ldrb	r3, [r3, #0]
    }

    if (Timeout != HAL_MAX_DELAY)
 80135be:	683b      	ldr	r3, [r7, #0]
 80135c0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80135c4:	d048      	beq.n	8013658 <SPI_WaitFifoStateUntilTimeout+0xc0>
    {
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 80135c6:	f7fe fb9f 	bl	8011d08 <HAL_GetTick>
 80135ca:	4602      	mov	r2, r0
 80135cc:	69bb      	ldr	r3, [r7, #24]
 80135ce:	1ad3      	subs	r3, r2, r3
 80135d0:	683a      	ldr	r2, [r7, #0]
 80135d2:	429a      	cmp	r2, r3
 80135d4:	d902      	bls.n	80135dc <SPI_WaitFifoStateUntilTimeout+0x44>
 80135d6:	683b      	ldr	r3, [r7, #0]
 80135d8:	2b00      	cmp	r3, #0
 80135da:	d13d      	bne.n	8013658 <SPI_WaitFifoStateUntilTimeout+0xc0>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80135dc:	68fb      	ldr	r3, [r7, #12]
 80135de:	681b      	ldr	r3, [r3, #0]
 80135e0:	685a      	ldr	r2, [r3, #4]
 80135e2:	68fb      	ldr	r3, [r7, #12]
 80135e4:	681b      	ldr	r3, [r3, #0]
 80135e6:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 80135ea:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80135ec:	68fb      	ldr	r3, [r7, #12]
 80135ee:	685b      	ldr	r3, [r3, #4]
 80135f0:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80135f4:	d111      	bne.n	801361a <SPI_WaitFifoStateUntilTimeout+0x82>
 80135f6:	68fb      	ldr	r3, [r7, #12]
 80135f8:	689b      	ldr	r3, [r3, #8]
 80135fa:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80135fe:	d004      	beq.n	801360a <SPI_WaitFifoStateUntilTimeout+0x72>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8013600:	68fb      	ldr	r3, [r7, #12]
 8013602:	689b      	ldr	r3, [r3, #8]
 8013604:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8013608:	d107      	bne.n	801361a <SPI_WaitFifoStateUntilTimeout+0x82>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 801360a:	68fb      	ldr	r3, [r7, #12]
 801360c:	681b      	ldr	r3, [r3, #0]
 801360e:	681a      	ldr	r2, [r3, #0]
 8013610:	68fb      	ldr	r3, [r7, #12]
 8013612:	681b      	ldr	r3, [r3, #0]
 8013614:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8013618:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 801361a:	68fb      	ldr	r3, [r7, #12]
 801361c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801361e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8013622:	d10f      	bne.n	8013644 <SPI_WaitFifoStateUntilTimeout+0xac>
        {
          SPI_RESET_CRC(hspi);
 8013624:	68fb      	ldr	r3, [r7, #12]
 8013626:	681b      	ldr	r3, [r3, #0]
 8013628:	681a      	ldr	r2, [r3, #0]
 801362a:	68fb      	ldr	r3, [r7, #12]
 801362c:	681b      	ldr	r3, [r3, #0]
 801362e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8013632:	601a      	str	r2, [r3, #0]
 8013634:	68fb      	ldr	r3, [r7, #12]
 8013636:	681b      	ldr	r3, [r3, #0]
 8013638:	681a      	ldr	r2, [r3, #0]
 801363a:	68fb      	ldr	r3, [r7, #12]
 801363c:	681b      	ldr	r3, [r3, #0]
 801363e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8013642:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8013644:	68fb      	ldr	r3, [r7, #12]
 8013646:	2201      	movs	r2, #1
 8013648:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 801364c:	68fb      	ldr	r3, [r7, #12]
 801364e:	2200      	movs	r2, #0
 8013650:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

        return HAL_TIMEOUT;
 8013654:	2303      	movs	r3, #3
 8013656:	e008      	b.n	801366a <SPI_WaitFifoStateUntilTimeout+0xd2>
  while ((hspi->Instance->SR & Fifo) != State)
 8013658:	68fb      	ldr	r3, [r7, #12]
 801365a:	681b      	ldr	r3, [r3, #0]
 801365c:	689a      	ldr	r2, [r3, #8]
 801365e:	68bb      	ldr	r3, [r7, #8]
 8013660:	4013      	ands	r3, r2
 8013662:	687a      	ldr	r2, [r7, #4]
 8013664:	429a      	cmp	r2, r3
 8013666:	d19f      	bne.n	80135a8 <SPI_WaitFifoStateUntilTimeout+0x10>
      }
    }
  }

  return HAL_OK;
 8013668:	2300      	movs	r3, #0
}
 801366a:	4618      	mov	r0, r3
 801366c:	3710      	adds	r7, #16
 801366e:	46bd      	mov	sp, r7
 8013670:	bd80      	pop	{r7, pc}

08013672 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8013672:	b580      	push	{r7, lr}
 8013674:	b086      	sub	sp, #24
 8013676:	af02      	add	r7, sp, #8
 8013678:	60f8      	str	r0, [r7, #12]
 801367a:	60b9      	str	r1, [r7, #8]
 801367c:	607a      	str	r2, [r7, #4]
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 801367e:	687b      	ldr	r3, [r7, #4]
 8013680:	9300      	str	r3, [sp, #0]
 8013682:	68bb      	ldr	r3, [r7, #8]
 8013684:	2200      	movs	r2, #0
 8013686:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
 801368a:	68f8      	ldr	r0, [r7, #12]
 801368c:	f7ff ff84 	bl	8013598 <SPI_WaitFifoStateUntilTimeout>
 8013690:	4603      	mov	r3, r0
 8013692:	2b00      	cmp	r3, #0
 8013694:	d007      	beq.n	80136a6 <SPI_EndRxTxTransaction+0x34>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8013696:	68fb      	ldr	r3, [r7, #12]
 8013698:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 801369a:	f043 0220 	orr.w	r2, r3, #32
 801369e:	68fb      	ldr	r3, [r7, #12]
 80136a0:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 80136a2:	2303      	movs	r3, #3
 80136a4:	e027      	b.n	80136f6 <SPI_EndRxTxTransaction+0x84>
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80136a6:	687b      	ldr	r3, [r7, #4]
 80136a8:	9300      	str	r3, [sp, #0]
 80136aa:	68bb      	ldr	r3, [r7, #8]
 80136ac:	2200      	movs	r2, #0
 80136ae:	2180      	movs	r1, #128	; 0x80
 80136b0:	68f8      	ldr	r0, [r7, #12]
 80136b2:	f7ff ff07 	bl	80134c4 <SPI_WaitFlagStateUntilTimeout>
 80136b6:	4603      	mov	r3, r0
 80136b8:	2b00      	cmp	r3, #0
 80136ba:	d007      	beq.n	80136cc <SPI_EndRxTxTransaction+0x5a>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80136bc:	68fb      	ldr	r3, [r7, #12]
 80136be:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80136c0:	f043 0220 	orr.w	r2, r3, #32
 80136c4:	68fb      	ldr	r3, [r7, #12]
 80136c6:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 80136c8:	2303      	movs	r3, #3
 80136ca:	e014      	b.n	80136f6 <SPI_EndRxTxTransaction+0x84>
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80136cc:	687b      	ldr	r3, [r7, #4]
 80136ce:	9300      	str	r3, [sp, #0]
 80136d0:	68bb      	ldr	r3, [r7, #8]
 80136d2:	2200      	movs	r2, #0
 80136d4:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 80136d8:	68f8      	ldr	r0, [r7, #12]
 80136da:	f7ff ff5d 	bl	8013598 <SPI_WaitFifoStateUntilTimeout>
 80136de:	4603      	mov	r3, r0
 80136e0:	2b00      	cmp	r3, #0
 80136e2:	d007      	beq.n	80136f4 <SPI_EndRxTxTransaction+0x82>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80136e4:	68fb      	ldr	r3, [r7, #12]
 80136e6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80136e8:	f043 0220 	orr.w	r2, r3, #32
 80136ec:	68fb      	ldr	r3, [r7, #12]
 80136ee:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 80136f0:	2303      	movs	r3, #3
 80136f2:	e000      	b.n	80136f6 <SPI_EndRxTxTransaction+0x84>
  }

  return HAL_OK;
 80136f4:	2300      	movs	r3, #0
}
 80136f6:	4618      	mov	r0, r3
 80136f8:	3710      	adds	r7, #16
 80136fa:	46bd      	mov	sp, r7
 80136fc:	bd80      	pop	{r7, pc}
	...

08013700 <__libc_init_array>:
 8013700:	b570      	push	{r4, r5, r6, lr}
 8013702:	4e0d      	ldr	r6, [pc, #52]	; (8013738 <__libc_init_array+0x38>)
 8013704:	4c0d      	ldr	r4, [pc, #52]	; (801373c <__libc_init_array+0x3c>)
 8013706:	1ba4      	subs	r4, r4, r6
 8013708:	10a4      	asrs	r4, r4, #2
 801370a:	2500      	movs	r5, #0
 801370c:	42a5      	cmp	r5, r4
 801370e:	d109      	bne.n	8013724 <__libc_init_array+0x24>
 8013710:	4e0b      	ldr	r6, [pc, #44]	; (8013740 <__libc_init_array+0x40>)
 8013712:	4c0c      	ldr	r4, [pc, #48]	; (8013744 <__libc_init_array+0x44>)
 8013714:	f000 f834 	bl	8013780 <_init>
 8013718:	1ba4      	subs	r4, r4, r6
 801371a:	10a4      	asrs	r4, r4, #2
 801371c:	2500      	movs	r5, #0
 801371e:	42a5      	cmp	r5, r4
 8013720:	d105      	bne.n	801372e <__libc_init_array+0x2e>
 8013722:	bd70      	pop	{r4, r5, r6, pc}
 8013724:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8013728:	4798      	blx	r3
 801372a:	3501      	adds	r5, #1
 801372c:	e7ee      	b.n	801370c <__libc_init_array+0xc>
 801372e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8013732:	4798      	blx	r3
 8013734:	3501      	adds	r5, #1
 8013736:	e7f2      	b.n	801371e <__libc_init_array+0x1e>
 8013738:	08016dc4 	.word	0x08016dc4
 801373c:	08016dc4 	.word	0x08016dc4
 8013740:	08016dc4 	.word	0x08016dc4
 8013744:	08016dc8 	.word	0x08016dc8

08013748 <memcpy>:
 8013748:	b510      	push	{r4, lr}
 801374a:	1e43      	subs	r3, r0, #1
 801374c:	440a      	add	r2, r1
 801374e:	4291      	cmp	r1, r2
 8013750:	d100      	bne.n	8013754 <memcpy+0xc>
 8013752:	bd10      	pop	{r4, pc}
 8013754:	f811 4b01 	ldrb.w	r4, [r1], #1
 8013758:	f803 4f01 	strb.w	r4, [r3, #1]!
 801375c:	e7f7      	b.n	801374e <memcpy+0x6>

0801375e <memset>:
 801375e:	4402      	add	r2, r0
 8013760:	4603      	mov	r3, r0
 8013762:	4293      	cmp	r3, r2
 8013764:	d100      	bne.n	8013768 <memset+0xa>
 8013766:	4770      	bx	lr
 8013768:	f803 1b01 	strb.w	r1, [r3], #1
 801376c:	e7f9      	b.n	8013762 <memset+0x4>

0801376e <strcpy>:
 801376e:	4603      	mov	r3, r0
 8013770:	f811 2b01 	ldrb.w	r2, [r1], #1
 8013774:	f803 2b01 	strb.w	r2, [r3], #1
 8013778:	2a00      	cmp	r2, #0
 801377a:	d1f9      	bne.n	8013770 <strcpy+0x2>
 801377c:	4770      	bx	lr
	...

08013780 <_init>:
 8013780:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8013782:	bf00      	nop
 8013784:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8013786:	bc08      	pop	{r3}
 8013788:	469e      	mov	lr, r3
 801378a:	4770      	bx	lr

0801378c <_fini>:
 801378c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801378e:	bf00      	nop
 8013790:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8013792:	bc08      	pop	{r3}
 8013794:	469e      	mov	lr, r3
 8013796:	4770      	bx	lr
